/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@openfin/core/out/mock.js":
/*!****************************************************!*\
  !*** ../../node_modules/@openfin/core/out/mock.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var require$$0 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
var require$$3 = __webpack_require__(/*! lodash */ "../../node_modules/lodash/lodash.js");

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

var mock = {};

var OpenFin$1 = {};

var events = {};

var application$1 = {};

/**
 * Namespace for events that can be emitted by an {@link OpenFin.Application}.  Includes events
 * re-propagated from the {@link OpenFin.Window} (and, transitively, {@link OpenFin.View}) level, prefixed with `window-` (and also, if applicable, `view-`).
 * For example, a view's "attached" event will fire as 'window-view-attached' at the application level.
 *
 * Event payloads are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * This namespace contains only payload shapes for events that are unique to `Application`.  Events that propagate to `Application` from
 * child {@link OpenFin.Window windows} and {@link OpenFin.View views} are defined in the {@link OpenFin.WindowEvents} and
 * {@link OpenFin.ViewEvents} namespaces.  For a list of valid string keys for *all* application events, see {@link Application.on Application.on}.
 *
 * {@link ApplicationSourcedEvent Application-sourced events} (i.e. those that have not propagated from {@link OpenFin.ViewEvents Views}
 * or {@link OpenFin.WindowEvents Windows} re-propagate to {@link OpenFin.SystemEvents System} with their type string prefixed with `application-`.
 * {@link ApplicationWindowEvent Application events that are tied to Windows but do not propagate from them}
 * are propagated to `System` without any type string prefixing.
 *
 * "Requested" events (e.g. {@link RunRequestedEvent}) do not propagate.
 *
 * @packageDocumentation
 */
Object.defineProperty(application$1, "__esModule", { value: true });

var base$1 = {};

/**
 * Namespace for shared event payloads and utility types common to all event emitters.
 *
 * @packageDocumentation
 */
Object.defineProperty(base$1, "__esModule", { value: true });

var externalApplication$1 = {};

/**
 * Namespace for events that can be transmitted by an {@link OpenFin.ExternalApplication}.
 *
 * Event payloads are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * For a list of valid string keys for external application events, see {@link ExternalApplication.on ExternalApplication.on}.
 *
 * @packageDocumentation
 */
Object.defineProperty(externalApplication$1, "__esModule", { value: true });

var frame$1 = {};

Object.defineProperty(frame$1, "__esModule", { value: true });

var globalHotkey$1 = {};

/**
 *
 * Namespace for events that can be transmitted by {@link GlobalHotkey.GlobalHotkey}.
 *
 * Event payloads are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * For a list of valid string keys for global hotkey events, see {@link GlobalHotkey.GlobalHotkey.on GlobalHotkey.on}.
 *
 * @packageDocumentation
 */
Object.defineProperty(globalHotkey$1, "__esModule", { value: true });

var platform$1 = {};

/**
 *
 * Namespace for events that can emitted by a {@link OpenFin.Platform}.
 *
 * Event payloads are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * The Platform `EventEmitter` is a superset of the {@link OpenFin.Application} `EventEmitter`,
 * meaning it can listen to all {@link OpenFin.ApplicationEvents Application events} in addition to the
 * Platform-specific events listed here.  For a list of valid string keys for *all* platform events, see
 * {@link Platform.on Platform.on}.
 *
 * @packageDocumentation
 */
Object.defineProperty(platform$1, "__esModule", { value: true });

var system$1 = {};

/**
 * Namespace for runtime-wide OpenFin events emitted by {@link System.System}.  Includes events
 * re-propagated from {@link OpenFin.Application}, {@link OpenFin.Window}, and {@link OpenFin.View} (prefixed with `application-`, `window-`, and `view-`).  All
 * event propagations are visible at the System level. Propagated events from WebContents (windows, views, frames) to the Application level will *not*
 * transitively re-propagate to the System level, because they are already visible at the system level and contain the identity
 * of the application.  For example, an application's "closed" event will fire as 'application-closed' at the system level.  A view's 'shown' event
 * will be visible as 'view-shown' at the system level, but *not* as `application-window-view-shown`.
 *
 * Event payloads are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * This namespace contains only payload shapes for events that are unique to `System`.  Events that propagate to `System` from
 * child {@link OpenFin.Application applications}, {@link OpenFin.Window windows}, and {@link OpenFin.View views} are defined in the
 * {@link OpenFin.ApplicationEvents}, {@link OpenFin.WindowEvents}, and {@link OpenFin.ViewEvents} namespaces.  For a list of valid string keys for *all*
 * system events, see {@link System.on System.on}.
 *
 * @packageDocumentation
 */
Object.defineProperty(system$1, "__esModule", { value: true });

var view$1 = {};

/**
 * Namespace for events that can be emitted by a {@link OpenFin.View}.
 *
 * Event payloads are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * This namespace contains only payload shapes for events that are unique to `View`.  Events that are shared between all `WebContents`
 * (i.e. {@link OpenFin.Window}, {@link OpenFin.View}) are defined in {@link OpenFin.WebContentsEvents}.  For a list
 * of valid string keys for *all* View events, see {@link View.on View.on}.
 *
 * View events propagate to their parent {@link OpenFin.WindowEvents Window}, {@link OpenFin.ApplicationEvents Application},
 * and {@link OpenFin.SystemEvents System} with an added `viewIdentity` property and their event types prefixed with `'view-'`.
 *
 * @packageDocumentation
 */
Object.defineProperty(view$1, "__esModule", { value: true });

var webcontents = {};

/**
 * Namespace for events shared by all OpenFin WebContents elements (i.e. {@link OpenFin.Window},
 * {@link OpenFin.View}).
 *
 * WebContents events will re-emit on parent entities - e.g., a propagating event in a view will also be emitted on the view's
 * parent window, and propagating events in a window will also be emitted on the window's parent {@link OpenFin.Application}.
 *
 * @packageDocumentation
 */
Object.defineProperty(webcontents, "__esModule", { value: true });

var window$2 = {};

/**
 * Namespace for events that can be emitted by a {@link OpenFin.Window}.
 *
 * Event payloads are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * This namespace contains only payload shapes for events that are unique to `Window`.  Events that are shared between all `WebContents`
 * (i.e. {@link OpenFin.Window}, {@link OpenFin.View}) are defined in {@link OpenFin.WebContentsEvents}. Events that
 * propagate from `View` are defined in {@link OpenFin.ViewEvents}. For a list of valid string keys for *all* Window events, see
 * {@link Window.on Window.on}
 *
 * {@link OpenFin.WindowEvents.WindowSourcedEvent Window-sourced events} (i.e. those that are not propagated from a
 * {@link OpenFin.ViewEvents View}) propagate to their parent {@link OpenFin.ApplicationEvents Application} and
 * {@link OpenFin.SystemEvents System} with their event types prefixed with `'window-'`).
 *
 * "Requested" events (e.g. {@link AuthRequestedEvent}) do not propagate to `System.  The {@link OpenFin.WindowEvents.WindowCloseRequestedEvent}
 * does not propagate at all.
 *
 * @packageDocumentation
 */
Object.defineProperty(window$2, "__esModule", { value: true });

/**
 * Namespace for OpenFin event types. Each entity that emits OpenFin events has its own sub-namespace. Event payloads
 * themselves are documented as interfaces, while algebraic helper types and derived types are documented as type aliases.
 *
 * #### Event emitters
 *
 * The following entities emit OpenFin events, and have corresponding sub-namespaces:
 *
 * * {@link OpenFin.Application}: {@link OpenFin.ApplicationEvents}
 * * {@link OpenFin.ExternalApplication}: {@link OpenFin.ExternalApplicationEvents}
 * * {@link OpenFin.Frame}: {@link OpenFin.FrameEvents}
 * * {@link OpenFin.GlobalHotkey}: {@link OpenFin.GlobalHotkeyEvents}
 * * {@link OpenFin.Platform}: {@link OpenFin.PlatformEvents}
 * * {@link OpenFin.System}: {@link OpenFin.SystemEvents}
 * * {@link OpenFin.View}: {@link OpenFin.ViewEvents}
 * * {@link OpenFin.Window}: {@link OpenFin.WindowEvents}
 *
 * These `EventEmitter` entities share a common set of methods for interacting with the OpenFin event bus, which can be
 * seen on the individual documentation pages for each entity type.
 *
 * Registering event handlers is an asynchronous operation. It is important to ensure that the returned Promises are awaited to reduce the
 * risk of race conditions.
 *
 * When the `EventEmitter` receives an event from the browser process and emits on the renderer, all of the functions attached to that
 * specific event are called synchronously. Any values returned by the called listeners are ignored and will be discarded.  If the window document
 * is destroyed by page navigation or reload, its registered event listeners will be removed.
 *
 * We recommend using Arrow Functions for event listeners to ensure the this scope is consistent with the original function context.
 *
 * Events re-propagate from smaller/more-local scopes to larger/more-global scopes.  For example, an event emitted on a specific
 * view will propagate to the window in which the view is embedded, and then to the application in which the window is running, and
 * finally to the OpenFin runtime itself at the "system" level.  For details on propagation semantics, see the namespace for
 * the propagating (or propagated-to) entity.
 *
 * If you need the payload type for a specific type of event (especially propagated events), use the emitting topic's `Payload` generic
 * (e.g. {@link WindowEvents.Payload}) with the event's `type` string.  For example, the payload of
 * a {@link ViewEvents.CreatedEvent} after it has propagated to its parent {@link WindowEvents Window} can be found with
 * `WindowEvents.Payload<'view-created'>`.
 *
 * @packageDocumentation
 */
Object.defineProperty(events, "__esModule", { value: true });
events.WindowEvents = events.WebContentsEvents = events.ViewEvents = events.SystemEvents = events.PlatformEvents = events.GlobalHotkeyEvents = events.FrameEvents = events.ExternalApplicationEvents = events.BaseEvents = events.ApplicationEvents = void 0;
const ApplicationEvents = application$1;
events.ApplicationEvents = ApplicationEvents;
const BaseEvents = base$1;
events.BaseEvents = BaseEvents;
const ExternalApplicationEvents = externalApplication$1;
events.ExternalApplicationEvents = ExternalApplicationEvents;
const FrameEvents = frame$1;
events.FrameEvents = FrameEvents;
const GlobalHotkeyEvents = globalHotkey$1;
events.GlobalHotkeyEvents = GlobalHotkeyEvents;
const PlatformEvents = platform$1;
events.PlatformEvents = PlatformEvents;
const SystemEvents = system$1;
events.SystemEvents = SystemEvents;
const ViewEvents = view$1;
events.ViewEvents = ViewEvents;
const WebContentsEvents = webcontents;
events.WebContentsEvents = WebContentsEvents;
const WindowEvents = window$2;
events.WindowEvents = WindowEvents;

(function (exports) {
	/**
	 * Top-level namespace for types referenced by the OpenFin API.  Contains:
	 *
	 * * The type of the global `fin` entry point ({@link FinApi})
	 * * Classes that act as static namespaces returned from the `fin` global (e.g. {@link ApplicationModule}, accessible via `fin.Application`)
	 * * Instance classes that are returned from API calls (e.g. {@link Application}, accessible via `fin.Application.getCurrentSync()`)
	 * * Parameter shapes for API methods (e.g. {@link ApplicationOptions}, used in `fin.Application.start()`)
	 * * Event namespaces and payload union types (e.g. {@link ApplicationEvents} and {@link ApplicationEvent})
	 *
	 * @packageDocumentation
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// Deprecated shim to preserve v30 namespace names
	__exportStar(events, exports); 
} (OpenFin$1));

var fin$1 = {};

var system = {};

var base = {};

var promises = {};

Object.defineProperty(promises, "__esModule", { value: true });
promises.promiseMapSerial = promises.serial = promises.promiseMap = promises.promisify = void 0;
function promisify(func) {
    return (...args) => new Promise((resolve, reject) => {
        func(...args, (err, val) => (err ? reject(err) : resolve(val)));
    });
}
promises.promisify = promisify;
async function promiseMap(arr, asyncF) {
    return Promise.all(arr.map(asyncF));
}
promises.promiseMap = promiseMap;
async function serial(arr) {
    const ret = [];
    for (const func of arr) {
        // eslint-disable-next-line no-await-in-loop
        const next = await func();
        ret.push(next);
    }
    return ret;
}
promises.serial = serial;
async function promiseMapSerial(arr, func) {
    return serial(arr.map((value, index, array) => () => func(value, index, array)));
}
promises.promiseMapSerial = promiseMapSerial;

var __classPrivateFieldSet$d = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$f = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EmitterBase_emitterAccessor;
Object.defineProperty(base, "__esModule", { value: true });
base.Reply = base.EmitterBase = base.Base = void 0;
const promises_1 = promises;
class Base {
    /**
     * @internal
     */
    constructor(wire) {
        /**
         * @internal
         * @deprecated
         */
        this.isNodeEnvironment = () => {
            return this.wire.environment.type === 'node';
        };
        /**
         * @internal
         * @deprecated
         */
        this.isOpenFinEnvironment = () => {
            return this.wire.environment.type === 'openfin';
        };
        /**
         * @internal
         * @deprecated
         */
        this.isBrowserEnvironment = () => {
            return this.wire.environment.type === 'other';
        };
        this.wire = wire;
    }
    get fin() {
        return this.wire.getFin();
    }
    /**
     * Provides access to the OpenFin representation of the current code context (usually a document
     * such as a {@link OpenFin.View} or {@link OpenFin.Window}), as well as to the current `Interop` context.
     *
     * Useful for debugging in the devtools console, where this will intelligently type itself based
     * on the context in which the devtools panel was opened.
     */
    get me() {
        return this.wire.me;
    }
}
base.Base = Base;
/**
 * An entity that emits OpenFin events.
 *
 * @remarks Event-binding methods are asynchronous as they must cross process boundaries
 * and setup the listener in the browser process.  When the `EventEmitter` receives an event from the browser process
 * and emits on the renderer, all of the functions attached to that specific event are called synchronously.  Any values
 * returned by the called listeners are ignored and will be discarded.  If the execution context of the window is destroyed
 * by page navigation or reload, any events that have been setup in that context will be destroyed.
 *
 * It is important to keep in mind that when an ordinary listener function is called, the standard `this` keyword is intentionally
 * set to reference the `EventEmitter` instance to which the listener is attached.  It is possible to use ES6 Arrow Functions as
 * listeners, however, when doing so, the `this` keyword will no longer reference the `EventEmitter` instance.
 *
 * Events re-propagate from smaller/more-local scopes to larger/more-global scopes.  For example, an event emitted on a specific
 * view will propagate to the window in which the view is embedded, and then to the application in which the window is running, and
 * finally to the OpenFin runtime itself at the "system" level.  Re-propagated events are prefixed with the name of the scope in which
 * they originated - for example, a "shown" event emitted on a view will be re-propagated at the window level as "view-shown", and
 * then to the application as "window-view-shown", and finally at the system level as "application-window-view-shown".
 *
 * All event propagations are visible at the System level, regardless of source, so transitive re-propagations (e.g. from view to window
 * to application) are visible in their entirety at the system level.  So, we can listen to the above event as "shown", "view-shown",
 * "window-view-shown", or "application-window-view-shown."
 */
class EmitterBase extends Base {
    constructor(wire, topic, ...additionalAccessors) {
        super(wire);
        this.topic = topic;
        _EmitterBase_emitterAccessor.set(this, void 0);
        this.eventNames = () => (this.hasEmitter() ? this.getOrCreateEmitter().eventNames() : []);
        /**
         * @internal
         */
        this.emit = (eventType, payload, ...args) => {
            return this.hasEmitter() ? this.getOrCreateEmitter().emit(eventType, payload, ...args) : false;
        };
        this.hasEmitter = () => this.wire.eventAggregator.has(__classPrivateFieldGet$f(this, _EmitterBase_emitterAccessor, "f"));
        this.getOrCreateEmitter = () => this.wire.eventAggregator.getOrCreate(__classPrivateFieldGet$f(this, _EmitterBase_emitterAccessor, "f"));
        this.listeners = (type) => this.hasEmitter() ? this.getOrCreateEmitter().listeners(type) : [];
        this.listenerCount = (type) => this.hasEmitter() ? this.getOrCreateEmitter().listenerCount(type) : 0;
        this.registerEventListener = async (eventType, options = {}, applySubscription, undoSubscription) => {
            const runtimeEvent = {
                ...this.identity,
                timestamp: options.timestamp || Date.now(),
                topic: this.topic,
                type: eventType
            };
            const emitter = this.getOrCreateEmitter();
            // We apply the subscription and then undo if the async call fails to avoid
            // indeterminacy in subscription application order, which can break things elsewhere
            applySubscription(emitter);
            try {
                await this.wire.sendAction('subscribe-to-desktop-event', runtimeEvent);
            }
            catch (e) {
                undoSubscription(emitter);
                this.deleteEmitterIfNothingRegistered(emitter);
                throw e;
            }
        };
        this.deregisterEventListener = async (eventType, options = {}) => {
            if (this.hasEmitter()) {
                const runtimeEvent = {
                    ...this.identity,
                    timestamp: options.timestamp || Date.now(),
                    topic: this.topic,
                    type: eventType
                };
                await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent).catch(() => null);
                const emitter = this.getOrCreateEmitter();
                return emitter;
            }
            // This will only be reached if unsubscribe from event that does not exist but do not want to error here
            return Promise.resolve();
        };
        __classPrivateFieldSet$d(this, _EmitterBase_emitterAccessor, [topic, ...additionalAccessors], "f");
        this.listeners = (event) => this.hasEmitter() ? this.getOrCreateEmitter().listeners(event) : [];
    }
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     *
     * @remarks Event payloads are documented in the {@link OpenFin.Events} namespace.
     */
    async on(eventType, listener, options) {
        await this.registerEventListener(eventType, options, (emitter) => {
            emitter.on(eventType, listener);
        }, (emitter) => {
            emitter.removeListener(eventType, listener);
        });
        return this;
    }
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     */
    async addListener(eventType, listener, options) {
        return this.on(eventType, listener, options);
    }
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     *
     * @remarks Event payloads are documented in the {@link OpenFin.Events} namespace.
     */
    async once(eventType, listener, options) {
        const deregister = () => this.deregisterEventListener(eventType);
        await this.registerEventListener(eventType, options, (emitter) => {
            emitter.once(eventType, deregister);
            emitter.once(eventType, listener);
        }, (emitter) => {
            emitter.removeListener(eventType, deregister);
            emitter.removeListener(eventType, listener);
        });
        return this;
    }
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     *
     * @remarks Event payloads are documented in the {@link OpenFin.Events} namespace.
     */
    async prependListener(eventType, listener, options) {
        await this.registerEventListener(eventType, options, (emitter) => {
            emitter.prependListener(eventType, listener);
        }, (emitter) => {
            emitter.removeListener(eventType, listener);
        });
        return this;
    }
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired,
     * after which it is removed. The listener is added to the beginning of the listeners array.
     *
     * @remarks Event payloads are documented in the {@link OpenFin.Events} namespace.
     */
    async prependOnceListener(eventType, listener, options) {
        const deregister = () => this.deregisterEventListener(eventType);
        await this.registerEventListener(eventType, options, (emitter) => {
            emitter.prependOnceListener(eventType, listener);
            emitter.once(eventType, deregister);
        }, (emitter) => {
            emitter.removeListener(eventType, listener);
            emitter.removeListener(eventType, deregister);
        });
        return this;
    }
    /**
     * Remove a listener from the listener array for the specified event.
     *
     * @remarks Caution: Calling this method changes the array indices in the listener array behind the listener.
     */
    async removeListener(eventType, listener, options) {
        const emitter = await this.deregisterEventListener(eventType, options);
        if (emitter) {
            emitter.removeListener(eventType, listener);
            this.deleteEmitterIfNothingRegistered(emitter);
        }
        return this;
    }
    async deregisterAllListeners(eventType) {
        const runtimeEvent = { ...this.identity, type: eventType, topic: this.topic };
        if (this.hasEmitter()) {
            const emitter = this.getOrCreateEmitter();
            const refCount = emitter.listenerCount(runtimeEvent.type);
            const unsubscribePromises = [];
            for (let i = 0; i < refCount; i++) {
                unsubscribePromises.push(this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent).catch(() => null));
            }
            await Promise.all(unsubscribePromises);
            return emitter;
        }
        return undefined;
    }
    /**
     * Removes all listeners, or those of the specified event.
     *
     */
    async removeAllListeners(eventType) {
        const removeByEvent = async (event) => {
            const emitter = await this.deregisterAllListeners(event);
            if (emitter) {
                emitter.removeAllListeners(event);
                this.deleteEmitterIfNothingRegistered(emitter);
            }
        };
        if (eventType) {
            await removeByEvent(eventType);
        }
        else if (this.hasEmitter()) {
            const events = this.getOrCreateEmitter().eventNames();
            await (0, promises_1.promiseMap)(events, removeByEvent);
        }
        return this;
    }
    deleteEmitterIfNothingRegistered(emitter) {
        if (emitter.eventNames().length === 0) {
            this.wire.eventAggregator.delete(__classPrivateFieldGet$f(this, _EmitterBase_emitterAccessor, "f"));
        }
    }
}
base.EmitterBase = EmitterBase;
_EmitterBase_emitterAccessor = new WeakMap();
class Reply {
}
base.Reply = Reply;

var transportErrors = {};

Object.defineProperty(transportErrors, "__esModule", { value: true });
transportErrors.RuntimeError = transportErrors.NotSupportedError = transportErrors.NotImplementedError = transportErrors.NoAckError = transportErrors.DuplicateCorrelationError = transportErrors.UnexpectedActionError = transportErrors.DisconnectedError = void 0;
class DisconnectedError extends Error {
    constructor(readyState) {
        super(`Expected websocket state OPEN but found ${readyState}`);
        this.readyState = readyState;
    }
}
transportErrors.DisconnectedError = DisconnectedError;
class UnexpectedActionError extends Error {
}
transportErrors.UnexpectedActionError = UnexpectedActionError;
class DuplicateCorrelationError extends Error {
}
transportErrors.DuplicateCorrelationError = DuplicateCorrelationError;
class NoAckError extends Error {
}
transportErrors.NoAckError = NoAckError;
class NotImplementedError extends Error {
}
transportErrors.NotImplementedError = NotImplementedError;
class NotSupportedError extends Error {
}
transportErrors.NotSupportedError = NotSupportedError;
class InternalError extends Error {
    constructor(err) {
        const { message, name, stack, ...rest } = err;
        super(message);
        this.name = name || 'Error';
        this.stack = stack ?? this.toString();
        Object.keys(rest).forEach(key => {
            this[key] = rest[key];
        });
    }
}
// For documentation of the error methods being used see here: https://v8.dev/docs/stack-trace-api
class RuntimeError extends Error {
    static getCallSite(callsToRemove = 0) {
        const length = Error.stackTraceLimit;
        const realCallsToRemove = callsToRemove + 1; // remove this call;
        Error.stackTraceLimit = length + realCallsToRemove;
        // eslint-disable-next-line no-underscore-dangle
        const _prepareStackTrace = Error.prepareStackTrace;
        // This will be called when we access the `stack` property
        Error.prepareStackTrace = (_, stack) => stack;
        // stack is optional in non chromium contexts
        const stack = new Error().stack?.slice(realCallsToRemove) ?? [];
        Error.prepareStackTrace = _prepareStackTrace;
        Error.stackTraceLimit = length;
        return stack;
    }
    static prepareStackTrace(err, callSites) {
        if (typeof Error.prepareStackTrace === 'function') {
            return Error.prepareStackTrace(err, callSites);
        }
        let string = "";
        string += err.name || "Error";
        string += `: ${err.message || ""}`;
        for (const callSite of callSites) {
            string += `\n    at ${callSite.toString()}`;
        }
        return string;
    }
    ;
    constructor(payload, callSites) {
        const { reason, error } = payload;
        super(reason);
        this.name = 'RuntimeError';
        if (error?.stack) {
            this.cause = new InternalError(error);
        }
        if (callSites) {
            this.stack = RuntimeError.prepareStackTrace(this, callSites);
        }
    }
}
transportErrors.RuntimeError = RuntimeError;

var window$1 = {};

var Factory$8 = {};

var validate = {};

Object.defineProperty(validate, "__esModule", { value: true });
validate.validateIdentity = void 0;
function validateIdentity(identity) {
    let errorMsg;
    if (typeof identity !== 'object' || typeof identity.uuid !== 'string') {
        errorMsg = 'Not a valid identity object';
    }
    return errorMsg;
}
validate.validateIdentity = validateIdentity;

var Instance$7 = {};

var application = {};

var Factory$7 = {};

var Instance$6 = {};

var view = {};

var Factory$6 = {};

var warnings = {};

Object.defineProperty(warnings, "__esModule", { value: true });
warnings.handleDeprecatedWarnings = void 0;
const handleDeprecatedWarnings = (options) => {
    if (options.contentNavigation?.whitelist ||
        options.contentNavigation?.blacklist ||
        options.contentRedirect?.whitelist ||
        options.contentRedirect?.blacklist) {
        console.warn(`The properties 'whitelist' and 'blacklist' have been marked as deprecated and will be removed in a future version. Please use 'allowlist' and 'denylist'.`);
    }
};
warnings.handleDeprecatedWarnings = handleDeprecatedWarnings;

var hasRequiredFactory$3;

function requireFactory$3 () {
	if (hasRequiredFactory$3) return Factory$6;
	hasRequiredFactory$3 = 1;
	Object.defineProperty(Factory$6, "__esModule", { value: true });
	Factory$6.ViewModule = void 0;
	const base_1 = base;
	const validate_1 = validate;
	const index_1 = requireView();
	const warnings_1 = warnings;
	/**
	 * Static namespace for OpenFin API methods that interact with the {@link View} class, available under `fin.View`.
	 */
	class ViewModule extends base_1.Base {
	    /**
	     * Creates a new View.
	     * @param options - View creation options
	     *
	     * @example
	     * ```js
	     * let view;
	     * async function createView() {
	     *     const me = await fin.Window.getCurrent();
	     *     return fin.View.create({
	     *         name: 'viewNameCreate',
	     *         target: me.identity,
	     *         bounds: {top: 10, left: 10, width: 200, height: 200}
	     *     });
	     * }
	     *
	     * createView()
	     *     .then((createdView) => {
	     *         view = createdView;
	     *         console.log('View created.', view);
	     *         view.navigate('https://google.com');
	     *         console.log('View navigated to given url.');
	     *     })
	     *     .catch(err => console.log(err));
	     * ```
	     * Note that created views needs to navigate somewhere for them to actually render a website.
	     * @experimental
	     */
	    async create(options) {
	        const { uuid } = this.wire.me;
	        if (!options.name || typeof options.name !== 'string') {
	            throw new Error('Please provide a name property as a string in order to create a View.');
	        }
	        (0, warnings_1.handleDeprecatedWarnings)(options);
	        if (this.wire.environment.childViews) {
	            await this.wire.environment.createChildContent({
	                entityType: 'view',
	                options: { ...options, uuid }
	            });
	        }
	        else {
	            await this.wire.sendAction('create-view', { ...options, uuid });
	        }
	        return this.wrapSync({ uuid, name: options.name });
	    }
	    /**
	     * Asynchronously returns a View object that represents an existing view.
	     *
	     * @example
	     * ```js
	     * fin.View.wrap({ uuid: 'testViewUuid', name: 'testViewName' }))
	     *     .then(view => console.log('wrapped view', view))
	     *     .catch(err => console.log(err));
	     * ```
	     * @experimental
	     */
	    async wrap(identity) {
	        this.wire.sendAction('view-wrap');
	        const errorMsg = (0, validate_1.validateIdentity)(identity);
	        if (errorMsg) {
	            throw new Error(errorMsg);
	        }
	        return new index_1.View(this.wire, identity);
	    }
	    /**
	     * Synchronously returns a View object that represents an existing view.
	     *
	     * @example
	     * ```js
	     * const view = fin.View.wrapSync({ uuid: 'testView', name: 'testViewName' });
	     * await view.hide();
	     * ```
	     * @experimental
	     */
	    wrapSync(identity) {
	        this.wire.sendAction('view-wrap-sync').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const errorMsg = (0, validate_1.validateIdentity)(identity);
	        if (errorMsg) {
	            throw new Error(errorMsg);
	        }
	        return new index_1.View(this.wire, identity);
	    }
	    /**
	     * Asynchronously returns a View object that represents the current view
	     *
	     * @example
	     * ```js
	     * fin.View.getCurrent()
	     *     .then(view => console.log('current view', view))
	     *     .catch(err => console.log(err));
	     *
	     * ```
	     * @experimental
	     */
	    getCurrent() {
	        this.wire.sendAction('view-get-current').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        if (!this.wire.me.isView) {
	            throw new Error('You are not in a View context');
	        }
	        const { uuid, name } = this.wire.me;
	        return this.wrap({ uuid, name });
	    }
	    /**
	     * Synchronously returns a View object that represents the current view
	     *
	     * @example
	     * ```js
	     * const view = fin.View.getCurrentSync();
	     * console.log(view);
	     *
	     * ```
	     * @experimental
	     */
	    getCurrentSync() {
	        this.wire.sendAction('view-get-current-sync').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        if (!this.wire.me.isView) {
	            throw new Error('You are not in a View context');
	        }
	        const { uuid, name } = this.wire.me;
	        return this.wrapSync({ uuid, name });
	    }
	}
	Factory$6.ViewModule = ViewModule;
	return Factory$6;
}

var Instance$5 = {};

var lazy = {};

Object.defineProperty(lazy, "__esModule", { value: true });
lazy.AsyncRetryableLazy = lazy.Lazy = void 0;
/**
 * Handy class for managing asynchronous dependencies of classes.
 *
 * Will call the producer function once and only once when getValue is called,
 * returning the resultant value for every subsequent call.
 */
class Lazy {
    // eslint-disable-next-line
    constructor(producerFn) {
        this.producerFn = producerFn;
    }
    /**
     * Lazily get the value returned by the producer.
     * @returns The value returned from the producer function
     */
    getValue() {
        if (!this.value) {
            this.value = this.producerFn();
        }
        return this.value;
    }
}
lazy.Lazy = Lazy;
/**
 * Handy class for managing asynchronous dependencies of classes.
 *
 * Will call asynchronous producer only after `getValue` is called.  If the
 * deferred code errors, we can try it again by re-calling `getValue` after
 * the promise rejects.
 */
class AsyncRetryableLazy {
    // eslint-disable-next-line
    constructor(producerFn) {
        this.producerFn = producerFn;
    }
    /**
     * Lazily get the value returned by the async producer.
     *
     * @returns The value returned from the producer function
     */
    async getValue() {
        if (!this.promise) {
            this.promise = this.producerFn().catch((e) => {
                delete this.promise;
                throw e;
            });
        }
        return this.promise;
    }
}
lazy.AsyncRetryableLazy = AsyncRetryableLazy;

var layoutEntities = {};

var apiExposer$1 = {};

var apiConsumer = {};

Object.defineProperty(apiConsumer, "__esModule", { value: true });
apiConsumer.ApiConsumer = void 0;
/**
 * Consumer for apis exposed with {@see ApiExposer}.
 *
 * A strategy that matches the strategy used to expose a target API must be provided.
 */
class ApiConsumer {
    // eslint-disable-next-line
    constructor(strategy) {
        this.strategy = strategy;
        /**
         * Consumes an api exposed using a given transport strategy, and generates a client
         * for easy, type safe consumption of that client.
         * @param options Strategy specific consumption options.
         * @returns An api client matching the given type.
         */
        this.consume = async (options) => {
            const exposedProperties = await this.strategy.getExposedFunctions(options);
            return exposedProperties.reduce((client, prop) => ({
                ...client,
                [prop.key]: this.strategy.createFunction(prop, options)
            }), {});
        };
    }
}
apiConsumer.ApiConsumer = ApiConsumer;

var apiExposer = {};

var decorators = {};

Object.defineProperty(decorators, "__esModule", { value: true });
decorators.expose = decorators.getExposedProperties = void 0;
const exposedProperties = Symbol('exposedProperties');
const getExposedProperties = (target) => {
    return target[exposedProperties] || target.prototype[exposedProperties] || [];
};
decorators.getExposedProperties = getExposedProperties;
/**
 * Indicates that a class member function can be exposed using {@link ApiExposer}.
 * @param options Options specific to the strategy used in {@link ApiExposer}
 */
// Returns any as decorator typing is weird.
const expose = (options) => (target, key, descriptor) => {
    target[exposedProperties] = target[exposedProperties] || [];
    target[exposedProperties].push({ key, descriptor, options });
};
decorators.expose = expose;

Object.defineProperty(apiExposer, "__esModule", { value: true });
apiExposer.ApiExposer = void 0;
const decorators_1 = decorators;
/**
 * Exposes api services on the transport of choice.
 */
class ApiExposer {
    /**
     * @param strategy The expose strategy to use to expose instances.
     */
    // eslint-disable-next-line
    constructor(strategy) {
        this.strategy = strategy;
        /**
         * Exposes an instance of a given api on
         * @param instance Instance of a class which has been decorated to indicate which functions can be exposed.
         * @param instanceOptions Transport strategy specific options to use when exposing.
         */
        this.exposeInstance = async (instance, instanceOptions) => {
            const exposableProps = (0, decorators_1.getExposedProperties)(instance);
            const exposedProps = await Promise.all(exposableProps.map(async ({ key, options }) => {
                const customConsumptionOptions = await this.strategy.exposeFunction(instance[key].bind(instance), {
                    key,
                    options,
                    meta: instanceOptions
                });
                return {
                    key,
                    options: customConsumptionOptions
                };
            }));
            await this.strategy.exposeMeta(instanceOptions, exposedProps);
        };
    }
    ;
}
apiExposer.ApiExposer = ApiExposer;

var strategies = {};

var openfinChannels = {};

var channelsConsumer = {};

Object.defineProperty(channelsConsumer, "__esModule", { value: true });
channelsConsumer.ChannelsConsumer = void 0;
class ChannelsConsumer {
    // eslint-disable-next-line
    constructor(channel) {
        this.channel = channel;
        this.getExposedFunctions = async (options) => {
            const { id } = options;
            const { props } = await this.channel.dispatch(`api-meta:${id}`);
            return props;
        };
        this.createFunction = (prop) => (...args) => {
            const { action } = prop.options;
            return this.channel.dispatch(action, { args });
        };
    }
    ;
}
channelsConsumer.ChannelsConsumer = ChannelsConsumer;

var channelsExposer = {};

Object.defineProperty(channelsExposer, "__esModule", { value: true });
channelsExposer.ChannelsExposer = void 0;
class ChannelsExposer {
    // eslint-disable-next-line
    constructor(channelProviderOrClient) {
        this.channelProviderOrClient = channelProviderOrClient;
        this.exposeFunction = async (target, config) => {
            const { key, options, meta } = config;
            const { id } = meta;
            const action = `${id}.${options?.action || key}`;
            await this.channelProviderOrClient.register(action, async ({ args }) => {
                return target(...args);
            });
            return { action };
        };
        this.exposeMeta = async ({ id }, props) => {
            const action = `api-meta:${id}`;
            await this.channelProviderOrClient.register(action, () => ({ props }));
        };
    }
}
channelsExposer.ChannelsExposer = ChannelsExposer;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(channelsConsumer, exports);
	__exportStar(channelsExposer, exports); 
} (openfinChannels));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(openfinChannels, exports); 
} (strategies));

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(apiConsumer, exports);
	__exportStar(apiExposer, exports);
	__exportStar(strategies, exports);
	__exportStar(decorators, exports); 
} (apiExposer$1));

var channelApiRelay = {};

Object.defineProperty(channelApiRelay, "__esModule", { value: true });
channelApiRelay.createRelayedDispatch = channelApiRelay.relayChannelClientApi = void 0;
const EXPECTED_ERRORS = [
    'no longer connected',
    'RTCDataChannel closed unexpectedly',
    'The client you are trying to dispatch from is disconnected from the target provider',
];
// Checks possible error messages that we want to trap, client error message can originate
// from ChannelProvider::dispatch OR ClassicStrategy::closeEndpoint OR RTCEndPoint::dataChannel::onclose
const isDisconnectedError = (errorMsg) => {
    return EXPECTED_ERRORS.some(e => errorMsg.includes(e));
};
/**
 * @internal
 * Create a channel relay for a given channel exposition, allowing a single provider to route
 * actions to the designated clients.
 *
 * Designed to be used in conjunction with @expose
 *
 * @param channelProvider The channel provider to relay the actions on.
 * @param config Determines which actions to relay. Please ensure action prefix matches the exposed api.
 */
const relayChannelClientApi = async (channelProvider, relayId) => {
    channelProvider.register(`relay:${relayId}`, ({ action, target, payload }) => {
        return channelProvider.dispatch(target, action, payload);
    });
    await Promise.resolve();
};
channelApiRelay.relayChannelClientApi = relayChannelClientApi;
const createRelayedDispatch = (client, target, relayId, relayErrorMsg) => async (action, payload) => {
    try {
        return await client.dispatch(`relay:${relayId}`, {
            action,
            payload,
            target
        });
    }
    catch (e) {
        if (isDisconnectedError(e.message) && relayErrorMsg) {
            throw new Error(relayErrorMsg);
        }
        throw e;
    }
};
channelApiRelay.createRelayedDispatch = createRelayedDispatch;

var __classPrivateFieldSet$c = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$e = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LayoutNode_client, _TabStack_client, _ColumnOrRow_client;
Object.defineProperty(layoutEntities, "__esModule", { value: true });
layoutEntities.ColumnOrRow = layoutEntities.TabStack = layoutEntities.LayoutNode = void 0;
const api_exposer_1 = apiExposer$1;
const channel_api_relay_1 = channelApiRelay;
/*
    This file includes LayoutNode, ColumnOrRow and TabStack classes, which are all closely
    intertwined, and share members via parent abstract class LayoutNode. To prevent circular
    refs, we define and export all the classes here.
*/
/**
 * @ignore
 * @internal
 * Supplies an ApiClient for {@link LayoutEntitiesController} and helper methods
 * for the entities {@link TabStack} AND {@link ColumnOrRow} to use.
 */
class LayoutNode {
    /**
     * @internal
     * @ignore
     */
    constructor(client, entityId) {
        /**
         * @ignore
         * @internal
         * ApiClient for {@link LayoutEntitiesController}
         */
        _LayoutNode_client.set(this, void 0);
        /**
         * Checks if the TabStack or ColumnOrRow is the root content item
         *
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * const isRoot = await stack.isRoot();
         * // The TabStack is root: false
         * console.log(`The TabStack is root: ${isRoot}`);
         *
         * // Retrieves the parent ColumnOrRow
         * const parent = await stack.getParent();
         * const parentIsRoot = await parent.isRoot();
         * // The parent ColumnOrRow is root: true
         * console.log(`The parent ColumnOrRow is root: ${parentIsRoot}`);
         * ```
         */
        this.isRoot = () => __classPrivateFieldGet$e(this, _LayoutNode_client, "f").isRoot(this.entityId);
        /**
         * Checks if the TabStack or ColumnOrRow exists
         *
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * // Retrieves the parent ColumnOrRow
         * const columnOrRow = await stack.getParent();
         * let exists = await stack.exists();
         * // or
         * let exists = await columnOrRow.exists();
         * // The entity exists: true
         * console.log(`The entity exists: ${exists}`);
         * ```
         */
        this.exists = () => __classPrivateFieldGet$e(this, _LayoutNode_client, "f").exists(this.entityId);
        /**
         * Retrieves the parent of the TabStack or ColumnOrRow
         *
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * // Retrieves the parent ColumnOrRow
         * const columnOrRow = await stack.getParent();
         *
         * // undefined if entity is the root item
         * let parent = await columnOrRow.getParent();
         * // or
         * let parent = await stack.getParent();
         * ```
         */
        this.getParent = async () => {
            const parent = await __classPrivateFieldGet$e(this, _LayoutNode_client, "f").getParent(this.entityId);
            if (!parent) {
                return undefined;
            }
            return LayoutNode.getEntity(parent, __classPrivateFieldGet$e(this, _LayoutNode_client, "f"));
        };
        /**
         * Creates a new TabStack adjacent to the given TabStack or ColumnOrRow. Inputs can be new views to create, or existing views.
         *
         * Known Issue: If the number of views to add overflows the tab-container, the added views will be set as active
         * during each render, and then placed at the front of the tab-stack, while the underlying order of tabs will remain unchanged.
         * This means the views you pass to createAdjacentStack() may not render in the order given by the array.
         * Until fixed, this problem can be avoided only if your window is wide enough to fit creating all the views in the tabstack.
         *
         * @param views The views that will populate the new TabStack.
         * @param options Additional options that control new TabStack creation.
         * @returns The newly-created TabStack.
         *
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * const columnOrRow = await stack.getParent();
         *
         * // Create view references by supplying a 'name' and 'url'
         * const views = [
         *     // if 'name' is undefined, one will be generated
         *     // if 'url' is undefined, it will default the view URL to 'about:blank'
         *     { name: 'google-view', url: 'http://google.com/'},
         *     { name: 'of-developers-view', url: 'http://developers.openfin.co/'},
         * ];
         *
         * // Create a view beforehand to be included in the new tab stack
         * const outsideView = await fin.View.create({
         *     name: 'outside-bloomberg-view',
         *     url: 'https://bloomberg.com/',
         *     target: fin.me.identity,
         * });
         *
         * // Views to add can be identities, or the reference views mentioned above
         * const viewsToAdd = [outsideView.identity, ...views];
         *
         * // Possible position inputs: 'right' | 'left' | 'top' | 'bottom'
         * let stackFrom = await columnOrRow.createAdjacentStack(viewsToAdd, { position: 'right' });
         * // Or
         * let newStack = await stack.createAdjacentStack(viewsToAdd, { position: 'right' });
         * console.log(`A new TabStack created to the right has ${newStack.length} views in it`);
         *
         * ```
         * @experimental
         */
        this.createAdjacentStack = async (views, options) => {
            const entityId = await __classPrivateFieldGet$e(this, _LayoutNode_client, "f").createAdjacentStack(this.entityId, views, options);
            return LayoutNode.getEntity({ entityId, type: 'stack' }, __classPrivateFieldGet$e(this, _LayoutNode_client, "f"));
        };
        /**
         * Retrieves the adjacent TabStacks of the given TabStack or ColumnOrRow.
         *
         * @param edge Edge whose adjacent TabStacks will be returned.
         *
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * const columnOrRow = await stack.getParent();
         * // Possible position inputs: 'right' | 'left' | 'top' | 'bottom'
         * let rightStacks = await columnOrRow.getAdjacentStacks('right');
         * let leftStacks = await columnOrRow.getAdjacentStacks('left');
         * // or
         * let rightStacks = await stack.getAdjacentStacks('right');
         * let leftStacks = await stack.getAdjacentStacks('left');
         *
         * console.log(`The entity has ${rightStacks.length} stacks to the right, and ${leftStacks.length} stacks to the left`);
         *
         * ```
         * @experimental
         */
        this.getAdjacentStacks = async (edge) => {
            const adjacentStacks = await __classPrivateFieldGet$e(this, _LayoutNode_client, "f").getAdjacentStacks({
                targetId: this.entityId,
                edge
            });
            return adjacentStacks.map((stack) => LayoutNode.getEntity({
                type: 'stack',
                entityId: stack.entityId
            }, __classPrivateFieldGet$e(this, _LayoutNode_client, "f")));
        };
        __classPrivateFieldSet$c(this, _LayoutNode_client, client, "f");
        this.entityId = entityId;
    }
}
layoutEntities.LayoutNode = LayoutNode;
_LayoutNode_client = new WeakMap();
/**
 * @ignore
 * @internal
 * Encapsulates Api consumption of {@link LayoutEntitiesClient} with a relayed dispatch
 * @param client
 * @param controllerId
 * @param identity
 * @returns a new instance of {@link LayoutEntitiesClient} with bound to the controllerId
 */
LayoutNode.newLayoutEntitiesClient = async (client, controllerId, identity) => {
    const dispatch = (0, channel_api_relay_1.createRelayedDispatch)(client, identity, 'layout-relay', 'You are trying to interact with a layout component on a window that does not exist or has been destroyed.');
    const consumer = new api_exposer_1.ApiConsumer(new api_exposer_1.ChannelsConsumer({ dispatch }));
    return consumer.consume({ id: controllerId });
};
LayoutNode.getEntity = (definition, client) => {
    const { entityId, type } = definition;
    switch (type) {
        case 'column':
        case 'row':
            return new ColumnOrRow(client, entityId, type);
        case 'stack':
            return new TabStack(client, entityId);
        default:
            throw new Error(`Unrecognised Layout Entity encountered ('${JSON.stringify(definition)})`);
    }
};
/**
 * A TabStack is used to manage the state of a stack of tabs within an OpenFin Layout.
 */
class TabStack extends LayoutNode {
    /** @internal */
    constructor(client, entityId) {
        super(client, entityId);
        /**
         * @internal
         * ApiClient for {@link LayoutEntitiesController}
         */
        _TabStack_client.set(this, void 0);
        /**
         * Type of the content item. Always stack, but useful for distinguishing between a {@link TabStack} and {@link ColumnOrRow}.
         */
        this.type = 'stack';
        /**
         * Retrieves a list of all views belonging to this {@link TabStack}.
         *
         * Known Issue: If adding a view overflows the tab-container width, the added view will be set as active
         * and rendered at the front of the tab-stack, while the underlying order of tabs will remain unchanged.
         * If that happens and then getViews() is called, it will return the identities in a different order than
         * than the currently rendered tab order.
         *
         *
         * @throws If the {@link TabStack} has been destroyed.
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * // Alternatively, you can wrap any view and get the stack from there
         * // const viewFromSomewhere = fin.View.wrapSync(someView.identity);
         * // const stack = await viewFromSomewhere.getCurrentStack();
         * const views = await stack.getViews();
         * console.log(`Stack contains ${views.length} view(s)`);
         * ```
         * @experimental
         */
        this.getViews = () => __classPrivateFieldGet$e(this, _TabStack_client, "f").getStackViews(this.entityId);
        /**
         * Adds or creates a view in this {@link TabStack}.
         *
         * @remarks Known Issue: If adding a view overflows the tab-container, the added view will be set as active
         * and rendered at the front of the tab-stack, while the underlying order of tabs will remain unchanged.
         *
         * @param view The identity of an existing view to add, or options to create a view.
         * @param options Optional view options: index number used to insert the view into the stack at that index. Defaults to 0 (front of the stack)
         * @returns Resolves with the {@link OpenFin.Identity identity} of the added view.
         * @throws If the view does not exist or fails to create.
         * @throws If the {@link TabStack} has been destroyed.
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * // Alternatively, you can wrap any view and get the stack from there
         * // const viewFromSomewhere = fin.View.wrapSync(someView.identity);
         * // const stack = await viewFromSomewhere.getCurrentStack();
         * const googleViewIdentity = await stack.addView({ name: 'google-view', url: 'http://google.com/' });
         * console.log('Identity of the google view just added', { googleViewIdentity });
         * // pass in { index: number } to set the index in the stack. Here 1 means, end of the stack (defaults to 0)
         * const appleViewIdentity = await stack.addView({ name: 'apple-view', url: 'http://apple.com/' }, { index: 1 });
         * console.log('Identity of the apple view just added', { appleViewIdentity });
         * ```
         * @experimental
         */
        this.addView = async (view, options = { index: 0 }) => __classPrivateFieldGet$e(this, _TabStack_client, "f").addViewToStack(this.entityId, view, options);
        /**
         * Removes a view from this {@link TabStack}.
         *
         * @remarks Throws an exception if the view identity does not exist or was already destroyed.
         *
         * @param view - Identity of the view to remove.
         * @throws If the view does not exist or does not belong to the stack.
         * @throws If the {@link TabStack} has been destroyed.
         *
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * const googleViewIdentity = await stack.addView({ name: 'google-view', url: 'http://google.com/' });
         *
         * await stack.removeView(googleViewIdentity);
         *
         * try {
         *     await stack.removeView(googleViewIdentity);
         * } catch (error) {
         *     // Tried to remove a view ('google-view') which does not belong to the stack.
         *     console.log(error);
         * }
         * ```
         */
        this.removeView = async (view) => {
            await __classPrivateFieldGet$e(this, _TabStack_client, "f").removeViewFromStack(this.entityId, view);
        };
        /**
         * Sets the active view of the {@link TabStack} without focusing it.
         * @param view - Identity of the view to activate.
         * @returns Promise which resolves with void once the view has been activated.
         * @throws If the {@link TabStack} has been destroyed.
         * @throws If the view does not exist.
         * @example
         * Change the active tab of a known View's TabStack:
         * ```js
         * const targetView = fin.View.wrapSync({ uuid: 'uuid', name: 'view-name' });
         * const stack = await targetView.getCurrentStack();
         * await stack.setActiveView(targetView.identity);
         * ```
         *
         * Set the current View as active within its TabStack:
         * ```js
         * const stack = await fin.me.getCurrentStack();
         * await stack.setActiveView(fin.me.identity);
         * ```
         * @experimental
         */
        this.setActiveView = async (view) => {
            await __classPrivateFieldGet$e(this, _TabStack_client, "f").setStackActiveView(this.entityId, view);
        };
        __classPrivateFieldSet$c(this, _TabStack_client, client, "f");
    }
}
layoutEntities.TabStack = TabStack;
_TabStack_client = new WeakMap();
/**
 * A ColumnOrRow is used to manage the state of Column and Rows within an OpenFin Layout.
 */
class ColumnOrRow extends LayoutNode {
    /**
     * @internal
     */
    constructor(client, entityId, type) {
        super(client, entityId);
        /**
         * @ignore
         * @internal
         * ApiClient for {@link LayoutEntitiesController}
         */
        _ColumnOrRow_client.set(this, void 0);
        /**
         * Retrieves the content array of the ColumnOrRow
         *
         * @example
         * ```js
         * if (!fin.me.isView) {
         *     throw new Error('Not running in a platform View.');
         * }
         *
         * const stack = await fin.me.getCurrentStack();
         * // Retrieves the parent ColumnOrRow
         * const columnOrRow = await stack.getParent();
         *
         * // returns [TabStack]
         * const contentArray = await columnOrRow.getContent();
         * console.log(`The ColumnOrRow has ${contentArray.length} item(s)`);
         * ```
         */
        this.getContent = async () => {
            const contentItemEntities = await __classPrivateFieldGet$e(this, _ColumnOrRow_client, "f").getContent(this.entityId);
            return contentItemEntities.map((entity) => LayoutNode.getEntity(entity, __classPrivateFieldGet$e(this, _ColumnOrRow_client, "f")));
        };
        __classPrivateFieldSet$c(this, _ColumnOrRow_client, client, "f");
        this.type = type;
    }
}
layoutEntities.ColumnOrRow = ColumnOrRow;
_ColumnOrRow_client = new WeakMap();

var layout_constants = {};

Object.defineProperty(layout_constants, "__esModule", { value: true });
layout_constants.DEFAULT_LAYOUT_KEY = layout_constants.LAYOUT_CONTROLLER_ID = void 0;
layout_constants.LAYOUT_CONTROLLER_ID = 'layout-entities';
// TODO: eventually export this somehow
layout_constants.DEFAULT_LAYOUT_KEY = '__default__';

var main = {};

Object.defineProperty(main, "__esModule", { value: true });
main.WebContents = void 0;
const base_1$k = base;
class WebContents extends base_1$k.EmitterBase {
    /**
     * @param identity The identity of the {@link OpenFin.WebContentsEvents WebContents}.
     * @param entityType The type of the {@link OpenFin.WebContentsEvents WebContents}.
     */
    constructor(wire, identity, entityType) {
        super(wire, entityType, identity.uuid, identity.name);
        this.identity = identity;
        this.entityType = entityType;
    }
    /**
     * Gets a base64 encoded image of all or part of the WebContents.
     * @param options Options for the capturePage call.
     *
     * @example
     *
     * View:
     * ```js
     * const view = fin.View.getCurrentSync();
     *
     * // PNG image of a full visible View
     * console.log(await view.capturePage());
     *
     * // Low-quality JPEG image of a defined visible area of the view
     * const options = {
     *     area: {
     *         height: 100,
     *         width: 100,
     *         x: 10,
     *         y: 10,
     *     },
     *     format: 'jpg',
     *     quality: 20
     * }
     * console.log(await view.capturePage(options));
     * ```
     *
     * Window:
     * ```js
     * const wnd = await fin.Window.getCurrent();
     *
     * // PNG image of a full visible window
     * console.log(await wnd.capturePage());
     *
     * // Low-quality JPEG image of a defined visible area of the window
     * const options = {
     *     area: {
     *         height: 100,
     *         width: 100,
     *         x: 10,
     *         y: 10,
     *     },
     *     format: 'jpg',
     *     quality: 20
     * }
     * console.log(await wnd.capturePage(options));
     * ```
     *
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    capturePage(options) {
        return this.wire.sendAction('capture-page', { options, ...this.identity }).then(({ payload }) => payload.data);
    }
    /**
     * Executes Javascript on the WebContents, restricted to contents you own or contents owned by
     * applications you have created.
     * @param code JavaScript code to be executed on the view.
     *
     * @example
     * View:
     * ```js
     * async function executeJavaScript(code) {
     *     const view = await fin.View.wrap({uuid: 'uuid', name: 'view name'});
     *     return await view.executeJavaScript(code);
     * }
     *
     * executeJavaScript(`console.log('Hello, Openfin')`).then(() => console.log('Javascript excuted')).catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function executeJavaScript(code) {
     *     const app = await fin.Application.start({
     *         name: 'myApp',
     *         uuid: 'app-1',
     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.executeJavaScript.html',
     *         autoShow: true
     *     });
     *     const win = await app.getWindow();
     *     return await win.executeJavaScript(code);
     * }
     *
     * executeJavaScript(`console.log('Hello, Openfin')`).then(() => console.log('Javascript excuted')).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    executeJavaScript(code) {
        return this.wire
            .sendAction('execute-javascript-in-window', { ...this.identity, code })
            .then(({ payload }) => payload.data);
    }
    /**
     * Returns the zoom level of the WebContents.
     *
     * @example
     * View:
     * ```js
     * async function getZoomLevel() {
     *     const view = await fin.View.getCurrent();
     *     return await view.getZoomLevel();
     * }
     *
     * getZoomLevel().then(zoomLevel => console.log(zoomLevel)).catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function createWin() {
     *     const app = await fin.Application.start({
     *         name: 'myApp',
     *         uuid: 'app-1',
     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getZoomLevel.html',
     *         autoShow: true
     *     });
     *     return await app.getWindow();
     * }
     *
     * async function getZoomLevel() {
     *     const win = await createWin();
     *     return await win.getZoomLevel();
     * }
     *
     * getZoomLevel().then(zoomLevel => console.log(zoomLevel)).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    getZoomLevel() {
        return this.wire.sendAction('get-zoom-level', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Sets the zoom level of the WebContents.
     * @param level The zoom level
     *
     * @example
     * View:
     * ```js
     * async function setZoomLevel(number) {
     *     const view = await fin.View.getCurrent();
     *     return await view.setZoomLevel(number);
     * }
     *
     * setZoomLevel(4).then(() => console.log('Setting a  zoom level')).catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function createWin() {
     *     const app = await fin.Application.start({
     *         name: 'myApp',
     *         uuid: 'app-1',
     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.setZoomLevel.html',
     *         autoShow: true
     *     });
     *     return await app.getWindow();
     * }
     *
     * async function setZoomLevel(number) {
     *     const win = await createWin();
     *     return await win.setZoomLevel(number);
     * }
     *
     * setZoomLevel(4).then(() => console.log('Setting a  zoom level')).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    setZoomLevel(level) {
        return this.wire.sendAction('set-zoom-level', { ...this.identity, level }).then(() => undefined);
    }
    /**
     * Navigates the WebContents to a specified URL.
     *
     * Note: The url must contain the protocol prefix such as http:// or https://.
     * @param url - The URL to navigate the WebContents to.
     *
     * @example
     * View:
     * ```js
     * async function createView() {
     *     const me = await fin.Window.getCurrent();
     *     return fin.View.create({
     *         name: 'viewName',
     *         target: me.identity,
     *         bounds: {top: 10, left: 10, width: 200, height: 200}
     *     });
     * }
     *
     * createView()
     *     .then(view => view.navigate('https://example.com'))
     *     .then(() => console.log('navigation complete'))
     *     .catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function navigate() {
     *     const win = await fin.Window.getCurrent();
     *     return await win.navigate('https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.navigate.html');
     * }
     * navigate().then(() => console.log('Navigate to tutorial')).catch(err => console.log(err));
     * ```
     * @experimental
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    navigate(url) {
        return this.wire.sendAction('navigate-window', { ...this.identity, url }).then(() => undefined);
    }
    /**
     * Navigates the WebContents back one page.
     *
     * @example
     * View:
     * ```js
     * async function navigateBack() {
     *     const view = await fin.View.wrap({ name: 'testapp-view', uuid: 'testapp' });
     *     await view.navigate('https://www.google.com');
     *     return await view.navigateBack();
     * }
     * navigateBack().then(() => console.log('Navigated back')).catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function navigateBack() {
     *     const win = await fin.Window.wrap({ name: 'testapp', uuid: 'testapp' });
     *     await win.navigate('https://www.google.com');
     *     return await win.navigateBack();
     * }
     * navigateBack().then(() => console.log('Navigated back')).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    navigateBack() {
        return this.wire.sendAction('navigate-window-back', { ...this.identity }).then(() => undefined);
    }
    /**
     * Navigates the WebContents forward one page.
     *
     * @example
     * View:
     * ```js
     * async function navigateForward() {
     *     const view = await fin.View.getCurrent();
     *     await view.navigate('https://www.google.com');
     *     await view.navigateBack();
     *     return await view.navigateForward();
     * }
     * navigateForward().then(() => console.log('Navigated forward')).catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function navigateForward() {
     *     const win = await fin.Window.getCurrent();
     *     await win.navigate('https://www.google.com');
     *     await win.navigateBack();
     *     return await win.navigateForward();
     * }
     * navigateForward().then(() => console.log('Navigated forward')).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async navigateForward() {
        await this.wire.sendAction('navigate-window-forward', { ...this.identity });
    }
    /**
     * Stops any current navigation the WebContents is performing.
     *
     * @example
     * View:
     * ```js
     * async function stopNavigation() {
     *     const view = await fin.View.wrap({ name: 'testapp-view', uuid: 'testapp' });
     *     await view.navigate('https://www.google.com');
     *     return await view.stopNavigation();
     * }
     * stopNavigation().then(() => console.log('you shall not navigate')).catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function stopNavigation() {
     *     const win = await fin.Window.wrap({ name: 'testapp', uuid: 'testapp' });
     *     await win.navigate('https://www.google.com');
     *     return await win.stopNavigation();
     * }
     * stopNavigation().then(() => console.log('you shall not navigate')).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    stopNavigation() {
        return this.wire.sendAction('stop-window-navigation', { ...this.identity }).then(() => undefined);
    }
    /**
     * Reloads the WebContents
     *
     * @example
     * View:
     * ```js
     * async function reload() {
     * 	const view = await fin.View.getCurrent();
     *     return await view.reload();
     * }
     *
     * reload().then(() => {
     * 		console.log('Reloaded view')
     * }).catch(err => console.log(err));
     * ```
     *
     * Window:
     * ```js
     * async function reloadWindow() {
     * 		const app = await fin.Application.start({
     * 				name: 'myApp',
     * 				uuid: 'app-1',
     * 				url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.reload.html',
     * 				autoShow: true
     * 		});
     * 		const win = await app.getWindow();
     *     return await win.reload();
     * }
     *
     * reloadWindow().then(() => {
     * 		console.log('Reloaded window')
     * }).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    reload(ignoreCache = false) {
        return this.wire
            .sendAction('reload-window', {
            ignoreCache,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Prints the WebContents.
     * @param options Printer Options
     *
     * Note: When `silent` is set to `true`, the API will pick the system's default printer if deviceName
     * is empty and the default settings for printing.
     *
     * Use the CSS style `page-break-before: always;` to force print to a new page.
     *
     * @example
     * ```js
     * const view = fin.View.getCurrentSync();
     *
     * view.print({ silent: false, deviceName: 'system-printer-name' }).then(() => {
     *     console.log('print call has been sent to the system');
     * });
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    print(options = {}) {
        return this.wire.sendAction('print', { ...this.identity, options }).then(() => undefined);
    }
    /**
     * Find and highlight text on a page.
     * @param searchTerm Term to find in page
     * @param options Search options
     *
     * Note: By default, each subsequent call will highlight the next text that matches the search term.
     *
     * Returns a promise with the results for the request. By subscribing to the
     * found-in-page event, you can get the results of this call as well.
     *
     * @example
     * View:
     * ```js
     * const view = fin.View.getCurrentSync();
     *
     * //By subscribing to the 'found in page' event we can get the results of each findInPage call made.
     * view.addListener('found-in-page', (event) => {
     *     console.log(event);
     * });
     *
     * // The promise also returns the results for the request
     * view.findInPage('a').then((result) => {
     *     console.log(result)
     * });
     * ```
     *
     * Window:
     * ```js
     * const win = fin.Window.getCurrentSync();
     *
     * //By subscribing to the 'found in page' event we can get the results of each findInPage call made.
     * win.addListener('found-in-page', (event) => {
     *     console.log(event);
     * });
     *
     * // The promise also returns the results for the request
     * win.findInPage('a').then((result) => {
     *     console.log(result)
     * });
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    findInPage(searchTerm, options) {
        return this.wire
            .sendAction('find-in-page', { ...this.identity, searchTerm, options })
            .then(({ payload }) => payload.data);
    }
    /**
     * Stop a {@link View#findInPage findInPage} call by specifying any of these actions:
     *
     * * clearSelection - Clear the selection.
     * * keepSelection - Translate the selection into a normal selection.
     * * activateSelection - Focus and click the selection node.
     *
     * @example
     * View:
     * ```js
     * const view = fin.View.getCurrentSync();
     *
     * view.addListener('found-in-page', (event) => {
     *     setTimeout(() => {
     *         view.stopFindInPage('clearSelection');
     *     }, 5000);
     * });
     *
     * view.findInPage('a').then(results => {
     *     console.log(results);
     * });
     * ```
     *
     * Window:
     * ```js
     * const win = fin.Window.getCurrentSync();
     *
     * win.addListener('found-in-page', (event) => {
     *     setTimeout(() => {
     *         win.stopFindInPage('clearSelection');
     *     }, 5000);
     * });
     *
     * win.findInPage('a').then(results => {
     *     console.log(results);
     * });
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    stopFindInPage(action) {
        return this.wire.sendAction('stop-find-in-page', { ...this.identity, action }).then(() => undefined);
    }
    /**
     * Returns an array with all system printers
     * @deprecated use System.getPrinters instead
     *
     * @example
     * View:
     * ```js
     * const view = fin.View.getCurrentSync();
     *
     * view.getPrinters()
     *     .then((printers) => {
     *         printers.forEach((printer) => {
     *             if (printer.isDefault) {
     *                 console.log(printer);
     *             }
     *         });
     *     })
     *     .catch((err) => {
     *         console.log(err);
     *     });
     * ```
     *
     * Window:
     * ```js
     * const win = fin.Window.getCurrentSync();
     *
     * win.getPrinters()
     *     .then((printers) => {
     *         printers.forEach((printer) => {
     *             if (printer.isDefault) {
     *                 console.log(printer);
     *             }
     *         });
     *     })
     *     .catch((err) => {
     *         console.log(err);
     *     });
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    getPrinters() {
        return this.wire.sendAction('get-printers', { ...this.identity }).then(({ payload }) => payload.data);
    }
    /**
     * Gives focus to the WebContents.
     *
     * @example
     * ```js
     * async function focusWindow() {
     *     const app = await fin.Application.start({
     *         name: 'myApp',
     *         uuid: 'app-1',
     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.focus.html',
     *         autoShow: true
     *     });
     *     const win = await app.getWindow();
     *     return await win.focus();
     * }
     *
     * focusWindow().then(() => console.log('Window focused')).catch(err => console.log(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async focus({ emitSynthFocused } = { emitSynthFocused: true }) {
        await this.wire.sendAction('focus-window', { emitSynthFocused, ...this.identity });
    }
    /**
     * Shows the Chromium Developer Tools
     *
     * @example
     * View:
     * ```js
     * async function showDeveloperTools() {
     *     const view = await fin.View.getCurrent();
     *     return view.showDeveloperTools();
     * }
     *
     * showDevelopertools()
     * .then(() => console.log('Showing dev tools'))
     * .catch(err => console.error(err));
     * ```
     *
     * Window:
     * ```js
     * async function showDeveloperTools() {
     *     const win = await fin.Window.getCurrent();
     *     return win.showDeveloperTools();
     * }
     *
     * showDevelopertools()
     * .then(() => console.log('Showing dev tools'))
     * .catch(err => console.error(err));
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async showDeveloperTools() {
        // Note this hits the system action map in core state for legacy reasons.
        await this.wire.sendAction('show-developer-tools', this.identity);
    }
    /**
     * Retrieves the process information associated with a WebContents.
     *
     * Note: This includes any iframes associated with the WebContents
     *
     * @example
     * View:
     * ```js
     *     const view = await fin.View.getCurrent();
     *     const processInfo = await view.getProcessInfo();
     * ```
     *
     * Window:
     * ```js
     *     const win = await fin.Window.getCurrent();
     *     const processInfo = await win.getProcessInfo();
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async getProcessInfo() {
        const { payload: { data } } = await this.wire.sendAction('get-process-info', this.identity);
        return data;
    }
    /**
     * Retrieves information on all Shared Workers.
     *
     * @example
     * View:
     * ```js
     *     const view = await fin.View.create({
     *         name: 'viewName',
     *         target: fin.me.identity,
     *         bounds: {top: 10, left: 10, width: 200, height: 200}
     *     });
     *
     *     await view.navigate('http://mdn.github.io/simple-shared-worker/index2.html');
     *
     *     const sharedWorkers = await view.getSharedWorkers();
     * ```
     *
     * Window:
     * ```js
     *     const winOption = {
     *         name:'child',
     *         defaultWidth: 300,
     *         defaultHeight: 300,
     *         url: 'http://mdn.github.io/simple-shared-worker/index2.html',
     *         frame: true,
     *         autoShow: true
     *     };
     *     const win = await fin.Window.create(winOption);
     *     const sharedWorkers = await win.getSharedWorkers();
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async getSharedWorkers() {
        return this.wire.sendAction('get-shared-workers', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Opens the developer tools for the shared worker context.
     *
     * @example
     * View:
     * ```js
     *     const view = await fin.View.create({
     *         name: 'viewName',
     *         target: fin.me.identity,
     *         bounds: {top: 10, left: 10, width: 200, height: 200}
     *     });
     *
     *     await view.navigate('http://mdn.github.io/simple-shared-worker/index2.html');
     *
     *     await view.inspectSharedWorker();
     * ```
     *
     * Example:
     * ```js
     *     const winOption = {
     *         name:'child',
     *         defaultWidth: 300,
     *         defaultHeight: 300,
     *         url: 'http://mdn.github.io/simple-shared-worker/index2.html',
     *         frame: true,
     *         autoShow: true
     *     };
     *     const win = await fin.Window.create(winOption);
     *     await win.inspectSharedWorker();
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async inspectSharedWorker() {
        await this.wire.sendAction('inspect-shared-worker', { ...this.identity });
    }
    /**
     * Inspects the shared worker based on its ID.
     * @param workerId - The id of the shared worker.
     *
     * @example
     * View:
     * ```js
     *     const view = await fin.View.create({
     *         name: 'viewName',
     *         target: fin.me.identity,
     *         bounds: {top: 10, left: 10, width: 200, height: 200}
     *     });
     *
     *     await view.navigate('http://mdn.github.io/simple-shared-worker/index2.html');
     *
     *     const sharedWorkers = await view.getSharedWorkers();
     *     await view.inspectSharedWorkerById(sharedWorkers[0].id);
     * ```
     *
     * Window:
     * ```js
     *     const winOption = {
     *         name:'child',
     *         defaultWidth: 300,
     *         defaultHeight: 300,
     *         url: 'http://mdn.github.io/simple-shared-worker/index2.html',
     *         frame: true,
     *         autoShow: true
     *     };
     *     const win = await fin.Window.create(winOption);
     *     const sharedWorkers = await win.getSharedWorkers();
     *     await win.inspectSharedWorkerById(sharedWorkers[0].id);
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async inspectSharedWorkerById(workerId) {
        await this.wire.sendAction('inspect-shared-worker-by-id', { ...this.identity, workerId });
    }
    /**
     * Opens the developer tools for the service worker context.
     *
     * @example
     * View:
     * ```js
     *     const view = await fin.View.create({
     *         name: 'viewName',
     *         target: fin.me.identity,
     *         bounds: {top: 10, left: 10, width: 200, height: 200}
     *     });
     *
     *     await view.navigate('http://googlechrome.github.io/samples/service-worker/basic/index.html');
     *
     *     await view.inspectServiceWorker();
     * ```
     *
     * Window:
     * ```js
     *     const winOption = {
     *         name:'child',
     *         defaultWidth: 300,
     *         defaultHeight: 300,
     *         url: 'http://googlechrome.github.io/samples/service-worker/basic/index.html',
     *         frame: true,
     *         autoShow: true
     *     };
     *     const win = await fin.Window.create(winOption);
     *     await win.inspectServiceWorker();
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async inspectServiceWorker() {
        await this.wire.sendAction('inspect-service-worker', { ...this.identity });
    }
    /**
     * Shows a popup window.
     *
     * Note: If this WebContents is a view and its attached window has a popup open, this will close it.
     *
     * Shows a popup window. Including a `name` in `options` will attempt to show an existing window as a popup, if
     * that window doesn't exist or no `name` is included a window will be created. If the caller view or the caller
     * view's parent window currently has a popup window open, calling `showPopupWindow` again will dismiss the currently
     * open popup window before showing the new popup window. Also, if the caller view is destroyed or detached, the popup
     * will be dismissed.
     *
     * Note: in the case where the window being shown as a popup needs to be created, it is a child of the caller view's parent window.
     *
     * @example
     *
     * Create and show a single-use popup window that returns a single result to the caller. `initialOptions` allows
     * us to pass window options to the popup window that will be created. `resultDispatchBehavior: 'close'` ensures
     * that once the popup window calls `dispatchPopupResult` it is closed. `blurBehavior: 'close'` will yield a dismissed
     * result should the popup window lose focus.
     *
     * ```js
     * const result = await fin.me.showPopupWindow({
     *     initialOptions: {
     *         frame: false
     *     },
     *     url: '<my_popup_url>',
     *     resultDispatchBehavior: 'close',
     *     blurBehavior: 'close',
     *     focus: true,
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0
     * });
     * ```
     *
     * Same as above but using an existing window as a popup by referencing its `name`:
     *
     * Note: if a window with the `name` provided doesn't exist, it will be created.
     *
     * ```js
     * const result = await fin.me.showPopupWindow({
     *     initialOptions: {
     *         frame: true
     *     },
     *     name: 'my-popup', // shows the 'my-popup' window if it exists, otherwise creates it
     *     url: '<my_popup_url>', // navigates to this url if it doesn't match the location.href of the 'my-popup' window
     *     resultDispatchBehavior: 'close',
     *     blurBehavior: 'close',
     *     focus: true,
     *     hideOnClose: true, // persist window on 'dismissed' result, alternatively change onResultDispatch and blurBehavior to 'hide'
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0
     * });
     * ```
     *
     * Create and show a popup window that is able to return multiple results to the caller via an `onPopupResult` callback. Each
     * time the popup window calls `dispatchPopupResult`, the callback will be executed on the result. Once the popup window is
     * closed or hidden, the `showPopupWindow` promise will resolve with a `dismissed` result that will include the most recently
     * dispatched result as `lastDispatchResult`:
     *
     * ```js
     * const popupResultCallback = (payload) => {
     *        if (payload.result === 'clicked') {
     *            if (payload.data.topic === 'color-changed') {
     *                // do something like
     *                // setColor(payload.data.value);
     *            }
     *        }
     * };
     *
     * await fin.me.showPopupWindow({
     *     initialOptions: {
     *         frame: false
     *     },
     *     url: '<my_popup_url>',
     *     resultDispatchBehavior: 'none',
     *     blurBehavior: 'close',
     *     focus: true,
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0,
     *     onPopupResult: popupResultCallback
     * });
     * ```
     *
     * Same as above but using an existing window as a popup:
     *
     * ```js
     * const popupResultCallback = (payload) => {
     *        if (payload.result === 'clicked') {
     *            if (payload.data.topic === 'color-changed') {
     *                // do something like
     *                // setColor(payload.data.value);
     *            }
     *        }
     * };
     *
     * await fin.me.showPopupWindow({
     *     initialOptions: {
     *         frame: false
     *     },
     *     name: 'my-popup', // shows the 'my-popup' window if it exists, otherwise creates it
     *     url: '<my_popup_url>', // navigates to this url if it doesn't match the location.href of the 'my-popup' window
     *     resultDispatchBehavior: 'none',
     *     blurBehavior: 'hide',
     *     focus: true,
     *     hideOnClose: true, // we can just use this or we can change blurBehavior to 'hide'
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0,
     *     onPopupResult: popupResultCallback
     * });
     * ```
     *
     * Create or show a popup window that disables user movement (positioning and resizing) in the caller
     * view's parent window by using `blurBehavior: 'modal'`:
     *
     * ```js
     * const result = await fin.me.showPopupWindow({
     *     initialOptions: {
     *         frame: false
     *     },
     *     url: '<my_popup_url>',
     *     resultDispatchBehavior: 'close',
     *     blurBehavior: 'modal',
     *     focus: true,
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0
     * });
     * ```
     *
     * Create a popup window as a modal:
     *
     * Note: The only way to ensure true modal behavior is to create the window being shown as a popup with a
     * `modalParentIdentity` that uses the caller view's parent window identity.
     *
     * ```js
     * const result = await fin.me.showPopupWindow({
     *     initialOptions: {
     *         frame: false,
     *         modalParentIdentity: fin.me.identity
     *     },
     *     url: '<my_popup_url>',
     *     resultDispatchBehavior: 'close',
     *     blurBehavior: 'modal',
     *     focus: true,
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0
     * });
     * ```
     *
     * Pass data to a popup window that is available when the popup is shown.
     *
     * Note: this is just one example for a use of `additionalOptions`, it can be used to update any updatable
     * window options when creating or showing an existing window as a popup.
     *
     * ```js
     * const result = await fin.me.showPopupWindow({
     *     additionalOptions: {
     *         customData: {
     *             foo: 'bar'
     *         }
     *     },
     *     url: '<my_popup_url>',
     *     resultDispatchBehavior: 'close',
     *     blurBehavior: 'close',
     *     focus: true,
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0
     * });
     *
     * // Access from the popup window context like so:
     * const { customData } = await fin.me.getOptions();
     * const { foo } = customData;
     * ```
     *
     * Execute a callback on the popup's OpenFin window when the popup is shown:
     *
     * ```js
     * const popupWindowCallback = async (win) => {
     *     await win.flash();
     * };
     *
     * const result = await fin.me.showPopupWindow({
     *     url: '<my_popup_url>',
     *     resultDispatchBehavior: 'close',
     *     blurBehavior: 'close',
     *     focus: true,
     *     height: 300,
     *     width: 300,
     *     x: 0,
     *     y: 0,
     *     onPopupReady: popupWindowCallback;
     * });
     * ```
     * @remarks
     * `WebContents` refers to shared functionality between {@link OpenFin.Window} and {@link OpenFin.View}.
     * We do not expose an explicit superclass for this functionality, but it does have its own
     * {@link OpenFin.WebContentsEvents event namespace}.
     */
    async showPopupWindow(options) {
        this.wire.sendAction(`${this.entityType}-show-popup-window`, this.identity).catch(() => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        if (options?.onPopupReady) {
            const readyListener = async ({ popupName }) => {
                try {
                    const popupWindow = this.fin.Window.wrapSync({ uuid: this.fin.me.uuid, name: popupName });
                    await options.onPopupReady(popupWindow);
                }
                catch (error) {
                    throw new Error(`Something went wrong during onPopupReady execution: ${error}`);
                }
            };
            // TODO: fix typing (internal)
            // @ts-expect-error
            await this.once('popup-ready', readyListener);
        }
        const { payload: tryCreatePayload } = await this.wire.sendAction('try-create-popup-window', {
            options: {
                ...options,
                // Internal use only.
                // @ts-expect-error
                hasResultCallback: !!options?.onPopupResult,
                hasReadyCallback: !!options?.onPopupReady
            },
            ...this.identity
        });
        const { data: { willOpen, options: popupOptions } } = tryCreatePayload;
        if (willOpen) {
            // Solve the issue where Interop in a popup window with non cross-origin url is not working(core-1076).
            await this.fin.Window.create(popupOptions.initialOptions);
        }
        const normalizePopupResult = (payload) => {
            const { name, uuid, result, data } = payload;
            const popupResult = {
                identity: {
                    name,
                    uuid
                },
                result
            };
            if (data) {
                popupResult.data = data;
            }
            return popupResult;
        };
        if (options?.onPopupResult) {
            const dispatchResultListener = async (payload) => {
                await options.onPopupResult(normalizePopupResult(payload));
            };
            const teardownListener = async () => {
                // TODO: fix typing (internal)
                // @ts-expect-error
                await this.removeListener('popup-result', dispatchResultListener);
            };
            // TODO: fix typing (internal)
            // @ts-expect-error
            await this.on('popup-result', dispatchResultListener);
            // TODO: fix typing (internal)
            // hilariously this does not need a ts-expect-error - this is gap in type soundness
            // should investigate - probably due to `teardownListener` taking a void argument
            // which might play nicely with the `never` type?  huh...
            await this.once('popup-teardown', teardownListener);
        }
        const { payload } = await this.wire.sendAction('show-popup-window', {
            options: popupOptions,
            ...this.identity
        });
        return payload.data;
    }
}
main.WebContents = WebContents;

var hasRequiredInstance$2;

function requireInstance$2 () {
	if (hasRequiredInstance$2) return Instance$5;
	hasRequiredInstance$2 = 1;
	var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var _View_providerChannelClient;
	Object.defineProperty(Instance$5, "__esModule", { value: true });
	Instance$5.View = void 0;
	const transport_errors_1 = transportErrors;
	const lazy_1 = lazy;
	const layout_entities_1 = layoutEntities;
	const layout_constants_1 = layout_constants;
	const main_1 = main;
	const window_1 = requireWindow();
	/**
	 * A View can be used to embed additional web content into a Window.
	 * It is like a child window, except it is positioned relative to its owning window.
	 * It has the ability to listen for {@link OpenFin.ViewEvents View-specific events}.
	 *
	 * By default, a View will try to share the same renderer process as other Views owned by its parent Application.
	 * To change that behavior, see the processAffinity {@link OpenFin.ViewOptions view option}.
	 *
	 * A View's lifecycle is tied to its owning window and can be re-attached to a different window at any point during its lifecycle.
	 */
	class View extends main_1.WebContents {
	    /**
	     * @internal
	     */
	    constructor(wire, identity) {
	        super(wire, identity, 'view');
	        this.identity = identity;
	        _View_providerChannelClient.set(this, new lazy_1.Lazy(() => {
	            const platform = this.fin.Platform.wrapSync(this.identity);
	            return platform.getClient();
	        }));
	        /**
	         * Attaches the current view to the given window identity.
	         * Identity must be the identity of a window in the same application.
	         * This detaches the view from its current window, and sets the view to be destroyed when its new window closes.
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         name: 'viewNameAttach',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function attachView() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url.');
	         *
	         *     const winOption = {
	         *         name:'winOptionName',
	         *         defaultWidth: 300,
	         *         defaultHeight: 300,
	         *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.create.html',
	         *         frame: true,
	         *         autoShow: true
	         *     };
	         *     const newWindow = await fin.Window.create(winOption);
	         *     view.attach(newWindow.identity);
	         * }
	         *
	         * attachView()
	         *     .then(() => console.log('View attached to new window.'))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.attach = async (target) => {
	            await this.wire.sendAction('attach-view', { target, ...this.identity });
	        };
	        /**
	         * Destroys the current view
	         *
	         * @example
	         * ```js
	         * const view = fin.View.wrapSync({ uuid: 'viewUuid', name: 'viewName' });
	         * view.destroy();
	         * ```
	         * @experimental
	         */
	        this.destroy = async () => {
	            await this.wire.sendAction('destroy-view', { ...this.identity });
	        };
	        /**
	         * Shows the current view if it is currently hidden.
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         name: 'viewNameShow',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function hideAndShowView() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url option.');
	         *
	         *     await view.hide();
	         *     console.log("View hidden.");
	         *
	         *     view.show();
	         *     console.log("View shown.");
	         * }
	         *
	         * hideAndShowView()
	         *     .then(() => console.log('View hidden and shown.'))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.show = async () => {
	            await this.wire.sendAction('show-view', { ...this.identity });
	        };
	        /**
	         * Sets the bounds (top, left, width, height) of the view relative to its window and shows it if it is hidden.
	         * This method ensures the view is both positioned and showing. It will reposition a visible view and both show and reposition a hidden view.
	         *
	         * @remarks View position is relative to the bounds of the window.
	         * ({top: 0, left: 0} represents the top left corner of the window)
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         name: 'viewNameSetBounds',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function showViewAt() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url.');
	         *
	         *     await view.showAt({
	         *         top: 100,
	         *         left: 100,
	         *         width: 300,
	         *         height: 300
	         *     });
	         * }
	         *
	         * showViewAt()
	         *     .then(() => console.log('View set to new bounds and shown.'))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.showAt = async (bounds) => {
	            await this.wire.sendAction('show-view-at', { bounds, ...this.identity });
	        };
	        /**
	         * Hides the current view if it is currently visible.
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         name: 'viewNameHide',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function hideView() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url.');
	         *
	         *     await view.hide();
	         * }
	         *
	         * hideView()
	         *     .then(() => console.log('View hidden.'))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.hide = async () => {
	            await this.wire.sendAction('hide-view', { ...this.identity });
	        };
	        /**
	         * Sets the bounds (top, left, width, height) of the view relative to its window.
	         *
	         * @remarks View position is relative to the bounds of the window.
	         * ({top: 0, left: 0} represents the top left corner of the window)
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         name: 'viewNameSetBounds',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function setViewBounds() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url.');
	         *
	         *     await view.setBounds({
	         *         top: 100,
	         *         left: 100,
	         *         width: 300,
	         *         height: 300
	         *     });
	         * }
	         *
	         * setViewBounds()
	         *     .then(() => console.log('View set to new bounds.'))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.setBounds = async (bounds) => {
	            await this.wire.sendAction('set-view-bounds', { bounds, ...this.identity });
	        };
	        /**
	         * Gets the bounds (top, left, width, height) of the view relative to its window.
	         *
	         * @remarks View position is relative to the bounds of the window.
	         * ({top: 0, left: 0} represents the top left corner of the window)
	         *
	         * @example
	         * ```js
	         * const view = await fin.View.create({
	         *     name: 'viewNameSetBounds',
	         *     target: fin.me.identity,
	         *     bounds: {top: 10, left: 10, width: 200, height: 200}
	         * });
	         *
	         * await view.navigate('https://google.com');
	         *
	         * await view.setBounds({
	         *     top: 100,
	         *     left: 100,
	         *     width: 300,
	         *     height: 300
	         * });
	         *
	         * console.log(await view.getBounds());
	         * ```
	         * @experimental
	         */
	        this.getBounds = async () => {
	            const ack = await this.wire.sendAction('get-view-bounds', { ...this.identity });
	            return ack.payload.data;
	        };
	        /**
	         * Gets the View's info.
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         name: 'viewNameGetInfo',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function getViewInfo() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url.');
	         *
	         *     return view.getInfo();
	         * }
	         *
	         * getViewInfo()
	         *     .then((info) => console.log('View info fetched.', info))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.getInfo = async () => {
	            const ack = await this.wire.sendAction('get-view-info', { ...this.identity });
	            return ack.payload.data;
	        };
	        /**
	         * Retrieves the layout for the window the view is attached to.
	         *
	         * @example
	         * ```js
	         *     //get the current View
	         *     const view = await fin.View.getCurrent();
	         *
	         *     //get a reference to the Layout for the Window the view is part of
	         *     const layout = await view.getParentLayout();
	         * ```
	         * @experimental
	         */
	        this.getParentLayout = async () => {
	            this.wire.sendAction('view-get-parent-layout', { ...this.identity }).catch(() => {
	                // don't expose
	            });
	            const layoutWindow = await this.getCurrentWindow();
	            try {
	                const providerChannelClient = await __classPrivateFieldGet(this, _View_providerChannelClient, "f").getValue();
	                const client = await layout_entities_1.LayoutNode.newLayoutEntitiesClient(providerChannelClient, layout_constants_1.LAYOUT_CONTROLLER_ID, layoutWindow.identity);
	                const layoutIdentity = await client.getLayoutIdentityForViewOrThrow(this.identity);
	                return this.fin.Platform.Layout.wrap(layoutIdentity);
	            }
	            catch (e) {
	                const allowedErrors = [
	                    'No action registered at target for',
	                    'getLayoutIdentityForViewOrThrow is not a function'
	                ];
	                if (!allowedErrors.some((m) => e.message.includes(m))) {
	                    throw e;
	                }
	                // fallback logic for missing endpoint
	                return this.fin.Platform.Layout.wrap(layoutWindow.identity);
	            }
	        };
	        /**
	         * Gets the View's options.
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         name: 'viewNameGetOptions',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function getViewOptions() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url.');
	         *
	         *     const me = await fin.Window.getCurrent();
	         *     view = fin.View.wrapSync({ uuid: me.identity.uuid, name: 'viewNameGetOptions' });
	         *     return view.getOptions();
	         * }
	         *
	         * getViewOptions()
	         *     .then((info) => console.log('View options fetched.', info))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.getOptions = async () => {
	            return this.wire.sendAction('get-view-options', { ...this.identity }).then(({ payload }) => payload.data);
	        };
	        /**
	         * Updates the view's options.
	         *
	         * @example
	         * ```js
	         * let view;
	         * async function createView() {
	         *     const me = await fin.Window.getCurrent();
	         *     return fin.View.create({
	         *         url: 'https://google.com',
	         *         name: 'viewNameUpdateOptions',
	         *         target: me.identity,
	         *         bounds: {top: 10, left: 10, width: 200, height: 200}
	         *     });
	         * }
	         *
	         * async function updateViewOptions() {
	         *     view = await createView();
	         *     console.log('View created.');
	         *
	         *     await view.navigate('https://google.com');
	         *     console.log('View navigated to given url option.');
	         *
	         *     const newOptions = { autoResize: {
	         *         width: true,
	         *         horizontal: true
	         *     }};
	         *     return view.updateOptions(newOptions);
	         * }
	         *
	         * updateViewOptions()
	         *     .then(payload => console.log('View options updated: ', payload))
	         *     .catch(err => console.log(err));
	         * ```
	         * @experimental
	         */
	        this.updateOptions = async (options) => {
	            return this.wire.sendAction('update-view-options', { options, ...this.identity }).then(() => undefined);
	        };
	        /**
	         * Retrieves the window the view is currently attached to.
	         *
	         * @example
	         * ```js
	         * const view = fin.View.wrapSync({ uuid: 'viewUuid', name: 'viewName' });
	         * view.getCurrentWindow()
	         *     .then(win => console.log('current window', win))
	         *     .catch(err => console.log(err));)
	         * ```
	         * @experimental
	         */
	        this.getCurrentWindow = async () => {
	            const { payload: { data } } = await this.wire.sendAction('get-view-window', { ...this.identity });
	            return new window_1._Window(this.wire, data);
	        };
	        /**
	         * Retrieves the current {@link OpenFin.TabStack} of the view if it belongs to one.
	         * @returns this view belongs to.
	         * @throws if this view does not belong to a TabStack or if the window has been destroyed.
	         * @example
	         * ```js
	         * if (!fin.me.isView) {
	         *     throw new Error('Not running in a platform View.');
	         * }
	         *
	         * const stack = await fin.me.getCurrentStack();
	         * // Alternatively, you can wrap any view and get the stack from there
	         * // const viewFromSomewhere = fin.View.wrapSync(someView.identity);
	         * // const stack = await viewFromSomewhere.getCurrentStack();
	         * const views = await stack.getViews();
	         * console.log(`Stack contains ${views.length} view(s)`);
	         * ```
	         */
	        this.getCurrentStack = async () => {
	            this.wire.sendAction('view-get-current-stack').catch(() => {
	                // don't expose
	            });
	            try {
	                const layoutWindow = await this.getCurrentWindow();
	                const providerChannelClient = await __classPrivateFieldGet(this, _View_providerChannelClient, "f").getValue();
	                const client = await layout_entities_1.LayoutNode.newLayoutEntitiesClient(providerChannelClient, layout_constants_1.LAYOUT_CONTROLLER_ID, layoutWindow.identity);
	                const stackDefinition = (await client.getStackByView(this.identity));
	                return layout_entities_1.LayoutNode.getEntity(stackDefinition, client);
	            }
	            catch (error) {
	                throw new transport_errors_1.RuntimeError({ reason: 'This view does not belong to a stack.', error });
	            }
	        };
	        /**
	         * Triggers the before-unload handler for the View, if one is set.
	         *
	         * @remarks Returns `true` if the handler is trying to prevent the View from unloading, and `false` if it isn't.
	         * Only enabled when setting enableBeforeUnload: true in your View options. If this option is not enabled it will
	         * always return false.
	         *
	         * This method is used internally by the Platform Provider to determine the status of each before unload handler in Views when closing the Window.
	         *
	         * @example
	         *
	         * ```js
	         * // from inside a View context
	         * const unloadPrevented = await fin.me.triggerBeforeUnload();
	         * ```
	         *
	         * @experimental
	         */
	        this.triggerBeforeUnload = async () => {
	            const message = await this.wire.sendAction('trigger-before-unload', { ...this.identity });
	            return message.payload.data;
	        };
	        /**
	         * **NOTE**: Internal use only.
	         * Attaches this view to an HTML element in the current context. The view will resize responsively when the element bounds change.
	         *
	         * **Known issue**: View.bindToElement does not track position changes, if the element has fixed px width and height values it is possible for the view to not update responsively.
	         *
	         * **Known issue**: When View.bindToElement is used on a element that takes up the entire page in a platform window, the bound view will not respond responsively when the window is resized to be smaller.
	         *
	         * @param element - HTML element to attach the view to.
	         * @returns - Cleanup function that will disconnect the element resize observer.
	         * @internal
	         * @experimental
	         * @remarks View will resize accordingly when the element is resized. If the element is repositioned in the DOM the view will not be repositioned, to handle this case call `bindToElement` again once the element changes position.
	         *
	         * @example
	         * ```html
	         * <div id="view-container"></div>
	         * <script>
	         *     async function createAndAttachView() {
	         *         const url = 'https://example.com';
	         *         const elementId = 'view-container';
	         *         const element = document.getElementById(elementId);
	         *         const view = await fin.View.create({
	         *             name: 'my-view',
	         *             url,
	         *             target: fin.me.identity
	         *         });
	         *         await view.navigate(url);
	         *         await view.bindToElement(element);
	         *     }
	         *     createAndAttachView().catch(console.error);
	         * </script>
	         * ```
	         */
	        this.bindToElement = async (element) => {
	            if (!element) {
	                throw new Error('Element not found.');
	            }
	            const onChange = async (bounds) => this.setBounds(bounds);
	            return this.wire.environment.observeBounds(element, onChange);
	        };
	    }
	    /**
	     * Focuses the view
	     *
	     * @example
	     * ```js
	     * const view = fin.View.wrapSync({ uuid: 'viewUuid', name: 'viewName' });
	     * await view.focus();
	     * // do things with the focused view
	     * ```
	     * @experimental
	     */
	    async focus({ emitSynthFocused } = { emitSynthFocused: true }) {
	        const win = await this.getCurrentWindow();
	        await win.focusedWebViewWasChanged();
	        await super.focus({ emitSynthFocused });
	    }
	}
	Instance$5.View = View;
	_View_providerChannelClient = new WeakMap();
	return Instance$5;
}

var hasRequiredView;

function requireView () {
	if (hasRequiredView) return view;
	hasRequiredView = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		/**
		 * Entry points for the OpenFin `View` API (`fin.View`).
		 *
		 * * {@link ViewModule} contains static members of the `View` API, accessible through `fin.View`.
		 * * {@link View} describes an instance of an OpenFin View, e.g. as returned by `fin.View.getCurrent`.
		 *
		 * These are separate code entities, and are documented separately.  In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
		 * both of these were documented on the same page.
		 *
		 * @packageDocumentation
		 */
		__exportStar(requireFactory$3(), exports);
		__exportStar(requireInstance$2(), exports); 
	} (view));
	return view;
}

var hasRequiredInstance$1;

function requireInstance$1 () {
	if (hasRequiredInstance$1) return Instance$6;
	hasRequiredInstance$1 = 1;
	Object.defineProperty(Instance$6, "__esModule", { value: true });
	Instance$6.Application = void 0;
	/* eslint-disable import/prefer-default-export */
	const base_1 = base;
	const window_1 = requireWindow();
	const view_1 = requireView();
	/**
	 * An object representing an application. Allows the developer to create,
	 * execute, show/close an application as well as listen to {@link OpenFin.ApplicationEvents application events}.
	 */
	class Application extends base_1.EmitterBase {
	    /**
	     * @internal
	     */
	    constructor(wire, identity) {
	        super(wire, 'application', identity.uuid);
	        this.identity = identity;
	        this.window = new window_1._Window(this.wire, {
	            uuid: this.identity.uuid,
	            name: this.identity.uuid
	        });
	    }
	    windowListFromIdentityList(identityList) {
	        const windowList = [];
	        identityList.forEach((identity) => {
	            windowList.push(new window_1._Window(this.wire, {
	                uuid: identity.uuid,
	                name: identity.name
	            }));
	        });
	        return windowList;
	    }
	    /**
	     * Determines if the application is currently running.
	     *
	     * @example
	     *
	     * ```js
	     * async function isAppRunning() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.isRunning();
	     * }
	     * isAppRunning().then(running => console.log(`Current app is running: ${running}`)).catch(err => console.log(err));
	     * ```
	     */
	    isRunning() {
	        return this.wire.sendAction('is-application-running', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Closes the application and any child windows created by the application.
	     * Cleans the application from state so it is no longer found in getAllApplications.
	     * @param force Close will be prevented from closing when force is false and
	     *  ‘close-requested’ has been subscribed to for application’s main window.
	     *
	     * @example
	     *
	     * ```js
	     * async function closeApp() {
	     *     const allApps1 = await fin.System.getAllApplications(); //[{uuid: 'app1', isRunning: true}, {uuid: 'app2', isRunning: true}]
	     *     const app = await fin.Application.wrap({uuid: 'app2'});
	     *     await app.quit();
	     *     const allApps2 = await fin.System.getAllApplications(); //[{uuid: 'app1', isRunning: true}]
	     *
	     * }
	     * closeApp().then(() => console.log('Application quit')).catch(err => console.log(err));
	     * ```
	     */
	    async quit(force = false) {
	        try {
	            await this._close(force);
	            await this.wire.sendAction('destroy-application', { force, ...this.identity });
	        }
	        catch (error) {
	            const acceptableErrors = ['Remote connection has closed', 'Could not locate the requested application'];
	            if (!acceptableErrors.some((msg) => error.message.includes(msg))) {
	                throw error;
	            }
	        }
	    }
	    async _close(force = false) {
	        try {
	            await this.wire.sendAction('close-application', { force, ...this.identity });
	        }
	        catch (error) {
	            if (!error.message.includes('Remote connection has closed')) {
	                throw error;
	            }
	        }
	    }
	    /**
	     * @deprecated use Application.quit instead
	     * Closes the application and any child windows created by the application.
	     * @param force - Close will be prevented from closing when force is false and ‘close-requested’ has been subscribed to for application’s main window.
	     * @param callback - called if the method succeeds.
	     * @param errorCallback - called if the method fails. The reason for failure is passed as an argument.
	     *
	     * @example
	     *
	     * ```js
	     * async function closeApp() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.close();
	     * }
	     * closeApp().then(() => console.log('Application closed')).catch(err => console.log(err));
	     * ```
	     */
	    close(force = false) {
	        console.warn('Deprecation Warning: Application.close is deprecated Please use Application.quit');
	        this.wire.sendAction('application-close', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this._close(force);
	    }
	    /**
	     * Retrieves an array of wrapped fin.Windows for each of the application’s child windows.
	     *
	     * @example
	     *
	     * ```js
	     * async function getChildWindows() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.getChildWindows();
	     * }
	     *
	     * getChildWindows().then(children => console.log(children)).catch(err => console.log(err));
	     * ```
	     */
	    getChildWindows() {
	        return this.wire.sendAction('get-child-windows', this.identity).then(({ payload }) => {
	            const identityList = [];
	            payload.data.forEach((winName) => {
	                identityList.push({ uuid: this.identity.uuid, name: winName });
	            });
	            return this.windowListFromIdentityList(identityList);
	        });
	    }
	    /**
	     * Retrieves the JSON manifest that was used to create the application. Invokes the error callback
	     * if the application was not created from a manifest.
	     *
	     * @example
	     *
	     * ```js
	     * async function getManifest() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.getManifest();
	     * }
	     *
	     * getManifest().then(manifest => console.log(manifest)).catch(err => console.log(err));
	     * ```
	     */
	    getManifest() {
	        return this.wire.sendAction('get-application-manifest', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Retrieves UUID of the application that launches this application. Invokes the error callback
	     * if the application was created from a manifest.
	     *
	     * @example
	     *
	     * ```js
	     * async function getParentUuid() {
	     *     const app = await fin.Application.start({
	     *         uuid: 'app-1',
	     *         name: 'myApp',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Application.getParentUuid.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getParentUuid();
	     * }
	     *
	     * getParentUuid().then(parentUuid => console.log(parentUuid)).catch(err => console.log(err));
	     * ```
	     */
	    getParentUuid() {
	        return this.wire.sendAction('get-parent-application', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Retrieves current application's shortcut configuration.
	     *
	     * @example
	     *
	     * ```js
	     * async function getShortcuts() {
	     *     const app = await fin.Application.wrap({ uuid: 'testapp' });
	     *     return await app.getShortcuts();
	     * }
	     * getShortcuts().then(config => console.log(config)).catch(err => console.log(err));
	     * ```
	     */
	    getShortcuts() {
	        return this.wire.sendAction('get-shortcuts', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Retrieves current application's views.
	     * @experimental
	     *
	     * @example
	     *
	     * ```js
	     * async function getViews() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.getViews();
	     * }
	     * getViews().then(views => console.log(views)).catch(err => console.log(err));
	     * ```
	     */
	    async getViews() {
	        const { payload } = await this.wire.sendAction('application-get-views', this.identity);
	        return payload.data.map((id) => new view_1.View(this.wire, id));
	    }
	    /**
	     * Returns the current zoom level of the application.
	     *
	     * @example
	     *
	     * ```js
	     * async function getZoomLevel() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.getZoomLevel();
	     * }
	     *
	     * getZoomLevel().then(zoomLevel => console.log(zoomLevel)).catch(err => console.log(err));
	     * ```
	     */
	    getZoomLevel() {
	        return this.wire.sendAction('get-application-zoom-level', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Returns an instance of the main Window of the application
	     *
	     * @example
	     *
	     * ```js
	     * async function getWindow() {
	     *     const app = await fin.Application.start({
	     *         uuid: 'app-1',
	     *         name: 'myApp',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Application.getWindow.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * getWindow().then(win => {
	     *     win.showAt(0, 400);
	     *     win.flash();
	     * }).catch(err => console.log(err));
	     * ```
	     */
	    getWindow() {
	        this.wire.sendAction('application-get-window', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return Promise.resolve(this.window);
	    }
	    /**
	     * Manually registers a user with the licensing service. The only data sent by this call is userName and appName.
	     * @param userName - username to be passed to the RVM.
	     * @param appName - app name to be passed to the RVM.
	     *
	     * @example
	     *
	     * ```js
	     * async function registerUser() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.registerUser('user', 'myApp');
	     * }
	     *
	     * registerUser().then(() => console.log('Successfully registered the user')).catch(err => console.log(err));
	     * ```
	     */
	    registerUser(userName, appName) {
	        return this.wire.sendAction('register-user', { userName, appName, ...this.identity }).then(() => undefined);
	    }
	    /**
	     * Removes the application’s icon from the tray.
	     *
	     * @example
	     *
	     * ```js
	     * async function removeTrayIcon() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.removeTrayIcon();
	     * }
	     *
	     * removeTrayIcon().then(() => console.log('Removed the tray icon.')).catch(err => console.log(err));
	     * ```
	     */
	    removeTrayIcon() {
	        return this.wire.sendAction('remove-tray-icon', this.identity).then(() => undefined);
	    }
	    /**
	     * Restarts the application.
	     *
	     * @example
	     *
	     * ```js
	     * async function restartApp() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.restart();
	     * }
	     * restartApp().then(() => console.log('Application restarted')).catch(err => console.log(err));
	     * ```
	     */
	    restart() {
	        return this.wire.sendAction('restart-application', this.identity).then(() => undefined);
	    }
	    /**
	     * DEPRECATED method to run the application.
	     * Needed when starting application via {@link Application.create}, but NOT needed when starting via {@link Application.start}.
	     *
	     * @example
	     *
	     * ```js
	     * async function run() {
	     *     const app = await fin.Application.create({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Application.run.html',
	     *         autoShow: true
	     *     });
	     *     await app.run();
	     * }
	     * run().then(() => console.log('Application is running')).catch(err => console.log(err));
	     * ```
	     *
	     * @ignore
	     */
	    run() {
	        console.warn('Deprecation Warning: Application.run is deprecated Please use fin.Application.start');
	        this.wire.sendAction('application-run', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this._run();
	    }
	    _run(opts = {}) {
	        return this.wire
	            .sendAction('run-application', {
	            manifestUrl: this._manifestUrl,
	            opts,
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Instructs the RVM to schedule one restart of the application.
	     *
	     * @example
	     *
	     * ```js
	     * async function scheduleRestart() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.scheduleRestart();
	     * }
	     *
	     * scheduleRestart().then(() => console.log('Application is scheduled to restart')).catch(err => console.log(err));
	     * ```
	     */
	    scheduleRestart() {
	        return this.wire.sendAction('relaunch-on-close', this.identity).then(() => undefined);
	    }
	    /**
	     * Sends a message to the RVM to upload the application's logs. On success,
	     * an object containing logId is returned.
	     *
	     * @example
	     *
	     * ```js
	     * async function sendLog() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.sendApplicationLog();
	     * }
	     *
	     * sendLog().then(info => console.log(info.logId)).catch(err => console.log(err));
	     * ```
	     */
	    async sendApplicationLog() {
	        const { payload } = await this.wire.sendAction('send-application-log', this.identity);
	        return payload.data;
	    }
	    /**
	     * Sets or removes a custom JumpList for the application. Only applicable in Windows OS.
	     * If categories is null the previously set custom JumpList (if any) will be replaced by the standard JumpList for the app (managed by Windows).
	     *
	     * Note: If the "name" property is omitted it defaults to "tasks".
	     * @param jumpListCategories An array of JumpList Categories to populate. If null, remove any existing JumpList configuration and set to Windows default.
	     *
	     *
	     * @remarks If categories is null the previously set custom JumpList (if any) will be replaced by the standard JumpList for the app (managed by Windows).
	     *
	     * The bottommost item in the jumplist will always be an item pointing to the current app. Its name is taken from the manifest's
	     * **` shortcut.name `** and uses **` shortcut.company `** as a fallback. Clicking that item will launch the app from its current manifest.
	     *
	     * Note: If the "name" property is omitted it defaults to "tasks".
	     *
	     * Note: Window OS caches jumplists icons, therefore an icon change might only be visible after the cache is removed or the
	     * uuid or shortcut.name is changed.
	     *
	     * @example
	     *
	     * ```js
	     *     const app = fin.Application.getCurrentSync();
	     *     const appName = 'My App';
	     *     const jumpListConfig = [ // array of JumpList categories
	     *         {
	     *             // has no name and no type so `type` is assumed to be "tasks"
	     *             items: [ // array of JumpList items
	     *             {
	     *                 type: 'task',
	     *                 title: `Launch ${appName}`,
	     *                 description: `Runs ${appName} with the default configuration`,
	     *                 deepLink: 'fins://path.to/app/manifest.json',
	     *                 iconPath: 'https://path.to/app/icon.ico',
	     *                 iconIndex: 0
	     *             },
	     *             { type: 'separator' },
	     *             {
	     *                 type: 'task',
	     *                 title: `Restore ${appName}`,
	     *                 description: 'Restore to last configuration',
	     *                 deepLink: 'fins://path.to/app/manifest.json?$$use-last-configuration=true',
	     *                 iconPath: 'https://path.to/app/icon.ico',
	     *                 iconIndex: 0
	     *             },
	     *             ]
	     *         },
	     *         {
	     *             name: 'Tools',
	     *             items: [ // array of JumpList items
	     *             {
	     *                 type: 'task',
	     *                 title: 'Tool A',
	     *                 description: 'Runs Tool A',
	     *                 deepLink: 'fins://path.to/tool-a/manifest.json',
	     *                 iconPath: 'https://path.to/tool-a/icon.ico',
	     *                 iconIndex: 0
	     *             },
	     *             {
	     *                 type: 'task',
	     *                 title: 'Tool B',
	     *                 description: 'Runs Tool B',
	     *                 deepLink: 'fins://path.to/tool-b/manifest.json',
	     *                 iconPath: 'https://path.to/tool-b/icon.ico',
	     *                 iconIndex: 0
	     *             }]
	     *         }
	     *     ];
	     *
	     *     app.setJumpList(jumpListConfig).then(() => console.log('JumpList applied')).catch(e => console.log(`JumpList failed to apply: ${e.toString()}`));
	     * ```
	     *
	     * To handle deeplink args:
	     * ```js
	     *     function handleUseLastConfiguration() {
	     *         // this handler is called when the app is being launched
	     *         app.on('run-requested', event => {
	     *             if(event.userAppConfigArgs['use-last-configuration']) {
	     *                 // your logic here
	     *             }
	     *         });
	     *         // this handler is called when the app was already running when the launch was requested
	     *         fin.desktop.main(function(args) {
	     *             if(args && args['use-last-configuration']) {
	     *                 // your logic here
	     *             }
	     *         });
	     *     }
	     * ```
	     */
	    async setJumpList(jumpListCategories) {
	        await this.wire.sendAction('set-jump-list', { config: jumpListCategories, ...this.identity });
	    }
	    /**
	     * Adds a customizable icon in the system tray.  To listen for a click on the icon use the `tray-icon-clicked` event.
	     * @param icon Image URL or base64 encoded string to be used as the icon
	     *
	     * @example
	     *
	     * ```js
	     * const imageUrl = "http://cdn.openfin.co/assets/testing/icons/circled-digit-one.png";
	     * const base64EncodedImage = "iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAQMAAAD+wSzIAAAABlBMVEX\
	     * ///+/v7+jQ3Y5AAAADklEQVQI12P4AIX8EAgALgAD/aNpbtEAAAAASUVORK5CYII";
	     * const dataURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DH\
	     * xgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==";
	     *
	     * async function setTrayIcon(icon) {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.setTrayIcon(icon);
	     * }
	     *
	     * // use image url to set tray icon
	     * setTrayIcon(imageUrl).then(() => console.log('Setting tray icon')).catch(err => console.log(err));
	     *
	     * // use base64 encoded string to set tray icon
	     * setTrayIcon(base64EncodedImage).then(() => console.log('Setting tray icon')).catch(err => console.log(err));
	     *
	     * // use a dataURL to set tray icon
	     * setTrayIcon(dataURL).then(() => console.log('Setting tray icon')).catch(err => console.log(err));
	     * ```
	     */
	    setTrayIcon(icon) {
	        return this.wire
	            .sendAction('set-tray-icon', {
	            enabledIcon: icon,
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Sets new application's shortcut configuration. Windows only.
	     * @param config New application's shortcut configuration.
	     *
	     * @remarks Application has to be launched with a manifest and has to have shortcut configuration (icon url, name, etc.) in its manifest
	     * to be able to change shortcut states.
	     *
	     * @example
	     *
	     * ```js
	     * async function setShortcuts(config) {
	     *     const app = await fin.Application.getCurrent();
	     *     return app.setShortcuts(config);
	     * }
	     *
	     * setShortcuts({
	     *     desktop: true,
	     *     startMenu: false,
	     *     systemStartup: true
	     * }).then(() => console.log('Shortcuts are set.')).catch(err => console.log(err));
	     * ```
	     */
	    setShortcuts(config) {
	        return this.wire.sendAction('set-shortcuts', { data: config, ...this.identity }).then(() => undefined);
	    }
	    /**
	     * Sets the query string in all shortcuts for this app. Requires RVM 5.5+.
	     * @param queryString The new query string for this app's shortcuts.
	     *
	     * @example
	     *
	     * ```js
	     * const newQueryArgs = 'arg=true&arg2=false';
	     * const app = await fin.Application.getCurrent();
	     * try {
	     *     await app.setShortcutQueryParams(newQueryArgs);
	     * } catch(err) {
	     *     console.error(err)
	     * }
	     * ```
	     */
	    async setShortcutQueryParams(queryString) {
	        await this.wire.sendAction('set-shortcut-query-args', { data: queryString, ...this.identity });
	    }
	    /**
	     * Sets the zoom level of the application. The original size is 0 and each increment above or below represents zooming 20%
	     * larger or smaller to default limits of 300% and 50% of original size, respectively.
	     * @param level The zoom level
	     *
	     * @example
	     *
	     * ```js
	     * async function setZoomLevel(number) {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.setZoomLevel(number);
	     * }
	     *
	     * setZoomLevel(5).then(() => console.log('Setting a  zoom level')).catch(err => console.log(err));
	     * ```
	     */
	    setZoomLevel(level) {
	        return this.wire.sendAction('set-application-zoom-level', { level, ...this.identity }).then(() => undefined);
	    }
	    /**
	     * Sets a username to correlate with App Log Management.
	     * @param username Username to correlate with App's Log.
	     *
	     * @example
	     *
	     * ```js
	     * async function setAppLogUser() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.setAppLogUsername('username');
	     * }
	     *
	     * setAppLogUser().then(() => console.log('Success')).catch(err => console.log(err));
	     *
	     * ```
	     */
	    async setAppLogUsername(username) {
	        await this.wire.sendAction('set-app-log-username', { data: username, ...this.identity });
	    }
	    /**
	     * Retrieves information about the system tray. If the system tray is not set, it will throw an error message.
	     * @remarks The only information currently returned is the position and dimensions.
	     *
	     * @example
	     *
	     * ```js
	     * async function getTrayIconInfo() {
	     *     const app = await fin.Application.wrap({ uuid: 'testapp' });
	     *     return await app.getTrayIconInfo();
	     * }
	     * getTrayIconInfo().then(info => console.log(info)).catch(err => console.log(err));
	     * ```
	     */
	    getTrayIconInfo() {
	        return this.wire.sendAction('get-tray-icon-info', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Checks if the application has an associated tray icon.
	     *
	     * @example
	     *
	     * ```js
	     * const app = await fin.Application.wrap({ uuid: 'testapp' });
	     * const hasTrayIcon = await app.hasTrayIcon();
	     * console.log(hasTrayIcon);
	     * ```
	     */
	    hasTrayIcon() {
	        return this.wire.sendAction('has-tray-icon', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Closes the application by terminating its process.
	     *
	     * @example
	     *
	     * ```js
	     * async function terminateApp() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.terminate();
	     * }
	     * terminateApp().then(() => console.log('Application terminated')).catch(err => console.log(err));
	     * ```
	     */
	    terminate() {
	        return this.wire.sendAction('terminate-application', this.identity).then(() => undefined);
	    }
	    /**
	     * Waits for a hanging application. This method can be called in response to an application
	     * "not-responding" to allow the application to continue and to generate another "not-responding"
	     * message after a certain period of time.
	     *
	     * @ignore
	     */
	    wait() {
	        return this.wire.sendAction('wait-for-hung-application', this.identity).then(() => undefined);
	    }
	    /**
	     * Retrieves information about the application.
	     *
	     * @remarks If the application was not launched from a manifest, the call will return the closest parent application `manifest`
	     * and `manifestUrl`.  `initialOptions` shows the parameters used when launched programmatically, or the `startup_app` options
	     * if launched from manifest. The `parentUuid` will be the uuid of the immediate parent (if applicable).
	     *
	     * @example
	     *
	     * ```js
	     * async function getInfo() {
	     *     const app = await fin.Application.getCurrent();
	     *     return await app.getInfo();
	     * }
	     *
	     * getInfo().then(info => console.log(info)).catch(err => console.log(err));
	     * ```
	     */
	    getInfo() {
	        return this.wire.sendAction('get-info', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Retrieves all process information for entities (windows and views) associated with an application.
	     *
	     * @example
	     * ```js
	     *     const app = await fin.Application.getCurrent();
	     *     const processInfo = await app.getProcessInfo();
	     * ```
	     * @experimental
	     */
	    async getProcessInfo() {
	        const { payload: { data } } = await this.wire.sendAction('application-get-process-info', this.identity);
	        return data;
	    }
	    /**
	     * Sets file auto download location. It's only allowed in the same application.
	     *
	     * Note: This method is restricted by default and must be enabled via
	     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
	     * @param downloadLocation file auto download location
	     *
	     * @throws if setting file auto download location on different applications.
	     * @example
	     *
	     * ```js
	     * const downloadLocation = 'C:\\dev\\temp';
	     * const app = await fin.Application.getCurrent();
	     * try {
	     *     await app.setFileDownloadLocation(downloadLocation);
	     *     console.log('File download location is set');
	     * } catch(err) {
	     *     console.error(err)
	     * }
	     * ```
	     */
	    async setFileDownloadLocation(downloadLocation) {
	        const { name } = this.wire.me;
	        const entityIdentity = { uuid: this.identity.uuid, name };
	        await this.wire.sendAction('set-file-download-location', { ...entityIdentity, downloadLocation });
	    }
	    /**
	     * Gets file auto download location. It's only allowed in the same application. If file auto download location is not set, it will return the default location.
	     *
	     * Note: This method is restricted by default and must be enabled via
	     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
	     *
	     * @throws if getting file auto download location on different applications.
	     * @example
	     *
	     * ```js
	     * const app = await fin.Application.getCurrent();
	     * const fileDownloadDir =  await app.getFileDownloadLocation();
	     * ```
	     */
	    async getFileDownloadLocation() {
	        const { payload: { data } } = await this.wire.sendAction('get-file-download-location', this.identity);
	        return data;
	    }
	    /**
	     * Shows a menu on the tray icon. Use with tray-icon-clicked event.
	     * @param options
	     * @typeParam Data User-defined shape for data returned upon menu item click. Should be a
	     * [union](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
	     * of all possible data shapes for the entire menu, and the click handler should process
	     * these with a "reducer" pattern.
	     * @throws if the application has no tray icon set
	     * @throws if the system tray is currently hidden
	     * @example
	     *
	     * ```js
	     * const iconUrl = 'http://cdn.openfin.co/assets/testing/icons/circled-digit-one.png';
	     * const app = fin.Application.getCurrentSync();
	     *
	     * await app.setTrayIcon(iconUrl);
	     *
	     * const template = [
	     *  {
	     *    label: 'Menu Item 1',
	     *    data: 'hello from item 1'
	     *  },
	     *  { type: 'separator' },
	     *  {
	     *    label: 'Menu Item 2',
	     *    type: 'checkbox',
	     *    checked: true,
	     *    data: 'The user clicked the checkbox'
	     *  },
	     *  {
	     *    label: 'see more',
	     *    enabled: false,
	     *    submenu: [
	     *      { label: 'submenu 1', data: 'hello from submenu' }
	     *    ]
	     *  }
	     * ];
	     *
	     * app.addListener('tray-icon-clicked', (event) => {
	     *   // right-click
	     *   if (event.button === 2) {
	     *     app.showTrayIconPopupMenu({ template }).then(r => {
	     *       if (r.result === 'closed') {
	     *         console.log('nothing happened');
	     *       } else {
	     *         console.log(r.data);
	     *       }
	     *     });
	     *   }
	     * });
	     * ```
	     */
	    async showTrayIconPopupMenu(options) {
	        const { name } = this.wire.me;
	        const entityIdentity = { uuid: this.identity.uuid, name };
	        const { payload } = await this.wire.sendAction('show-tray-icon-popup-menu', { ...entityIdentity, options });
	        return payload.data;
	    }
	    /**
	     * CLoses the tray icon menu.
	     *
	     * @throws if the application has no tray icon set
	     * @example
	     *
	     * ```js
	     * const app = fin.Application.getCurrentSync();
	     *
	     * await app.closeTrayIconPopupMenu();
	     * ```
	     */
	    async closeTrayIconPopupMenu() {
	        const { name } = this.wire.me;
	        const entityIdentity = { uuid: this.identity.uuid, name };
	        await this.wire.sendAction('close-tray-icon-popup-menu', { ...entityIdentity });
	    }
	}
	Instance$6.Application = Application;
	return Instance$6;
}

var hasRequiredFactory$2;

function requireFactory$2 () {
	if (hasRequiredFactory$2) return Factory$7;
	hasRequiredFactory$2 = 1;
	Object.defineProperty(Factory$7, "__esModule", { value: true });
	Factory$7.ApplicationModule = void 0;
	const base_1 = base;
	const validate_1 = validate;
	const Instance_1 = requireInstance$1();
	/**
	 * Static namespace for OpenFin API methods that interact with the {@link Application} class, available under `fin.Application`.
	 */
	class ApplicationModule extends base_1.Base {
	    /**
	     * Asynchronously returns an Application object that represents an existing application.
	     *
	     * @example
	     *
	     * ```js
	     * fin.Application.wrap({ uuid: 'testapp' })
	     * .then(app => app.isRunning())
	     * .then(running => console.log('Application is running: ' + running))
	     * .catch(err => console.log(err));
	     * ```
	     *
	     */
	    async wrap(identity) {
	        this.wire.sendAction('wrap-application').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const errorMsg = (0, validate_1.validateIdentity)(identity);
	        if (errorMsg) {
	            throw new Error(errorMsg);
	        }
	        return new Instance_1.Application(this.wire, identity);
	    }
	    /**
	     * Synchronously returns an Application object that represents an existing application.
	     *
	     * @example
	     *
	     * ```js
	     * const app = fin.Application.wrapSync({ uuid: 'testapp' });
	     * await app.close();
	     * ```
	     *
	     */
	    wrapSync(identity) {
	        this.wire.sendAction('wrap-application-sync').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const errorMsg = (0, validate_1.validateIdentity)(identity);
	        if (errorMsg) {
	            throw new Error(errorMsg);
	        }
	        return new Instance_1.Application(this.wire, identity);
	    }
	    async _create(appOptions) {
	        // set defaults:
	        if (appOptions.waitForPageLoad === undefined) {
	            appOptions.waitForPageLoad = false;
	        }
	        if (appOptions.autoShow === undefined && appOptions.isPlatformController === undefined) {
	            appOptions.autoShow = true;
	        }
	        await this.wire.sendAction('create-application', appOptions);
	        return this.wrap({ uuid: appOptions.uuid });
	    }
	    /**
	     * DEPRECATED method to create a new Application. Use {@link Application.ApplicationModule.start Application.start} instead.
	     *
	     * @example
	     *
	     * ```js
	     * async function createApp() {
	     *     const app = await fin.Application.create({
	     *         name: 'myApp',
	     *         uuid: 'app-3',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Application.create.html',
	     *         autoShow: true
	     *     });
	     *     await app.run();
	     * }
	     *
	     * createApp().then(() => console.log('Application is created')).catch(err => console.log(err));
	     * ```
	     *
	     * @ignore
	     */
	    create(appOptions) {
	        console.warn('Deprecation Warning: fin.Application.create is deprecated. Please use fin.Application.start');
	        this.wire.sendAction('application-create').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this._create(appOptions);
	    }
	    /**
	     * Creates and starts a new Application.
	     *
	     * @example
	     *
	     * ```js
	     * async function start() {
	     *     return fin.Application.start({
	     *         name: 'app-1',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Application.start.html',
	     *         autoShow: true
	     *     });
	     * }
	     * start().then(() => console.log('Application is running')).catch(err => console.log(err));
	     * ```
	     *
	     */
	    async start(appOptions) {
	        this.wire.sendAction('start-application').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const app = await this._create(appOptions);
	        await this.wire.sendAction('run-application', { uuid: appOptions.uuid });
	        return app;
	    }
	    /**
	     * Asynchronously starts a batch of applications given an array of application identifiers and manifestUrls.
	     * Returns once the RVM is finished attempting to launch the applications.
	     * @param opts - Parameters that the RVM will use.
	     *
	     * @example
	     *
	     * ```js
	     *
	     * const applicationInfoArray = [
	     *     {
	     *         "uuid": 'App-1',
	     *         "manifestUrl": 'http://localhost:5555/app1.json',
	     *     },
	     *     {
	     *         "uuid": 'App-2',
	     *         "manifestUrl": 'http://localhost:5555/app2.json',
	     *     },
	     *     {
	     *         "uuid": 'App-3',
	     *         "manifestUrl": 'http://localhost:5555/app3.json',
	     *     }
	     * ]
	     *
	     * fin.Application.startManyManifests(applicationInfoArray)
	     *     .then(() => {
	     *         console.log('RVM has finished launching the application list.');
	     *     })
	     *     .catch((err) => {
	     *         console.log(err);
	     *     })
	     * ```
	     *
	     * @experimental
	     */
	    async startManyManifests(applications, opts) {
	        return this.wire.sendAction('run-applications', { applications, opts }).then(() => undefined);
	    }
	    /**
	     * Asynchronously returns an Application object that represents the current application
	     *
	     * @example
	     *
	     * ```js
	     * async function isCurrentAppRunning () {
	     *     const app = await fin.Application.getCurrent();
	     *     return app.isRunning();
	     * }
	     *
	     * isCurrentAppRunning().then(running => {
	     *     console.log(`Current app is running: ${running}`);
	     * }).catch(err => {
	     *     console.error(err);
	     * });
	     *
	     * ```
	     */
	    getCurrent() {
	        this.wire.sendAction('get-current-application').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this.wrap({ uuid: this.wire.me.uuid });
	    }
	    /**
	     * Synchronously returns an Application object that represents the current application
	     *
	     * @example
	     *
	     * ```js
	     * async function isCurrentAppRunning () {
	     *     const app = fin.Application.getCurrentSync();
	     *     return app.isRunning();
	     * }
	     *
	     * isCurrentAppRunning().then(running => {
	     *     console.log(`Current app is running: ${running}`);
	     * }).catch(err => {
	     *     console.error(err);
	     * });
	     *
	     * ```
	     */
	    getCurrentSync() {
	        this.wire.sendAction('get-current-application-sync').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this.wrapSync({ uuid: this.wire.me.uuid });
	    }
	    /**
	     * Retrieves application's manifest and returns a running instance of the application.
	     * @param manifestUrl - The URL of app's manifest.
	     * @param opts - Parameters that the RVM will use.
	     *
	     * @example
	     *
	     * ```js
	     * fin.Application.startFromManifest('http://localhost:5555/app.json').then(app => console.log('App is running')).catch(err => console.log(err));
	     *
	     * // For a local manifest file:
	     * fin.Application.startFromManifest('file:///C:/somefolder/app.json').then(app => console.log('App is running')).catch(err => console.log(err));
	     * ```
	     */
	    async startFromManifest(manifestUrl, opts) {
	        this.wire.sendAction('application-start-from-manifest').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const app = await this._createFromManifest(manifestUrl);
	        // @ts-expect-error using private method without warning.
	        await app._run(opts); // eslint-disable-line no-underscore-dangle
	        return app;
	    }
	    /**
	     * @deprecated Use {@link Application.ApplicationModule.startFromManifest Application.startFromManifest} instead.
	     * Retrieves application's manifest and returns a wrapped application.
	     * @param manifestUrl - The URL of app's manifest.
	     * @param callback - called if the method succeeds.
	     * @param errorCallback - called if the method fails. The reason for failure is passed as an argument.
	     *
	     * @example
	     *
	     * ```js
	     * fin.Application.createFromManifest('http://localhost:5555/app.json').then(app => console.log(app)).catch(err => console.log(err));
	     * ```
	     * @ignore
	     */
	    createFromManifest(manifestUrl) {
	        console.warn('Deprecation Warning: fin.Application.createFromManifest is deprecated. Please use fin.Application.startFromManifest');
	        this.wire.sendAction('application-create-from-manifest').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this._createFromManifest(manifestUrl);
	    }
	    _createFromManifest(manifestUrl) {
	        return this.wire
	            .sendAction('get-application-manifest', { manifestUrl })
	            .then(({ payload }) => {
	            const uuid = payload.data.platform ? payload.data.platform.uuid : payload.data.startup_app.uuid;
	            return this.wrap({ uuid });
	        })
	            .then((app) => {
	            app._manifestUrl = manifestUrl; // eslint-disable-line no-underscore-dangle
	            return app;
	        });
	    }
	}
	Factory$7.ApplicationModule = ApplicationModule;
	return Factory$7;
}

var hasRequiredApplication;

function requireApplication () {
	if (hasRequiredApplication) return application;
	hasRequiredApplication = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		/**
		 * Entry points for the OpenFin `Application` API (`fin.Application`).
		 *
		 * * {@link ApplicationModule} contains static members of the `Application` API, accessible through `fin.Application`.
		 * * {@link Application} describes an instance of an OpenFin Application, e.g. as returned by `fin.Application.getCurrent`.
		 *
		 * These are separate code entities, and are documented separately.  In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
		 * both of these were documented on the same page.
		 *
		 * @packageDocumentation
		 */
		__exportStar(requireFactory$2(), exports);
		__exportStar(requireInstance$1(), exports); 
	} (application));
	return application;
}

var promisifySubscription$1 = {};

Object.defineProperty(promisifySubscription$1, "__esModule", { value: true });
promisifySubscription$1.promisifySubscription = void 0;
const promisifySubscription = async (emitter, eventName, predicate = () => true, timeout) => {
    let resolve;
    let reject;
    let timer;
    const valuePromise = new Promise((y, n) => {
        resolve = y;
        reject = n;
    });
    const listener = (e) => {
        if (predicate(e)) {
            clearTimeout(timer);
            resolve(e);
        }
    };
    await emitter.on(eventName, listener);
    if (timeout) {
        timer = setTimeout(() => reject(new Error('event timed out')), timeout);
    }
    valuePromise.finally(() => {
        emitter.removeListener(eventName, listener).catch(() => null);
    });
    return {
        getValue: () => valuePromise
    };
};
promisifySubscription$1.promisifySubscription = promisifySubscription;

var hasRequiredInstance;

function requireInstance () {
	if (hasRequiredInstance) return Instance$7;
	hasRequiredInstance = 1;
	Object.defineProperty(Instance$7, "__esModule", { value: true });
	Instance$7._Window = void 0;
	/* eslint-disable import/prefer-default-export */
	/* eslint-disable @typescript-eslint/no-unused-vars */
	/* eslint-disable no-console */
	/* eslint-disable @typescript-eslint/no-non-null-assertion */
	const application_1 = requireApplication();
	const main_1 = main;
	const view_1 = requireView();
	const warnings_1 = warnings;
	const promisifySubscription_1 = promisifySubscription$1;
	/**
	 * A basic window that wraps a native HTML window. Provides more fine-grained
	 * control over the window state such as the ability to minimize, maximize, restore, etc.
	 * By default a window does not show upon instantiation; instead the window's show() method
	 * must be invoked manually. The new window appears in the same process as the parent window.
	 * It has the ability to listen for {@link OpenFin.WindowEvents window specific events}.
	 */
	// The window.Window name is taken
	class _Window extends main_1.WebContents {
	    /**
	     * @internal
	     */
	    constructor(wire, identity) {
	        super(wire, identity, 'window');
	    }
	    async createWindow(options) {
	        this.wire.sendAction('window-create-window', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const CONSTRUCTOR_CB_TOPIC = 'fire-constructor-callback';
	        const responseSubscription = await (0, promisifySubscription_1.promisifySubscription)(this, CONSTRUCTOR_CB_TOPIC);
	        // set defaults:
	        if (options.waitForPageLoad === undefined) {
	            options.waitForPageLoad = false;
	        }
	        if (options.autoShow === undefined) {
	            options.autoShow = true;
	        }
	        (0, warnings_1.handleDeprecatedWarnings)(options);
	        const windowCreation = this.wire.environment.createChildContent({ entityType: 'window', options });
	        const [response] = await Promise.all([responseSubscription.getValue(), windowCreation]);
	        let cbPayload;
	        const { success } = response;
	        const responseData = response.data;
	        const { message } = responseData;
	        if (success) {
	            cbPayload = {
	                httpResponseCode: responseData.httpResponseCode,
	                apiInjected: responseData.apiInjected
	            };
	        }
	        else {
	            cbPayload = {
	                message: responseData.message,
	                networkErrorCode: responseData.networkErrorCode,
	                stack: responseData.stack
	            };
	        }
	        const pageResolve = {
	            message,
	            cbPayload,
	            success
	        };
	        try {
	            // this is to enforce a 5.0 contract that the child's main function
	            // will not fire before the parent's success callback on creation.
	            // if the child window is not accessible (CORS) this contract does
	            // not hold.
	            const webWindow = this.getWebWindow();
	            webWindow.fin.__internal_.openerSuccessCBCalled();
	        }
	        catch (e) {
	            // common for main windows, we do not want to expose this error. here just to have a debug target.
	            // console.error(e);
	        }
	        if (pageResolve.success) {
	            return this;
	        }
	        return Promise.reject(pageResolve);
	    }
	    /**
	     * Retrieves an array of frame info objects representing the main frame and any
	     * iframes that are currently on the page.
	     *
	     * @example
	     * ```js
	     * async function getAllFrames() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getAllFrames.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getAllFrames();
	     * }
	     *
	     * getAllFrames().then(framesInfo => console.log(framesInfo)).catch(err => console.log(err));
	     * ```
	     */
	    getAllFrames() {
	        return this.wire.sendAction('get-all-frames', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Gets the current bounds (top, bottom, right, left, width, height) of the window.
	     *
	     * @example
	     * ```js
	     * async function getBounds() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-3',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getBounds.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getBounds();
	     * }
	     *
	     * getBounds().then(bounds => console.log(bounds)).catch(err => console.log(err));
	     * ```
	     */
	    getBounds() {
	        return this.wire
	            .sendAction('get-window-bounds', this.identity)
	            .then(({ payload }) => payload.data);
	    }
	    /**
	     * Centers the window on its current screen.
	     *
	     * @remarks Does not have an effect on minimized or maximized windows.
	     *
	     * @example
	     * ```js
	     * async function centerWindow() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.center.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.center();
	     * }
	     *
	     * centerWindow().then(() => console.log('Window centered')).catch(err => console.log(err));
	     * ```
	     *
	     */
	    center() {
	        return this.wire.sendAction('center-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Removes focus from the window.
	     *
	     * @example
	     * ```js
	     * async function blurWindow() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.blur.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.blur();
	     * }
	     *
	     * blurWindow().then(() => console.log('Blured Window')).catch(err => console.log(err));
	     * ```
	     */
	    blur() {
	        return this.wire.sendAction('blur-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Brings the window to the front of the window stack.
	     *
	     * @example
	     * ```js
	     * async function BringWindowToFront() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.bringToFront.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.bringToFront();
	     * }
	     *
	     * BringWindowToFront().then(() => console.log('Window is in the front')).catch(err => console.log(err));
	     * ```
	     */
	    bringToFront() {
	        return this.wire.sendAction('bring-window-to-front', this.identity).then(() => undefined);
	    }
	    /**
	     * Performs the specified window transitions.
	     * @param transitions - Describes the animations to perform. See the tutorial.
	     * @param options - Options for the animation. See the tutorial.
	     *
	     * @example
	     * ```
	     * async function animateWindow() {
	     *     const transitions = {
	     *         opacity: {
	     *             opacity: 0.7,
	     *             duration: 500
	     *         },
	     *         position: {
	     *             top: 100,
	     *             left: 100,
	     *             duration: 500,
	     *             relative: true
	     *         }
	     *     };
	     *     const options = {
	     *         interrupt: true,
	     *         tween: 'ease-in'
	     *     };
	     *
	     *     const win = await fin.Window.getCurrent();
	     *     return win.animate(transitions, options);
	     * }
	     *
	     * animateWindow()
	     *     .then(() => console.log('Animation done'))
	     *     .catch(err => console.error(err));
	     * ```
	     */
	    animate(transitions, options) {
	        return this.wire
	            .sendAction('animate-window', {
	            transitions,
	            options,
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Hides the window.
	     *
	     * @example
	     * ```js
	     * async function hideWindow() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.hide.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.hide();
	     * }
	     *
	     * hideWindow().then(() => console.log('Window is hidden')).catch(err => console.log(err));
	     * ```
	     */
	    hide() {
	        return this.wire.sendAction('hide-window', this.identity).then(() => undefined);
	    }
	    /**
	     * closes the window application
	     * @param force Close will be prevented from closing when force is false and
	     *  ‘close-requested’ has been subscribed to for application’s main window.
	     *
	     * @example
	     * ```js
	     * async function closeWindow() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-3',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.close.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.close();
	     * }
	     *
	     * closeWindow().then(() => console.log('Window closed')).catch(err => console.log(err));
	     * ```
	     */
	    close(force = false) {
	        return this.wire.sendAction('close-window', { force, ...this.identity }).then(() => {
	            Object.setPrototypeOf(this, null);
	            return undefined;
	        });
	    }
	    focusedWebViewWasChanged() {
	        return this.wire.sendAction('focused-webview-changed', this.identity).then(() => undefined);
	    }
	    /**
	     * Returns the native OS level Id.
	     *
	     * @remarks In Windows, it will return the Windows [handle](https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types#HWND).
	     *
	     * @example
	     * ```js
	     * async function getWindowNativeId() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-3',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getNativeId.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getNativeId();
	     * }
	     *
	     * getWindowNativeId().then(nativeId => console.log(nativeId)).catch(err => console.log(err));
	     * ```
	     */
	    getNativeId() {
	        return this.wire.sendAction('get-window-native-id', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Retrieves window's attached views.
	     * @experimental
	     *
	     * @example
	     * ```js
	     * const win = fin.Window.getCurrentSync();
	     *
	     * win.getCurrentViews()
	     *   .then(views => console.log(views))
	     *   .catch(console.error);
	     * ```
	     */
	    async getCurrentViews() {
	        const { payload } = await this.wire.sendAction('window-get-views', this.identity);
	        return payload.data.map((id) => new view_1.View(this.wire, id));
	    }
	    /**
	     * @deprecated Use {@link Window._Window.disableUserMovement} instead.
	     */
	    disableFrame() {
	        console.warn('Function is deprecated; use disableUserMovement instead.');
	        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);
	    }
	    /**
	     * Prevents a user from changing a window's size/position when using the window's frame.
	     *
	     * @example
	     * ```js
	     * async function disableUserMovement() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-3',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.disableFrame.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.disableUserMovement();
	     * }
	     *
	     * disableUserMovement().then(() => console.log('Window is disabled')).catch(err => console.log(err));
	     * ```
	     */
	    disableUserMovement() {
	        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);
	    }
	    /**
	     * @deprecated Use {@link Window._Window.enableUserMovement} instead.
	     */
	    enableFrame() {
	        console.warn('Function is deprecated; use enableUserMovement instead.');
	        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);
	    }
	    /**
	     * Re-enables user changes to a window's size/position when using the window's frame.
	     *
	     * @example
	     * ```js
	     * async function enableUserMovement() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-3',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.enableFrame.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.enableUserMovement();
	     * }
	     *
	     * enableUserMovement().then(() => console.log('Window is enabled')).catch(err => console.log(err));
	     * ```
	     */
	    enableUserMovement() {
	        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);
	    }
	    /**
	     * Flashes the window’s frame and taskbar icon until stopFlashing is called or until a focus event is fired.
	     *
	     * @remarks On macOS flash only works on inactive windows.
	     * @example
	     * ```js
	     * async function windowFlash() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.flash.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.flash();
	     * }
	     *
	     * windowFlash().then(() => console.log('Window flashing')).catch(err => console.log(err));
	     * ```
	     */
	    flash() {
	        return this.wire.sendAction('flash-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Stops the taskbar icon from flashing.
	     *
	     * @example
	     * ```js
	     * async function stopWindowFlashing() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.stopFlashing.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.stopFlashing();
	     * }
	     *
	     * stopWindowFlashing().then(() => console.log('Application window flashing')).catch(err => console.log(err));
	     * ```
	     */
	    stopFlashing() {
	        return this.wire.sendAction('stop-flash-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Gets an information object for the window.
	     *
	     * @example
	     * ```js
	     * async function getInfo() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getInfo.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getInfo();
	     * }
	     *
	     * getInfo().then(info => console.log(info)).catch(err => console.log(err));
	     * ```
	     */
	    getInfo() {
	        return this.wire.sendAction('get-window-info', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Retrieves the window's Layout
	     *
	     * @example
	     * ```js
	     *     //get the current window
	     *     const window = await fin.Window.getCurrent();
	     *
	     *     //get the layout for the window
	     *     const layout = await window.getLayout();
	     * ```
	     * @experimental
	     */
	    async getLayout(layoutIdentity) {
	        this.wire.sendAction('window-get-layout', this.identity).catch((e) => {
	            // don't expose
	        });
	        const opts = await this.getOptions();
	        if (!opts.layout || !opts.layoutSnapshot) {
	            throw new Error('Window does not have a Layout');
	        }
	        return this.fin.Platform.Layout.wrap(layoutIdentity ?? this.identity);
	    }
	    /**
	     * Gets the current settings of the window.
	     *
	     * @example
	     * ```js
	     * async function getWindowOptions() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getOptions.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getOptions();
	     * }
	     *
	     * getWindowOptions().then(opts => console.log(opts)).catch(err => console.log(err));
	     * ```
	     */
	    getOptions() {
	        return this.wire.sendAction('get-window-options', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Gets the parent application.
	     *
	     * @example
	     * ```js
	     * async function getParentApplication() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getParentApplication.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getParentApplication();
	     * }
	     *
	     * getParentApplication().then(parentApplication => console.log(parentApplication)).catch(err => console.log(err));
	     * ```
	     */
	    getParentApplication() {
	        this.wire.sendAction('window-get-parent-application', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return Promise.resolve(new application_1.Application(this.wire, this.identity));
	    }
	    /**
	     * Gets the parent window.
	     *
	     * @example
	     * ```js
	     * async function getParentWindow() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getParentWindow.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getParentWindow();
	     * }
	     *
	     * getParentWindow().then(parentWindow => console.log(parentWindow)).catch(err => console.log(err));
	     * ```
	     */
	    getParentWindow() {
	        this.wire.sendAction('window-get-parent-window', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return Promise.resolve(new application_1.Application(this.wire, this.identity)).then((app) => app.getWindow());
	    }
	    /**
	     * ***DEPRECATED - please use Window.capturePage.***
	     * Gets a base64 encoded PNG image of the window or just part a of it.
	     * @param area The area of the window to be captured.
	     * Omitting it will capture the whole visible window.
	     *
	     * @tutorial Window.capturePage
	     */
	    async getSnapshot(area) {
	        const req = { area, ...this.identity };
	        console.warn('Window.getSnapshot has been deprecated, please use Window.capturePage');
	        const res = await this.wire.sendAction('get-window-snapshot', req);
	        return res.payload.data;
	    }
	    /**
	     * Gets the current state ("minimized", "maximized", or "normal") of the window.
	     *
	     * @example
	     * ```js
	     * async function getWindowState() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.getState.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.getState();
	     * }
	     *
	     * getWindowState().then(winState => console.log(winState)).catch(err => console.log(err));
	     * ```
	     */
	    getState() {
	        return this.wire.sendAction('get-window-state', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Previously called getNativeWindow.
	     * Returns the [Window Object](https://developer.mozilla.org/en-US/docs/Web/API/Window)
	     * that represents the web context of the target window. This is the same object that
	     * you would get from calling [window.open()](https://developer.mozilla.org/en-US/docs/Web/API/Window/open) in a standard web context.
	     * The target window needs to be in the same application as the requesting window
	     * as well as comply with [same-origin](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) policy requirements.
	     *
	     * @example
	     * Injecting content into an empty window:
	     *
	     * ```js
	     * (async ()=> {
	     *     try {
	     *         const winName = `child-window-${Date.now()}`;
	     *         const win = await fin.Window.create({
	     *             name: winName,
	     *             url: 'about:blank'
	     *         });
	     *         win.getWebWindow().document.write('<h1>Hello World</h1>');
	     *     } catch (err) {
	     *         console.error(err);
	     *     }
	     * })();
	     * ```
	     *
	     * Cloning DOM elements from the parent window (in this example we clone an `h3` element from the parent window):
	     * ```js
	     * (async ()=> {
	     *     try {
	     *         const currentWindow = await fin.Window.getCurrent();
	     *         const parentWindow = await currentWindow.getParentWindow();
	     *         const clonedH3 = parentWindow.getWebWindow().document.querySelector('h3').cloneNode(true);
	     *         document.body.append(clonedH3);
	     *
	     *     } catch (err) {
	     *         console.error(err);
	     *     }
	     * })();
	     * ```
	     *
	     * Rendering on a child window via a library (in this example we are using the [lit-html](https://lit-html.polymer-project.org/)
	     * template library to render content on a blank child window. You are not going to be able to copy paste this example without
	     * configuring the project correctly but this would demonstrate some templating options available):
	     * ```js
	     * (async ()=> {
	     *     try {
	     *         const win = await fin.Window.create({
	     *             name: `child-window-${Date.now()}`,
	     *             url: 'about:blank'
	     *         });
	     *         const template = html`
	     *             <div>
	     *                 <span>Click here: </span>
	     *                 <button @click=${()=> console.log('Hello World!')}>log to the console</button>
	     *             </div>`;
	     *         render(template, win.getWebWindow().document.body);
	     *
	     *     } catch (err) {
	     *         console.error(err);
	     *     }
	     * })();
	     * ```
	     */
	    getWebWindow() {
	        this.wire.sendAction('window-get-web-window', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this.wire.environment.getWebWindow(this.identity);
	    }
	    /**
	     * Determines if the window is a main window.
	     *
	     * @example
	     * ```js
	     * const wnd = fin.Window.getCurrentSync();
	     * const isMainWnd = wnd.isMainWindow();
	     * console.log('Is this a main window? ' + isMainWnd);
	     * ```
	     */
	    isMainWindow() {
	        this.wire.sendAction('window-is-main-window', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        return this.me.uuid === this.me.name;
	    }
	    /**
	     * Determines if the window is currently showing.
	     *
	     * @example
	     * ```js
	     * async function isWindowShowing() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.isShowing.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.isShowing();
	     * }
	     *
	     * isWindowShowing().then(bool => console.log(bool)).catch(err => console.log(err));
	     * ```
	     */
	    isShowing() {
	        return this.wire.sendAction('is-window-showing', this.identity).then(({ payload }) => payload.data);
	    }
	    /**
	     * Maximizes the window
	     *
	     * @example
	     * ```js
	     * async function maxWindow() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.maximize.html',
	     *         autoShow: true
	     *     });
	     *     const win = await app.getWindow();
	     *     return await win.maximize();
	     * }
	     *
	     * maxWindow().then(() => console.log('Maximized window')).catch(err => console.log(err));
	     * ```
	     */
	    maximize() {
	        return this.wire.sendAction('maximize-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Minimizes the window.
	     *
	     * @example
	     * ```js
	     * async function minWindow() {
	     *     const win = await fin.Window.getCurrent();
	     *     return await win.minimize();
	     * }
	     *
	     * minWindow().then(() => console.log('Minimized window')).catch(err => console.log(err));
	     * ```
	     */
	    minimize() {
	        return this.wire.sendAction('minimize-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Moves the window by a specified amount.
	     * @param deltaLeft The change in the left position of the window
	     * @param deltaTop The change in the top position of the window
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.moveBy.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function moveBy(left, top) {
	     *     const win = await createWin();
	     *     return await win.moveBy(left, top);
	     * }
	     *
	     * moveBy(580, 300).then(() => console.log('Moved')).catch(err => console.log(err));
	     * ```
	     */
	    moveBy(deltaLeft, deltaTop, positioningOptions) {
	        return this.wire
	            .sendAction('move-window-by', {
	            deltaLeft,
	            deltaTop,
	            positioningOptions,
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Moves the window to a specified location.
	     * @param left The left position of the window
	     * @param top The top position of the window
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.moveTo.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function moveTo(left, top) {
	     *     const win = await createWin();
	     *     return await win.moveTo(left, top)
	     * }
	     *
	     * moveTo(580, 300).then(() => console.log('Moved')).catch(err => console.log(err))
	     * ```
	     */
	    moveTo(left, top, positioningOptions) {
	        return this.wire
	            .sendAction('move-window', {
	            left,
	            top,
	            positioningOptions,
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Resizes the window by a specified amount.
	     * @param deltaWidth The change in the width of the window
	     * @param deltaHeight The change in the height of the window
	     * @param anchor Specifies a corner to remain fixed during the resize.
	     * Can take the values: "top-left", "top-right", "bottom-left", or "bottom-right".
	     * If undefined, the default is "top-left"
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.resizeBy.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function resizeBy(left, top, anchor) {
	     *     const win = await createWin();
	     *     return await win.resizeBy(left, top, anchor)
	     * }
	     *
	     * resizeBy(580, 300, 'top-right').then(() => console.log('Resized')).catch(err => console.log(err));
	     * ```
	     */
	    resizeBy(deltaWidth, deltaHeight, anchor, positioningOptions) {
	        return this.wire
	            .sendAction('resize-window-by', {
	            deltaWidth: Math.floor(deltaWidth),
	            deltaHeight: Math.floor(deltaHeight),
	            anchor,
	            positioningOptions,
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Resizes the window to the specified dimensions.
	     * @param width The change in the width of the window
	     * @param height The change in the height of the window
	     * @param anchor Specifies a corner to remain fixed during the resize.
	     * Can take the values: "top-left", "top-right", "bottom-left", or "bottom-right".
	     * If undefined, the default is "top-left"
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.resizeTo.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function resizeTo(left, top, anchor) {
	     *     const win = await createWin();
	     *     return await win.resizeTo(left, top, anchor);
	     * }
	     *
	     * resizeTo(580, 300, 'top-left').then(() => console.log('Resized')).catch(err => console.log(err));
	     * ```
	     */
	    resizeTo(width, height, anchor, positioningOptions) {
	        return this.wire
	            .sendAction('resize-window', {
	            width: Math.floor(width),
	            height: Math.floor(height),
	            anchor,
	            positioningOptions,
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Restores the window to its normal state (i.e., unminimized, unmaximized).
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.restore.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function restore() {
	     *     const win = await createWin();
	     *     return await win.restore();
	     * }
	     *
	     * restore().then(() => console.log('Restored')).catch(err => console.log(err));
	     * ```
	     */
	    restore() {
	        return this.wire.sendAction('restore-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Will bring the window to the front of the entire stack and give it focus.
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.setAsForeground.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function setAsForeground() {
	     *     const win = await createWin();
	     *     return await win.setAsForeground()
	     * }
	     *
	     * setAsForeground().then(() => console.log('In the foreground')).catch(err => console.log(err));
	     * ```
	     */
	    setAsForeground() {
	        return this.wire.sendAction('set-foreground-window', this.identity).then(() => undefined);
	    }
	    /**
	     * Sets the window's size and position.
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.setBounds.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function setBounds(bounds) {
	     *     const win = await createWin();
	     *     return await win.setBounds(bounds);
	     * }
	     *
	     * setBounds({
	     *     height: 100,
	     *     width: 200,
	     *     top: 400,
	     *     left: 400
	     * }).then(() => console.log('Bounds set to window')).catch(err => console.log(err));
	     * ```
	     */
	    setBounds(bounds, positioningOptions) {
	        return this.wire
	            .sendAction('set-window-bounds', { ...bounds, ...this.identity, positioningOptions })
	            .then(() => undefined);
	    }
	    /**
	     * Shows the window if it is hidden.
	     * @param force Show will be prevented from showing when force is false and
	     *  ‘show-requested’ has been subscribed to for application’s main window.
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.show.html',
	     *         autoShow: false
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function show() {
	     *     const win = await createWin();
	     *     return await win.show()
	     * }
	     *
	     * show().then(() => console.log('Showing')).catch(err => console.log(err));
	     * ```
	     */
	    show(force = false) {
	        return this.wire.sendAction('show-window', { force, ...this.identity }).then(() => undefined);
	    }
	    /**
	     * Shows the window if it is hidden at the specified location.
	     *
	     * @param left The left position of the window in pixels
	     * @param top The top position of the window in pixels
	     * @param force Show will be prevented from closing when force is false and
	     * ‘show-requested’ has been subscribed to for application’s main window
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.showAt.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     *
	     * async function showAt(left, top) {
	     *     const win = await createWin();
	     *     return await win.showAt(left, top)
	     * }
	     *
	     * showAt(580, 300).then(() => console.log('Showing at')).catch(err => console.log(err));
	     * ```
	     */
	    showAt(left, top, force = false) {
	        return this.wire
	            .sendAction('show-at-window', {
	            force,
	            left: Math.floor(left),
	            top: Math.floor(top),
	            ...this.identity
	        })
	            .then(() => undefined);
	    }
	    /**
	     * Shows the Chromium Developer Tools
	     *
	     * @tutorial Window.showDeveloperTools
	     */
	    /**
	     * Updates the window using the passed options.
	     *
	     * @remarks Values that are objects are deep-merged, overwriting only the values that are provided.
	     * @param options Changes a window's options that were defined upon creation. See tutorial
	     *
	     * @example
	     * ```js
	     * async function updateOptions() {
	     *     const win = await fin.Window.getCurrent();
	     *     return win.updateOptions({maxWidth: 100});
	     * }
	     * updateOptions().then(() => console.log('options is updated')).catch(err => console.error(err));
	     * ```
	     */
	    updateOptions(options) {
	        return this.wire.sendAction('update-window-options', { options, ...this.identity }).then(() => undefined);
	    }
	    /**
	     * Provides credentials to authentication requests
	     * @param userName userName to provide to the authentication challenge
	     * @param password password to provide to the authentication challenge
	     *
	     * @example
	     * ```js
	     * fin.Application.wrap({uuid: 'OpenfinPOC'}).then(app => {
	     *     app.on('window-auth-requested', evt => {
	     *         let win = fin.Window.wrap({ uuid: evt.uuid, name: evt.name});
	     *         win.authenticate('userName', 'P@assw0rd').then(()=> console.log('authenticated')).catch(err => console.log(err));
	     *     });
	     * });
	     * ```
	     */
	    authenticate(userName, password) {
	        return this.wire
	            .sendAction('window-authenticate', { userName, password, ...this.identity })
	            .then(() => undefined);
	    }
	    /**
	     * Shows a menu on the window.
	     *
	     * @remarks Returns a promise that resolves when the user has either selected an item or closed the menu. (This may take longer than other apis).
	     * Resolves to an object with `{result: 'clicked', data }` where data is the data field on the menu item clicked, or `{result 'closed'}` when the user doesn't select anything.
	     * Calling this method will close previously opened menus.
	     * @experimental
	     * @param options
	     * @typeParam Data User-defined shape for data returned upon menu item click.  Should be a
	     * [union](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
	     * of all possible data shapes for the entire menu, and the click handler should process
	     * these with a "reducer" pattern.
	     * @example
	     * This could be used to show a drop down menu over views in a platform window:
	     * ```js
	     * const template = [
	     *     {
	     *         label: 'Menu Item 1',
	     *         data: 'hello from item 1'
	     *     },
	     *     { type: 'separator' },
	     *     {
	     *         label: 'Menu Item 2',
	     *         type: 'checkbox',
	     *         checked: true,
	     *         data: 'The user clicked the checkbox'
	     *     },
	     *     {
	     *         label: 'see more',
	     *         enabled: false,
	     *         submenu: [
	     *             { label: 'submenu 1', data: 'hello from submenu' }
	     *         ]
	     *     }
	     * ]
	     * fin.me.showPopupMenu({ template }).then(r => {
	     *     if (r.result === 'closed') {
	     *         console.log('nothing happened');
	     *     } else {
	     *         console.log(r.data)
	     *     }
	     * })
	     * ```
	     *
	     * Overriding the built in context menu (note: that this can be done per element or document wide):
	     * ```js
	     * document.addEventListener('contextmenu', e => {
	     *     e.preventDefault();
	     *     const template = [
	     *         {
	     *             label: 'Menu Item 1',
	     *             data: 'hello from item 1'
	     *         },
	     *         { type: 'separator' },
	     *         {
	     *             label: 'Menu Item 2',
	     *             type: 'checkbox',
	     *             checked: true,
	     *             data: 'The user clicked the checkbox'
	     *         },
	     *         {
	     *             label: 'see more',
	     *             enabled: false,
	     *             submenu: [
	     *                 { label: 'submenu 1', data: 'hello from submenu' }
	     *             ]
	     *         }
	     *     ]
	     *     fin.me.showPopupMenu({ template, x: e.x, y: e.y }).then(r => {
	     *         if (r.result === 'closed') {
	     *             console.log('nothing happened');
	     *         } else {
	     *             console.log(r.data)
	     *         }
	     *     })
	     * })
	     * ```
	     */
	    async showPopupMenu(options) {
	        const { payload } = await this.wire.sendAction('show-popup-menu', { options, ...this.identity });
	        return payload.data;
	    }
	    /**
	     * Closes the window's popup menu, if one exists.
	     * @experimental
	     *
	     * @remarks Only one popup menu will ever be showing at a time. Calling `showPopupMenu` will automatically close
	     * any existing popup menu.
	     *
	     *
	     * @example
	     * This could be used to close a popup menu if the user's mouse leaves an element for example.
	     *
	     * ```js
	     * await fin.me.closePopupMenu();
	     * ```
	     */
	    async closePopupMenu() {
	        return this.wire.sendAction('close-popup-menu', { ...this.identity }).then(() => undefined);
	    }
	    /**
	     * Dispatch a result to the caller of `showPopupWindow`.
	     *
	     * @remarks If this window isn't currently being shown as a popup, this call will silently fail.
	     * @param data Serializable data to send to the caller window.
	     *
	     * @example
	     * ```js
	     * await fin.me.dispatchPopupResult({
	     *     foo: 'bar'
	     * });
	     * ```
	     */
	    async dispatchPopupResult(data) {
	        this.wire.sendAction('window-dispatch-popup-result', this.identity).catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        await this.wire.sendAction('dispatch-popup-result', { data, ...this.identity });
	    }
	    /**
	     * Prints the contents of the window.
	     *
	     * @param options Configuration for the print task.
	     * @remarks When `silent` is set to `true`, the API will pick the system's default printer if deviceName is empty
	     * and the default settings for printing.
	     *
	     * Use the CSS style `page-break-before: always;` to force print to a new page.
	     *
	     * @example
	     * ```js
	     * const win = fin.Window.getCurrentSync();
	     *
	     * win.print({ silent: false, deviceName: 'system-printer-name' }).then(() => {
	     *     console.log('print call has been sent to the system');
	     * });
	     * ```
	     *
	     * If a window has embedded views, those views will not print by default.  To print a window's contents including embedded views,
	     * use the `content` option:
	     *
	     * ```js
	     * const win = fin.Window.getCurrentSync();
	     *
	     * // Print embedded views
	     * win.print({ content: 'views' });
	     *
	     * // Print screenshot of current window
	     * win.print({ content: 'screenshot' })
	     * ```
	     *
	     * When `content` is set to `views`, the embedded views in the platform window will be concatenated and printed as
	     * individual pages.  If `includeSelf` is set to `true`, the platform window itself will be printed as the first
	     * page - be aware that this page will *not* include the embedded views - it will only include the contents of
	     * the platform window itself (e.g. tab stacks), with blank spaces where the view contents would be embedded.
	     *
	     * Due to a known issue, view contents that are not visible at the time `print` is called will not appear when
	     * printing `contents: views`.  This includes views that are obscured behind other active UI elements.
	     *
	     * To print the views embedded in their page context, set `content` to `screenshot`.
	     */
	    async print(options = { content: 'self' }) {
	        switch (options.content) {
	            case undefined:
	            case 'self':
	                return super.print(options);
	            case 'screenshot':
	                return this.wire.sendAction('print-screenshot', this.identity).then(() => undefined);
	            case 'views':
	                return this.wire.sendAction('print-views', { ...this.identity, options }).then(() => undefined);
	            default:
	                return undefined;
	        }
	    }
	}
	Instance$7._Window = _Window;
	return Instance$7;
}

var hasRequiredFactory$1;

function requireFactory$1 () {
	if (hasRequiredFactory$1) return Factory$8;
	hasRequiredFactory$1 = 1;
	Object.defineProperty(Factory$8, "__esModule", { value: true });
	Factory$8._WindowModule = void 0;
	const base_1 = base;
	const validate_1 = validate;
	const Instance_1 = requireInstance();
	/**
	 * Static namespace for OpenFin API methods that interact with the {@link _Window} class, available under `fin.Window`.
	 */
	class _WindowModule extends base_1.Base {
	    /**
	     * Asynchronously returns a Window object that represents an existing window.
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.wrap.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     * createWin().then(() => fin.Window.wrap({ uuid: 'app-1', name: 'myApp' }))
	     * .then(win => console.log('wrapped window'))
	     * .catch(err => console.log(err));
	     * ```
	     */
	    async wrap(identity) {
	        this.wire.sendAction('window-wrap').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const errorMsg = (0, validate_1.validateIdentity)(identity);
	        if (errorMsg) {
	            throw new Error(errorMsg);
	        }
	        return new Instance_1._Window(this.wire, identity);
	    }
	    /**
	     * Synchronously returns a Window object that represents an existing window.
	     *
	     * @example
	     * ```js
	     * async function createWin() {
	     *     const app = await fin.Application.start({
	     *         name: 'myApp',
	     *         uuid: 'app-1',
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.wrapSync.html',
	     *         autoShow: true
	     *     });
	     *     return await app.getWindow();
	     * }
	     * await createWin();
	     * let win = fin.Window.wrapSync({ uuid: 'app-1', name: 'myApp' });
	     * ```
	     */
	    wrapSync(identity) {
	        this.wire.sendAction('window-wrap-sync').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const errorMsg = (0, validate_1.validateIdentity)(identity);
	        if (errorMsg) {
	            throw new Error(errorMsg);
	        }
	        return new Instance_1._Window(this.wire, identity);
	    }
	    /**
	     * Creates a new Window.
	     * @param options - Window creation options
	     *
	     * @example
	     * ```js
	     * async function createWindow() {
	     *     const winOption = {
	     *         name:'child',
	     *         defaultWidth: 300,
	     *         defaultHeight: 300,
	     *         url: 'https://cdn.openfin.co/docs/javascript/stable/tutorial-Window.create.html',
	     *         frame: true,
	     *         autoShow: true
	     *     };
	     *     return await fin.Window.create(winOption);
	     * }
	     *
	     * createWindow().then(() => console.log('Window is created')).catch(err => console.log(err));
	     * ```
	     */
	    create(options) {
	        this.wire.sendAction('create-window').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        const win = new Instance_1._Window(this.wire, { uuid: this.me.uuid, name: options.name });
	        return win.createWindow(options);
	    }
	    /**
	     * Asynchronously returns a Window object that represents the current window
	     *
	     * @example
	     * ```js
	     * fin.Window.getCurrent()
	     * .then(wnd => console.log('current window'))
	     * .catch(err => console.log(err));
	     *
	     * ```
	     */
	    getCurrent() {
	        this.wire.sendAction('get-current-window').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        if (!this.wire.me.isWindow) {
	            throw new Error('You are not in a Window context');
	        }
	        const { uuid, name } = this.wire.me;
	        return this.wrap({ uuid, name });
	    }
	    /**
	     * Synchronously returns a Window object that represents the current window
	     *
	     * @example
	     * ```js
	     * const wnd = fin.Window.getCurrentSync();
	     * const info = await wnd.getInfo();
	     * console.log(info);
	     *
	     * ```
	     */
	    getCurrentSync() {
	        this.wire.sendAction('get-current-window-sync').catch((e) => {
	            // we do not want to expose this error, just continue if this analytics-only call fails
	        });
	        if (!this.wire.me.isWindow) {
	            throw new Error('You are not in a Window context');
	        }
	        const { uuid, name } = this.wire.me;
	        return this.wrapSync({ uuid, name });
	    }
	}
	Factory$8._WindowModule = _WindowModule;
	return Factory$8;
}

var hasRequiredWindow;

function requireWindow () {
	if (hasRequiredWindow) return window$1;
	hasRequiredWindow = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		/**
		 * Entry points for the OpenFin `Window` API (`fin.Window`).
		 *
		 * * {@link _WindowModule} contains static members of the `Window` API, accessible through `fin.Window`.
		 * * {@link _Window} describes an instance of an OpenFin Window, e.g. as returned by `fin.Window.getCurrent`.
		 *
		 * These are separate code entities, and are documented separately.  In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
		 * both of these were documented on the same page.
		 *
		 * Underscore prefixing of OpenFin types that alias DOM entities will be fixed in a future version.
		 *
		 * @packageDocumentation
		 */
		__exportStar(requireFactory$1(), exports);
		__exportStar(requireInstance(), exports); 
	} (window$1));
	return window$1;
}

/**
 * Entry point for the OpenFin `System` API (`fin.System`).
 *
 * * {@link System} contains static members of the `System` API (available under `fin.System`)
 *
 * @packageDocumentation
 */
Object.defineProperty(system, "__esModule", { value: true });
system.System = void 0;
const base_1$j = base;
const transport_errors_1$1 = transportErrors;
const window_1 = requireWindow();
const events_1$6 = require$$0;
/**
 * An object representing the core of OpenFin Runtime. Allows the developer
 * to perform system-level actions, such as accessing logs, viewing processes,
 * clearing the cache and exiting the runtime as well as listen to {@link OpenFin.SystemEvents system events}.
 *
 */
class System extends base_1$j.EmitterBase {
    /**
     * @internal
     */
    constructor(wire) {
        super(wire, 'system');
    }
    sendExternalProcessRequest(action, options) {
        return new Promise((resolve, reject) => {
            const exitEventKey = 'external-process-exited';
            let processUuid;
            let exitPayload;
            let externalProcessExitHandler;
            let ofWindow;
            if (typeof options.listener === 'function') {
                externalProcessExitHandler = (payload) => {
                    const data = payload || {};
                    exitPayload = {
                        topic: 'exited',
                        uuid: data.processUuid || '',
                        exitCode: data.exitCode || 0
                    };
                    if (processUuid === payload.processUuid) {
                        options.listener(exitPayload);
                        ofWindow.removeListener(exitEventKey, externalProcessExitHandler);
                    }
                };
                // window constructor expects the name is not undefined
                if (!this.wire.me.name) {
                    this.wire.me.name = this.wire.me.uuid;
                }
                ofWindow = new window_1._Window(this.wire, this.wire.me);
                ofWindow.on(exitEventKey, externalProcessExitHandler);
            }
            this.wire
                .sendAction(action, options)
                .then(({ payload }) => {
                processUuid = payload.data.uuid;
                resolve(payload.data);
                if (exitPayload && processUuid === exitPayload.uuid) {
                    options.listener(exitPayload);
                    ofWindow.removeListener(exitEventKey, externalProcessExitHandler);
                }
            })
                .catch((err) => {
                if (ofWindow) {
                    ofWindow.removeListener(exitEventKey, externalProcessExitHandler);
                }
                reject(err);
            });
        });
    }
    /**
     * Returns the version of the runtime. The version contains the major, minor,
     * build and revision numbers.
     *
     * @example
     * ```js
     * fin.System.getVersion().then(v => console.log(v)).catch(err => console.log(err));
     * ```
     */
    getVersion() {
        return this.wire.sendAction('get-version').then(({ payload }) => payload.data);
    }
    /**
     * Clears cached data containing application resource
     * files (images, HTML, JavaScript files), cookies, and items stored in the
     * Local Storage.
     * @param options - See below for details.
     *
     * @remarks For more information on the accepted options, see the following pages:
     * * cache: browsing data cache for html files and images ([caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching))
     * * cookies: browser [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
     * * localStorage: browser data that can be used across sessions ([local storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage))
     * * appcache: html5 [application cache](https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache)
     * @example
     * ```js
     * const clearCacheOptions = {
     *     appcache: true,
     *     cache: true,
     *     cookies: true,
     *     localStorage: true
     * };
     * fin.System.clearCache(clearCacheOptions).then(() => console.log('Cache cleared')).catch(err => console.log(err));
     * ```
     *
     */
    clearCache(options) {
        return this.wire.sendAction('clear-cache', options).then(() => undefined);
    }
    /**
     * Clears all cached data when OpenFin Runtime exits.
     *
     * @example
     * ```js
     * fin.System.deleteCacheOnExit().then(() => console.log('Deleted Cache')).catch(err => console.log(err));
     * ```
     */
    deleteCacheOnExit() {
        return this.wire.sendAction('delete-cache-request').then(() => undefined);
    }
    /**
     * Exits the Runtime.
     *
     * @example
     * ```js
     * fin.System.exit().then(() => console.log('exit')).catch(err => console.log(err));
     * ```
     */
    exit() {
        return this.wire.sendAction('exit-desktop').then(() => undefined);
    }
    /**
     * Fetches a JSON manifest using the browser process and returns a Javascript object.
     * @param manifestUrl The URL of the manifest to fetch.
     *
     * @example
     * ```js
     * const manifest = await fin.System.fetchManifest('https://www.path-to-manifest.com');
     * console.log(manifest);
     * ```
     */
    async fetchManifest(manifestUrl) {
        const { payload: { data } } = await this.wire.sendAction('fetch-manifest', { manifestUrl });
        return data;
    }
    /**
     * Writes any unwritten cookies data to disk.
     *
     * @example
     * ```js
     * fin.System.flushCookieStore()
     *     .then(() => console.log('success'))
     *     .catch(err => console.error(err));
     * ```
     */
    flushCookieStore() {
        return this.wire.sendAction('flush-cookie-store').then(() => undefined);
    }
    /**
     * Retrieves an array of data (name, ids, bounds) for all application windows.
     *
     * @example
     * ```js
     * fin.System.getAllWindows().then(wins => console.log(wins)).catch(err => console.log(err));
     * ```
     */
    getAllWindows() {
        return this.wire.sendAction('get-all-windows').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of data for all applications.
     *
     * @example
     * ```js
     * fin.System.getAllApplications().then(apps => console.log(apps)).catch(err => console.log(err));
     * ```
     */
    getAllApplications() {
        return this.wire.sendAction('get-all-applications').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves the command line argument string that started OpenFin Runtime.
     *
     * @example
     * ```js
     * fin.System.getCommandLineArguments().then(args => console.log(args)).catch(err => console.log(err));
     * ```
     */
    getCommandLineArguments() {
        return this.wire.sendAction('get-command-line-arguments').then(({ payload }) => payload.data);
    }
    /**
     * Get the current state of the crash reporter.
     *
     * @example
     * ```js
     * fin.System.getCrashReporterState().then(state => console.log(state)).catch(err => console.log(err));
     * ```
     */
    async getCrashReporterState() {
        const { payload: { data: { diagnosticMode, isRunning } } } = await this.wire.sendAction('get-crash-reporter-state');
        console.warn('diagnosticMode property is deprecated. It will be removed in a future version');
        return {
            // diagnosticMode will be removed in a future version
            diagnosticMode,
            diagnosticsMode: diagnosticMode,
            isRunning
        };
    }
    /**
     * Start the crash reporter if not already running.
     * @param options - configure crash reporter
     *
     * @remarks You can optionally specify `diagnosticsMode` to have the logs sent to
     * OpenFin on runtime close. (NOTE: `diagnosticsMode` will turn on verbose logging and disable the sandbox
     * for newly launched renderer processes. See https://developers.openfin.co/of-docs/docs/debugging#diagnostics-mode for
     * more details.)
     *
     * @example
     * ```js
     * fin.System.startCrashReporter({diagnosticsMode: true}).then(reporter => console.log(reporter)).catch(err => console.log(err));
     * ```
     */
    async startCrashReporter(options) {
        const opts = options;
        const newOpts = { ...opts, diagnosticMode: opts.diagnosticsMode || opts.diagnosticMode };
        const { payload: { data: { diagnosticMode, isRunning } } } = await this.wire.sendAction('start-crash-reporter', newOpts);
        return {
            // diagnosticMode will be removed in a future version
            diagnosticMode,
            diagnosticsMode: diagnosticMode,
            isRunning
        };
    }
    /**
     * Returns a hex encoded hash of the machine id and the currently logged in user name.
     * This is the recommended way to uniquely identify a user / machine combination.
     *
     * @remarks For Windows systems this is a sha256 hash of the machine ID set in the registry key:
     * `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\MachineGuid` and `USERNAME`.
     *
     * For OSX systems, a native-level call is used to get the machine ID.
     *
     * @example
     * ```js
     * fin.System.getUniqueUserId().then(id => console.log(id)).catch(err => console.log(err));
     * ```
     */
    getUniqueUserId() {
        return this.wire.sendAction('get-unique-user-id').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves a frame info object for the uuid and name passed in
     * @param uuid - The UUID of the target.
     * @param name - The name of the target.
     *
     * @remarks The possible types are 'window', 'iframe', 'external connection' or 'unknown'.
     * @example
     * ```js
     * const entityUuid = 'OpenfinPOC';
     * const entityName = '40c74b5d-ed98-40f7-853f-e3d3c2699175';
     * fin.System.getEntityInfo(entityUuid, entityName).then(info => console.log(info)).catch(err => console.log(err));
     *
     * // example info shape
     * {
     *     "uuid": "OpenfinPOC",
     *     "name": "40c74b5d-ed98-40f7-853f-e3d3c2699175",
     *     "parent": {
     *         "uuid": "OpenfinPOC",
     *         "name": "OpenfinPOC"
     *     },
     *     "entityType": "iframe"
     * }
     * ```
     */
    getEntityInfo(uuid, name) {
        return this.wire.sendAction('get-entity-info', { uuid, name }).then(({ payload }) => payload.data);
    }
    /**
     * Gets the value of a given environment variable on the computer on which the runtime is installed
     *
     * @example
     * ```js
     * fin.System.getEnvironmentVariable('HOME').then(env => console.log(env)).catch(err => console.log(err));
     * ```
     */
    getEnvironmentVariable(envName) {
        return this.wire
            .sendAction('get-environment-variable', {
            environmentVariables: envName
        })
            .then(({ payload }) => payload.data);
    }
    /**
     * Get current focused window.
     *
     * @example
     * ```js
     * fin.System.getFocusedWindow().then(winInfo => console.log(winInfo)).catch(err => console.log(err));
     * ```
     */
    getFocusedWindow() {
        return this.wire.sendAction('get-focused-window').then(({ payload }) => payload.data);
    }
    /**
     * Returns information about the given app's certification status
     *
     * @example
     * ```js
     * const manifestUrl = "http://localhost:1234/app.json"
     * try {
     *     const certificationInfo = await fin.System.isAppCertified(manifestUrl);
     * } catch(err) {
     *     console.error(err)
     * }
     * ```
     */
    async isAppCertified(manifestUrl) {
        const { payload: { data: { certifiedInfo } } } = await this.wire.sendAction('is-app-certified', { manifestUrl });
        return certifiedInfo;
    }
    /**
     * Returns an array of all the installed runtime versions in an object.
     *
     * @example
     * ```js
     * fin.System.getInstalledRuntimes().then(runtimes => console.log(runtimes)).catch(err => console.log(err));
     * ```
     */
    // incompatible with standalone node process.
    getInstalledRuntimes() {
        return this.wire.sendAction('get-installed-runtimes').then(({ payload }) => payload.data.runtimes);
    }
    // incompatible with standalone node process.
    async getInstalledApps() {
        const { payload: { data: { installedApps } } } = await this.wire.sendAction('get-installed-apps');
        return installedApps;
    }
    /**
     * Retrieves the contents of the log with the specified filename.
     * @param options A object that id defined by the GetLogRequestType interface
     *
     * @example
     * ```js
     * async function getLog() {
     *     const logs = await fin.System.getLogList();
     *     return await fin.System.getLog(logs[0]);
     * }
     *
     * getLog().then(log => console.log(log)).catch(err => console.log(err));
     * ```
     */
    getLog(options) {
        return this.wire.sendAction('view-log', options).then(({ payload }) => payload.data);
    }
    /**
     * Returns a unique identifier (UUID) provided by the machine.
     *
     * @example
     * ```js
     * fin.System.getMachineId().then(id => console.log(id)).catch(err => console.log(err));
     * ```
     */
    getMachineId() {
        return this.wire.sendAction('get-machine-id').then(({ payload }) => payload.data);
    }
    /**
     * Returns the minimum (inclusive) logging level that is currently being written to the log.
     *
     * @example
     * ```js
     * fin.System.getMinLogLevel().then(level => console.log(level)).catch(err => console.log(err));
     * ```
     */
    getMinLogLevel() {
        return this.wire.sendAction('get-min-log-level').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array containing information for each log file.
     *
     * @example
     * ```js
     * fin.System.getLogList().then(logList => console.log(logList)).catch(err => console.log(err));
     * ```
     */
    getLogList() {
        return this.wire.sendAction('list-logs').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an object that contains data about the monitor setup of the
     * computer that the runtime is running on.
     *
     * @example
     * ```js
     * fin.System.getMonitorInfo().then(monitorInfo => console.log(monitorInfo)).catch(err => console.log(err));
     * ```
     */
    getMonitorInfo() {
        return this.wire.sendAction('get-monitor-info').then(({ payload }) => payload.data);
    }
    /**
     * Returns the mouse in virtual screen coordinates (left, top).
     *
     * @example
     * ```js
     * fin.System.getMousePosition().then(mousePosition => console.log(mousePosition)).catch(err => console.log(err));
     * ```
     */
    getMousePosition() {
        return this.wire.sendAction('get-mouse-position').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of all of the runtime processes that are currently
     * running. Each element in the array is an object containing the uuid
     * and the name of the application to which the process belongs.
     * @deprecated Please use our new set of process APIs:
     * {@link Window._Window#getProcessInfo Window.getProcessInfo}
     * {@link View.View#getProcessInfo View.getProcessInfo}
     * {@link Application.Application#getProcessInfo Application.getProcessInfo}
     * {@link System#getAllProcessInfo System.getAllProcessInfo}
     *
     * @example
     * ```js
     * fin.System.getProcessList().then(ProcessList => console.log(ProcessList)).catch(err => console.log(err));
     * ```
     */
    getProcessList() {
        // eslint-disable-next-line no-console
        console.warn('System.getProcessList has been deprecated. Please consider using our new process APIs: Window.getProcessInfo, View.getProcessInfo, Application.getProcessInfo, System.getAllProcessInfo');
        return this.wire.sendAction('process-snapshot').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves all process information.
     *
     * @remarks This includes the browser process and every process associated to all entities (windows and views).
     *
     * @example
     * ```js
     * const allProcessInfo = await fin.System.getAllProcessInfo();
     * ```
     * @experimental
     */
    async getAllProcessInfo() {
        const { payload: { data } } = await this.wire.sendAction('get-all-process-info', this.identity);
        return data;
    }
    /**
     * Retrieves the Proxy settings.
     *
     * @example
     * ```js
     * fin.System.getProxySettings().then(ProxySetting => console.log(ProxySetting)).catch(err => console.log(err));
     *
     * //This response has the following shape:
     * {
     *     config: {
     *         proxyAddress: "proxyAddress", //the configured Proxy Address
     *         proxyPort: 0, //the configured Proxy port
     *         type: "system" //Proxy Type
     *     },
     *     system: {
     *         autoConfigUrl: "",
     *         bypass: "",
     *         enabled: false,
     *         proxy: ""
     *     }
     * }
     * ```
     */
    getProxySettings() {
        return this.wire.sendAction('get-proxy-settings').then(({ payload }) => payload.data);
    }
    /**
     * Returns information about the running Runtime in an object.
     *
     * @example
     * ```js
     * fin.System.getRuntimeInfo().then(RuntimeInfo => console.log(RuntimeInfo)).catch(err => console.log(err));
     * ```
     */
    getRuntimeInfo() {
        return this.wire.sendAction('get-runtime-info').then(({ payload }) => payload.data);
    }
    /**
     * Returns information about the running RVM in an object.
     *
     * @example
     * ```js
     * fin.System.getRvmInfo().then(RvmInfo => console.log(RvmInfo)).catch(err => console.log(err));
     * ```
     */
    // incompatible with standalone node process.
    getRvmInfo() {
        return this.wire.sendAction('get-rvm-info').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves system information.
     *
     * @example
     * ```js
     * fin.System.getHostSpecs().then(specs => console.log(specs)).catch(err => console.log(err));
     * ```
     */
    getHostSpecs() {
        return this.wire.sendAction('get-host-specs').then(({ payload }) => payload.data);
    }
    /**
     * Runs an executable or batch file. A path to the file must be included in options.
     * <br> A uuid may be optionally provided. If not provided, OpenFin will create a uuid for the new process.
     * <br> Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>. Also, this api has an enhanced permission set to make it less dangerous. So application owners can only allow to launch the assets owned by the application, the enabled downloaded files or the restricted executables.
     * @param options A object that is defined in the ExternalProcessRequestType interface
     *
     * @remarks If an unused UUID is provided in options, it will be used. If no UUID is provided, OpenFin will assign one.
     * This api has an enhanced permission set to make it less dangerous. So application owners can only allow to launch the
     * assets owned by the application, the enabled downloaded files or the restricted executables.
     *
     * **Note:** Since _appAssets_ relies on the RVM, which is missing on MAC_OS, 'alias' is not available. Instead provide
     * the full path e.g. _/Applications/Calculator.app/Contents/MacOS/Calculator_.
     *
     * @example
     * Basic Example:
     * ```js
     * fin.System.launchExternalProcess({
     *     path: 'notepad',
     *     arguments: '',
     *     listener: function (result) {
     *         console.log('the exit code', result.exitCode);
     *     }
     * }).then(processIdentity => {
     *     console.log(processIdentity);
     * }).catch(error => {
     *     console.log(error);
     * });
     * ```
     *
     * Promise resolution:
     *
     * ```js
     * //This response has the following shape:
     * {
     *     uuid: "FB3E6E36-0976-4C2B-9A09-FB2E54D2F1BB" // The mapped UUID which identifies the launched process
     * }
     * ```
     *
     * Listener callback:
     * ```js
     * //This response has the following shape:
     * {
     *     topic: "exited", // Or "released" on a call to releaseExternalProcess
     *     uuid: "FB3E6E36-0976-4C2B-9A09-FB2E54D2F1BB", // The mapped UUID which identifies the launched process
     *     exitCode: 0 // Process exit code
     * }
     * ```
     *
     * By specifying a lifetime, an external process can live as long the window/application that launched it or
     * persist after the application exits. The default value is null, which is equivalent to 'persist', meaning
     * the process lives on after the application exits:
     *
     * ```js
     * fin.System.launchExternalProcess({
     *     path: 'notepad',
     *     arguments: '',
     *     listener: (result) => {
     *         console.log('the exit code', result.exitCode);
     *     },
     *     lifetime: 'window'
     * }).then(processIdentity => {
     *     console.log(processIdentity);
     * }).catch(error => {
     *     console.log(error);
     * });
     * ```
     *
     * Note: A process that exits when the window/application exits cannot be released via fin.desktop.System.releaseExternalProcess.
     *
     * By specifying a cwd, it will set current working directory when launching an external process:
     *
     * ```js
     * fin.System.launchExternalProcess({
     *     path: 'cmd.exe',
     *     cwd: 'c:\\temp',
     *     arguments: '',
     *     listener: (result) => {
     *         console.log('the exit code', result.exitCode);
     *     }
     * }).then(processIdentity => {
     *     console.log(processIdentity);
     * }).catch(error => {
     *     console.log(error);
     * });
     * ```
     *
     * Example using an alias from app.json appAssets property:
     *
     * ```json
     * "appAssets": [
     *     {
     *         "src": "exe.zip",
     *         "alias": "myApp",
     *         "version": "4.12.8",
     *         "target": "myApp.exe",
     *         "args": "a b c d"
     *     },
     * ]
     * ```
     *
     * ```js
     * //  When called, if no arguments are passed then the arguments (if any)
     * //  are taken from the 'app.json' file, from the  'args' parameter
     * //  of the 'appAssets' Object with the relevant 'alias'.
     * fin.System.launchExternalProcess({
     *     //Additionally note that the executable found in the zip file specified in appAssets
     *     //will default to the one mentioned by appAssets.target
     *     //If the the path below refers to a specific path it will override this default
     *     alias: 'myApp',
     *     listener: (result) => {
     *         console.log('the exit code', result.exitCode);
     *     }
     * }).then(processIdentity => {
     *     console.log(processIdentity);
     * }).catch(error => {
     *     console.log(error);
     * });
     * ```
     *
     * Example using an alias but overriding the arguments:
     *
     * ```json
     * "appAssets": [
     *     {
     *         "src": "exe.zip",
     *         "alias": "myApp",
     *         "version": "4.12.8",
     *         "target": "myApp.exe",
     *         "args": "a b c d"
     *     },
     * ]
     * ```
     *
     * ```js
     * //  If 'arguments' is passed as a parameter it takes precedence
     * //  over any 'args' set in the 'app.json'.
     * fin.System.launchExternalProcess({
     *     alias: 'myApp',
     *     arguments: 'e f g',
     *     listener: (result) => {
     *         console.log('the exit code', result.exitCode);
     *     }
     * }).then(processIdentity => {
     *     console.log(processIdentity);
     * }).catch(error => {
     *     console.log(error);
     * });
     * ```
     *
     * It is now possible to optionally perform any combination of the following certificate checks
     * against an absolute target via `fin.desktop.System.launchExternalProcess()`:
     *
     * ```js
     * "certificate": {
     *     "serial": "3c a5 ...",                        // A hex string with or without spaces
     *     "subject": "O=OpenFin INC., L=New York, ...", // An internally tokenized and comma delimited string allowing partial or full checks of the subject fields
     *     "publickey": "3c a5 ...",                     // A hex string with or without spaces
     *     "thumbprint": "3c a5 ...",                    // A hex string with or without spaces
     *     "trusted": true                               // A boolean indicating that the certificate is trusted and not revoked
     * }
     * ```
     *
     * Providing this information as part of the default configurations for assets in an application's manifest
     * will be added in a future RVM update:
     *
     * ```js
     * fin.System.launchExternalProcess({
     *     path: 'C:\\Users\\ExampleUser\\AppData\\Local\\OpenFin\\OpenFinRVM.exe',
     *     arguments: '--version',
     *     certificate: {
     *         trusted: true,
     *         subject: 'O=OpenFin INC., L=New York, S=NY, C=US',
     *         thumbprint: '‎3c a5 28 19 83 05 fe 69 88 e6 8f 4b 3a af c5 c5 1b 07 80 5b'
     *     },
     *     listener: (result) => {
     *         console.log('the exit code', result.exitCode);
     *     }
     * }).then(processIdentity => {
     *     console.log(processIdentity);
     * }).catch(error => {
     *     console.log(error);
     * });
     * ```
     *
     * It is possible to launch files that have been downloaded by the user by listening to the window
     * `file-download-completed` event and using the `fileUuid` provided by the event:
     *
     * ```js
     * const win = fin.Window.getCurrentSync();
     * win.addListener('file-download-completed', (evt) => {
     *     if (evt.state === 'completed') {
     *         fin.System.launchExternalProcess({
     *             fileUuid: evt.fileUuid,
     *             arguments: '',
     *             listener: (result) => {
     *                 console.log('the exit code', result.exitCode);
     *             }
     *         }).then(processIdentity => {
     *             console.log(processIdentity);
     *         }).catch(error => {
     *             console.log(error);
     *         });
     *     }
     * });
     * ```
     *
     * Launching assets specified in the app manifest:
     *
     * Sample appAssets section in app.json
     * ```js
     *     "appAssets": [
     *         {
     *             "src": "http://filesamples.com/exe.zip",
     *             "alias": "myApp",
     *             "version": "4.12.8",
     *             "target": "myApp.exe",
     *             "args": "a b c d"
     *         },
     *         {
     *             "src": "http://examples.com/exe.zip",
     *             "alias": "myApp2",
     *             "version": "5.12.8",
     *             "target": "myApp2.exe",
     *             "args": "a b c"
     *         }
     *     ]
     * ```
     *
     * This permission allows for launching of all assets specified in the above appAssets section. ("myApp" and "myApp2"):
     *
     * ```js
     *     "permissions": {
     *        "System": {
     *            "launchExternalProcess": {
     *                 "enabled": true,
     *                 "assets": {
     *                     "enabled": true
     *                 }
     *             }
     *        }
     *     }
     * ```
     *
     * This permission allows for launching of _only_ the "myApp" asset in the above appAssets section, as defined in `srcRules`:
     * ```js
     *     "permissions": {
     *        "System": {
     *            "launchExternalProcess": {
     *                 "enabled": true,
     *                 "assets": {
     *                     "enabled": true
     *                     "srcRules": [
     *                         {
     *                             "match": [
     *                                 "*://filesamples.com/*"
     *                             ],
     *                             "behavior": "allow"
     *                         },
     *                         {
     *                             "match": [
     *                                 "<all_urls>"
     *                             ],
     *                             "behavior": "block"
     *                         }
     *                     ]
     *                 }
     *             }
     *        }
     *     }
     * ```
     *
     * Launching downloaded files:
     * ```js
     *     "permissions": {
     *        "System": {
     *            "launchExternalProcess": {
     *                 "enabled": true,
     *                 "downloads": {
     *                     "enabled": true
     *                 }
     *             }
     *        }
     *     }
     * ```
     *
     * This permission allows to launch all the executables:
     * ```js
     *     "permissions": {
     *        "System": {
     *            "launchExternalProcess": {
     *                 "enabled": true,
     *                 "executables": {
     *                     "enabled": true
     *                 }
     *             }
     *        }
     *     }
     * ```
     *
     *
     * This permission only allows launching of executables whose file paths match the corresponding `pathRules`:
     * ```js
     *     "permissions": {
     *        "System": {
     *            "launchExternalProcess": {
     *                 "enabled": true,
     *                 "executables": {
     *                     "enabled": true
     *                     "pathRules": [
     *                         {
     *                             "match": [
     *                                 "/Windows/System32/*.exe"
     *                             ],
     *                             "behavior": "allow"
     *                         },
     *                         {
     *                             "match": [
     *                                 "*.exe"
     *                             ],
     *                             "behavior": "block"
     *                         }
     *                     ]
     *                 }
     *             }
     *        }
     *     }
     * ```
     */
    launchExternalProcess(options) {
        return this.sendExternalProcessRequest('launch-external-process', options);
    }
    /**
     * Monitors a running process. A pid for the process must be included in options.
     * <br> A uuid may be optionally provided. If not provided, OpenFin will create a uuid for the new process.
     *
     * @remarks If an unused uuid is provided in options, it will be used. If no uuid is provided, OpefinFin will assign a uuid.
     * @example
     * ```js
     * fin.System.monitorExternalProcess({
     *     pid: 10208,
     *     uuid: 'my-external-process', // optional
     *     listener: function (result) {
     *         console.log('the exit code', result.exitCode);
     *     }
     * }).then(processIdentity => console.log(processIdentity)).catch(err => console.log(err));
     * ```
     */
    monitorExternalProcess(options) {
        return this.sendExternalProcessRequest('monitor-external-process', options);
    }
    /**
     * Writes the passed message into both the log file and the console.
     * @param level The log level for the entry. Can be either "info", "warning" or "error"
     * @param message The log message text
     *
     * @example
     * ```js
     * fin.System.log("info", "An example log message").then(() => console.log('Log info message')).catch(err => console.log(err));
     * ```
     */
    log(level, message) {
        return this.wire.sendAction('write-to-log', { level, message }).then(() => undefined);
    }
    /**
     * Opens the passed URL in the default web browser.
     *
     * @remarks It only supports http(s) and fin(s) protocols by default.
     * In order to use other custom protocols, they have to be enabled via
     * [API security settings](https://developers.openfin.co/docs/api-security).
     * File protocol and file path are not supported.
     * @param url The URL to open
     *
     * @example
     * ```js
     * fin.System.openUrlWithBrowser('https://cdn.openfin.co/docs/javascript/stable/tutorial-System.openUrlWithBrowser.html')
     * .then(() => console.log('Opened URL'))
     * .catch(err => console.log(err));
     * ```
     *
     * Example of permission definition to enable non-default protocols:
     *
     * Note: permission definition should be specified in an app manifest file if there is no DOS settings.
     * Otherwise it has to be specified in both DOS and app manifest files.
     *
     * ```js
     *     "permissions": {
     *        "System": {
     *            "openUrlWithBrowser": {
     *                 "enabled": true,
     *                 "protocols": [ "msteams", "slack"]
     *             }
     *        }
     *     }
     * ```
     */
    openUrlWithBrowser(url) {
        return this.wire.sendAction('open-url-with-browser', { url }).then(() => undefined);
    }
    /**
     * Creates a new registry entry under the HKCU root Windows registry key if the given custom protocol name doesn't exist or
     * overwrites the existing registry entry if the given custom protocol name already exists.
     *
     * Note: This method is restricted by default and must be enabled via
     * {@link https://developers.openfin.co/docs/api-security API security settings}. It requires RVM 12 or higher version.
     *
     *
     * @remarks These protocols are reserved and cannot be registered:
     * - fin
     * - fins
     * - openfin
     * - URI Schemes registered with {@link https://en.wikipedia.org/wiki/List_of_URI_schemes#Official_IANA-registered_schemes IANA}
     *
     * @throws if a given custom protocol failed to be registered.
     * @throws if a manifest URL contains the '%1' string.
     * @throws if a manifest URL contains a query string parameter which name equals to the Protocol Launch Request Parameter Name.
     * @throws if the full length of the command string that is to be written to the registry exceeds 2048 bytes.
     *
     * @example
     * ```js
     * fin.System.registerCustomProtocol({protocolName:'protocol1'}).then(console.log).catch(console.error);
     * ```
     */
    async registerCustomProtocol(options) {
        if (typeof options !== 'object') {
            throw new Error('Must provide an object with a `protocolName` property having a string value.');
        }
        await this.wire.sendAction('register-custom-protocol', options);
    }
    /**
     * Removes the registry entry for a given custom protocol.
     *
     * Note: This method is restricted by default and must be enabled via
     * {@link https://developers.openfin.co/docs/api-security API security settings}. It requires RVM 12 or higher version.
     *
     *
     * @remarks These protocols are reserved and cannot be unregistered:
     * - fin
     * - fins
     * - openfin
     * - URI Schemes registered with {@link https://en.wikipedia.org/wiki/List_of_URI_schemes#Official_IANA-registered_schemes IANA}
     *
     * @throws if a protocol entry failed to be removed in registry.
     *
     * @example
     * ```js
     * await fin.System.unregisterCustomProtocol('protocol1');
     * ```
     */
    async unregisterCustomProtocol(protocolName) {
        await this.wire.sendAction('unregister-custom-protocol', { protocolName });
    }
    /**
     * Retrieves the registration state for a given custom protocol.
     *
     * Note: This method is restricted by default and must be enabled via
     * {@link https://developers.openfin.co/docs/api-security API security settings}. It requires RVM 12 or higher version.
     *
     * @remarks These protocols are reserved and cannot get states for them:
     * - fin
     * - fins
     * - openfin
     * - URI Schemes registered with {@link https://en.wikipedia.org/wiki/List_of_URI_schemes#Official_IANA-registered_schemes IANA}
     *
     *
     * @example
     * ```js
     * const protocolState = await fin.System.getCustomProtocolState('protocol1');
     */
    async getCustomProtocolState(protocolName) {
        return this.wire.sendAction('get-custom-protocol-state', { protocolName }).then(({ payload }) => payload.data);
    }
    /**
     * Removes the process entry for the passed UUID obtained from a prior call
     * of fin.System.launchExternalProcess().
     * @param uuid The UUID for a process obtained from a prior call to fin.desktop.System.launchExternalProcess()
     *
     * @example
     * ```js
     * fin.System.launchExternalProcess({
     *     path: "notepad",
     *     listener: function (result) {
     *         console.log("The exit code", result.exitCode);
     *     }
     * })
     * .then(identity => fin.System.releaseExternalProcess(identity.uuid))
     * .then(() => console.log('Process has been unmapped!'))
     * .catch(err => console.log(err));
     * ```
     */
    releaseExternalProcess(uuid) {
        return this.wire.sendAction('release-external-process', { uuid }).then(() => undefined);
    }
    /**
     * Shows the Chromium Developer Tools for the specified window
     * @param identity This is a object that is defined by the Identity interface
     *
     * @tutorial System.showDeveloperTools
     */
    showDeveloperTools(identity) {
        return this.wire.sendAction('show-developer-tools', identity).then(() => undefined);
    }
    /**
     * Attempt to close an external process. The process will be terminated if it
     * has not closed after the elapsed timeout in milliseconds.
     *
     * Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @param options A object defined in the TerminateExternalRequestType interface
     *
     * @example
     * ```js
     * fin.System.launchExternalProcess({
     *     path: "notepad",
     *     listener: function (result) {
     *         console.log("The exit code", result.exitCode);
     *     }
     * })
     * .then(identity => fin.System.terminateExternalProcess({uuid: identity.uuid, timeout:2000, killTree: false}))
     * .then(() => console.log('Terminate the process'))
     * .catch(err => console.log(err));
     * ```
     */
    terminateExternalProcess(options) {
        return this.wire.sendAction('terminate-external-process', options).then(() => undefined);
    }
    /**
     * Update the OpenFin Runtime Proxy settings.
     * @param options A config object defined in the ProxyConfig interface
     *
     * @example
     * ```js
     * fin.System.updateProxySettings({proxyAddress:'127.0.0.1', proxyPort:8080, type:'http'})
     * .then(() => console.log('Update proxy successfully'))
     * .catch(err => console.error(err));
     * ```
     */
    updateProxySettings(options) {
        return this.wire.sendAction('update-proxy', options).then(() => undefined);
    }
    /**
     * Downloads the given application asset.
     *
     * Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @param appAsset App asset object
     *
     * @example
     * ```js
     * async function downloadAsset() {
     *     const appAsset = {
     *         src: `${ location.origin }/assets.zip`,
     *         alias: 'dirApp',
     *         version: '1.23.24',
     *         target: 'assets/run.bat'
     *     };
     *
     *     return fin.System.downloadAsset(appAsset, (progress => {
     *     //Print progress as we download the asset.
     *         const downloadedPercent = Math.floor((progress.downloadedBytes / progress.totalBytes) * 100);
     *         console.log(`Downloaded ${downloadedPercent}%`);
     *     }));
     * }
     *
     * downloadAsset()
     * .then(() => console.log('Success'))
     * .catch(err => console.error(err));
     *
     * ```
     */
    // incompatible with standalone node process.
    async downloadAsset(appAsset, progressListener) {
        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/no-empty-function
        const noop = () => { };
        let resolve = noop;
        let reject = noop;
        const downloadCompletePromise = new Promise((y, n) => {
            resolve = y;
            reject = n;
        });
        // node.js environment not supported
        if (this.wire.environment.type !== 'openfin') {
            throw new transport_errors_1$1.NotSupportedError('downloadAsset only supported in an OpenFin Render process');
        }
        const callSite = transport_errors_1$1.RuntimeError.getCallSite();
        const downloadId = this.wire.environment.getNextMessageId().toString();
        const dlProgressKey = `asset-download-progress-${downloadId}`;
        const dlErrorKey = `asset-download-error-${downloadId}`;
        const dlCompleteKey = `asset-download-complete-${downloadId}`;
        const dlProgress = (progress) => {
            const p = {
                downloadedBytes: progress.downloadedBytes,
                totalBytes: progress.totalBytes
            };
            progressListener(p);
        };
        const cleanListeners = () => {
            // TODO: fix internal types
            // @ts-expect-error
            this.removeListener(dlProgressKey, dlProgress);
        };
        const dlError = (payload) => {
            cleanListeners();
            const { reason, err: error } = payload;
            reject(new transport_errors_1$1.RuntimeError({ reason, error }, callSite));
        };
        const dlComplete = () => {
            cleanListeners();
            resolve();
        };
        await Promise.all([
            // TODO: fix internal types
            // @ts-expect-error
            this.on(dlProgressKey, dlProgress),
            // TODO: fix internal types
            // @ts-expect-error
            this.once(dlErrorKey, dlError),
            // TODO: fix internal types
            // @ts-expect-error
            this.once(dlCompleteKey, dlComplete)
        ]);
        const downloadOptions = Object.assign(appAsset, { downloadId });
        await this.wire.sendAction('download-asset', downloadOptions).catch((err) => {
            cleanListeners();
            throw err;
        });
        return downloadCompletePromise;
    }
    /**
     * Downloads a version of the runtime.
     * @param options - Download options.
     * @param progressListener - called as the runtime is downloaded with progress information.
     *
     * @remarks Only supported in an OpenFin Render process.
     *
     * @example
     * ```js
     * var downloadOptions = {
     *     //Specific version number required, if given a release channel the call will produce an error.
     *     version: '9.61.30.1'
     * };
     *
     * function onProgress(progress) {
     *     console.log(`${Math.floor((progress.downloadedBytes / progress.totalBytes) * 100)}%`);
     * }
     *
     * fin.System.downloadRuntime(downloadOptions, onProgress).then(() => {
     *     console.log('Download complete');
     * }).catch(err =>    {
     *     console.log(`Download Failed, we could retry: ${err.message}`);
     *     console.log(err);
     * });
     * ```
     */
    downloadRuntime(options, progressListener) {
        const callsites = transport_errors_1$1.RuntimeError.getCallSite();
        return new Promise((resolve, reject) => {
            // node.js environment not supported
            if (this.wire.environment.type !== 'openfin') {
                reject(new transport_errors_1$1.NotSupportedError('downloadRuntime only supported in an OpenFin Render process'));
                return;
            }
            const downloadId = this.wire.environment.getNextMessageId().toString();
            const dlProgressKey = `runtime-download-progress-${downloadId}`;
            const dlErrorKey = `runtime-download-error-${downloadId}`;
            const dlCompleteKey = `runtime-download-complete-${downloadId}`;
            const dlProgress = (progress) => {
                const p = {
                    downloadedBytes: progress.downloadedBytes,
                    totalBytes: progress.totalBytes
                };
                progressListener(p);
            };
            const cleanListeners = () => {
                // TODO: fix internal types
                // @ts-expect-error
                this.removeListener(dlProgressKey, dlProgress);
            };
            const dlError = (payload) => {
                cleanListeners();
                const { reason, err: error } = payload;
                reject(new transport_errors_1$1.RuntimeError({ reason, error }, callsites));
            };
            const dlComplete = () => {
                cleanListeners();
                resolve();
            };
            // TODO: fix internal types
            // @ts-expect-error
            this.on(dlProgressKey, dlProgress);
            // TODO: fix internal types
            // @ts-expect-error
            this.once(dlErrorKey, dlError);
            // TODO: fix internal types
            // @ts-expect-error
            this.once(dlCompleteKey, dlComplete);
            const downloadOptions = Object.assign(options, { downloadId });
            this.wire.sendAction('download-runtime', downloadOptions).catch((err) => {
                cleanListeners();
                reject(err);
            });
        });
    }
    /**
     * Download preload scripts from given URLs
     * @param scripts - URLs of preload scripts.
     *
     * @example
     * ```js
     * const scripts = [
     *     { url: 'http://.../preload.js' },
     *     { url: 'http://.../preload2.js' }
     * ];
     *
     * fin.System.downloadPreloadScripts(scripts).then(results => {
     *     results.forEach(({url, success, error}) => {
     *         console.log(`URL: ${url}`);
     *         console.log(`Success: ${success}`);
     *         if (error) {
     *             console.log(`Error: ${error}`);
     *         }
     *     });
     * });
     * ```
     */
    downloadPreloadScripts(scripts) {
        return this.wire.sendAction('download-preload-scripts', { scripts }).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of data (name, ids, bounds) for all application windows.
     *
     * @example
     * ```js
     * fin.System.getAllExternalApplications()
     * .then(externalApps => console.log('Total external apps: ' + externalApps.length))
     * .catch(err => console.log(err));
     * ```
     */
    getAllExternalApplications() {
        return this.wire.sendAction('get-all-external-applications').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves app asset information.
     * @param options
     *
     * @example
     * ```js
     * fin.System.getAppAssetInfo({alias:'procexp'}).then(assetInfo => console.log(assetInfo)).catch(err => console.log(err));
     * ```
     */
    getAppAssetInfo(options) {
        return this.wire.sendAction('get-app-asset-info', options).then(({ payload }) => payload.data);
    }
    /**
     * Get additional info of cookies.
     *
     * @example
     * ```js
     * fin.System.getCookies({name: 'myCookie'}).then(cookies => console.log(cookies)).catch(err => console.log(err));
     * ```
     */
    getCookies(options) {
        const url = this.wire.environment.getUrl();
        const newOptions = Object.assign(options, { url });
        return this.wire.sendAction('get-cookies', newOptions).then(({ payload }) => payload.data);
    }
    /**
     * Set the minimum log level above which logs will be written to the OpenFin log
     * @param The minimum level (inclusive) above which all calls to log will be written
     *
     * @example
     * ```js
     * fin.System.setMinLogLevel("verbose").then(() => console.log("log level is set to verbose")).catch(err => console.log(err));
     * ```
     */
    setMinLogLevel(level) {
        return this.wire.sendAction('set-min-log-level', { level }).then(() => undefined);
    }
    /**
     * Retrieves the UUID of the computer on which the runtime is installed
     * @param uuid The uuid of the running application
     *
     * @example
     * ```js
     * fin.System.resolveUuid('OpenfinPOC').then(entity => console.log(entity)).catch(err => console.log(err));
     * ```
     */
    resolveUuid(uuid) {
        return this.wire
            .sendAction('resolve-uuid', {
            entityKey: uuid
        })
            .then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of data for all external applications
     * @param requestingIdentity This object is described in the Identity typedef
     * @param data Any data type to pass to the method
     *
     * @ignore
     */
    executeOnRemote(requestingIdentity, data) {
        data.requestingIdentity = requestingIdentity;
        return this.wire.ferryAction(data);
    }
    /**
     * Reads the specifed value from the registry.
     * @remarks This method is restricted by default and must be enabled via
     * [API security settings](https://developers.openfin.co/docs/api-security).
     * @param rootKey - The registry root key.
     * @param subkey - The registry key.
     * @param value - The registry value name.
     *
     * @example
     * ```js
     * fin.System.readRegistryValue("HKEY_LOCAL_MACHINE", "HARDWARE\\DESCRIPTION\\System", "BootArchitecture").then(val => console.log(val)).catch(err => console.log(err));
     * ```
     *
     * See {@link https://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx here} for Window's error code definitions.
     *
     * Example payloads of different registry types:
     *
     * See list of types {@link https://msdn.microsoft.com/en-us/library/windows/desktop/ms724884(v=vs.85).aspx here}.
     *
     * ```js
     * // REG_DWORD
     * {
     *     data: 1,
     *     rootKey: "HKEY_LOCAL_MACHINE",
     *     subkey: "Foo\Bar",
     *     type: "REG_DWORD",
     *     value: "Baz"
     * }
     *
     * // REG_QWORD
     * {
     *     data: 13108146671334112,
     *     rootKey: "HKEY_LOCAL_MACHINE",
     *     subkey: "Foo\Bar",
     *     type: "REG_QWORD",
     *     value: "Baz"
     * }
     *
     * // REG_SZ
     * {
     *     data: "FooBarBaz",
     *     rootKey: "HKEY_LOCAL_MACHINE",
     *     subkey: "Foo\Bar",
     *     type: "REG_SZ",
     *     value: "Baz"
     * }
     *
     * // REG_EXPAND_SZ
     * {
     *     data: "C:\User\JohnDoe\AppData\Local",
     *     rootKey: "HKEY_CURRENT_USER",
     *     subkey: "Foo\Bar",
     *     type: "REG_EXPAND_SZ",
     *     value: "Baz"
     * }
     *
     * // REG_MULTI_SZ
     * {
     *     data: [
     *         "Foo",
     *         "Bar",
     *         "Baz"
     *     ],
     *     rootKey: "HKEY_CURRENT_USER",
     *     subkey: "Foo\Bar",
     *     type: "REG_MULTI_SZ",
     *     value: "Baz"
     * }
     *
     * // REG_BINARY
     * {
     *     data: {
     *         data: [
     *             255,
     *             255,
     *             0,
     *             43,
     *             55,
     *             0,
     *             0,
     *             255,
     *             255
     *         ],
     *         type: "Buffer"
     *     },
     *     rootKey: "HKEY_CURRENT_USER",
     *     subkey: "Foo\Bar",
     *     type: "REG_BINARY",
     *     value: "Baz"
     * }
     * ```
     */
    readRegistryValue(rootKey, subkey, value) {
        return this.wire
            .sendAction('read-registry-value', {
            rootKey,
            subkey,
            value
        })
            .then(({ payload }) => payload.data);
    }
    /**
     * This function call will register a unique id and produce a token.
     * The token can be used to broker an external connection.
     * @param uuid - A UUID for the remote connection.
     *
     * @example
     * ```js
     * fin.System.registerExternalConnection("remote-connection-uuid").then(conn => console.log(conn)).catch(err => console.log(err));
     *
     *
     * // object comes back with
     * //     token: "0489EAC5-6404-4F0D-993B-92BB8EAB445D", // this will be unique each time
     * //     uuid: "remote-connection-uuid"
     *
     * ```
     */
    registerExternalConnection(uuid) {
        return this.wire.sendAction('register-external-connection', { uuid }).then(({ payload }) => payload.data);
    }
    /**
     * Returns the json blob found in the [desktop owner settings](https://openfin.co/documentation/desktop-owner-settings/)
     * for the specified service.
     * @param serviceIdentifier An object containing a name key that identifies the service.
     *
     * @remarks More information about desktop services can be found [here](https://developers.openfin.co/docs/desktop-services).
     * This call will reject if the desktop owner settings file is not present, not correctly formatted, or if the service requested is not configured or configured incorrectly.
     *
     * @example
     * ```js
     * // Here we are using the [layouts](https://github.com/HadoukenIO/layouts-service) service.
     * fin.System.getServiceConfiguration({name:'layouts'}).then(console.log).catch(console.error);
     * ```
     */
    async getServiceConfiguration(serviceIdentifier) {
        if (typeof serviceIdentifier.name !== 'string') {
            throw new Error('Must provide an object with a `name` property having a string value');
        }
        const { name } = serviceIdentifier;
        return this.wire.sendAction('get-service-configuration', { name }).then(({ payload }) => payload.data);
    }
    async getSystemAppConfig(name) {
        if (typeof name !== 'string') {
            throw new Error('Must provide a string value for name of system app');
        }
        return this.wire.sendAction('get-system-app-configuration', { name }).then(({ payload }) => payload.data);
    }
    /**
     * Registers a system shutdown handler so user can do some cleanup before system is shutting down.
     * @remarks Once system shutdown starts, you are unable to cancel it.
     * @param handler system shutdown handler
     *
     * @example
     * ```js
     * fin.System.registerShutdownHandler((shutdownEvent) => {
     *         // save state or cleanup
     *         console.log('do some cleanup before shutdown');
     *         // Notify app is ready for termination.
     *         shutdownEvent.proceed();
     * })
     * .then(() => console.log('Shutdown handler registered!'))
     * .catch(err => console.log(err));
     * ```
     * @experimental
     */
    async registerShutdownHandler(handler) {
        this.wire.sendAction('system-register-shutdown-handler').catch((e) => {
            // don't expose, analytics-only call
        });
        const SystemShutdownEventName = 'system-shutdown';
        const SystemShutdownHandledEventName = 'system-shutdown-handled';
        const { uuid, name } = this.wire.me;
        const shutdownHandler = (payload) => {
            const proceed = () => {
                // notify core that the app is ready for shutdown
                this.wire.environment.raiseEvent(`application/${SystemShutdownHandledEventName}`, {
                    uuid,
                    name,
                    topic: 'application'
                });
            };
            handler({ proceed });
        };
        this.on(SystemShutdownEventName, shutdownHandler);
    }
    /**
     * Signals the RVM to perform a health check and returns the results as json.
     *
     * @remarks Requires RVM 5.5+
     *
     * @example
     * ```js
     * try {
     *     const results = await fin.System.runRvmHealthCheck();
     *     console.log(results);
     * } catch(e) {
     *      console.error(e);
     * }
     * ```
     */
    runRvmHealthCheck() {
        return this.wire.sendAction('run-rvm-health-check').then(({ payload }) => payload.data);
    }
    /**
     * Launch application using a manifest URL/path. It differs from Application.startFromManifest in that this API can accept a manifest using the fin protocol.
     * @param manifestUrl - The manifest's URL or path.
     * @param opts - Parameters that the RVM will use.
     *
     * @experimental
     * @remarks Supports protocols http/s and fin/s, and also a local path.
     *
     * Note: This API is Windows only.
     *
     * @example
     *
     * This API can handle most manifest types. Some examples below.
     *
     * Traditional:
     * ```js
     * const manifest = await fin.System.launchManifest(
     *   'https://demoappdirectory.openf.in/desktop/config/apps/OpenFin/HelloOpenFin/app.json');
     * console.log(manifest);
     * ```
     *
     * Platform:
     * ```js
     * const manifest = await fin.System.launchManifest('https://openfin.github.io/platform-api-project-seed/public.json');
     * console.log(manifest);
     * ```
     *
     * Launching traditional manifest into a platform:
     * ```js
     * const manifest = await fin.System.launchManifest(
     *   'https://openfin.github.io/platform-api-project-seed/public.json?\
     *   $$appManifestUrl=https://demoappdirectory.openf.in/desktop/config/\
     *   apps/OpenFin/HelloOpenFin/app.json');
     * console.log(manifest);
     * ```
     *
     * Launching with RVM options:
     * ```js
     * const manifest = await fin.System.launchManifest('https://openfin.github.io/platform-api-project-seed/public.json',
     *     { noUi: true, userAppConfigArgs: { abc: '123', xyz: '789' } });
     * console.log(manifest);
     * ```
     *
     * Local Path:
     * ```js
     * const manifest =  await fin.System.launchManifest('file://c:\\path\\to\\manifest\\file.json');
     * console.log(manifest);
     * ```
     *
     * Launching with RVM 'subscribe' option:
     *
     * This option allows users to subscribe to app version resolver events when
     * calling launchManifest with fallbackManifests specified.
     *
     * ```js
     * fin.System.launchManifest('fins://system-apps/notifications/app.json', { subscribe: (launch) => {
     * 		launch.on('app-version-progress', (progress) => {
     * 			console.log("Trying manifest " + progress.manifest)
     * 		});
     *
     * 		launch.on('runtime-status', (status) => {
     * 			console.log("Runtime status: " + JSON.stringify(status));
     * 		});
     *
     * 		// RVM has successfully found the target runtime version
     * 		launch.on('app-version-complete', (complete) => {
     * 			console.log("Parent app " + complete.srcManifest + " resolved to " + complete.manifest);
     * 			launch.removeAllListeners();
     * 		});
     *
     * 		// RVM failed to find an available runtime version
     * 		launch.on('app-version-error', (error) => {
     * 			console.log("Failed to resolve " + error.srcManifest + " from the fallbackManifests");
     * 			launch.removeAllListeners();
     * 		});
     * 	}
     * });
     * ```
     */
    async launchManifest(manifestUrl, opts = {}) {
        const { subscribe, ..._sendOpts } = opts;
        const sendOpts = _sendOpts;
        if (subscribe) {
            const launchEmitter = new events_1$6.EventEmitter();
            subscribe(launchEmitter);
            const AppVersionProgressEventName = 'app-version-progress';
            const RuntimeStatusEventName = 'runtime-status';
            const AppVersionCompleteEventName = 'app-version-complete';
            const AppVersionErrorEventName = 'app-version-error';
            // add id to avoid multiple api calls getting duplicated events
            const id = this.wire.environment.getNextMessageId().toString();
            sendOpts.appVersionId = id;
            const supportedEvents = [
                AppVersionCompleteEventName,
                AppVersionProgressEventName,
                RuntimeStatusEventName,
                AppVersionErrorEventName
            ];
            const cleanEventPayload = (payload) => {
                // We need to do type castings below to make sure the return type is correct.
                const { appVersionId, topic, type: typeWithId, ...rest } = payload;
                const type = supportedEvents.find((x) => typeWithId.includes(x));
                return {
                    ...rest,
                    type
                };
            };
            const appVersionListener = (payload) => {
                const cleanPayload = cleanEventPayload(payload);
                launchEmitter.emit(cleanPayload.type, cleanPayload);
            };
            const removeAllListeners = () => {
                this.removeListener(`${AppVersionProgressEventName}.${id}`, appVersionListener);
                this.removeListener(`${RuntimeStatusEventName}.${id}`, appVersionListener);
                this.removeListener(`${AppVersionCompleteEventName}.${id}`, appVersionListener);
                this.removeListener(`${AppVersionErrorEventName}.${id}`, appVersionListener);
                this.removeListener(`${AppVersionCompleteEventName}.${id}`, removeAllListeners);
                this.removeListener(`${AppVersionErrorEventName}.${id}`, removeAllListeners);
            };
            await Promise.all([
                this.on(`${AppVersionProgressEventName}.${id}`, appVersionListener),
                this.on(`${RuntimeStatusEventName}.${id}`, appVersionListener),
                this.once(`${AppVersionCompleteEventName}.${id}`, appVersionListener),
                this.once(`${AppVersionErrorEventName}.${id}`, appVersionListener),
                this.once(`${AppVersionCompleteEventName}.${id}`, removeAllListeners),
                this.once(`${AppVersionErrorEventName}.${id}`, removeAllListeners)
            ]);
        }
        const response = await this.wire.sendAction('launch-manifest', {
            manifestUrl,
            opts: sendOpts
        });
        return response.payload.data.manifest;
    }
    /**
     * Query permission of a secured api in current context.
     * @param apiName - The full name of a secured API.
     *
     * @example
     * ```js
     * fin.System.queryPermissionForCurrentContext('System.launchExternalProcess').then(result => console.log(result)).catch(err => console.log(err));
     *
     * //This response has the following shape:
     * {
     *    permission: 'System.launchExternalProcess', // api full name
     *    state: 'granted', // state of permission
     *    granted: true
     * }
     * ```
     */
    async queryPermissionForCurrentContext(apiName) {
        const identity = { uuid: this.wire.me.uuid, name: this.wire.me.name };
        const response = await this.wire.sendAction('query-permission-for-current-context', {
            apiName,
            identity
        });
        return response.payload.data;
    }
    // Not documenting, internal use only.
    async enableNativeWindowIntegrationProvider(permissions) {
        const { payload } = await this.wire.sendAction('enable-native-window-integration-provider', { permissions });
        return payload.data;
    }
    /**
     * (Internal) Register the usage of a component with a platform
     * @param options - Object with data and type
     *
     * @example
     * ```js
     * async function registerUsage() {
     *     const app = await fin.System.getCurrent();
     *     return await fin.System.registerUsage({
     *         type: 'workspace-licensing',
     *         // example values for the following data object
     *         data: {
     *             apiVersion: '1.0',
     *             componentName: 'home',
     *             componentVersion: '1.0',
     *             allowed: true,
     *             rejectionCode: ''
     *         }
     *     });
     * }
     *
     * registerUsage().then(() => console.log('Successfully registered component application')).catch(err => console.log(err));
     * ```
     */
    async registerUsage({ data, type }) {
        await this.wire.sendAction('register-usage', { data, type });
    }
    /**
     * Returns an array with all printers of the caller and not all the printers on the desktop.
     *
     * @example
     * ```js
     * fin.System.getPrinters()
     *     .then((printers) => {
     *         printers.forEach((printer) => {
     *             if (printer.isDefault) {
     *                 console.log(printer);
     *             }
     *         });
     *     })
     *     .catch((err) => {
     *         console.log(err);
     *     });
     * ```
     */
    async getPrinters() {
        const { payload } = await this.wire.sendAction('system-get-printers');
        return payload.data;
    }
    /**
     * Updates Process Logging values: periodic interval and outlier detection entries and interval.
     * @param options Process Logging updatable options.
     *
     * @remarks When enabling verbose mode, additional process information is logged to the debug.log:
     *
     * 1. Periodically process usage (memory, cpu, etc) will be logged for each PID along with the windows, views and
     * iframes that belong to them. The default is every 30 seconds. Updatable by passing the interval option.
     * 2. When Windows and Views are created or navigated the PID they belong to and their options will be logged.
     * 3. When Windows and Views are destroyed their last known process usage will be logged.
     * 4. Whenever an outlier memory usage is detected it will be logged. By default, on an interval of 5 seconds we will
     * collect process usage for all PIDs and when 144 such entries are collected, we will start analyzing the data for any
     * possible outliers in the following entries. The interval and maximum number of entries stored in the running buffer
     * can be updatable by passing the outlierDetection.interval and outlierDetection.entries options.
     *
     * @example
     *
     * ```js
     * await fin.System.updateProcessLoggingOptions({
     *     interval: 10,
     *     outlierDetection: {
     *         interval: 15,
     *         entries: 200
     *     }
     * });
     * ```
     */
    async updateProcessLoggingOptions(options) {
        await this.wire.sendAction('system-update-process-logging-options', { options });
    }
    /**
     * Returns domain settings for the current application.
     * Initial settings are configured with the defaultDomainSettings application option via manifest.
     * Domain settings can be overwritten during runtime with System.setDomainSettings.
     * @example
     * ```js
     * const domainSettings = await fin.System.getDomainSettings();
     * // {
     * //     "rules": [
     * //         {
     * //             "match": [
     * //                 "https://openfin.co"
     * //             ],
     * //             "options": {
     * //                 "downloadSettings": {
     * //                     "rules": [
     * //                         {
     * //                             "match": [
     * //                                 "<all_urls>"
     * //                             ],
     * //                             "behavior": "prompt"
     * //                         }
     * //                     ]
     * //                 }
     * //             }
     * //         }
     * //     ]
     * // }
     * ```
     */
    async getDomainSettings() {
        const { payload: { data } } = await this.wire.sendAction('get-domain-settings', this.identity);
        return data;
    }
    /**
     * Sets the domain settings for the current application.
     * @param domainSettings - domain settings object
     * @example
     * ```js
     * const domainSettings = await fin.System.getDomainSettings();
     * // {
     * //     "rules": [
     * //         {
     * //             "match": [
     * //                 "https://openfin.co"
     * //             ],
     * //             "options": {
     * //                 "downloadSettings": {
     * //                     "rules": [
     * //                         {
     * //                             "match": [
     * //                                 "<all_urls>"
     * //                             ],
     * //                             "behavior": "prompt"
     * //                         }
     * //                     ]
     * //                 }
     * //             }
     * //         }
     * //     ]
     * // }
     *
     * // Valid rule behaviors are 'prompt' and 'no-prompt'
     * domainSettings.rules[0].options.downloadSettings.rules[0].behavior = 'no-prompt';
     *
     * await fin.System.setDomainSettings(domainSettings);
     *
     * const newDomainSettings = await fin.System.getDomainSettings();
     * // {
     * //     "rules": [
     * //         {
     * //             "match": [
     * //                 "https://openfin.co"
     * //             ],
     * //             "options": {
     * //                 "downloadSettings": {
     * //                     "rules": [
     * //                         {
     * //                             "match": [
     * //                                 "<all_urls>"
     * //                             ],
     * //                             "behavior": "no-prompt"
     * //                         }
     * //                     ]
     * //                 }
     * //             }
     * //         }
     * //     ]
     * // }
     * ```
     */
    async setDomainSettings(domainSettings) {
        await this.wire.sendAction('set-domain-settings', { domainSettings, ...this.identity });
    }
}
system.System = System;

var interappbus = {};

var refCounter = {};

Object.defineProperty(refCounter, "__esModule", { value: true });
refCounter.RefCounter = void 0;
class RefCounter {
    constructor() {
        this.topicRefMap = new Map();
    }
    // returns the ref count after incrementing
    incRefCount(key) {
        const refCount = this.topicRefMap.get(key);
        let returnCount;
        if (!refCount) {
            this.topicRefMap.set(key, 1);
            returnCount = 1;
        }
        else {
            const newRefCount = refCount + 1;
            returnCount = newRefCount;
            this.topicRefMap.set(key, newRefCount);
        }
        return returnCount;
    }
    // returns the ref count after decrementing, or -1 if the key already had no references
    decRefCount(key) {
        const refCount = this.topicRefMap.get(key);
        let returnCount;
        if (refCount) {
            const newRefCount = refCount - 1;
            this.topicRefMap.set(key, newRefCount);
            returnCount = newRefCount;
        }
        else {
            returnCount = -1;
        }
        return returnCount;
    }
    // Execute firstAction if it is the first such ref, else execute nonFirstAction.
    // In either case the return value is that of the action executed
    actOnFirst(key, firstAction, nonFirstAction) {
        const numRefs = this.incRefCount(key);
        const isFirstRef = numRefs === 1;
        return isFirstRef ? firstAction() : nonFirstAction();
    }
    // Execute lastAction if it is the first such ref, else execute nonLastAction.
    // In either case the return value is that of the action executed
    actOnLast(key, lastAction, nonLastAction) {
        const numRefs = this.decRefCount(key);
        const isLastRef = numRefs === 0;
        return isLastRef ? lastAction() : nonLastAction();
    }
}
refCounter.RefCounter = RefCounter;

var channel$1 = {};

var client = {};

var channel = {};

Object.defineProperty(channel, "__esModule", { value: true });
channel.ChannelBase = channel.ProtectedItems = void 0;
const resultOrPayload = (func) => async (topic, payload, senderIdentity) => {
    const res = await func(topic, payload, senderIdentity);
    return res === undefined ? payload : res;
};
class ProtectedItems {
    /**
     * @internal
     */
    constructor(providerIdentity, wire) {
        this.providerIdentity = providerIdentity;
        this.wire = wire;
    }
}
channel.ProtectedItems = ProtectedItems;
class ChannelBase {
    static defaultAction(topic) {
        throw new Error(`No action registered at target for ${topic}`);
    }
    constructor() {
        this.subscriptions = new Map();
    }
    async processAction(topic, payload, senderIdentity) {
        try {
            const mainAction = this.subscriptions.has(topic)
                ? this.subscriptions.get(topic)
                : (currentPayload, id) => (this.defaultAction ?? ChannelBase.defaultAction)(topic, currentPayload, id);
            const preActionProcessed = this.preAction ? await this.preAction(topic, payload, senderIdentity) : payload;
            const actionProcessed = await mainAction(preActionProcessed, senderIdentity);
            return this.postAction ? await this.postAction(topic, actionProcessed, senderIdentity) : actionProcessed;
        }
        catch (e) {
            if (this.errorMiddleware) {
                return this.errorMiddleware(topic, e, senderIdentity);
            }
            throw e;
        }
    }
    /**
     * Register middleware that fires before the action.
     *
     * @param func
     *
     * @example
     *
     * Channel Provider:
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     provider.register('provider-action', (payload, identity) => {
     *         console.log(payload, identity);
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     provider.beforeAction((action, payload, identity) => {
     *         //The payload can be altered here before handling the action.
     *         payload.received = Date.now();
     *         return payload;
     *     });
     *
     * })();
     * ```
     *
     * Channel Client:
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     client.register('client-action', (payload, identity) => {
     *         console.log(payload, identity);
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     client.beforeAction((action, payload, identity) => {
     *         //The payload can be altered here before handling the action.
     *         payload.received = Date.now();
     *         return payload;
     *     });
     *
     *     const providerResponse = await client.dispatch('provider-action', { message: 'Hello From the client' });
     *     console.log(providerResponse);
     * })();
     * ```
     */
    beforeAction(func) {
        if (this.preAction) {
            throw new Error('Already registered beforeAction middleware');
        }
        this.preAction = resultOrPayload(func);
    }
    /**
     * Register an error handler. This is called before responding on any error.
     *
     * @param func
     *
     * Channel Provider:
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     provider.register('provider-action', (payload, identity) => {
     *         console.log(payload);
     *         throw new Error('Action error');
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     provider.onError((action, error, identity) => {
     *         console.log('uncaught Exception in action:', action);
     *         console.error(error);
     *     });
     *
     * })();
     * ```
     *
     * Channel Client:
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     client.register('client-action', (payload, identity) => {
     *         console.log(payload);
     *         throw new Error('Action error');
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     client.onError((action, error, identity) => {
     *         console.log('uncaught Exception in action:', action);
     *         console.error(error);
     *     });
     * })();
     * ```
     */
    onError(func) {
        if (this.errorMiddleware) {
            throw new Error('Already registered error middleware');
        }
        this.errorMiddleware = func;
    }
    /**
     * Register middleware that fires after the action.
     *
     * @param func
     *
     * @remarks If the action does not return the payload, then the afterAction will not have access to the payload object.
     *
     * @example
     *
     * Channel Provider:
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.register('provider-action', (payload, identity) => {
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     await provider.afterAction((action, payload, identity) => {
     *         //the payload can be altered here after handling the action but before sending an acknowledgement.
     *         payload.sent = date.now();
     *         return payload;
     *     });
     *
     * })();
     * ```
     *
     * Channel Client:
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     await client.register('client-action', (payload, identity) => {
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     await client.afterAction((action, payload, identity) => {
     *         //the payload can be altered here after handling the action but before sending an acknowledgement.
     *         payload.sent = date.now();
     *         return payload;
     *     });
     *
     * })();
     * ```
     */
    afterAction(func) {
        if (this.postAction) {
            throw new Error('Already registered afterAction middleware');
        }
        this.postAction = resultOrPayload(func);
    }
    /**
     * Remove an action by action name.
     *
     * @param action
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.register('provider-action', (payload, identity) => {
     *         console.log(payload);
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     await provider.remove('provider-action');
     *
     * })();
     * ```
     */
    remove(action) {
        this.subscriptions.delete(action);
    }
    /**
     * Registers a default action. This is used any time an action that has not been registered is invoked.
     *
     * @example
     *
     * Channel Provider:
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.setDefaultAction((action, payload, identity) => {
     *         console.log(`Client with identity ${JSON.stringify(identity)} has attempted to dispatch unregistered action: ${action}.`);
     *
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     * })();
     * ```
     *
     * Channel Client:
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     await client.setDefaultAction((action, payload, identity) => {
     *         console.log(`Provider with identity ${JSON.stringify(identity)} has attempted to dispatch unregistered action: ${action}.`);
     *
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     * })();
     * ```
     * @param func
     */
    setDefaultAction(func) {
        if (this.defaultAction) {
            throw new Error('default action can only be set once');
        }
        else {
            this.defaultAction = func;
        }
    }
    /**
     * Register an action to be called by dispatching from any channelClient or channelProvider.
     *
     * @param topic
     * @param listener
     *
     * @remarks The return value will be sent back as an acknowledgement to the original caller. You can throw an
     * error to send a negative-acknowledgement and the error will reject the promise returned to the sender by the
     * dispatch call.  Once a listener is registered for a particular action, it stays in place receiving and responding
     * to incoming messages until it is removed.  This messaging mechanism works exactly the same when messages are
     * dispatched from the provider to a client.  However, the provider has an additional publish method that sends messages
     * to all connected clients.
     *
     * Because multiple clients can share the same `name` and `uuid`, in order to distinguish between individual clients,
     * the `identity` argument in a provider's registered action callback contains an `endpointId` property. When dispatching
     * from a provider to a client, the `endpointId` property must be provided in order to send an action to a specific client.
     *
     * @example
     *
     * Channel Provider:
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.register('provider-action', (payload, identity) => {
     *        console.log('Action dispatched by client: ', identity);
     *        console.log('Payload sent in dispatch: ', payload);
     *
     *        return { echo: payload };
     *    });
     * })();
     * ```
     *
     * Channel Client:
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     await client.register('client-action', (payload, identity) => {
     *        console.log('Action dispatched by client: ', identity);
     *        console.log('Payload sent in dispatch: ', payload);
     *
     *        return { echo: payload };
     *    });
     * })();
     * ```
     */
    register(topic, listener) {
        if (this.subscriptions.has(topic)) {
            throw new Error(`Subscription already registered for action: ${topic}. Unsubscribe before adding new subscription`);
        }
        else {
            this.subscriptions.set(topic, listener);
            return true;
        }
    }
}
channel.ChannelBase = ChannelBase;

var __classPrivateFieldGet$d = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$b = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ChannelClient_protectedObj, _ChannelClient_strategy, _ChannelClient_close;
Object.defineProperty(client, "__esModule", { value: true });
client.ChannelClient = void 0;
const channel_1$1 = channel;
const channelClientsByEndpointId = new Map();
/**
 * Instance created to enable use of a channel as a client.  Allows for communication with the
 * {@link ChannelProvider ChannelProvider} by invoking an action on the
 * provider via {@link ChannelClient#dispatch dispatch} and to listen for communication
 * from the provider by registering an action via {@link ChannelClient#register register}.
 *
 * ### Synchronous Methods:
 *  * {@link ChannelClient#onDisconnection onDisconnection(listener)}
 *  * {@link ChannelClient#register register(action, listener)}
 *  * {@link ChannelClient#remove remove(action)}
 *
 * ### Asynchronous Methods:
 *  * {@link ChannelClient#disconnect disconnect()}
 *  * {@link ChannelClient#dispatch dispatch(action, payload)}
 *
 * ### Middleware:
 * Middleware functions receive the following arguments: (action, payload, senderId).
 * The return value of the middleware function will be passed on as the payload from beforeAction, to the action listener, to afterAction
 * unless it is undefined, in which case the original payload is used.  Middleware can be used for side effects.
 *  * {@link ChannelClient#setDefaultAction setDefaultAction(middleware)}
 *  * {@link ChannelClient#onError onError(middleware)}
 *  * {@link ChannelClient#beforeAction beforeAction(middleware)}
 *  * {@link ChannelClient#afterAction afterAction(middleware)}
 */
class ChannelClient extends channel_1$1.ChannelBase {
    /**
     * @internal
     */
    static closeChannelByEndpointId(id) {
        const channel = channelClientsByEndpointId.get(id);
        if (channel) {
            __classPrivateFieldGet$d(channel, _ChannelClient_close, "f").call(channel);
        }
    }
    /**
     * @internal
     * closes the corresponding channel and invokes the disconnect listener if an event payload is passed.
     */
    static handleProviderDisconnect(eventPayload) {
        for (const channelClient of channelClientsByEndpointId.values()) {
            if (channelClient.providerIdentity.channelId === eventPayload.channelId) {
                channelClient.disconnectListener(eventPayload);
                __classPrivateFieldGet$d(channelClient, _ChannelClient_close, "f").call(channelClient);
            }
        }
    }
    /**
     * @internal
     */
    constructor(routingInfo, wire, strategy) {
        super();
        _ChannelClient_protectedObj.set(this, void 0);
        _ChannelClient_strategy.set(this, void 0);
        // needs to be bound;
        this.processAction = (action, payload, senderIdentity) => super.processAction(action, payload, senderIdentity);
        _ChannelClient_close.set(this, () => {
            channelClientsByEndpointId.delete(this.endpointId);
            __classPrivateFieldGet$d(this, _ChannelClient_strategy, "f").close();
        });
        __classPrivateFieldSet$b(this, _ChannelClient_protectedObj, new channel_1$1.ProtectedItems(routingInfo, wire), "f");
        this.disconnectListener = () => undefined;
        this.endpointId = routingInfo.endpointId;
        __classPrivateFieldSet$b(this, _ChannelClient_strategy, strategy, "f");
        channelClientsByEndpointId.set(this.endpointId, this);
        strategy.receive(this.processAction);
    }
    /**
     * a read-only provider identity
     */
    get providerIdentity() {
        const protectedObj = __classPrivateFieldGet$d(this, _ChannelClient_protectedObj, "f");
        return protectedObj.providerIdentity;
    }
    /**
     * Dispatch the given action to the channel provider. Returns a promise that resolves with the response from
     * the provider for that action.
     *
     * @param action
     * @param payload
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     await client.register('client-action', (payload, identity) => {
     *         console.log(payload, identity);
     *         return {
     *             echo: payload
     *         };
     *     });
     *
     *     const providerResponse = await client.dispatch('provider-action', { message: 'Hello From the client'});
     *     console.log(providerResponse);
     * })();
     * ```
     */
    async dispatch(action, payload) {
        if (__classPrivateFieldGet$d(this, _ChannelClient_strategy, "f").isEndpointConnected(this.providerIdentity.channelId)) {
            return __classPrivateFieldGet$d(this, _ChannelClient_strategy, "f").send(this.providerIdentity.channelId, action, payload);
        }
        throw new Error('The client you are trying to dispatch from is disconnected from the target provider.');
    }
    /**
     * Register a listener that is called on provider disconnection. It is passed the disconnection event of the
     * disconnecting provider.
     *
     * @param listener
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     await client.onDisconnection(evt => {
     *         console.log('Provider disconnected', `uuid: ${evt.uuid}, name: ${evt.name}`);
     *     });
     * })();
     * ```
     */
    onDisconnection(listener) {
        this.disconnectListener = (payload) => {
            try {
                listener(payload);
            }
            catch (err) {
                throw new Error(`Error while calling the onDisconnection callback: ${err.message}`);
            }
            finally {
                this.disconnectListener = () => undefined;
            }
        };
    }
    /**
     * Disconnects the client from the channel.
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *     const client = await fin.InterApplicationBus.Channel.connect('channelName');
     *
     *     await client.disconnect();
     * })();
     * ```
     */
    async disconnect() {
        await this.sendDisconnectAction();
        __classPrivateFieldGet$d(this, _ChannelClient_close, "f").call(this);
    }
    async sendDisconnectAction() {
        const protectedObj = __classPrivateFieldGet$d(this, _ChannelClient_protectedObj, "f");
        const { channelName, uuid, name } = protectedObj.providerIdentity;
        await protectedObj.wire.sendAction('disconnect-from-channel', {
            channelName,
            uuid,
            name,
            endpointId: this.endpointId
        });
    }
}
client.ChannelClient = ChannelClient;
_ChannelClient_protectedObj = new WeakMap(), _ChannelClient_strategy = new WeakMap(), _ChannelClient_close = new WeakMap();

var connectionManager = {};

var exhaustive = {};

Object.defineProperty(exhaustive, "__esModule", { value: true });
exhaustive.exhaustiveCheck = void 0;
function exhaustiveCheck(value, allowed) {
    throw new Error(`Unsupported value: ${value}${allowed ? `\n Supported values are: ${allowed.join('')}` : ''}`);
}
exhaustive.exhaustiveCheck = exhaustiveCheck;

var strategy$2 = {};

var __classPrivateFieldSet$a = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$c = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ClassicStrategy_wire, _ClassicStrategy_endpointIdentityMap, _ClassicStrategy_pendingMessagesByEndpointId;
Object.defineProperty(strategy$2, "__esModule", { value: true });
strategy$2.ClassicInfo = strategy$2.ClassicStrategy = void 0;
/*
This is used to abstract out ipc messaging from the channels implementation. It is only concerned with sending messages and registration with the MessageReceiver
*/
class ClassicStrategy {
    constructor(wire, messageReceiver, endpointId, // Provider endpointId is channelId
    providerIdentity) {
        this.messageReceiver = messageReceiver;
        this.endpointId = endpointId;
        this.providerIdentity = providerIdentity;
        _ClassicStrategy_wire.set(this, void 0);
        // Store full endpointIdentity by endpointId of all known endpoints for this strategy instance.
        // (clients will only have 1: the provider, the provider will have all clients)
        _ClassicStrategy_endpointIdentityMap.set(this, new Map());
        // Store a set of cancellable promises to be able to reject them when client
        // connection problems occur
        _ClassicStrategy_pendingMessagesByEndpointId.set(this, new Map);
        this.send = async (endpointId, action, payload) => {
            const to = __classPrivateFieldGet$c(this, _ClassicStrategy_endpointIdentityMap, "f").get(endpointId);
            if (!to) {
                throw new Error(`Could not locate routing info for endpoint ${endpointId}`);
            }
            // as casting to any because typescript complains. The following is only relevant if this is a locally set endpointId on a ClientIdentity.
            // We delete these properties to not change backwards compatibility.
            const cleanId = { ...to };
            if (cleanId.isLocalEndpointId) {
                delete cleanId.endpointId;
            }
            delete cleanId.isLocalEndpointId;
            // grab the promise before awaiting it to save in our pending messages map
            const p = __classPrivateFieldGet$c(this, _ClassicStrategy_wire, "f")
                .sendAction('send-channel-message', {
                ...cleanId,
                providerIdentity: this.providerIdentity,
                action,
                payload
            });
            __classPrivateFieldGet$c(this, _ClassicStrategy_pendingMessagesByEndpointId, "f").get(endpointId)?.add(p);
            const raw = await p.catch((error) => {
                throw new Error(error.message);
            }).finally(() => {
                // clean up the pending promise
                __classPrivateFieldGet$c(this, _ClassicStrategy_pendingMessagesByEndpointId, "f").get(endpointId)?.delete(p);
            });
            return raw.payload.data.result;
        };
        this.close = async () => {
            this.messageReceiver.removeEndpoint(this.providerIdentity.channelId, this.endpointId);
            [...__classPrivateFieldGet$c(this, _ClassicStrategy_endpointIdentityMap, "f").keys()].forEach((id) => this.closeEndpoint(id));
            __classPrivateFieldSet$a(this, _ClassicStrategy_endpointIdentityMap, new Map(), "f");
        };
        __classPrivateFieldSet$a(this, _ClassicStrategy_wire, wire, "f");
    }
    onEndpointDisconnect(endpointId, listener) {
        // Never fires for 'classic'.
    }
    receive(listener) {
        this.messageReceiver.addEndpoint(listener, this.providerIdentity.channelId, this.endpointId);
    }
    async closeEndpoint(endpointId) {
        const id = __classPrivateFieldGet$c(this, _ClassicStrategy_endpointIdentityMap, "f").get(endpointId);
        __classPrivateFieldGet$c(this, _ClassicStrategy_endpointIdentityMap, "f").delete(endpointId);
        const pendingSet = __classPrivateFieldGet$c(this, _ClassicStrategy_pendingMessagesByEndpointId, "f").get(endpointId);
        pendingSet?.forEach((p) => {
            const errorMsg = `Channel connection with identity uuid: ${id?.uuid} / name: ${id?.name} / endpointId: ${endpointId} no longer connected.`;
            p.cancel(new Error(errorMsg));
        });
    }
    isEndpointConnected(endpointId) {
        return __classPrivateFieldGet$c(this, _ClassicStrategy_endpointIdentityMap, "f").has(endpointId);
    }
    addEndpoint(endpointId, payload) {
        __classPrivateFieldGet$c(this, _ClassicStrategy_endpointIdentityMap, "f").set(endpointId, payload.endpointIdentity);
        __classPrivateFieldGet$c(this, _ClassicStrategy_pendingMessagesByEndpointId, "f").set(endpointId, new Set());
    }
    isValidEndpointPayload(payload) {
        return (typeof payload?.endpointIdentity?.endpointId === 'string' ||
            typeof payload?.endpointIdentity?.channelId === 'string');
    }
}
strategy$2.ClassicStrategy = ClassicStrategy;
_ClassicStrategy_wire = new WeakMap(), _ClassicStrategy_endpointIdentityMap = new WeakMap(), _ClassicStrategy_pendingMessagesByEndpointId = new WeakMap();
// Arbitrarily starting at 5 to leave the door open to backfilling pre endpointId etc.
strategy$2.ClassicInfo = { version: 5, minimumVersion: 0, type: 'classic' };

var strategy$1 = {};

var endpoint = {};

var errors = {};

Object.defineProperty(errors, "__esModule", { value: true });
errors.errorToPOJO = void 0;
function errorToPOJO(error) {
    return {
        stack: error.stack,
        name: error.name,
        message: error.message,
        // support the case where stack is empty or missing
        toString: () => error.stack || error.toString()
    };
}
errors.errorToPOJO = errorToPOJO;

var __classPrivateFieldGet$b = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$9 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _RTCEndpoint_processAction, _RTCEndpoint_disconnectListener;
Object.defineProperty(endpoint, "__esModule", { value: true });
endpoint.RTCEndpoint = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const errors_1$1 = errors;
/*
This handles sending RTC messages between RTC connections over the request and response data channels.
*/
class RTCEndpoint {
    constructor(rtc, endpointIdentity) {
        this.rtc = rtc;
        this.endpointIdentity = endpointIdentity;
        this.responseMap = new Map();
        _RTCEndpoint_processAction.set(this, null);
        _RTCEndpoint_disconnectListener.set(this, void 0);
        this.connectionStateChangeHandler = (event) => {
            if (this.rtc.rtcClient.connectionState !== 'connected') {
                this.rtc.rtcClient.removeEventListener('connectionstatechange', this.connectionStateChangeHandler);
                this.close();
                if (__classPrivateFieldGet$b(this, _RTCEndpoint_disconnectListener, "f")) {
                    __classPrivateFieldGet$b(this, _RTCEndpoint_disconnectListener, "f").call(this);
                }
            }
        };
        this.send = async (action, payload) => {
            const messageId = `message-${Math.random()}`;
            const promise = new Promise((resolve, reject) => {
                this.responseMap.set(messageId, { resolve, reject });
            });
            this.rtc.channels.request.send(JSON.stringify({ action, payload, messageId }));
            return promise;
        };
        this.close = () => {
            this.responseMap.forEach((response) => response.reject('Connection has closed.'));
            this.responseMap = new Map();
            this.rtc.channels.request.close();
            this.rtc.channels.response.close();
            this.rtc.rtcClient.close();
        };
        this.rtc.channels.response.addEventListener('message', (e) => {
            let { data } = e;
            if (e.data instanceof ArrayBuffer) {
                data = new TextDecoder().decode(e.data);
            }
            const { messageId, payload, success, error } = JSON.parse(data);
            const { resolve, reject } = this.responseMap.get(messageId) ?? {};
            if (resolve && reject) {
                this.responseMap.delete(messageId);
                if (success) {
                    resolve(payload);
                }
                else {
                    reject(error);
                }
            }
            else {
                console.log('Could not find id in responseMap.');
                console.log(e);
            }
        });
        this.rtc.channels.request.addEventListener('message', async (e) => {
            let { data } = e;
            if (e.data instanceof ArrayBuffer) {
                data = new TextDecoder().decode(e.data);
            }
            const { messageId, action, payload } = JSON.parse(data);
            if (__classPrivateFieldGet$b(this, _RTCEndpoint_processAction, "f")) {
                try {
                    const res = await __classPrivateFieldGet$b(this, _RTCEndpoint_processAction, "f").call(this, action, payload, endpointIdentity);
                    this.rtc.channels.response.send(JSON.stringify({
                        messageId,
                        payload: res,
                        success: true
                    }));
                }
                catch (error) {
                    // Check if RTCDataChannel is open before sending, error gets swallowed here in the case where
                    // client dispatched then closed or disconnected before the dispatch resolves.
                    if (this.rtc.channels.response.readyState === 'open') {
                        this.rtc.channels.response.send(JSON.stringify({
                            messageId,
                            error: (0, errors_1$1.errorToPOJO)(error),
                            success: false
                        }));
                    }
                }
                // Check if RTCDataChannel is open for same reason as catch block above.
            }
            else if (this.rtc.channels.response.readyState === 'open') {
                this.rtc.channels.response.send(JSON.stringify({
                    messageId,
                    success: false,
                    error: 'Connection not ready.'
                }));
            }
        });
        this.rtc.rtcClient.addEventListener('connectionstatechange', this.connectionStateChangeHandler);
        // Disconnect if data channels close unexpectedly, e.g. can happen due to message size > ~255kB (RTCPeerConnection.sctp.maxMessageSizeLimit: 262144)
        Object.values(this.rtc.channels).forEach((datachannel) => {
            datachannel.onclose = (e) => {
                [...this.responseMap.values()].forEach((promise) => promise.reject(new Error('RTCDataChannel closed unexpectedly, this is most commonly caused by message size. Note: RTC Channels have a message size limit of ~255kB.')));
                this.close();
                if (__classPrivateFieldGet$b(this, _RTCEndpoint_disconnectListener, "f")) {
                    __classPrivateFieldGet$b(this, _RTCEndpoint_disconnectListener, "f").call(this);
                }
            };
        });
    }
    onDisconnect(listener) {
        if (!__classPrivateFieldGet$b(this, _RTCEndpoint_disconnectListener, "f")) {
            __classPrivateFieldSet$9(this, _RTCEndpoint_disconnectListener, listener, "f");
        }
        else {
            throw new Error('RTCEndpoint disconnectListener cannot be set twice.');
        }
    }
    receive(listener) {
        if (__classPrivateFieldGet$b(this, _RTCEndpoint_processAction, "f")) {
            throw new Error('You have already set a listener for this RTC Endpoint.');
        }
        __classPrivateFieldSet$9(this, _RTCEndpoint_processAction, listener, "f");
    }
    get connected() {
        return this.rtc.rtcClient.connectionState === 'connected';
    }
}
endpoint.RTCEndpoint = RTCEndpoint;
_RTCEndpoint_processAction = new WeakMap(), _RTCEndpoint_disconnectListener = new WeakMap();

var __classPrivateFieldGet$a = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$8 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _RTCStrategy_processAction, _RTCStrategy_rtcEndpointMap, _RTCStrategy_connected;
Object.defineProperty(strategy$1, "__esModule", { value: true });
strategy$1.RTCInfo = strategy$1.RTCStrategy = void 0;
const endpoint_1 = endpoint;
/*
This is used to abstract out rtc messaging from the channels implementation using RTCEndpoints.
*/
class RTCStrategy {
    constructor() {
        _RTCStrategy_processAction.set(this, null);
        _RTCStrategy_rtcEndpointMap.set(this, new Map());
        _RTCStrategy_connected.set(this, true);
        this.send = async (endpointId, action, payload) => {
            return this.getEndpointById(endpointId).send(action, payload);
        };
        this.close = async () => {
            if (__classPrivateFieldGet$a(this, _RTCStrategy_connected, "f")) {
                __classPrivateFieldGet$a(this, _RTCStrategy_rtcEndpointMap, "f").forEach((rtcEndpoint) => rtcEndpoint.close());
                __classPrivateFieldSet$8(this, _RTCStrategy_rtcEndpointMap, new Map(), "f");
            }
            __classPrivateFieldSet$8(this, _RTCStrategy_connected, false, "f");
        };
    }
    onEndpointDisconnect(endpointId, listener) {
        this.getEndpointById(endpointId).onDisconnect(listener);
    }
    receive(listener) {
        if (__classPrivateFieldGet$a(this, _RTCStrategy_processAction, "f")) {
            throw new Error('You have already set a listener for this RTC Strategy');
        }
        __classPrivateFieldSet$8(this, _RTCStrategy_processAction, listener, "f");
        __classPrivateFieldGet$a(this, _RTCStrategy_rtcEndpointMap, "f").forEach((rtcEndpoint) => rtcEndpoint.receive(__classPrivateFieldGet$a(this, _RTCStrategy_processAction, "f")));
    }
    getEndpointById(endpointId) {
        const endpoint = __classPrivateFieldGet$a(this, _RTCStrategy_rtcEndpointMap, "f").get(endpointId);
        if (!endpoint) {
            throw new Error(`Client with endpoint id ${endpointId} is not connected`);
        }
        return endpoint;
    }
    get connected() {
        return __classPrivateFieldGet$a(this, _RTCStrategy_connected, "f");
    }
    isEndpointConnected(endpointId) {
        return __classPrivateFieldGet$a(this, _RTCStrategy_rtcEndpointMap, "f").has(endpointId);
    }
    addEndpoint(endpointId, payload) {
        if (!__classPrivateFieldGet$a(this, _RTCStrategy_connected, "f")) {
            console.warn('Adding endpoint to disconnected RTC Strategy');
            return;
        }
        const clientStrat = new endpoint_1.RTCEndpoint(payload.rtc, payload.endpointIdentity);
        if (__classPrivateFieldGet$a(this, _RTCStrategy_processAction, "f")) {
            clientStrat.receive(__classPrivateFieldGet$a(this, _RTCStrategy_processAction, "f"));
        }
        __classPrivateFieldGet$a(this, _RTCStrategy_rtcEndpointMap, "f").set(endpointId, clientStrat);
    }
    async closeEndpoint(endpointId) {
        __classPrivateFieldGet$a(this, _RTCStrategy_rtcEndpointMap, "f").delete(endpointId);
    }
    isValidEndpointPayload(payload) {
        const isObject = (x) => {
            return typeof x === 'object' && x !== null;
        };
        return (isObject(payload) &&
            isObject(payload.endpointIdentity) &&
            isObject(payload.rtc) &&
            typeof payload.endpointIdentity.endpointId === 'string');
    }
}
strategy$1.RTCStrategy = RTCStrategy;
_RTCStrategy_processAction = new WeakMap(), _RTCStrategy_rtcEndpointMap = new WeakMap(), _RTCStrategy_connected = new WeakMap();
strategy$1.RTCInfo = { version: 2, minimumVersion: 0, type: 'rtc' };

var iceManager = {};

Object.defineProperty(iceManager, "__esModule", { value: true });
iceManager.RTCICEManager = void 0;
const base_1$i = base;
/*
Singleton that facilitates Offer and Answer exchange required for establishing RTC connections.
*/
class RTCICEManager extends base_1$i.EmitterBase {
    constructor(wire) {
        super(wire, 'channel');
        this.ensureChannelOpened = (channel) => {
            return new Promise((resolve, reject) => {
                if (channel.readyState === 'open') {
                    resolve();
                }
                else if (channel.readyState === 'connecting') {
                    const listener = () => {
                        channel.removeEventListener('open', listener);
                        resolve();
                    };
                    channel.addEventListener('open', listener);
                }
                else {
                    reject(new Error('This Channel has already closed'));
                }
            });
        };
    }
    static createDataChannelPromise(label, rtcClient) {
        let resolver;
        const promise = new Promise((resolve) => {
            resolver = resolve;
        });
        const listener = (e) => {
            const openListener = () => {
                e.channel.removeEventListener('open', openListener);
                resolver(e.channel);
            };
            if (e.channel.label === label) {
                e.channel.addEventListener('open', openListener);
                rtcClient.removeEventListener('datachannel', listener);
            }
        };
        rtcClient.addEventListener('datachannel', listener);
        return promise;
    }
    async listenForProviderIce(rtcConnectionId, listener) {
        await this.on(this.createProviderEventName(rtcConnectionId), listener, { timestamp: Date.now() });
    }
    async raiseProviderIce(rtcConnectionId, payload) {
        await this.wire.environment.raiseEvent(this.createRouteString(this.createProviderEventName(rtcConnectionId)), payload);
    }
    async listenForClientIce(rtcConnectionId, listener) {
        await this.on(this.createClientEventName(rtcConnectionId), listener, { timestamp: Date.now() });
    }
    async raiseClientIce(rtcConnectionId, payload) {
        await this.wire.environment.raiseEvent(this.createRouteString(this.createClientEventName(rtcConnectionId)), payload);
    }
    cleanupIceListeners(rtcConnectionId) {
        this.removeAllListeners(this.createClientEventName(rtcConnectionId));
        this.removeAllListeners(this.createProviderEventName(rtcConnectionId));
    }
    createClientEventName(rtcConnectionId) {
        return `ice-client-${rtcConnectionId}`;
    }
    createProviderEventName(rtcConnectionId) {
        return `ice-provider-${rtcConnectionId}`;
    }
    createRouteString(name) {
        return `channel/${name}`;
    }
    createRtcPeer() {
        return this.wire.environment.getRtcPeer();
    }
    async startClientOffer() {
        // TODO replace with real guid.
        const rtcConnectionId = Math.random().toString();
        const rtcClient = this.createRtcPeer();
        rtcClient.addEventListener('icecandidate', async (e) => {
            if (e.candidate) {
                await this.raiseClientIce(rtcConnectionId, { candidate: e.candidate?.toJSON() });
            }
        });
        await this.listenForProviderIce(rtcConnectionId, async (payload) => {
            await rtcClient.addIceCandidate(payload.candidate);
        });
        const channels = {
            request: rtcClient.createDataChannel('request'),
            response: rtcClient.createDataChannel('response')
        };
        const offer = await rtcClient.createOffer();
        await rtcClient.setLocalDescription(offer);
        const channelsOpened = Promise.all([channels.request, channels.response].map(this.ensureChannelOpened)).then(() => undefined);
        return { rtcClient, channels, offer, rtcConnectionId, channelsOpened };
    }
    async finishClientOffer(rtcClient, answer, providerReady) {
        await rtcClient.setRemoteDescription(answer);
        await providerReady;
        return true;
    }
    async createProviderAnswer(rtcConnectionId, offer) {
        const rtcClient = this.createRtcPeer();
        const requestChannelPromise = RTCICEManager.createDataChannelPromise('request', rtcClient);
        const responseChannelPromise = RTCICEManager.createDataChannelPromise('response', rtcClient);
        rtcClient.addEventListener('icecandidate', async (e) => {
            if (e.candidate) {
                await this.raiseProviderIce(rtcConnectionId, { candidate: e.candidate?.toJSON() });
            }
        });
        await this.listenForClientIce(rtcConnectionId, async (payload) => {
            await rtcClient.addIceCandidate(payload.candidate);
        });
        await rtcClient.setRemoteDescription(offer);
        const answer = await rtcClient.createAnswer();
        await rtcClient.setLocalDescription(answer);
        const channels = Promise.all([requestChannelPromise, responseChannelPromise]).then(([request, response]) => {
            // Clean up ice events.
            this.cleanupIceListeners(rtcConnectionId);
            return { request, response };
        });
        return {
            rtcClient,
            answer,
            channels
        };
    }
}
iceManager.RTCICEManager = RTCICEManager;

var provider = {};

var runtimeVersioning = {};

Object.defineProperty(runtimeVersioning, "__esModule", { value: true });
runtimeVersioning.runtimeUuidMeetsMinimumRuntimeVersion = runtimeVersioning.parseRuntimeUuid = runtimeVersioning.meetsMinimumRuntimeVersion = void 0;
function vNum(x) {
    return [...x.split('.').reverse().entries()].reduce((p, [i, v]) => p + +v * 10000 ** i, 0);
}
/*
  Compares runtime versions to see if the current runtime meets your desired minimum.
*/
function meetsMinimumRuntimeVersion(currentVersion, minVersion) {
    const currentVersionParsed = vNum(currentVersion);
    const minVersionParsed = vNum(minVersion);
    return currentVersionParsed >= minVersionParsed;
}
runtimeVersioning.meetsMinimumRuntimeVersion = meetsMinimumRuntimeVersion;
// Strips the port info from the runtimeUuid, leaving just the runtime version.
function parseRuntimeUuid(runtimeUuid) {
    return runtimeUuid.split('/')[0];
}
runtimeVersioning.parseRuntimeUuid = parseRuntimeUuid;
function runtimeUuidMeetsMinimumRuntimeVersion(runtimeUuid, minVersion) {
    const runtimeVersion = parseRuntimeUuid(runtimeUuid);
    return meetsMinimumRuntimeVersion(runtimeVersion, minVersion);
}
runtimeVersioning.runtimeUuidMeetsMinimumRuntimeVersion = runtimeUuidMeetsMinimumRuntimeVersion;

var __classPrivateFieldGet$9 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$7 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ChannelProvider_connections, _ChannelProvider_protectedObj, _ChannelProvider_strategy, _ChannelProvider_removeEndpoint, _ChannelProvider_close;
Object.defineProperty(provider, "__esModule", { value: true });
provider.ChannelProvider = void 0;
const channel_1 = channel;
const runtimeVersioning_1 = runtimeVersioning;
/**
 * Instance created to enable use of a channel as a provider. Allows for communication with the {@link ChannelClient ChannelClients} by invoking an action on
 * a single client via {@link ChannelProvider#dispatch dispatch} or all clients via {@link ChannelProvider#publish publish}
 * and to listen for communication from clients by registering an action via {@link ChannelProvider#register register}.
 *
 * ### Synchronous Methods:
 *  * {@link ChannelProvider#onConnection onConnection(listener)}
 *  * {@link ChannelProvider#onDisconnection onDisconnection(listener)}
 *  * {@link ChannelProvider#publish publish(action, payload)}
 *  * {@link ChannelProvider#register register(action, listener)}
 *  * {@link ChannelProvider#remove remove(action)}
 *
 * ### Asynchronous Methods:
 *  * {@link ChannelProvider#destroy destroy()}
 *  * {@link ChannelProvider#dispatch dispatch(to, action, payload)}
 *  * {@link ChannelProvider#getAllClientInfo getAllClientInfo()}
 *
 * ### Middleware:
 * Middleware functions receive the following arguments: (action, payload, senderId).
 * The return value of the middleware function will be passed on as the payload from beforeAction, to the action listener, to afterAction
 * unless it is undefined, in which case the most recently defined payload is used.  Middleware can be used for side effects.
 *  * {@link ChannelProvider#setDefaultAction setDefaultAction(middleware)}
 *  * {@link ChannelProvider#onError onError(middleware)}
 *  * {@link ChannelProvider#beforeAction beforeAction(middleware)}
 *  * {@link ChannelProvider#afterAction afterAction(middleware)}
 */
class ChannelProvider extends channel_1.ChannelBase {
    /**
     * a read-only array containing all the identities of connecting clients.
     */
    get connections() {
        return [...__classPrivateFieldGet$9(this, _ChannelProvider_connections, "f")];
    }
    static handleClientDisconnection(channel, payload) {
        const removeById = channel.connections.find((identity) => identity.endpointId === payload.endpointId);
        if (removeById) {
            __classPrivateFieldGet$9(channel, _ChannelProvider_removeEndpoint, "f").call(channel, removeById);
        }
        else {
            const multipleRemoves = channel.connections.filter((identity) => {
                return identity.uuid === payload.uuid && identity.name === payload.name;
            });
            multipleRemoves.forEach(__classPrivateFieldGet$9(channel, _ChannelProvider_removeEndpoint, "f"));
        }
        channel.disconnectListener(payload);
    }
    static setProviderRemoval(provider, remove) {
        ChannelProvider.removalMap.set(provider, remove);
    }
    /**
     * @internal
     */
    constructor(providerIdentity, wire, strategy) {
        super();
        _ChannelProvider_connections.set(this, void 0);
        _ChannelProvider_protectedObj.set(this, void 0);
        _ChannelProvider_strategy.set(this, void 0);
        _ChannelProvider_removeEndpoint.set(this, (identity) => {
            const remainingConnections = this.connections.filter((clientIdentity) => clientIdentity.endpointId !== identity.endpointId);
            __classPrivateFieldGet$9(this, _ChannelProvider_strategy, "f").closeEndpoint(identity.endpointId);
            __classPrivateFieldSet$7(this, _ChannelProvider_connections, remainingConnections, "f");
        });
        // Must be bound.
        this.processAction = async (action, payload, senderIdentity) => {
            if (ChannelProvider.clientIsMultiRuntime(senderIdentity) &&
                !(0, runtimeVersioning_1.runtimeUuidMeetsMinimumRuntimeVersion)(senderIdentity.runtimeUuid, '18.87.56.0')) {
                this.handleMultiRuntimeLegacyClient(senderIdentity);
            }
            else {
                this.checkForClientConnection(senderIdentity);
            }
            return super.processAction(action, payload, senderIdentity);
        };
        _ChannelProvider_close.set(this, () => {
            __classPrivateFieldGet$9(this, _ChannelProvider_strategy, "f").close();
            const remove = ChannelProvider.removalMap.get(this);
            if (remove) {
                remove();
            }
        });
        __classPrivateFieldSet$7(this, _ChannelProvider_protectedObj, new channel_1.ProtectedItems(providerIdentity, wire), "f");
        this.connectListener = () => undefined;
        this.disconnectListener = () => undefined;
        __classPrivateFieldSet$7(this, _ChannelProvider_connections, [], "f");
        __classPrivateFieldSet$7(this, _ChannelProvider_strategy, strategy, "f");
        strategy.receive(this.processAction);
    }
    /**
     * Dispatch an action to a specified client. Returns a promise for the result of executing that action on the client side.
     *
     * @param to - Identity of the target client.
     * @param action - Name of the action to be invoked by the client.
     * @param payload - Payload to be sent along with the action.
     *
     * @remarks
     *
     * Because multiple clients can share the same `name` and `uuid`, when dispatching from a provider to a client,
     * the `identity` you provide must include the client's unique `endpointId` property. This `endpointId` is
     * passed to the provider in both the `Provider.onConnection` callback and in any registered action callbacks.
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.register('provider-action', async (payload, identity) => {
     *         console.log(payload, identity);
     *         return await provider.dispatch(identity, 'client-action', 'Hello, World!');
     *     });
     * })();
     * ```
     */
    dispatch(to, action, payload) {
        const endpointId = to.endpointId ?? this.getEndpointIdForOpenFinId(to, action);
        if (endpointId && __classPrivateFieldGet$9(this, _ChannelProvider_strategy, "f").isEndpointConnected(endpointId)) {
            return __classPrivateFieldGet$9(this, _ChannelProvider_strategy, "f").send(endpointId, action, payload);
        }
        return Promise.reject(new Error(`Client connection with identity uuid: ${to.uuid} / name: ${to.name} / endpointId: ${endpointId} no longer connected.`));
    }
    async processConnection(senderId, payload) {
        __classPrivateFieldGet$9(this, _ChannelProvider_connections, "f").push(senderId);
        return this.connectListener(senderId, payload);
    }
    /**
     * Publish an action and payload to every connected client.
     * Synchronously returns an array of promises for each action (see dispatch).
     *
     * @param action
     * @param payload
     *
     * @example
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.register('provider-action', async (payload, identity) => {
     *         console.log(payload, identity);
     *         return await Promise.all(provider.publish('client-action', { message: 'Broadcast from provider'}));
     *     });
     * })();
     * ```
     */
    publish(action, payload) {
        return this.connections.map((to) => __classPrivateFieldGet$9(this, _ChannelProvider_strategy, "f").send(to.endpointId, action, payload));
    }
    /**
     * Register a listener that is called on every new client connection.
     *
     * @remarks It is passed the identity of the connecting client and a payload if it was provided to Channel.connect.
     * If you wish to reject the connection, throw an error. Be sure to synchronously provide an onConnection upon receipt of
     * the channelProvider to ensure all potential client connections are caught by the listener.
     *
     * Because multiple clients can exist at the same `name` and `uuid`, in order to distinguish between individual clients,
     * the `identity` argument in a provider's `onConnection` callback contains an `endpointId` property. When dispatching from a
     * provider to a client, the `endpointId` property must be provided in order to send an action to a specific client.
     *
     * @example
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     provider.onConnection(identity => {
     *         console.log('Client connected', identity);
     *     });
     * })();
     * ```
     *
     * Reject connection:
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     provider.onConnection(identity => {
     *         throw new Error('Connection Rejected');
     *     });
     * })();
     * ```
     * @param listener
     */
    onConnection(listener) {
        this.connectListener = listener;
    }
    /**
     * Register a listener that is called on client disconnection. It is passed the disconnection event of the disconnecting
     * client.
     *
     * @param listener
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.onDisconnection(evt => {
     *         console.log('Client disconnected', `uuid: ${evt.uuid}, name: ${evt.name}`);
     *     });
     * })();
     * ```
     */
    onDisconnection(listener) {
        this.disconnectListener = listener;
    }
    /**
     * Destroy the channel, raises `disconnected` events on all connected channel clients.
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *     const provider = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *     await provider.destroy();
     * })();
     * ```
     */
    async destroy() {
        const protectedObj = __classPrivateFieldGet$9(this, _ChannelProvider_protectedObj, "f");
        const { channelName } = protectedObj.providerIdentity;
        __classPrivateFieldSet$7(this, _ChannelProvider_connections, [], "f");
        await protectedObj.wire.sendAction('destroy-channel', { channelName });
        __classPrivateFieldGet$9(this, _ChannelProvider_close, "f").call(this);
    }
    /**
     * Returns an array with info on every Client connected to the Provider
     *
     * @example
     *
     * ```js
     * const provider = await fin.InterApplicationBus.Channel.create('openfin');
     * const client = await fin.InterApplicationBus.Channel.connect('openfin');
     * const clientInfo = await provider.getAllClientInfo();
     *
     * console.log(clientInfo);
     *
     * // [
     * //    {
     * //        "uuid": "openfin",
     * //        "name": "openfin-view",
     * //        "endpointId": "6d4c7ca8-4a74-4634-87f8-760558229613",
     * //        "entityType": "view",
     * //        "url": "https://openfin.co"
     * //    },
     * //    {
     * //        "uuid": "openfin2",
     * //        "name": "openfin-view2",
     * //        "endpointId": "4z5d8ab9-2b81-3691-91ex-142179382511",
     * //        "entityType": "view",
     * //        "url": "https://example.com"
     * //    }
     * //]
     * ```
     */
    async getAllClientInfo() {
        return this.connections.map((clientInfo) => {
            const { uuid, name, endpointId, entityType, connectionUrl } = clientInfo;
            return { uuid, name, endpointId, entityType, connectionUrl };
        });
    }
    checkForClientConnection(clientIdentity) {
        if (!this.isClientConnected(clientIdentity)) {
            throw new Error(`This action was sent from a client that is not connected to the provider.
                    Client Identity: {uuid: ${clientIdentity.uuid}, name: ${clientIdentity.name}, endpointId: ${clientIdentity.endpointId}}`);
        }
    }
    isClientConnected(clientIdentity) {
        if (ChannelProvider.clientIdentityIncludesEndpointId(clientIdentity)) {
            return this.connections.some((identity) => {
                return (
                // Might be redundant to check for uuid and name here after we get an endpointId match, but just in case
                identity.endpointId === clientIdentity.endpointId &&
                    identity.uuid === clientIdentity.uuid &&
                    identity.name === clientIdentity.name);
            });
        }
        return this.isLegacyClientConnected(clientIdentity);
    }
    isLegacyClientConnected(clientIdentity) {
        return this.connections.some((identity) => {
            return identity.uuid === clientIdentity.uuid && identity.name === clientIdentity.name;
        });
    }
    handleMultiRuntimeLegacyClient(senderIdentity) {
        if (!this.isLegacyClientConnected(senderIdentity)) {
            throw new Error(`This action was sent from a client that is not connected to the provider. Client Identity:
                    {uuid: ${senderIdentity.uuid}, name: ${senderIdentity.name}, endpointId: ${senderIdentity.endpointId}}`);
        }
    }
    getEndpointIdForOpenFinId(clientIdentity, action) {
        const matchingConnections = this.connections.filter((c) => c.name === clientIdentity.name && c.uuid === clientIdentity.uuid);
        if (matchingConnections.length >= 2) {
            const protectedObj = __classPrivateFieldGet$9(this, _ChannelProvider_protectedObj, "f");
            const { uuid, name } = clientIdentity;
            const providerUuid = protectedObj?.providerIdentity.uuid;
            const providerName = protectedObj?.providerIdentity.name;
            // eslint-disable-next-line no-console
            console.warn(`WARNING: Dispatch call may have unintended results. The "to" argument of your dispatch call is missing the
                "endpointId" parameter. The identity you are dispatching to ({uuid: ${uuid}, name: ${name}})
                has multiple channelClients for this channel. Your dispatched action: (${action}) from the provider:
                ({uuid: ${providerUuid}, name: ${providerName}}) will only be processed by the most recently-created client.`);
        }
        // Pop to return the most recently created endpointId.
        return matchingConnections.pop()?.endpointId;
    }
    // eslint-disable-next-line class-methods-use-this
    static clientIdentityIncludesEndpointId(subscriptionIdentity) {
        return subscriptionIdentity.endpointId !== undefined;
    }
    // eslint-disable-next-line class-methods-use-this
    static clientIsMultiRuntime(subscriptionIdentity) {
        return subscriptionIdentity.runtimeUuid !== undefined;
    }
}
provider.ChannelProvider = ChannelProvider;
_ChannelProvider_connections = new WeakMap(), _ChannelProvider_protectedObj = new WeakMap(), _ChannelProvider_strategy = new WeakMap(), _ChannelProvider_removeEndpoint = new WeakMap(), _ChannelProvider_close = new WeakMap();
// The following line should be changed following a typescript update.
// static #removalMap = new WeakMap<ChannelProvider, Function>();
ChannelProvider.removalMap = new WeakMap();

var messageReceiver = {};

Object.defineProperty(messageReceiver, "__esModule", { value: true });
messageReceiver.MessageReceiver = void 0;
const client_1$1 = client;
const base_1$h = base;
/*
This is a singleton (per fin object) tasked with routing messages coming off the ipc to the correct endpoint.
It needs to be a singleton because there can only be one per wire. It tracks both clients and providers' processAction passed in via the strategy.
If functionality is not about receiving messages, it does not belong here.
*/
class MessageReceiver extends base_1$h.Base {
    constructor(wire) {
        super(wire);
        this.onmessage = (msg) => {
            if (msg.action === 'process-channel-message') {
                this.processChannelMessage(msg);
                return true;
            }
            return false;
        };
        this.endpointMap = new Map();
        this.latestEndpointIdByChannelId = new Map();
        wire.registerMessageHandler(this.onmessage.bind(this));
    }
    async processChannelMessage(msg) {
        const { senderIdentity, providerIdentity, action, ackToSender, payload, intendedTargetIdentity } = msg.payload;
        const key = intendedTargetIdentity.channelId ?? // The recipient is a provider
            intendedTargetIdentity.endpointId ?? // The recipient is a client
            this.latestEndpointIdByChannelId.get(providerIdentity.channelId); // No endpointId was passed, make best attempt
        const handler = this.endpointMap.get(key);
        if (!handler) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = `Client connection with identity uuid: ${this.wire.me.uuid} / name: ${this.wire.me.name} / endpointId: ${key} no longer connected.`;
            return this.wire.sendRaw(ackToSender);
        }
        try {
            const res = await handler(action, payload, senderIdentity);
            ackToSender.payload.payload = ackToSender.payload.payload || {};
            ackToSender.payload.payload.result = res;
            return this.wire.sendRaw(ackToSender);
        }
        catch (e) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = e.message;
            return this.wire.sendRaw(ackToSender);
        }
    }
    addEndpoint(handler, channelId, endpointId) {
        this.endpointMap.set(endpointId, handler);
        // Providers have the same endpointId and channelId.
        // This is only used when clients are receiving messages from providers, so we shouldn't save provider endpointId here.
        if (channelId !== endpointId) {
            this.latestEndpointIdByChannelId.set(channelId, endpointId);
        }
    }
    removeEndpoint(channelId, endpointId) {
        this.endpointMap.delete(endpointId);
        if (this.latestEndpointIdByChannelId.get(channelId) === endpointId) {
            this.latestEndpointIdByChannelId.delete(channelId);
        }
    }
    checkForPreviousClientConnection(channelId) {
        const endpointIdFromPreviousConnection = this.latestEndpointIdByChannelId.get(channelId);
        if (endpointIdFromPreviousConnection) {
            // Not convinced by this way of doing things, but pushing up for now.
            client_1$1.ChannelClient.closeChannelByEndpointId(endpointIdFromPreviousConnection);
            // eslint-disable-next-line no-console
            console.warn('You have created a second connection to an older provider. First connection has been removed from the clientMap');
            // eslint-disable-next-line no-console
            console.warn('If the provider calls publish(), you may receive multiple messages.');
        }
    }
}
messageReceiver.MessageReceiver = MessageReceiver;

var protocolManager = {};

Object.defineProperty(protocolManager, "__esModule", { value: true });
protocolManager.ProtocolManager = void 0;
/*
This should be agnostic of any actual openfin code to be unit testable.
Dependencies on the actual srategies should be handled in ConnectionManager
*/
class ProtocolManager {
    // eslint-disable-next-line no-useless-constructor
    constructor(ProtocolsInPreferenceOrder) {
        this.ProtocolsInPreferenceOrder = ProtocolsInPreferenceOrder;
        this.DefaultClientProtocols = ['classic'];
        this.DefaultProviderProtocols = ['classic'];
        this.getClientProtocols = (protocols) => {
            const supported = protocols
                ? this.ProtocolsInPreferenceOrder.filter((x) => protocols.includes(x))
                : this.DefaultClientProtocols;
            if (!supported.length) {
                throw new Error(`No valid protocols were passed in. Accepted values are: ${this.ProtocolsInPreferenceOrder.join(', ')}.`);
            }
            return supported;
        };
        this.getProviderProtocols = (protocols) => {
            const supported = protocols
                ? this.ProtocolsInPreferenceOrder.filter((x) => protocols.includes(x))
                : this.DefaultProviderProtocols;
            if (!supported.length) {
                throw new Error(`No valid protocols were passed in. Accepted values are: ${this.ProtocolsInPreferenceOrder.join(', ')}.`);
            }
            return supported;
        };
        this.getCompatibleProtocols = (providerProtocols, clientOffer) => {
            const supported = clientOffer.supportedProtocols.filter((clientProtocol) => providerProtocols.some((providerProtocol) => providerProtocol.type === clientProtocol.type &&
                clientProtocol.version >= providerProtocol.minimumVersion &&
                providerProtocol.version >= (clientProtocol.minimumVersion ?? 0)));
            return supported.slice(0, clientOffer.maxProtocols);
        };
    }
}
protocolManager.ProtocolManager = ProtocolManager;

var strategy = {};

Object.defineProperty(strategy, "__esModule", { value: true });
class CombinedStrategy {
    // Making this a static method because the constructor can't be typed.
    // Otherwise it will error when calling addEndpoint but I'd rather the whole instance be typed as never.
    static combine(a, b) {
        return new CombinedStrategy(a, b);
    }
    // eslint-disable-next-line no-useless-constructor
    constructor(primary, secondary) {
        this.primary = primary;
        this.secondary = secondary;
    }
    onEndpointDisconnect(endpointId, listener) {
        this.primary.onEndpointDisconnect(endpointId, () => {
            if (!this.secondary.isEndpointConnected(endpointId)) {
                listener();
            }
        });
        this.secondary.onEndpointDisconnect(endpointId, () => {
            if (!this.primary.isEndpointConnected(endpointId)) {
                listener();
            }
        });
    }
    isValidEndpointPayload(payload) {
        return this.primary.isValidEndpointPayload(payload) || this.secondary.isValidEndpointPayload(payload);
    }
    async closeEndpoint(endpointId) {
        await this.primary.closeEndpoint(endpointId);
        await this.secondary.closeEndpoint(endpointId);
    }
    isEndpointConnected(endpoint) {
        return this.primary.isEndpointConnected(endpoint) || this.secondary.isEndpointConnected(endpoint);
    }
    async addEndpoint(endpoint, payload) {
        if (this.primary.isValidEndpointPayload(payload)) {
            await this.primary.addEndpoint(endpoint, payload);
        }
        if (this.secondary.isValidEndpointPayload(payload)) {
            await this.secondary.addEndpoint(endpoint, payload);
        }
    }
    receive(listener) {
        this.primary.receive(listener);
        this.secondary.receive(listener);
    }
    send(endpointId, action, payload) {
        if (this.primary.isEndpointConnected(endpointId)) {
            return this.primary.send(endpointId, action, payload);
        }
        return this.secondary.send(endpointId, action, payload);
    }
    async close() {
        await Promise.all([this.primary.close(), this.secondary.close()]);
    }
}
strategy.default = CombinedStrategy;

var __classPrivateFieldSet$6 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$8 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ConnectionManager_messageReceiver, _ConnectionManager_rtcConnectionManager;
Object.defineProperty(connectionManager, "__esModule", { value: true });
connectionManager.ConnectionManager = void 0;
const exhaustive_1 = exhaustive;
const base_1$g = base;
const strategy_1 = strategy$2;
const strategy_2 = strategy$1;
const ice_manager_1 = iceManager;
const provider_1$1 = provider;
const message_receiver_1 = messageReceiver;
const protocol_manager_1 = protocolManager;
const strategy_3 = strategy;
class ConnectionManager extends base_1$g.Base {
    static getProtocolOptionsFromStrings(protocols) {
        return protocols.map((protocol) => {
            switch (protocol) {
                case 'rtc':
                    return strategy_2.RTCInfo;
                case 'classic':
                    return strategy_1.ClassicInfo;
                default:
                    return (0, exhaustive_1.exhaustiveCheck)(protocol, ['rtc', 'classic']);
            }
        });
    }
    constructor(wire) {
        super(wire);
        _ConnectionManager_messageReceiver.set(this, void 0);
        _ConnectionManager_rtcConnectionManager.set(this, void 0);
        this.removeChannelFromProviderMap = (channelId) => {
            this.providerMap.delete(channelId);
        };
        this.onmessage = (msg) => {
            if (msg.action === 'process-channel-connection') {
                this.processChannelConnection(msg);
                return true;
            }
            return false;
        };
        this.providerMap = new Map();
        this.protocolManager = new protocol_manager_1.ProtocolManager(this.wire.environment.type === 'node' ? ['classic'] : ['rtc', 'classic']);
        __classPrivateFieldSet$6(this, _ConnectionManager_messageReceiver, new message_receiver_1.MessageReceiver(wire), "f");
        __classPrivateFieldSet$6(this, _ConnectionManager_rtcConnectionManager, new ice_manager_1.RTCICEManager(wire), "f");
        wire.registerMessageHandler(this.onmessage.bind(this));
    }
    createProvider(options, providerIdentity) {
        const opts = Object.assign(this.wire.environment.getDefaultChannelOptions().create, options || {});
        const protocols = this.protocolManager.getProviderProtocols(opts?.protocols);
        const createSingleStrategy = (stratType) => {
            switch (stratType) {
                case 'rtc':
                    return new strategy_2.RTCStrategy();
                case 'classic':
                    return new strategy_1.ClassicStrategy(this.wire, __classPrivateFieldGet$8(this, _ConnectionManager_messageReceiver, "f"), 
                    // Providers do not have an endpointId, use channelId as endpointId in the strategy.
                    providerIdentity.channelId, providerIdentity);
                default:
                    return (0, exhaustive_1.exhaustiveCheck)(stratType, ['rtc', 'classic']);
            }
        };
        const strategies = protocols.map(createSingleStrategy);
        let strategy;
        if (strategies.length === 2) {
            const [a, b] = strategies;
            strategy = strategy_3.default.combine(a, b);
        }
        else if (strategies.length === 1) {
            [strategy] = strategies;
        }
        else {
            // Should be impossible.
            throw new Error('failed to combine strategies');
        }
        const channel = new provider_1$1.ChannelProvider(providerIdentity, this.wire, strategy);
        const key = providerIdentity.channelId;
        this.providerMap.set(key, {
            provider: channel,
            strategy,
            supportedProtocols: ConnectionManager.getProtocolOptionsFromStrings(protocols)
        });
        provider_1$1.ChannelProvider.setProviderRemoval(channel, this.removeChannelFromProviderMap.bind(this));
        return channel;
    }
    async createClientOffer(options) {
        const protocols = this.protocolManager.getClientProtocols(options?.protocols);
        let rtcPacket;
        const supportedProtocols = await Promise.all(protocols.map(async (type) => {
            switch (type) {
                case 'rtc': {
                    const { rtcClient, channels, offer, rtcConnectionId, channelsOpened } = await __classPrivateFieldGet$8(this, _ConnectionManager_rtcConnectionManager, "f").startClientOffer();
                    rtcPacket = { rtcClient, channels, channelsOpened };
                    return {
                        type: 'rtc',
                        version: strategy_2.RTCInfo.version,
                        payload: { offer, rtcConnectionId }
                    };
                }
                case 'classic':
                    return { type: 'classic', version: strategy_1.ClassicInfo.version };
                default:
                    return (0, exhaustive_1.exhaustiveCheck)(type, ['rtc', 'classic']);
            }
        }));
        return {
            offer: {
                supportedProtocols,
                maxProtocols: 2
            },
            rtc: rtcPacket
        };
    }
    async createClientStrategy(rtcPacket, routingInfo) {
        if (!routingInfo.endpointId) {
            routingInfo.endpointId = this.wire.environment.getNextMessageId();
            // For New Clients connecting to Old Providers. To prevent multi-dispatching and publishing, we delete previously-connected
            // clients that are in the same context as the newly-connected client.
            __classPrivateFieldGet$8(this, _ConnectionManager_messageReceiver, "f").checkForPreviousClientConnection(routingInfo.channelId);
        }
        const answer = routingInfo.answer ?? {
            supportedProtocols: [{ type: 'classic', version: 1 }]
        };
        const createStrategyFromAnswer = async (protocol) => {
            if (protocol.type === 'rtc' && rtcPacket) {
                await __classPrivateFieldGet$8(this, _ConnectionManager_rtcConnectionManager, "f").finishClientOffer(rtcPacket.rtcClient, protocol.payload.answer, rtcPacket.channelsOpened);
                return new strategy_2.RTCStrategy();
            }
            if (protocol.type === 'classic') {
                return new strategy_1.ClassicStrategy(this.wire, __classPrivateFieldGet$8(this, _ConnectionManager_messageReceiver, "f"), routingInfo.endpointId, routingInfo);
            }
            return null;
        };
        const allProtocols = (await Promise.all(answer.supportedProtocols.map(createStrategyFromAnswer))).filter((x) => x !== null);
        // Clean up logic if provider didn't support rtc.
        if (rtcPacket && !allProtocols.some((x) => x instanceof strategy_2.RTCStrategy)) {
            if (rtcPacket) {
                rtcPacket.rtcClient.close();
            }
        }
        let strategy;
        if (allProtocols.length >= 2) {
            strategy = strategy_3.default.combine(allProtocols[0], allProtocols[1]);
        }
        else if (allProtocols.length) {
            [strategy] = allProtocols;
        }
        else {
            // Should be impossible.
            throw new Error('No compatible protocols');
        }
        // as casting rtcPacket because we won't have an rtcStrategy if rtcPacket is undefined;
        const endpointPayload = { endpointIdentity: routingInfo, rtc: rtcPacket };
        strategy.addEndpoint(routingInfo.channelId, endpointPayload);
        return strategy;
    }
    async processChannelConnection(msg) {
        const { clientIdentity, providerIdentity, ackToSender, payload, offer: clientOffer } = msg.payload;
        if (!clientIdentity.endpointId) {
            // Should be polyfilled by core but not in cases of node connecting to an old runtime.
            clientIdentity.endpointId = this.wire.environment.getNextMessageId();
            clientIdentity.isLocalEndpointId = true;
        }
        else {
            clientIdentity.isLocalEndpointId = false;
        }
        const key = providerIdentity.channelId;
        const bus = this.providerMap.get(key);
        if (!bus) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = `Channel "${providerIdentity.channelName}" has been destroyed.`;
            return this.wire.sendRaw(ackToSender);
        }
        const { provider, strategy, supportedProtocols } = bus;
        try {
            if (!(provider instanceof provider_1$1.ChannelProvider)) {
                throw Error('Cannot connect to a channel client');
            }
            const offer = clientOffer ?? {
                supportedProtocols: [{ type: 'classic', version: 1 }],
                maxProtocols: 1
            };
            const overlappingProtocols = this.protocolManager.getCompatibleProtocols(supportedProtocols, offer);
            if (!overlappingProtocols.length) {
                throw new Error('This provider does not support any of the offered protocols.');
            }
            const res = await provider.processConnection(clientIdentity, payload);
            ackToSender.payload.payload = ackToSender.payload.payload || {};
            // Loop through all supported protocols and accumulate them into the answer
            // addEndpoint is tricky but we need to wait for channel resolution before adding the endpoint.
            let clientAnswer = {
                supportedProtocols: [],
                endpointPayloadPromise: Promise.resolve({ endpointIdentity: clientIdentity })
            };
            clientAnswer = await overlappingProtocols.reduce(async (accumP, protocolToUse) => {
                const answer = await accumP;
                if (protocolToUse.type === 'rtc') {
                    const { answer: rtcAnswer, rtcClient, channels } = await __classPrivateFieldGet$8(this, _ConnectionManager_rtcConnectionManager, "f").createProviderAnswer(protocolToUse.payload.rtcConnectionId, protocolToUse.payload.offer);
                    answer.supportedProtocols.push({
                        type: 'rtc',
                        version: strategy_2.RTCInfo.version,
                        payload: {
                            answer: rtcAnswer
                        }
                    });
                    answer.endpointPayloadPromise = answer.endpointPayloadPromise.then((endpointPayload) => channels.then((resolvedChannels) => {
                        return {
                            ...endpointPayload,
                            rtc: {
                                rtcClient,
                                channels: resolvedChannels
                            }
                        };
                    }));
                }
                else {
                    answer.supportedProtocols.push({ type: 'classic', version: strategy_1.ClassicInfo.version });
                }
                return answer;
            }, Promise.resolve(clientAnswer));
            // Need to as cast here.
            clientAnswer.endpointPayloadPromise.then((endpointPayload) => strategy.addEndpoint(clientIdentity.endpointId, endpointPayload));
            ackToSender.payload.payload.result = res;
            ackToSender.payload.payload.answer = clientAnswer;
            return this.wire.sendRaw(ackToSender);
        }
        catch (e) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = e.message;
            return this.wire.sendRaw(ackToSender);
        }
    }
}
connectionManager.ConnectionManager = ConnectionManager;
_ConnectionManager_messageReceiver = new WeakMap(), _ConnectionManager_rtcConnectionManager = new WeakMap();

/**
 * Entry points for the `Channel` subset of the `InterApplicationBus` API (`fin.InterApplicationBus.Channel`).
 *
 * * {@link Channel} contains static members of the `Channel` API, accessible through `fin.InterApplicationBus.Channel`.
 * * {@link OpenFin.ChannelClient} describes a client of a channel, e.g. as returned by `fin.InterApplicationBus.Channel.connect`.
 * * {@link OpenFin.ChannelProvider} describes a provider of a channel, e.g. as returned by `fin.InterApplicationBus.Channel.create`.
 *
 * @packageDocumentation
 */
var __classPrivateFieldSet$5 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$7 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Channel_connectionManager, _Channel_internalEmitter, _Channel_readyToConnect;
Object.defineProperty(channel$1, "__esModule", { value: true });
channel$1.Channel = void 0;
/* eslint-disable no-console */
const events_1$5 = require$$0;
const lazy_1$1 = lazy;
const base_1$f = base;
const client_1 = client;
const connection_manager_1 = connectionManager;
const provider_1 = provider;
function retryDelay(count) {
    const interval = 500; // base delay
    const steps = 10; // How many retries to do before incrementing the delay
    const base = 2; // How much to multiply the previous delay by
    const max = 30000; // max delay
    const step = Math.floor(count / steps);
    const delay = Math.min(max, interval * base ** step);
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(false);
        }, delay);
    });
}
/**
 * The Channel API allows an OpenFin application to create a channel as a {@link ChannelProvider ChannelProvider},
 * or connect to a channel as a {@link ChannelClient ChannelClient}.
 * @remarks The "handshake" between the communication partners is
 * simplified when using a channel.  A request to connect to a channel as a client will return a promise that resolves if/when the channel has been created. Both the
 * provider and client can dispatch actions that have been registered on their opposites, and dispatch returns a promise that resolves with a payload from the other
 * communication participant. There can be only one provider per channel, but many clients.  Version `9.61.35.*` or later is required for both communication partners.
 *
 * Asynchronous Methods:
 *  * {@link Channel.create create(channelName, options)}
 *  * {@link Channel.connect connect(channelName, options)}
 *  * {@link Channel.onChannelConnect onChannelConnect(listener)}
 *  * {@link Channel.onChannelDisconnect onChannelDisconnect(listener)}
 */
class Channel extends base_1$f.EmitterBase {
    /**
     * @internal
     */
    constructor(wire) {
        super(wire, 'channel');
        _Channel_connectionManager.set(this, void 0);
        _Channel_internalEmitter.set(this, new events_1$5.EventEmitter());
        // OpenFin API has not been injected at construction time, *must* wait for API to be ready.
        _Channel_readyToConnect.set(this, new lazy_1$1.AsyncRetryableLazy(async () => {
            await Promise.all([
                this.on('disconnected', (eventPayload) => {
                    client_1.ChannelClient.handleProviderDisconnect(eventPayload);
                }),
                this.on('connected', (...args) => {
                    __classPrivateFieldGet$7(this, _Channel_internalEmitter, "f").emit('connected', ...args);
                })
            ]).catch(() => new Error('error setting up channel connection listeners'));
        }));
        __classPrivateFieldSet$5(this, _Channel_connectionManager, new connection_manager_1.ConnectionManager(wire), "f");
    }
    /**
     *
     * @internal
     */
    async getAllChannels() {
        return this.wire.sendAction('get-all-channels').then(({ payload }) => payload.data);
    }
    /**
     * Listens for channel connections.
     *
     * @param listener - callback to execute.
     *
     * @example
     *
     * ```js
     * const listener = (channelPayload) => console.log(channelPayload); // see return value below
     *
     * fin.InterApplicationBus.Channel.onChannelConnect(listener);
     *
     * // example shape
     * {
     *     "topic": "channel",
     *     "type": "connected",
     *     "uuid": "OpenfinPOC",
     *     "name": "OpenfinPOC",
     *     "channelName": "counter",
     *     "channelId": "OpenfinPOC/OpenfinPOC/counter"
     * }
     *
     * ```
     */
    async onChannelConnect(listener) {
        await this.on('connected', listener);
    }
    /**
     * Listen for channel disconnections.
     *
     * @param listener - callback to execute.
     *
     * @example
     *
     * ```js
     * const listener = (channelPayload) => console.log(channelPayload); // see return value below
     *
     * fin.InterApplicationBus.Channel.onChannelDisconnect(listener);
     *
     * // example shape
     * {
     *     "topic": "channel",
     *     "type": "disconnected",
     *     "uuid": "OpenfinPOC",
     *     "name": "OpenfinPOC",
     *     "channelName": "counter",
     *     "channelId": "OpenfinPOC/OpenfinPOC/counter"
     * }
     *
     * ```
     */
    async onChannelDisconnect(listener) {
        await this.on('disconnected', listener);
    }
    async safeConnect(channelName, shouldWait, connectPayload) {
        const retryInfo = { count: 0 };
        /* eslint-disable no-await-in-loop, no-constant-condition */
        do {
            // setup a listener and a connected promise to await in case we connect before the channel is ready
            let connectedListener = () => undefined;
            const connectedPromise = new Promise((resolve) => {
                connectedListener = (payload) => {
                    if (channelName === payload.channelName) {
                        resolve(true);
                    }
                };
                __classPrivateFieldGet$7(this, _Channel_internalEmitter, "f").on('connected', connectedListener);
            });
            try {
                if (retryInfo.count > 0) {
                    // Wait before retrying
                    // Delay returns false connectedPromise returns true so we can know if a retry is due to connected event
                    retryInfo.gotConnectedEvent = await Promise.race([retryDelay(retryInfo.count), connectedPromise]);
                    const result = await this.wire.sendAction('connect-to-channel', { ...connectPayload, retryInfo });
                    // log only if there was a retry
                    console.log(`Successfully connected to channelName: ${channelName}`);
                    return result.payload.data;
                }
                // Send retryInfo to the core for debug log inclusion
                const sentMessagePromise = this.wire.sendAction('connect-to-channel', connectPayload);
                // Save messageId from the first connection attempt
                retryInfo.originalMessageId = sentMessagePromise.messageId;
                const result = await sentMessagePromise;
                return result.payload.data;
            }
            catch (error) {
                if (!error.message.includes('internal-nack')) {
                    // Not an internal nack, break the loop
                    throw error;
                }
                if (shouldWait && retryInfo.count === 0) {
                    // start waiting on the next iteration, warn the user
                    console.warn(`No channel found for channelName: ${channelName}. Waiting for connection...`);
                }
            }
            finally {
                retryInfo.count += 1;
                // in case of other errors, remove our listener
                __classPrivateFieldGet$7(this, _Channel_internalEmitter, "f").removeListener('connected', connectedListener);
            }
        } while (shouldWait); // If we're waiting we retry the above loop
        // Should wait was false, no channel was found.
        throw new Error(`No channel found for channelName: ${channelName}.`);
        /* eslint-enable no-await-in-loop, no-constant-condition */
    }
    /**
     * Connect to a channel. If you wish to send a payload to the provider, add a payload property to the options argument.
     * EXPERIMENTAL: pass { protocols: ['rtc'] } as options to opt-in to High Throughput Channels.
     *
     * @param channelName - Name of the target channel.
     * @param options - Connection options.
     * @returns Returns a promise that resolves with an instance of {@link ChannelClient ChannelClient}.
     *
     * @remarks The connection request will be routed to the channelProvider if/when the channel is created.  If the connect
     * request is sent prior to creation, the promise will not resolve or reject until the channel is created by a channelProvider
     * (whether or not to wait for creation is configurable in the connectOptions).
     *
     * The connect call returns a promise that will resolve with a channelClient bus if accepted by the channelProvider, or reject if
     * the channelProvider throws an error to reject the connection. This bus can communicate with the Provider, but not to other
     * clients on the channel. Using the bus, the channelClient can register actions and middleware. Channel lifecycle can also be
     * handled with an onDisconnection listener.
     *
     * @example
     *
     * ```js
     * async function makeClient(channelName) {
     *    // A payload can be sent along with channel connection requests to help with authentication
     *    const connectPayload = { payload: 'token' };
     *
     *    // If the channel has been created this request will be sent to the provider.  If not, the
     *    // promise will not be resolved or rejected until the channel has been created.
     *    const clientBus = await fin.InterApplicationBus.Channel.connect(channelName, connectPayload);
     *
     *    clientBus.onDisconnection(channelInfo => {
     *        // handle the channel lifecycle here - we can connect again which will return a promise
     *        // that will resolve if/when the channel is re-created.
     *        makeClient(channelInfo.channelName);
     *    })
     *
     *    clientBus.register('topic', (payload, identity) => {
     *        // register a callback for a topic to which the channel provider can dispatch an action
     *        console.log('Action dispatched by provider: ', JSON.stringify(identity));
     *        console.log('Payload sent in dispatch: ', JSON.stringify(payload));
     *        return {
     *            echo: payload
     *        };
     *    });
     * }
     *
     * makeClient('channelName')
     * .then(() => console.log('Connected'))
     * .catch(console.error);
     * ```
     */
    async connect(channelName, options = {}) {
        // Make sure we don't connect before listeners are set up
        // This also errors if we're not in OpenFin, ensuring we don't run unnecessary code
        await __classPrivateFieldGet$7(this, _Channel_readyToConnect, "f").getValue();
        if (!channelName || typeof channelName !== 'string') {
            throw new Error('Please provide a channelName string to connect to a channel.');
        }
        const opts = { wait: true, ...this.wire.environment.getDefaultChannelOptions().connect, ...options };
        const { offer, rtc: rtcPacket } = await __classPrivateFieldGet$7(this, _Channel_connectionManager, "f").createClientOffer(opts);
        let connectionUrl;
        if (this.fin.me.isFrame || this.fin.me.isView || this.fin.me.isWindow) {
            connectionUrl = (await this.fin.me.getInfo()).url;
        }
        const connectPayload = {
            channelName,
            ...opts,
            offer,
            connectionUrl
        };
        const routingInfo = await this.safeConnect(channelName, opts.wait, connectPayload);
        const strategy = await __classPrivateFieldGet$7(this, _Channel_connectionManager, "f").createClientStrategy(rtcPacket, routingInfo);
        const channel = new client_1.ChannelClient(routingInfo, this.wire, strategy);
        // It is the client's responsibility to handle endpoint disconnection to the provider.
        // If the endpoint dies, the client will force a disconnection through the core.
        // The provider does not care about endpoint disconnection.
        strategy.onEndpointDisconnect(routingInfo.channelId, async () => {
            try {
                await channel.sendDisconnectAction();
            }
            catch (error) {
                console.warn(`Something went wrong during disconnect for client with uuid: ${routingInfo.uuid} / name: ${routingInfo.name} / endpointId: ${routingInfo.endpointId}.`);
            }
            finally {
                client_1.ChannelClient.handleProviderDisconnect(routingInfo);
            }
        });
        return channel;
    }
    /**
     * Create a new channel.
     * You must provide a unique channelName. If a channelName is not provided, or it is not unique, the creation will fail.
     * EXPERIMENTAL: pass { protocols: ['rtc'] } as options to opt-in to High Throughput Channels.
     *
     * @param channelName - Name of the channel to be created.
     * @param options - Creation options.
     * @returns Returns a promise that resolves with an instance of {@link ChannelProvider ChannelProvider}.
     *
     * @remarks If successful, the create method returns a promise that resolves to an instance of the channelProvider bus. The caller
     * then becomes the “channel provider” and can use the channelProvider bus to register actions and middleware.
     *
     * The caller can also set an onConnection and/or onDisconnection listener that will execute on any new channel
     * connection/disconnection attempt from a channel client. To reject a connection, simply throw an error in the
     * onConnection listener.  The default behavior is to accept all new connections.
     *
     * A map of client connections is updated automatically on client connection and disconnection and saved in the
     * [read-only] `connections` property on the channelProvider bus.  The channel will exist until the provider
     * destroys it or disconnects by closing or destroying the context (navigating or reloading). To setup a channel
     * as a channelProvider, call `Channel.create` with a unique channel name. A map of client connections is updated
     * automatically on client connection and disconnection.
     *
     * @example
     *
     * ```js
     * (async ()=> {
     *    // entity creates a channel and becomes the channelProvider
     *    const providerBus = await fin.InterApplicationBus.Channel.create('channelName');
     *
     *    providerBus.onConnection((identity, payload) => {
     *        // can reject a connection here by throwing an error
     *        console.log('Client connection request identity: ', JSON.stringify(identity));
     *        console.log('Client connection request payload: ', JSON.stringify(payload));
     *    });
     *
     *    providerBus.register('topic', (payload, identity) => {
     *        // register a callback for a 'topic' to which clients can dispatch an action
     *        console.log('Action dispatched by client: ', JSON.stringify(identity));
     *        console.log('Payload sent in dispatch: ', JSON.stringify(payload));
     *        return {
     *            echo: payload
     *        };
     *    });
     * })();
     * ```
     */
    async create(channelName, options) {
        if (!channelName) {
            throw new Error('Please provide a channelName to create a channel');
        }
        const { payload: { data: providerIdentity } } = await this.wire.sendAction('create-channel', { channelName });
        const channel = __classPrivateFieldGet$7(this, _Channel_connectionManager, "f").createProvider(options, providerIdentity);
        // TODO: fix typing (internal)
        // @ts-expect-error
        this.on('client-disconnected', (eventPayload) => {
            if (eventPayload.channelName === channelName) {
                provider_1.ChannelProvider.handleClientDisconnection(channel, eventPayload);
            }
        });
        return channel;
    }
}
channel$1.Channel = Channel;
_Channel_connectionManager = new WeakMap(), _Channel_internalEmitter = new WeakMap(), _Channel_readyToConnect = new WeakMap();

Object.defineProperty(interappbus, "__esModule", { value: true });
interappbus.InterAppPayload = interappbus.InterApplicationBus = void 0;
/**
 * Entry point for the OpenFin `InterApplicationBus` API (`fin.InterApplicationBus`).
 *
 * * {@link InterApplicationBus} contains static members of the `InterApplicationBus` API, accessible through `fin.InterApplicationBus`.
 *
 * @packageDocumentation
 */
const events_1$4 = require$$0;
const base_1$e = base;
const ref_counter_1 = refCounter;
const index_1$2 = channel$1;
const validate_1$3 = validate;
/**
 * A messaging bus that allows for pub/sub messaging between different applications.
 *
 */
class InterApplicationBus extends base_1$e.Base {
    /**
     * @internal
     */
    constructor(wire) {
        super(wire);
        this.events = {
            subscriberAdded: 'subscriber-added',
            subscriberRemoved: 'subscriber-removed'
        };
        this.refCounter = new ref_counter_1.RefCounter();
        this.Channel = new index_1$2.Channel(wire);
        this.emitter = new events_1$4.EventEmitter();
        wire.registerMessageHandler(this.onmessage.bind(this));
        this.on = this.emitter.on.bind(this.emitter);
        this.removeAllListeners = this.emitter.removeAllListeners.bind(this.emitter);
    }
    /**
     * Publishes a message to all applications running on OpenFin Runtime that
     * are subscribed to the specified topic.
     * @param topic The topic on which the message is sent
     * @param message The message to be published. Can be either a primitive
     * data type (string, number, or boolean) or composite data type (object, array)
     * that is composed of other primitive or composite data types
     *
     * @example
     * ```js
     * fin.InterApplicationBus.publish('topic', 'hello').then(() => console.log('Published')).catch(err => console.log(err));
     * ```
     */
    async publish(topic, message) {
        await this.wire.sendAction('publish-message', {
            topic,
            message,
            sourceWindowName: this.me.name
        });
    }
    /**
     * Sends a message to a specific application on a specific topic.
     * @param destination The identity of the application to which the message is sent
     * @param topic The topic on which the message is sent
     * @param message The message to be sent. Can be either a primitive data
     * type (string, number, or boolean) or composite data type (object, array) that
     * is composed of other primitive or composite data types
     *
     * @example
     * ```js
     * fin.InterApplicationBus.send(fin.me, 'topic', 'Hello there!').then(() => console.log('Message sent')).catch(err => console.log(err));
     * ```
     */
    async send(destination, topic, message) {
        const errorMsg = (0, validate_1$3.validateIdentity)(destination);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        await this.wire.sendAction('send-message', {
            destinationUuid: destination.uuid,
            destinationWindowName: destination.name,
            topic,
            message,
            sourceWindowName: this.me.name
        });
    }
    /**
     * Subscribes to messages from the specified application on the specified topic.
     * @param source This object is described in the Identity in the typedef
     * @param topic The topic on which the message is sent
     * @param listener A function that is called when a message has
     * been received. It is passed the message, uuid and name of the sending application.
     * The message can be either a primitive data type (string, number, or boolean) or
     * composite data type (object, array) that is composed of other primitive or composite
     * data types
     *
     * @example
     * ```js
     * // subscribe to a specified application
     * fin.InterApplicationBus.subscribe(fin.me, 'topic', sub_msg => console.log(sub_msg)).then(() => console.log('Subscribed to the specified application')).catch(err => console.log(err));
     *
     * // subscribe to wildcard
     * fin.InterApplicationBus.subscribe({ uuid: '*' }, 'topic', sub_msg => console.log(sub_msg)).then(() => console.log('Subscribed to *')).catch(err => console.log(err));
     * ```
     */
    subscribe(source, topic, listener) {
        const subKey = this.createSubscriptionKey(source.uuid, source.name || '*', topic);
        const sendSubscription = async () => {
            await this.wire.sendAction('subscribe', {
                sourceUuid: source.uuid,
                sourceWindowName: source.name || '*',
                topic,
                destinationWindowName: this.me.name
            });
        };
        const alreadySubscribed = () => {
            return Promise.resolve();
        };
        this.emitter.on(subKey, listener);
        return this.refCounter.actOnFirst(subKey, sendSubscription, alreadySubscribed);
    }
    /**
     * Unsubscribes to messages from the specified application on the specified topic.
     *
     * @remarks If you are listening to all apps on a topic, (i.e you passed `{ uuid:'*' }` to the subscribe function)
     * then you need to pass `{ uuid:'*' }` to unsubscribe as well. If you are listening to a specific application,
     * (i.e you passed `{ uuid:'some_app' }` to the subscribe function) then you need to provide the same identifier to
     * unsubscribe, unsubscribing to `*` on that same topic will not unhook your initial listener otherwise.
     *
     * @param source This object is described in the Identity in the typedef
     * @param topic The topic on which the message is sent
     * @param listener A callback previously registered with subscribe()
     *
     * @example
     * ```js
     * const listener = console.log;
     *
     * // If any application publishes a message on topic `foo`, our listener will be called.
     * await fin.InterApplicationBus.subscribe({ uuid:'*' }, 'foo', listener)
     *
     * // When you want to unsubscribe, you need to specify the uuid of the app you'd like to
     * // unsubscribe from (or `*`) and provide the same function you gave the subscribe function
     * await fin.InterApplicationBus.unsubscribe({ uuid:'*' }, 'foo', listener)
     * ```
     */
    unsubscribe(source, topic, listener) {
        const sourceWindowName = source.name || '*';
        const subKey = this.createSubscriptionKey(source.uuid, sourceWindowName, topic);
        const sendUnsubscription = async () => {
            await this.wire.sendAction('unsubscribe', {
                sourceUuid: source.uuid,
                sourceWindowName,
                topic,
                destinationWindowName: this.me.name
            });
        };
        const dontSendUnsubscription = () => {
            return new Promise((r) => r).then(() => undefined);
        };
        this.emitter.removeListener(subKey, listener);
        return this.refCounter.actOnLast(subKey, sendUnsubscription, dontSendUnsubscription);
    }
    processMessage(message) {
        const { payload: { message: payloadMessage, sourceWindowName, sourceUuid, topic } } = message;
        const keys = [
            this.createSubscriptionKey(sourceUuid, sourceWindowName, topic),
            this.createSubscriptionKey(sourceUuid, '*', topic),
            this.createSubscriptionKey('*', '*', topic)
        ];
        const idOfSender = { uuid: sourceUuid, name: sourceWindowName };
        keys.forEach((key) => {
            this.emitter.emit(key, payloadMessage, idOfSender);
        });
    }
    emitSubscriverEvent(type, message) {
        const { payload: { targetName: name, uuid, topic } } = message;
        const payload = { name, uuid, topic };
        this.emitter.emit(type, payload);
    }
    // eslint-disable-next-line class-methods-use-this
    createSubscriptionKey(uuid, name, topic) {
        const n = name || '*';
        if (!(uuid && n && topic)) {
            throw new Error('Missing uuid, name, or topic string');
        }
        return createKey(uuid, n, topic);
    }
    onmessage(message) {
        const { action } = message;
        switch (action) {
            case 'process-message':
                this.processMessage(message);
                break;
            case this.events.subscriberAdded:
                this.emitSubscriverEvent(this.events.subscriberAdded, message);
                break;
            case this.events.subscriberRemoved:
                this.emitSubscriverEvent(this.events.subscriberRemoved, message);
                break;
        }
        return true;
    }
}
interappbus.InterApplicationBus = InterApplicationBus;
/**
 * @internal
 */
class InterAppPayload {
}
interappbus.InterAppPayload = InterAppPayload;
function createKey(...toHash) {
    return toHash
        .map((item) => {
        return Buffer.from(`${item}`).toString('base64');
    })
        .join('/');
}

var clipboard = {};

/**
 * Entry point for the OpenFin `Clipboard` API (`fin.Clipboard`).
 *
 * * {@link Clipboard} contains static members of the `Clipboard` API, accessible through `fin.Clipboard`.
 *
 * @packageDocumentation
 */
Object.defineProperty(clipboard, "__esModule", { value: true });
clipboard.Clipboard = void 0;
const base_1$d = base;
/**
 * The Clipboard API allows reading and writing to the clipboard in multiple formats.
 *
 */
class Clipboard extends base_1$d.Base {
    /**
     * Writes data into the clipboard as plain text
     * @param writeObj The object for writing data into the clipboard
     *
     * @example
     * ```js
     * fin.Clipboard.writeText({
     *     data: 'hello, world'
     * }).then(() => console.log('Text On clipboard')).catch(err => console.log(err));
     * ```
     */
    async writeText(writeObj) {
        await this.wire.sendAction('clipboard-write-text', writeObj);
    }
    /**
     * Read the content of the clipboard as plain text
     * @param type Clipboard Type defaults to 'clipboard', use 'selection' for linux
     *
     * @example
     * ```js
     * fin.Clipboard.readText().then(text => console.log(text)).catch(err => console.log(err));
     * ```
     */
    async readText(type) {
        // NOTE: When we start supporting linux, we could detect the OS and choose 'selection' automatically for the user
        const { payload } = await this.wire.sendAction('clipboard-read-text', { type });
        return payload.data;
    }
    /**
     * Writes data into the clipboard as an Image
     * @param writeRequest The object to write an image to the clipboard
     *
     * @example
     * ```js
     * fin.Clipboard.writeImage({
     *   // raw base64 string, or dataURL of either data:image/png or data:image/jpeg type
     *   image: '...'
     * }).then(() => console.log('Image written to clipboard')).catch(err => console.log(err));
     * ```
     */
    async writeImage(writeRequest) {
        await this.wire.sendAction('clipboard-write-image', writeRequest);
    }
    /**
     * Read the content of the clipboard as a base64 string or a dataURL based on the input parameter 'format', defaults to 'dataURL'
     * @param readRequest Clipboard Read Image request with formatting options
     *
     * @example
     * ```js
     * // see TS type: OpenFin.ImageFormatOptions
     *
     * const pngOrDataURLOrBmpOptions = {
     *     format: 'png', // can be: 'png' | 'dataURL' | 'bmp'
     * };
     *
     * const jpgOptions = {
     *     format: 'jpg',
     *     quality: 80 // optional, if omitted defaults to 100
     * };
     *
     * fin.Clipboard.readImage(pngOrDataURLOrBmpOptions)
     *     .then(image => console.log('Image read from clipboard as PNG, DataURL or BMP', image))
     *     .catch(err => console.log(err));
     *
     * fin.Clipboard.readImage(jpgOptions)
     *     .then(image => console.log('Image read from clipboard as JPG', image))
     *     .catch(err => console.log(err));
     *
     * // defaults to {format: 'dataURL'}
     * fin.Clipboard.readImage()
     *     .then(image => console.log('Image read from clipboard as DataURL', image))
     *     .catch(err => console.log(err));
     *
     * ```
     */
    async readImage(readRequest = { format: 'dataURL' }) {
        const { payload } = await this.wire.sendAction('clipboard-read-image', readRequest);
        return payload.data;
    }
    /**
     * Writes data into the clipboard as Html
     * @param writeObj The object for writing data into the clipboard
     *
     * @example
     * ```js
     * fin.Clipboard.writeHtml({
     *         data: '<h1>Hello, World!</h1>'
     * }).then(() => console.log('HTML On clipboard')).catch(err => console.log(err));
     * ```
     */
    async writeHtml(writeObj) {
        await this.wire.sendAction('clipboard-write-html', writeObj);
    }
    /**
     * Read the content of the clipboard as Html
     * @param type Clipboard Type defaults to 'clipboard', use 'selection' for linux
     *
     * @example
     * ```js
     * fin.Clipboard.readHtml().then(html => console.log(html)).catch(err => console.log(err));
     * ```
     */
    async readHtml(type) {
        const { payload } = await this.wire.sendAction('clipboard-read-html', { type });
        return payload.data;
    }
    /**
     * Writes data into the clipboard as Rtf
     * @param writeObj The object for writing data into the clipboard
     *
     * @example
     * ```js
     * fin.Clipboard.writeRtf({
     *         data: 'some text goes here'
     * }).then(() => console.log('RTF On clipboard')).catch(err => console.log(err));
     * ```
     */
    async writeRtf(writeObj) {
        await this.wire.sendAction('clipboard-write-rtf', writeObj);
    }
    /**
     * Read the content of the clipboard as Rtf
     * @param type Clipboard Type defaults to 'clipboard', use 'selection' for linux
     *
     * @example
     *
     * ```js
     * const writeObj = {
     *     data: 'some text goes here'
     * };
     * async function readRtf() {
     *     await fin.Clipboard.writeRtf(writeObj);
     *     return await fin.Clipboard.readRtf();
     * }
     * readRtf().then(rtf => console.log(rtf)).catch(err => console.log(err));
     * ```
     */
    async readRtf(type) {
        const { payload } = await this.wire.sendAction('clipboard-read-rtf', { type });
        return payload.data;
    }
    /**
     * Writes data into the clipboard
     * @param writeObj The object for writing data into the clipboard
     *
     * @example
     * ```js
     * fin.Clipboard.write({
     *   data: {
     *     text: 'a',
     *     html: 'b',
     *     rtf: 'c',
     *     // Can be either a base64 string, or a DataURL string. If using DataURL, the
     *     // supported formats are `data:image/png[;base64],` and `data:image/jpeg[;base64],`.
     *     // Using other image/<format> DataURLs will throw an Error.
     *     image: '...'
     *   }
     * }).then(() => console.log('write data into clipboard')).catch(err => console.log(err));
     * ```
     */
    async write(writeObj) {
        await this.wire.sendAction('clipboard-write', writeObj);
    }
    /**
     * Reads available formats for the clipboard type
     * @param type Clipboard Type defaults to 'clipboard', use 'selection' for linux
     *
     * @example
     * ```js
     * fin.Clipboard.getAvailableFormats().then(formats => console.log(formats)).catch(err => console.log(err));
     * ```
     */
    async getAvailableFormats(type) {
        const { payload } = await this.wire.sendAction('clipboard-read-formats', { type });
        return payload.data;
    }
}
clipboard.Clipboard = Clipboard;

var externalApplication = {};

var Factory$5 = {};

var Instance$4 = {};

Object.defineProperty(Instance$4, "__esModule", { value: true });
Instance$4.ExternalApplication = void 0;
/* eslint-disable import/prefer-default-export */
const base_1$c = base;
/**
 * An ExternalApplication object representing native language adapter connections to the runtime. Allows
 * the developer to listen to {@link OpenFin.ExternalApplicationEvents external application events}.
 * Discovery of connections is provided by {@link System.System.getAllExternalApplications getAllExternalApplications}.</a>
 *
 * Processes that can be wrapped as `ExternalApplication`s include the following:
 * - Processes which have connected to an OpenFin runtime via an adapter
 * - Processes started via `System.launchExternalApplication`
 * - Processes monitored via `System.monitorExternalProcess`
 */
class ExternalApplication extends base_1$c.EmitterBase {
    /**
     * @internal
     */
    constructor(wire, identity) {
        super(wire, 'external-application', identity.uuid);
        this.identity = identity;
    }
    /**
     * Retrieves information about the external application.
     *
     * @example
     * ```js
     * async function getInfo() {
     *     const extApp = await fin.ExternalApplication.wrap('javaApp-uuid');
     *     return await extApp.getInfo();
     * }
     * getInfo().then(info => console.log(info)).catch(err => console.log(err));
     * ```
     */
    getInfo() {
        return this.wire.sendAction('get-external-application-info', this.identity).then(({ payload }) => payload.data);
    }
}
Instance$4.ExternalApplication = ExternalApplication;

Object.defineProperty(Factory$5, "__esModule", { value: true });
Factory$5.ExternalApplicationModule = void 0;
const base_1$b = base;
const Instance_1$4 = Instance$4;
/**
 * Static namespace for OpenFin API methods that interact with the {@link ExternalApplication} class, available under `fin.ExternalApplication`.
 */
class ExternalApplicationModule extends base_1$b.Base {
    /**
     * Asynchronously returns an External Application object that represents an external application.
     * <br>It is possible to wrap a process that does not yet exist, (for example, to listen for startup-related events)
     * provided its uuid is already known.
     * @param uuid The UUID of the external application to be wrapped
     *
     * @example
     * ```js
     * fin.ExternalApplication.wrap('javaApp-uuid');
     * .then(extApp => console.log('wrapped external application'))
     * .catch(err => console.log(err));
     * ```
     */
    wrap(uuid) {
        this.wire.sendAction('external-application-wrap').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return Promise.resolve(new Instance_1$4.ExternalApplication(this.wire, { uuid }));
    }
    /**
     * Synchronously returns an External Application object that represents an external application.
     * <br>It is possible to wrap a process that does not yet exist, (for example, to listen for startup-related events)
     * provided its uuid is already known.
     * @param uuid The UUID of the external application to be wrapped
     *
     * @example
     * ```js
     * const extApp = fin.ExternalApplication.wrapSync('javaApp-uuid');
     * const info = await extApp.getInfo();
     * console.log(info);
     * ```
     */
    wrapSync(uuid) {
        this.wire.sendAction('external-application-wrap-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return new Instance_1$4.ExternalApplication(this.wire, { uuid });
    }
}
Factory$5.ExternalApplicationModule = ExternalApplicationModule;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Entry points for the OpenFin `ExternalApplication` API (`fin.ExternalApplication`).
	 *
	 * * {@link ExternalApplicationModule} contains static members of the `ExternalApplication` type, accessible through `fin.ExternalApplication`.
	 * * {@link ExternalApplication} describes an instance of an OpenFin ExternalApplication, e.g. as returned by `fin.ExternalApplication.getCurrent`.
	 *
	 * These are separate code entities, and are documented separately.  In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
	 * both of these were documented on the same page.
	 *
	 * @packageDocumentation
	 */
	__exportStar(Factory$5, exports);
	__exportStar(Instance$4, exports); 
} (externalApplication));

var frame = {};

var Factory$4 = {};

var Instance$3 = {};

Object.defineProperty(Instance$3, "__esModule", { value: true });
Instance$3._Frame = void 0;
/* eslint-disable import/prefer-default-export */
const base_1$a = base;
/**
 * An iframe represents an embedded HTML page within a parent HTML page. Because this embedded page
 * has its own DOM and global JS context (which may or may not be linked to that of the parent depending
 * on if it is considered out of the root domain or not), it represents a unique endpoint as an OpenFin
 * connection. Iframes may be generated dynamically, or be present on initial page load and each non-CORS
 * iframe has the OpenFin API injected by default. It is possible to opt into cross-origin iframes having
 * the API by setting api.iframe.crossOriginInjection to true in a window's options. To block all iframes
 * from getting the API injected you can set api.frame.sameOriginInjection
 * to false <a href="Window.html#~options" target="_blank">({@link OpenFin.WindowCreationOptions see Window Options})</a>.
 *
 * To be able to directly address this context for eventing and messaging purposes, it needs a
 * unique uuid name pairing. For OpenFin applications and windows this is provided via a configuration
 * object in the form of a manifest URL or options object, but there is no configuration object for iframes.
 * Just as a call to window.open outside of our Window API returns a new window with a random GUID assigned
 * for the name, each iframe that has the API injected will be assigned a GUID as its name, the UUID will be
 * the same as the parent window's.
 *
 * The fin.Frame namespace represents a way to interact with `iframes` and facilitates the discovery of current context
 * (iframe or main window) as well as the ability to listen for {@link OpenFin.FrameEvents frame-specific events}.
 */
class _Frame extends base_1$a.EmitterBase {
    /**
     * @internal
     */
    constructor(wire, identity) {
        super(wire, 'frame', identity.uuid, identity.name);
        this.identity = identity;
    }
    /**
     * Returns a frame info object for the represented frame.
     *
     * @example
     * ```js
     * async function getInfo() {
     *     const frm = await fin.Frame.getCurrent();
     *     return await frm.getInfo();
     * }
     * getInfo().then(info => console.log(info)).catch(err => console.log(err));
     * ```
     */
    getInfo() {
        return this.wire.sendAction('get-frame-info', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Returns a frame info object representing the window that the referenced iframe is
     * currently embedded in.
     *
     * @remarks If the frame is embedded in a view, this will return an invalid stub with empty fields.
     *
     * @example
     * ```js
     * async function getParentWindow() {
     *     const frm = await fin.Frame.getCurrent();
     *     return await frm.getParentWindow();
     * }
     * getParentWindow().then(winInfo => console.log(winInfo)).catch(err => console.log(err));
     * ```
     */
    getParentWindow() {
        return this.wire.sendAction('get-parent-window', this.identity).then(({ payload }) => payload.data);
    }
}
Instance$3._Frame = _Frame;

Object.defineProperty(Factory$4, "__esModule", { value: true });
Factory$4._FrameModule = void 0;
const base_1$9 = base;
const validate_1$2 = validate;
const Instance_1$3 = Instance$3;
/**
 * Static namespace for OpenFin API methods that interact with the {@link _Frame} class, available under `fin.Frame`.
 */
class _FrameModule extends base_1$9.Base {
    /**
     * Asynchronously returns a reference to the specified frame. The frame does not have to exist
     * @param identity - the identity of the frame you want to wrap
     *
     * @example
     * ```js
     * fin.Frame.wrap({ uuid: 'testFrame', name: 'testFrame' })
     * .then(frm => console.log('wrapped frame'))
     * .catch(err => console.log(err));
     * ```
     */
    async wrap(identity) {
        this.wire.sendAction('frame-wrap').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = (0, validate_1$2.validateIdentity)(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1$3._Frame(this.wire, identity);
    }
    /**
     * Synchronously returns a reference to the specified frame. The frame does not have to exist
     * @param identity - the identity of the frame you want to wrap
     *
     * @example
     * ```js
     * const frm = fin.Frame.wrapSync({ uuid: 'testFrame', name: 'testFrame' });
     * const info = await frm.getInfo();
     * console.log(info);
     * ```
     */
    wrapSync(identity) {
        this.wire.sendAction('frame-wrap-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = (0, validate_1$2.validateIdentity)(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1$3._Frame(this.wire, identity);
    }
    /**
     * Asynchronously returns a reference to the current frame
     *
     * @example
     * ```js
     * fin.Frame.getCurrent()
     * .then(frm => console.log('current frame'))
     * .catch(err => console.log(err));
     * ```
     */
    getCurrent() {
        this.wire.sendAction('frame-get-current').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return Promise.resolve(new Instance_1$3._Frame(this.wire, this.wire.environment.getCurrentEntityIdentity()));
    }
    /**
     * Synchronously returns a reference to the current frame
     *
     * @example
     * ```js
     * const frm = fin.Frame.getCurrentSync();
     * const info = await frm.getInfo();
     * console.log(info);
     * ```
     */
    getCurrentSync() {
        this.wire.sendAction('frame-get-current-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return new Instance_1$3._Frame(this.wire, this.wire.environment.getCurrentEntityIdentity());
    }
}
Factory$4._FrameModule = _FrameModule;

(function (exports) {
	/**
	 * Entry points for the OpenFin `Frame` API (`fin.Frame`).
	 *
	 * * {@link _FrameModule} contains static members of the `Frame` API, accessible through `fin.Frame`.
	 * * {@link _Frame} describes an instance of an OpenFin Frame, e.g. as returned by `fin.Frame.getCurrent`.
	 *
	 * These are separate code entities, and are documented separately. In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
	 * both of these were documented on the same page.
	 *
	 * Underscore prefixing of OpenFin types that alias DOM entities will be fixed in a future version.
	 *
	 * @packageDocumentation
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(Factory$4, exports);
	__exportStar(Instance$3, exports); 
} (frame));

var globalHotkey = {};

Object.defineProperty(globalHotkey, "__esModule", { value: true });
globalHotkey.GlobalHotkey = void 0;
const base_1$8 = base;
/**
 * The GlobalHotkey module can register/unregister a global hotkeys.
 *
 */
class GlobalHotkey extends base_1$8.EmitterBase {
    /**
     * @internal
     */
    constructor(wire) {
        super(wire, 'global-hotkey');
    }
    /**
     * Registers a global hotkey with the operating system.
     * @param hotkey a hotkey string
     * @param listener called when the registered hotkey is pressed by the user.
     * @throws If the `hotkey` is reserved, see list below.
     * @throws if the `hotkey` is already registered by another application.
     *
     * @remarks The `hotkey` parameter expects an electron compatible [accelerator](https://github.com/electron/electron/blob/master/docs/api/accelerator.md) and the `listener` will be called if the `hotkey` is pressed by the user.
     * If successfull, the hotkey will be 'claimed' by the application, meaning that this register call can be called multiple times from within the same application but will fail if another application has registered the hotkey.
     * <br>The register call will fail if given any of these reserved Hotkeys:
     * * `CommandOrControl+0`
     * * `CommandOrControl+=`
     * * `CommandOrControl+Plus`
     * * `CommandOrControl+-`
     * * `CommandOrControl+_`
     * * `CommandOrControl+Shift+I`
     * * `F5`
     * * `CommandOrControl+R`
     * * `Shift+F5`
     * * `CommandOrControl+Shift+R`
     *
     * Raises the `registered` event.
     *
     * @example
     * ```js
     * const hotkey = 'CommandOrControl+X';
     *
     * fin.GlobalHotkey.register(hotkey, () => {
     * console.log(`${hotkey} pressed`);
     * })
     * .then(() => {
     *     console.log('Success');
     * })
     * .catch(err => {
     *     console.log('Error registering the hotkey', err);
     * });
     * ```
     */
    async register(hotkey, listener) {
        // TODO: fix typing (hotkey events are not typed)
        // @ts-expect-error
        await this.on(hotkey, listener);
        await this.wire.sendAction('global-hotkey-register', { hotkey });
        return undefined;
    }
    /**
     * Unregisters a global hotkey with the operating system.
     * @param hotkey a hotkey string
     *
     * @remarks This method will unregister all existing registrations of the hotkey within the application.
     * Raises the `unregistered` event.
     *
     * @example
     * ```js
     * const hotkey = 'CommandOrControl+X';
     *
     * fin.GlobalHotkey.unregister(hotkey)
     * .then(() => {
     *     console.log('Success');
     * })
     * .catch(err => {
     *     console.log('Error unregistering the hotkey', err);
     * });
     * ```
     */
    async unregister(hotkey) {
        // TODO: fix typing (hotkey events are not typed)
        // @ts-expect-error
        await this.removeAllListeners(hotkey);
        await this.wire.sendAction('global-hotkey-unregister', { hotkey });
        return undefined;
    }
    /**
     * Unregisters all global hotkeys for the current application.
     *
     * @remarks Raises the `unregistered` event for each hotkey unregistered.
     *
     * @example
     * ```js
     * fin.GlobalHotkey.unregisterAll()
     * .then(() => {
     *     console.log('Success');
     * })
     * .catch(err => {
     *     console.log('Error unregistering all hotkeys for this application', err);
     * });
     * ```
     */
    async unregisterAll() {
        await Promise.all(this.eventNames()
            .filter((name) => !(name === 'registered' || name === 'unregistered'))
            // TODO: fix typing (hotkey events are not typed)
            // @ts-expect-error
            .map((name) => this.removeAllListeners(name)));
        await this.wire.sendAction('global-hotkey-unregister-all', {});
        return undefined;
    }
    /**
     * Checks if a given hotkey has been registered by an application within the current runtime.
     * @param hotkey a hotkey string
     *
     * @example
     * ```js
     * const hotkey = 'CommandOrControl+X';
     *
     * fin.GlobalHotkey.isRegistered(hotkey)
     * .then((registered) => {
     *     console.log(`hotkey ${hotkey} is registered ? ${registered}`);
     * })
     * .catch(err => {
     *     console.log('Error unregistering the hotkey', err);
     * });
     * ```
     */
    async isRegistered(hotkey) {
        const { payload: { data } } = await this.wire.sendAction('global-hotkey-is-registered', { hotkey });
        return data;
    }
}
globalHotkey.GlobalHotkey = GlobalHotkey;

var platform = {};

var Factory$3 = {};

var Instance$2 = {};

var __classPrivateFieldGet$6 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Platform_connectToProvider;
Object.defineProperty(Instance$2, "__esModule", { value: true });
Instance$2.Platform = void 0;
/* eslint-disable import/prefer-default-export, no-undef */
const base_1$7 = base;
const validate_1$1 = validate;
// Reuse clients to avoid overwriting already-registered client in provider
const clientMap = new Map();
/** Manages the life cycle of windows and views in the application.
 *
 * Enables taking snapshots of itself and applying them to restore a previous configuration
 * as well as listen to {@link OpenFin.PlatformEvents platform events}.
 */
class Platform extends base_1$7.EmitterBase {
    /**
     * @internal
     */
    // eslint-disable-next-line no-shadow
    constructor(identity, channel) {
        // we piggyback off of application event emitter because from the core's perspective platform is just an app.
        super(channel.wire, 'application', identity.uuid);
        this.getClient = (identity) => {
            this.wire.sendAction('platform-get-client', this.identity).catch((e) => {
                // don't expose
            });
            const target = identity || this.identity;
            const { uuid } = target;
            if (!clientMap.has(uuid)) {
                const clientPromise = __classPrivateFieldGet$6(this, _Platform_connectToProvider, "f").call(this, uuid);
                clientMap.set(uuid, clientPromise);
            }
            // we set it above
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return clientMap.get(uuid);
        };
        _Platform_connectToProvider.set(this, async (uuid) => {
            try {
                const channelName = `custom-frame-${uuid}`;
                const client = await this._channel.connect(channelName, { wait: false });
                client.onDisconnection(() => {
                    clientMap.delete(uuid);
                });
                return client;
            }
            catch (e) {
                clientMap.delete(uuid);
                throw new Error('The targeted Platform is not currently running. Listen for application-started event for the given Uuid.');
            }
        });
        /**
         * @deprecated (renamed)
         * @ignore
         */
        this.launchLegacyManifest = this.launchContentManifest;
        const errorMsg = (0, validate_1$1.validateIdentity)(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        this._channel = channel;
        this.identity = { uuid: identity.uuid };
        this.Layout = this.fin.Platform.Layout;
        this.Application = this.fin.Application.wrapSync(this.identity);
    }
    /**
     * Creates a new view and attaches it to a specified target window.
     * @param viewOptions View creation options
     * @param target The window to which the new view is to be attached. If no target, create a view in a new window.
     * @param targetView If provided, the new view will be added to the same tabstrip as targetView.
     *
     * @remarks If the view already exists, will reparent the view to the new target. You do not need to set a name for a View.
     * Views that are not passed a name get a randomly generated one.
     *
     * @example
     * ```js
     * let windowIdentity;
     * if (fin.me.isWindow) {
     *     windowIdentity = fin.me.identity;
     * } else if (fin.me.isView) {
     *     windowIdentity = (await fin.me.getCurrentWindow()).identity;
     * } else {
     *     throw new Error('Not running in a platform View or Window');
     * }
     *
     * const platform = fin.Platform.getCurrentSync();
     *
     * platform.createView({
     *     name: 'test_view',
     *     url: 'https://developers.openfin.co/docs/platform-api'
     * }, windowIdentity).then(console.log);
     * ```
     *
     * Reparenting a view:
     * ```js
     * let windowIdentity;
     * if (fin.me.isWindow) {
     *     windowIdentity = fin.me.identity;
     * } else if (fin.me.isView) {
     *     windowIdentity = (await fin.me.getCurrentWindow()).identity;
     * } else {
     *     throw new Error('Not running in a platform View or Window');
     * }
     *
     * let platform = fin.Platform.getCurrentSync();
     * let viewOptions = {
     *     name: 'example_view',
     *     url: 'https://example.com'
     * };
     * // a new view will now show in the current window
     * await platform.createView(viewOptions, windowIdentity);
     *
     * const view = fin.View.wrapSync({ uuid: windowIdentity.uuid, name: 'yahoo_view' });
     * // reparent `example_view` when a view in the new window is shown
     * view.on('shown', async () => {
     *     let viewIdentity = { uuid: windowIdentity.uuid, name: 'example_view'};
     *     let target = {uuid: windowIdentity.uuid, name: 'test_win'};
     *     platform.createView(viewOptions, target);
     * });
     *
     * // create a new window
     * await platform.createWindow({
     *     name: "test_win",
     *     layout: {
     *         content: [
     *             {
     *                 type: 'stack',
     *                 content: [
     *                     {
     *                         type: 'component',
     *                         componentName: 'view',
     *                         componentState: {
     *                             name: 'yahoo_view',
     *                             url: 'https://yahoo.com'
     *                         }
     *                     }
     *                 ]
     *             }
     *         ]
     *     }
     * }).then(console.log);
     * ```
     */
    async createView(viewOptions, target, targetView) {
        this.wire.sendAction('platform-create-view', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        const response = await client.dispatch('create-view', {
            target,
            opts: viewOptions,
            targetView
        });
        if (!response || (0, validate_1$1.validateIdentity)(response.identity)) {
            throw new Error(`When overwriting the createView call, please return an object that has a valid 'identity' property: ${JSON.stringify(response)}`);
        }
        return this.fin.View.wrapSync(response.identity);
    }
    /**
     * Creates a new Window.
     * @param options Window creation options
     *
     * @remarks There are two Window types at your disposal while using OpenFin Platforms - Default Window and Custom Window.
     *
     * The Default Window uses the standard OpenFin Window UI. It contains the standard close, maximize and minimize buttons,
     * and will automatically render the Window's layout if one is specified.
     *
     * For deeper customization, you can bring your own Window code into a Platform. This is called a Custom Window.
     *
     * @example
     *
     *
     * The example below will create a Default Window which uses OpenFin default Window UI.<br>
     * The Window contains two Views in a stack Layout:
     *
     * ```js
     * const platform = fin.Platform.getCurrentSync();
     * platform.createWindow({
     *     layout: {
     *         content: [
     *             {
     *                 type: 'stack',
     *                 content: [
     *                     {
     *                         type: 'component',
     *                         componentName: 'view',
     *                         componentState: {
     *                             name: 'test_view_1',
     *                             url: 'https://cdn.openfin.co/docs/javascript/canary/Platform.html'
     *                         }
     *                     },
     *                     {
     *                         type: 'component',
     *                         componentName: 'view',
     *                         componentState: {
     *                             name: 'test_view_2',
     *                             url: 'https://cdn.openfin.co/docs/javascript/canary/Platform.html'
     *                         }
     *                     }
     *                 ]
     *             }
     *         ]
     *     }
     * }).then(console.log);
     * ```
     * The Default Window's design can be customized by specifying the `stylesheetUrl` property in the manifest:
     *
     * ```json
     * {
     *     platform: {
     *         defaultWindowOptions: {
     *             stylesheetUrl: 'some-url.css',
     *             ...
     *         }
     *     }
     * }
     * ```
     * For a list of common Layout CSS classes you can override in your custom stylesheet, see <a href="tutorial-layoutStyles.html">Useful Layout CSS Classes</a>
     **
     * To specify a Platform Custom Window, provide a `url` property when creating a Window.
     * If you intend to render a Layout in your Custom Window, you must also specify an `HTMLElement` that the Layout will inject into and set its `id` property to `"layout-container"`.
     *
     * The example below will create a Platform Custom Window:
     *
     * ```js
     *     // in an OpenFin app:
     *     const platform = fin.Platform.getCurrentSync();
     *     const windowConfig =
     *         {
     *             url: "https://www.my-domain.com/my-custom-window.html", // here we point to where the Custom Frame is hosted.
     *             layout: {
     *                 content: [
     *                     {
     *                         type: "stack",
     *                         content: [
     *                             {
     *                                 type: "component",
     *                                 componentName: "view",
     *                                 componentState: {
     *                                     name: "app #1",
     *                                     url: "https://cdn.openfin.co/docs/javascript/canary/Platform.html"
     *                                 }
     *                             },
     *                             {
     *                                 type: "component",
     *                                 componentName: "view",
     *                                 componentState: {
     *                                     name: "app #2",
     *                                     url: "https://cdn.openfin.co/docs/javascript/canary/Platform.html"
     *                                 }
     *                             }
     *                         ]
     *                     }
     *                 ]
     *             }
     *         };
     *     platform.createWindow(windowConfig);
     * ```
     *
     * Here's an example of a minimalist Custom Platform Window implementation:
     * ```html
     * <html>
     *     <head>
     *         <meta charset="utf-8">
     *         <meta name="viewport" content="width=device-width, initial-scale=1">
     *         <link rel="stylesheet" type="text/css" href="./styles.css">
     *     </head>
     *     <body>
     *         <div id="of-frame-main">
     *             <div id="title-bar">
     *                 <div class="title-bar-draggable">
     *                     <div id="title"> This is a custom frame! </div>
     *                 </div>
     *                 <div id="buttons-wrapper">
     *                     <div class="button" id="minimize-button"></div>
     *                     <div class="button" id="expand-button"></div>
     *                     <div class="button" id="close-button"></div>
     *                 </div>
     *             </div>
     *             <div id="layout-container"></div> <!-- OpenFin layout would be injected here -->
     *             <script src="./custom-frame.js"></script>
     *         </div>
     *     </body>
     * </html>
     * ```
     * Your Custom Window can use in-domain resources for further customization (such as CSS, scripts, etc.).<br>
     * For a list of common Layout CSS classes you can override in your stylesheet, see <a href="tutorial-layoutStyles.html">Useful Layout CSS Classes</a>
     *
     * The example above will require the `body` element to have `height: 100%;` set in order to render the layout correctly.
     */
    async createWindow(options) {
        this.wire.sendAction('platform-create-window', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        if (!options.reason) {
            options.reason = 'api-call';
        }
        const response = await client.dispatch('create-view-container', options);
        if (!response || (0, validate_1$1.validateIdentity)(response.identity)) {
            throw new Error(`When overwriting the createWindow call, please return an object that has a valid 'identity' property: ${JSON.stringify(response)}`);
        }
        const { identity } = response;
        const res = this.fin.Window.wrapSync(identity);
        // we add the identity at the top level for backwards compatibility.
        res.name = identity.name;
        res.uuid = identity.uuid;
        return res;
    }
    /**
     * Closes current platform, all its windows, and their views.
     *
     * @example
     * ```js
     * const platform = await fin.Platform.getCurrent();
     * platform.quit();
     * // All windows/views in current layout platform will close and platform will shut down
     * ```
     */
    async quit() {
        this.wire.sendAction('platform-quit', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        return client.dispatch('quit');
    }
    /**
     * Closes a specified view in a target window.
     * @param viewIdentity View identity
     *
     * @example
     * ```js
     * let windowIdentity;
     * if (fin.me.isWindow) {
     *     windowIdentity = fin.me.identity;
     * } else if (fin.me.isView) {
     *     windowIdentity = (await fin.me.getCurrentWindow()).identity;
     * } else {
     *     throw new Error('Not running in a platform View or Window');
     * }
     *
     * const viewOptions = {
     *     name: 'test_view',
     *     url: 'https://example.com'
     * };
     *
     * function sleep(ms) {
     *     return new Promise(resolve => setTimeout(resolve, ms));
     * }
     *
     * const platform = await fin.Platform.getCurrent();
     *
     * await platform.createView(viewOptions, windowIdentity);
     * // a new view will now show in the current window
     *
     * await sleep(5000);
     *
     * const viewIdentity = { uuid: windowIdentity.uuid, name: 'test_view'};
     * platform.closeView(viewIdentity);
     * // the view will now close
     * ```
     */
    async closeView(viewIdentity) {
        this.wire.sendAction('platform-close-view', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        await client.dispatch('close-view', {
            view: viewIdentity
        });
    }
    /**
     * ***DEPRECATED - please use {@link Platform.createView Platform.createView}.***
     * Reparents a specified view in a new target window.
     * @param viewIdentity View identity
     * @param target new owner window identity
     *
     */
    async reparentView(viewIdentity, target) {
        // eslint-disable-next-line no-console
        console.warn('Platform.reparentView has been deprecated, please use Platform.createView');
        this.wire.sendAction('platform-reparent-view', this.identity).catch((e) => {
            // don't expose
        });
        const normalizedViewIdentity = {
            ...viewIdentity,
            uuid: viewIdentity.uuid ?? this.identity.uuid
        };
        const view = await this.fin.View.wrap(normalizedViewIdentity);
        const viewOptions = await view.getOptions();
        return this.createView(viewOptions, target);
    }
    /**
     * Returns a snapshot of the platform in its current state. You can pass the returning object to
     * [Platform.applySnapshot]{@link Platform#applySnapshot} to launch it.
     *
     * @remarks The snapshot will include details such as an [ISO format](https://en.wikipedia.org/wiki/ISO_8601)
     * timestamp of when the snapshot was taken, OpenFin runtime version the platform is running on, monitor information
     * and the list of currently running windows.
     *
     * @example
     * ```js
     * const platform = await fin.Platform.getCurrent();
     * const snapshot = await platform.getSnapshot();
     * ```
     */
    async getSnapshot() {
        this.wire.sendAction('platform-get-snapshot', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        return client.dispatch('get-snapshot');
    }
    /**
     * **NOTE**: Internal use only. It is not recommended to manage the state of individual views.
     *
     * Returns a snapshot of a single view's options in its current state.
     *
     * Can be used to restore a view to a previous state.
     *
     * @param viewIdentity View identity
     *
     * @internal
     * @experimental
     * @remarks This slice of snapshot state is equivalent to what is stored as `componentState` for views
     * when capturing platform state using [Platform.getSnapshot]{@link Platform#getSnapshot}.
     *
     * @example
     * ```js
     * const platform = await fin.Platform.getCurrent();
     * const url = 'https://google.com';
     * const view = await fin.View.create({ name: 'my-view', target: fin.me.identity, url });
     *
     * await view.navigate(url);
     *
     * const viewState = await platform.getViewSnapshot(view.identity);
     *
     * console.log(viewState);
     * ```
     */
    async getViewSnapshot(viewIdentity) {
        const client = await this.getClient();
        return client.dispatch('get-view-snapshot', { viewIdentity });
    }
    /**
     * Adds a snapshot to a running Platform.
     * Requested snapshot must be a valid Snapshot object, or a url or filepath to such an object.
     *
     * Can optionally close existing windows and overwrite current platform state with that of a snapshot.
     *
     * The function accepts either a snapshot taken using {@link Platform#getSnapshot getSnapshot},
     * or a url or filepath to a snapshot JSON object.
     * @param requestedSnapshot Snapshot to apply, or a url or filepath.
     * @param options Optional parameters to specify whether existing windows should be closed.
     *
     * @remarks Will create any windows and views that are not running but are passed in the snapshot object. Any View
     * specified in the snapshot is assigned a randomly generated name to avoid collisions.
     *
     * @example
     * ```js
     * // Get a wrapped layout platform instance
     * const platform = await fin.Platform.getCurrent();
     *
     * const snapshot = {
     *     windows: [
     *         {
     *             layout: {
     *                 content: [
     *                     {
     *                         type: 'stack',
     *                         content: [
     *                             {
     *                                 type: 'component',
     *                                 componentName: 'view',
     *                                 componentState: {
     *                                     name: 'component_X',
     *                                     url: 'https://www.openfin.co'
     *                                 }
     *                             },
     *                             {
     *                                 type: 'component',
     *                                 componentName: 'view',
     *                                 componentState: {
     *                                     name: 'component_Y',
     *                                     url: 'https://cdn.openfin.co/embed-web/chart.html'
     *                                 }
     *                             }
     *                         ]
     *                     }
     *                 ]
     *             }
     *         }
     *     ]
     * }
     *
     * platform.applySnapshot(snapshot);
     * ```
     *
     * In place of a snapshot object, `applySnapshot` can take a url or filepath and to retrieve a JSON snapshot.
     *
     * ```js
     * const platform = await fin.Platform.getCurrent();
     * platform.applySnapshot('https://api.jsonbin.io/b/5e6f903ef4331e681fc1231d/1');
     * ```
     *
     * Optionally, `applySnapshot` can close existing windows and restore a Platform to a previously saved state.
     * This is accomplished by providing `{ closeExistingWindows: true }` as an option.
     *
     * ```js
     * // Get a wrapped layout platform instance
     * const platform = await fin.Platform.getCurrent();
     *
     * async function addViewToWindow(winId) {
     *     return await platform.createView({
     *         name: 'test_view_3',
     *         url: 'https://openfin.co'
     *     }, winId);
     * }
     *
     * async function createWindowWithTwoViews() {
     *     const platform = await fin.Platform.getCurrent();
     *
     *     return platform.createWindow({
     *         layout: {
     *             content: [
     *                 {
     *                     type: 'stack',
     *                     content: [
     *                         {
     *                             type: 'component',
     *                             componentName: 'view',
     *                             componentState: {
     *                                 name: 'test_view_1',
     *                                 url: 'https://example.com'
     *                             }
     *                         },
     *                         {
     *                             type: 'component',
     *                             componentName: 'view',
     *                             componentState: {
     *                                 name: 'test_view_2',
     *                                 url: 'https://yahoo.com'
     *                             }
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     });
     * }
     *
     * const win = await createWindowWithTwoViews();
     * // ... you will now see a new window with two views in it
     *
     * // we take a snapshot of the current state of the app, before changing it
     * const snapshotOfInitialAppState = await platform.getSnapshot();
     *
     * // now let's change the state of the app:
     * await addViewToWindow(win.identity);
     * // ... the window now has three views in it
     *
     * await platform.applySnapshot(snapshotOfInitialAppState, { closeExistingWindows: true });
     * // ... the window will revert to previous state, with just two views
     *
     * ```
     */
    async applySnapshot(requestedSnapshot, options) {
        this.wire.sendAction('platform-apply-snapshot', this.identity).catch((e) => {
            // don't expose
        });
        const errMsg = 'Requested snapshot must be a valid Snapshot object, or a url or filepath to such an object.';
        let snapshot;
        if (typeof requestedSnapshot === 'string') {
            // Fetch and parse snapshot
            try {
                const response = await this._channel.wire.sendAction('get-application-manifest', {
                    manifestUrl: requestedSnapshot
                });
                snapshot = response.payload.data;
            }
            catch (err) {
                throw new Error(`${errMsg}: ${err}`);
            }
        }
        else {
            snapshot = requestedSnapshot;
        }
        if (!snapshot.windows) {
            throw new Error(errMsg);
        }
        const client = await this.getClient();
        await client.dispatch('apply-snapshot', {
            snapshot,
            options
        });
        return this;
    }
    /**
     * Fetches a JSON manifest using the browser process and returns a Javascript object.
     * Can be overwritten using {@link Platform.PlatformModule.init Platform.init}.
     * @param manifestUrl The URL of the manifest to fetch.
     *
     * @remarks Can be overwritten using {@link Platform#init Platform.init}.
     *
     * @example
     *
     * ```js
     * const platform = fin.Platform.getCurrentSync();
     * const manifest = await platform.fetchManifest('https://www.path-to-manifest.com/app.json');
     * console.log(manifest);
     * ```
     */
    async fetchManifest(manifestUrl) {
        const client = await this.getClient();
        return client.dispatch('platform-fetch-manifest', { manifestUrl });
    }
    /**
     * Retrieves a manifest by url and launches a legacy application manifest or snapshot into the platform.  Returns a promise that
     * resolves to the wrapped Platform.
     * @param manifestUrl - The URL of the manifest that will be launched into the platform.  If this app manifest
     * contains a snapshot, that will be launched into the platform.  If not, the application described in startup_app options
     * will be launched into the platform. The applicable startup_app options will become {@link OpenFin.ViewCreationOptions View Options}.
     *
     * @remarks If the app manifest contains a snapshot, that will be launched into the platform.  If not, the
     * application described in startup_app options will be launched into the platform as a window with a single view.
     * The applicable startup_app options will become View Options.
     *
     * @example
     * ```js
     * try {
     *     const platform = fin.Platform.getCurrentSync();
     *     await platform.launchContentManifest('http://localhost:5555/app.json');
     *     console.log(`content launched successfully into platform`);
     * } catch(e) {
     *     console.error(e);
     * }
     * // For a local manifest file:
     * try {
     *     const platform = fin.Platform.getCurrentSync();
     *     platform.launchContentManifest('file:///C:/somefolder/app.json');
     *     console.log(`content launched successfully into platform`);
     * } catch(e) {
     *     console.error(e);
     * }
     * ```
     * @experimental
     */
    async launchContentManifest(manifestUrl) {
        this.wire.sendAction('platform-launch-content-manifest', this.identity).catch(() => {
            // don't expose
        });
        const client = await this.getClient();
        const manifest = await this.fetchManifest(manifestUrl);
        client.dispatch('launch-into-platform', { manifest, manifestUrl });
        return this;
    }
    /**
     * Set the context of a host window. The context will be available to the window itself, and to its child Views. It will be saved in any platform snapshots.
     * It can be retrieved using {@link Platform#getWindowContext getWindowContext}.
     * @param context - A field where serializable context data can be stored to be saved in platform snapshots.
     * @param target - A target window or view may optionally be provided. If no target is provided, the update will be applied
     * to the current window (if called from a Window) or the current host window (if called from a View).
     *
     * @remarks The context data must be serializable.  This can only be called from a window or view that has been launched into a
     * platform.
     * This method can be called from the window itself, or from any child view. Context data is shared by all
     * entities within a window.
     *
     * @example
     * Setting own context:
     * ```js
     * const platform = fin.Platform.getCurrentSync();
     * const contextData = {
     *     security: 'STOCK',
     *     currentView: 'detailed'
     * }
     *
     * await platform.setWindowContext(contextData);
     * // Context of current window is now set to `contextData`
     * ```
     *
     * Setting the context of another window or view:
     * ```js
     * const platform = fin.Platform.getCurrentSync();
     * const contextData = {
     *     security: 'STOCK',
     *     currentView: 'detailed'
     * }
     *
     * const windowOrViewIdentity = { uuid: fin.me.uuid, name: 'nameOfWindowOrView' };
     * await platform.setWindowContext(contextData, windowOrViewIdentity);
     * // Context of the target window or view is now set to `contextData`
     * ```
     *
     * A view can listen to changes to its host window's context by listening to the `host-context-changed` event.
     * This event will fire when a host window's context is updated or when the view is reparented to a new window:
     *
     * ```js
     * // From a view
     * const contextChangeHandler = ({ context }) => {
     *     console.log('Host window\'s context has changed. New context data:', context);
     *     // react to new context data here
     * }
     * await fin.me.on('host-context-changed', contextChangeHandler);
     *
     * const platform = await fin.Platform.getCurrentSync();
     * const contextData = {
     *     security: 'STOCK',
     *     currentView: 'detailed'
     * }
     * platform.setWindowContext(contextData) // contextChangeHandler will log the new context
     * ```
     *
     * To listen to a window's context updates, use the `context-changed` event:
     * ```js
     * // From a window
     * const contextChangeHandler = ({ context }) => {
     *     console.log('This window\'s context has changed. New context data:', context);
     *     // react to new context data here
     * }
     * await fin.me.on('context-changed', contextChangeHandler);
     *
     * const platform = await fin.Platform.getCurrentSync();
     * const contextData = {
     *     security: 'STOCK',
     *     currentView: 'detailed'
     * }
     * platform.setWindowContext(contextData) // contextChangeHandler will log the new context
     * ```
     * @experimental
     */
    async setWindowContext(context = {}, target) {
        this.wire.sendAction('platform-set-window-context', this.identity).catch((e) => {
            // don't expose
        });
        if (!context) {
            throw new Error('Please provide a serializable object or string to set the context.');
        }
        const client = await this.getClient();
        const { entityType } = target ? await this.fin.System.getEntityInfo(target.uuid, target.name) : this.fin.me;
        await client.dispatch('set-window-context', {
            context,
            entityType,
            target: target || { uuid: this.fin.me.uuid, name: this.fin.me.name }
        });
    }
    /**
     * Get the context context of a host window that was previously set using {@link Platform#setWindowContext setWindowContext}.
     * The context will be saved in any platform snapshots.  Returns a promise that resolves to the context.
     * @param target - A target window or view may optionally be provided. If no target is provided, target will be
     * the current window (if called from a Window) or the current host window (if called from a View).
     *
     * @remarks This method can be called from the window itself, or from any child view. Context data is shared
     * by all entities within a window.
     *
     * @example
     *
     * Retrieving context from current window:
     * ```js
     * const platform = fin.Platform.getCurrentSync();
     * const customContext = { answer: 42 };
     * await platform.setWindowContext(customContext);
     *
     * const myContext = await platform.getWindowContext();
     * console.log(myContext); // { answer: 42 }
     * ```
     *
     * Retrieving the context of another window or view:
     * ```js
     * const platform = fin.Platform.getCurrentSync();
     *
     * const windowOrViewIdentity = { uuid: fin.me.uuid, name: 'nameOfWindowOrView' };
     *
     * const targetWindowContext = await platform.getWindowContext(windowOrViewIdentity);
     * console.log(targetWindowContext); // context of target window
     * ```
     * @experimental
     */
    async getWindowContext(target) {
        this.wire.sendAction('platform-get-window-context', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        const { entityType } = target ? await this.fin.System.getEntityInfo(target.uuid, target.name) : this.fin.me;
        return client.dispatch('get-window-context', {
            target: target || { uuid: this.fin.me.uuid, name: this.fin.me.name },
            entityType
        });
    }
    /**
     * Closes a window. If enableBeforeUnload is enabled in the Platform options, any beforeunload handler set on Views will fire
     * This behavior can be disabled by setting skipBeforeUnload to false in the options parameter.
     * @param winId
     * @param options
     *
     * @remarks This method works by setting a `close-requested` handler on the Platform Window. If you have your own `close-requested` handler set on the Platform Window as well,
     * it is recommended to move that logic over to the [PlatformProvider.closeWindow]{@link PlatformProvider#closeWindow} override to ensure it runs when the Window closes.
     *
     * @example
     *
     * ```js
     * // Close the current Window inside a Window context
     * const platform = await fin.Platform.getCurrent();
     * platform.closeWindow(fin.me.identity);
     *
     * // Close the Window from inside a View context
     * const platform = await fin.Platform.getCurrent();
     * const parentWindow = await fin.me.getCurrentWindow();
     * platform.closeWindow(parentWindow.identity);
     *
     * // Close the Window and do not fire the before unload handler on Views
     * const platform = await fin.Platform.getCurrent();
     * platform.closeWindow(fin.me.identity, { skipBeforeUnload: true });
     * ```
     * @experimental
     */
    async closeWindow(windowId, options = { skipBeforeUnload: false }) {
        this.wire.sendAction('platform-close-window', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        return client.dispatch('close-window', { windowId, options });
    }
}
Instance$2.Platform = Platform;
_Platform_connectToProvider = new WeakMap();

var layout = {};

var Factory$2 = {};

var Instance$1 = {};

var commonUtils = {};

Object.defineProperty(commonUtils, "__esModule", { value: true });
commonUtils.overrideFromComposables = commonUtils.isValidPresetType = void 0;
function isValidPresetType(type) {
    switch (type) {
        case 'columns':
        case 'grid':
        case 'rows':
        case 'tabs':
            return true;
        default:
            return false;
    }
}
commonUtils.isValidPresetType = isValidPresetType;
function overrideFromComposables(...overrides) {
    return (base) => overrides.reduceRight((p, c) => (b) => c(p(b)), (x) => x)(base);
}
commonUtils.overrideFromComposables = overrideFromComposables;
commonUtils.default = { isValidPresetType };

var __classPrivateFieldGet$5 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Layout_layoutClient;
Object.defineProperty(Instance$1, "__esModule", { value: true });
Instance$1.Layout = void 0;
const lazy_1 = lazy;
const validate_1 = validate;
const base_1$6 = base;
const common_utils_1 = commonUtils;
const layout_entities_1 = layoutEntities;
const layout_constants_1$1 = layout_constants;
/**
 *
 * Layouts give app providers the ability to embed multiple views in a single window. The Layout namespace
 * enables the initialization and manipulation of a window's Layout. A Layout will
 * emit events locally on the DOM element representing the layout-container.
 *
 *
 * ### Layout.DOMEvents
 *
 * When a Layout is created, it emits events onto the DOM element representing the Layout container.
 * This Layout container is the DOM element referenced by containerId in {@link Layout.LayoutModule#init Layout.init}.
 * You can use the built-in event emitter to listen to these events using [addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener).
 * The events are emitted synchronously and only in the process where the Layout exists.
 * Any values returned by the called listeners are ignored and will be discarded.
 * If the target DOM element is destroyed, any events that have been set up on that element will be destroyed.
 *
 * @remarks The built-in event emitter is not an OpenFin event emitter so it doesn't share propagation semantics.
 *
 * #### {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener addEventListener(type, listener [, options]);}
 * Adds a listener to the end of the listeners array for the specified event.
 * @example
 * ```js
 * const myLayoutContainer = document.getElementById('layout-container');
 *
 * myLayoutContainer.addEventListener('tab-created', function(event) {
 *      const { tabSelector } = event.detail;
 *      const tabElement = document.getElementById(tabSelector);
 *      const existingColor = tabElement.style.backgroundColor;
 *      tabElement.style.backgroundColor = "red";
 *      setTimeout(() => {
 *          tabElement.style.backgroundColor = existingColor;
 *      }, 2000);
 * });
 * ```
 *
 * #### {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener removeEventListener(type, listener [, options]);}
 * Adds a listener to the end of the listeners array for the specified event.
 * @example
 * ```js
 * const myLayoutContainer = document.getElementById('layout-container');
 *
 * const listener = function(event) {
 *     console.log(event.detail);
 *     console.log('container-created event fired once, removing listener');
 *     myLayoutContainer.removeEventListener('container-created', listener);
 * };
 *
 * myLayoutContainer.addEventListener('container-created', listener);
 * ```
 *
 * ### Supported event types are:
 *
 * * tab-created
 * * container-created
 * * layout-state-changed
 * * tab-closed
 * * tab-dropped
 *
 * ### Layout DOM Node Events
 *
 * #### tab-created
 * Generated when a tab is created.  As a user drags and drops tabs within window, new tabs are created.  A single view may have multiple tabs created and destroyed during its lifetime attached to a single window.
 * ```js
 * // The response has the following shape in event.detail:
 * {
 *     containerSelector: "container-component_A",
 *     name: "component_A",
 *     tabSelector: "tab-component_A",
 *     topic: "openfin-DOM-event",
 *     type: "tab-created",
 *     uuid: "OpenFin POC"
 * }
 * ```
 *
 * #### container-created
 * Generated when a container is created.  A single view will have only one container during its lifetime attached to a single window and the container's lifecycle is tied to the view.  To discover when the container is destroyed, please listen to view-detached event.
 * ```js
 * // The response has the following shape in event.detail:
 * {
 *     containerSelector: "container-component_A",
 *     name: "component_A",
 *     tabSelector: "tab-component_A",
 *     topic: "openfin-DOM-event",
 *     type: "container-created",
 *     uuid: "OpenFin POC"
 * }
 * ```
 *
 * ### layout-state-changed
 * Generated when the state of the layout changes in any way, such as a view added/removed/replaced. Note that this event can fire frequently as the underlying layout can change multiple components from all kinds of changes (resizing for example). Given this, it is recommended to debounce this event and then you can use the {@link Layout#getConfig Layout.getConfig} API to retrieve the most up-to-date state.
 * ```js
 * // The response has the following shape in event.detail
 * {
 *     containerSelector: "container-component_A",
 *     name: "component_A",
 *     tabSelector: "tab-component_A",
 *     topic: "openfin-DOM-event",
 *     type: "layout-state-changed",
 *     uuid: "OpenFin POC"
 * }
 * ```
 *
 * #### tab-closed
 * Generated when a tab is closed.
 * ```js
 * // The response has the following shape in event.detail:
 * {
 *     containerSelector: "container-component_A",
 *     name: "component_A",
 *     tabSelector: "tab-component_A",
 *     topic: "openfin-DOM-event",
 *     type: "tab-closed",
 *     uuid: "OpenFin POC",
 *     url: "http://openfin.co"   // The url of the view that was closed.
 * }
 * ```
 *
 * #### tab-dropped
 * Generated when a tab is dropped.
 * ```js
 * // The response has the following shape in event.detail:
 * {
 *     containerSelector: "container-component_A",
 *     name: "component_A",
 *     tabSelector: "tab-component_A",
 *     topic: "openfin-DOM-event",
 *     type: "tab-dropped",
 *     uuid: "OpenFin POC",
 *     url: "http://openfin.co"    // The url of the view linked to the dropped tab.
 * }
 * ```
 */
class Layout extends base_1$6.Base {
    /**
     * @internal
     */
    // eslint-disable-next-line no-shadow
    constructor(identity, wire) {
        super(wire);
        /**
         * @internal
         * Lazily constructed {@link LayoutEntitiesClient} bound to this platform's client and identity
         * The client is for {@link LayoutEntitiesController}
         */
        _Layout_layoutClient.set(this, new lazy_1.Lazy(async () => layout_entities_1.LayoutNode.newLayoutEntitiesClient(await this.platform.getClient(), layout_constants_1$1.LAYOUT_CONTROLLER_ID, this.identity)));
        /**
         * Replaces a Platform window's layout with a new layout.
         *
         * @remarks Any views that were in the old layout but not the new layout will be destroyed. Views will be assigned a randomly generated name to avoid collisions.
         * @example
         * ```js
         * let windowIdentity;
         * if (fin.me.isWindow) {
         *     windowIdentity = fin.me.identity;
         * } else if (fin.me.isView) {
         *     windowIdentity = (await fin.me.getCurrentWindow()).identity;
         * } else {
         *     throw new Error('Not running in a platform View or Window');
         * }
         *
         * const layout = fin.Platform.Layout.wrapSync(windowIdentity);
         *
         * const newLayout = {
         *     content: [
         *         {
         *             type: 'stack',
         *             content: [
         *                 {
         *                     type: 'component',
         *                     componentName: 'view',
         *                     componentState: {
         *                         name: 'new_component_A1',
         *                         processAffinity: 'ps_1',
         *                         url: 'https://www.example.com'
         *                     }
         *                 },
         *                 {
         *                     type: 'component',
         *                     componentName: 'view',
         *                     componentState: {
         *                         name: 'new_component_A2',
         *                         url: 'https://cdn.openfin.co/embed-web/chart.html'
         *                     }
         *                 }
         *             ]
         *         }
         *     ]
         * };
         *
         * layout.replace(newLayout);
         * ```
         */
        this.replace = async (layout) => {
            this.wire.sendAction('layout-replace').catch((e) => {
                // don't expose
            });
            const client = await this.platform.getClient();
            await client.dispatch('replace-layout', {
                target: this.identity,
                opts: { layout }
            });
        };
        /**
         * Replaces the specified view with a view with the provided configuration.
         *
         * @remarks The old view is stripped of its listeners and either closed or attached to the provider window
         * depending on `detachOnClose` view option.
         *
         * @param viewToReplace Identity of the view to be replaced
         * @param newView Creation options of the new view.
         *
         * @example
         * ```js
         * let currentWindow;
         * if (fin.me.isWindow) {
         *     currentWindow = fin.me;
         * } else if (fin.me.isView) {
         *     currentWindow = await fin.me.getCurrentWindow();
         * } else {
         *     throw new Error('Not running in a platform View or Window');
         * }
         *
         * const layout = fin.Platform.Layout.wrapSync(currentWindow.identity);
         * const viewToReplace = (await currentWindow.getCurrentViews())[0];
         * const newViewConfig = {url: 'https://example.com'};
         * await layout.replaceView(viewToReplace.identity, newViewConfig);
         * ```
         */
        this.replaceView = async (viewToReplace, newView) => {
            this.wire.sendAction('layout-replace-view').catch((e) => {
                // don't expose
            });
            const client = await this.platform.getClient();
            await client.dispatch('replace-view', {
                target: this.identity,
                opts: { viewToReplace, newView }
            });
        };
        /**
         * Replaces a Platform window's layout with a preset layout arrangement using the existing Views attached to the window.
         * The preset options are `columns`, `grid`, `rows`, and `tabs`.
         * @param options Mandatory object with `presetType` property that sets which preset layout arrangement to use.
         * The preset options are `columns`, `grid`, `rows`, and `tabs`.
         *
         * @example
         * ```js
         * let windowIdentity;
         * if (fin.me.isWindow) {
         *     windowIdentity = fin.me.identity;
         * } else if (fin.me.isView) {
         *     windowIdentity = (await fin.me.getCurrentWindow()).identity;
         * } else {
         *     throw new Error('Not running in a platform View or Window');
         * }
         *
         * const layout = fin.Platform.Layout.wrapSync(windowIdentity);
         * await layout.applyPreset({ presetType: 'grid' });
         *
         * // wait 5 seconds until you change the layout from grid to tabs
         * await new Promise (res => setTimeout(res, 5000));
         * await layout.applyPreset({ presetType: 'tabs' });
         * ```
         */
        this.applyPreset = async (options) => {
            this.wire.sendAction('layout-apply-preset').catch((e) => {
                // don't expose
            });
            const client = await this.platform.getClient();
            const { presetType } = options;
            if (!presetType || !(0, common_utils_1.isValidPresetType)(presetType)) {
                throw new Error('Cannot apply preset layout, please include an applicable presetType property in the PresetLayoutOptions.');
            }
            await client.dispatch('apply-preset-layout', {
                target: this.identity,
                opts: { presetType }
            });
        };
        const errorMsg = (0, validate_1.validateIdentity)(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        this.identity = identity;
        this.platform = this.fin.Platform.wrapSync({ uuid: identity.uuid });
        if (identity.uuid === this.fin.me.uuid && identity.name === this.fin.me.name) {
            this.init = this.fin.Platform.Layout.init;
        }
    }
    /**
     * Returns the configuration of the window's layout.  Returns the same information that is returned for all windows in getSnapshot.
     *
     * @remarks Cannot be called from a View.
     *
     *
     * @example
     * ```js
     * const layout = fin.Platform.Layout.getCurrentSync();
     * // Use wrapped instance to get the layout configuration of the current window's Layout:
     * const layoutConfig = await layout.getConfig();
     * ```
     */
    async getConfig() {
        this.wire.sendAction('layout-get-config').catch((e) => {
            // don't expose
        });
        const client = await this.platform.getClient();
        return client.dispatch('get-frame-snapshot', {
            target: this.identity
        });
    }
    /**
     * Retrieves the attached views in current window layout.
     *
     * @example
     * ```js
     * const layout = fin.Platform.Layout.getCurrentSync();
     * const views = await layout.getCurrentViews();
     * ```
     */
    async getCurrentViews() {
        this.wire.sendAction('layout-get-views').catch((e) => {
            // don't expose
        });
        const client = await this.platform.getClient();
        const viewIdentities = await client.dispatch('get-layout-views', {
            target: this.identity
        });
        return viewIdentities.map((identity) => this.fin.View.wrapSync(identity));
    }
    /**
     * Retrieves the top level content item of the layout.
     *
     * @remarks Cannot be called from a view.
     *
     *
     *
     * @example
     * ```js
     * if (!fin.me.isWindow) {
     *     throw new Error('Not running in a platform View.');
     * }
     *
     * // From the layout window
     * const layout = fin.Platform.Layout.getCurrentSync();
     * // Retrieves the ColumnOrRow instance
     * const rootItem = await layout.getRootItem();
     * const content = await rootItem.getContent();
     * console.log(`The root ColumnOrRow instance has ${content.length} item(s)`);
     * ```
     */
    async getRootItem() {
        this.wire.sendAction('layout-get-root-item').catch(() => {
            // don't expose
        });
        const client = await __classPrivateFieldGet$5(this, _Layout_layoutClient, "f").getValue();
        const root = await client.getRoot('layoutName' in this.identity ? this.identity : undefined);
        return layout_entities_1.LayoutNode.getEntity(root, client);
    }
}
Instance$1.Layout = Layout;
_Layout_layoutClient = new WeakMap();

var __classPrivateFieldGet$4 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$4 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _LayoutModule_instances, _LayoutModule_layoutInitializationAttempted, _LayoutModule_layoutManager, _LayoutModule_getLayoutManagerSpy, _LayoutModule_getSafeLayoutManager;
Object.defineProperty(Factory$2, "__esModule", { value: true });
Factory$2.LayoutModule = void 0;
const base_1$5 = base;
const Instance_1$2 = Instance$1;
const layout_constants_1 = layout_constants;
/**
 * Static namespace for OpenFin API methods that interact with the {@link Layout} class, available under `fin.Platform.Layout`.
 */
class LayoutModule extends base_1$5.Base {
    constructor() {
        super(...arguments);
        _LayoutModule_instances.add(this);
        _LayoutModule_layoutInitializationAttempted.set(this, false);
        _LayoutModule_layoutManager.set(this, null);
        /**
         * Initialize the window's Layout.
         *
         * @remarks Must be called from a custom window that has a 'layout' option set upon creation of that window.
         * If a containerId is not provided, this method attempts to find an element with the id `layout-container`.
         * A Layout will emit events locally on the DOM element representing the layout-container.
         * In order to capture the relevant events during Layout initiation, set up the listeners on the DOM element prior to calling `init`.
         * @param options - Layout init options.
         *
         * @experimental
         *
         * @example
         * ```js
         * // If no options are included, the layout in the window options is initialized in an element with the id `layout-container`
         * const layout = await fin.Platform.Layout.init();
         * ```
         * <br>
         *
         * ```js
         * const containerId = 'my-custom-container-id';
         *
         * const myLayoutContainer = document.getElementById(containerId);
         *
         * myLayoutContainer.addEventListener('tab-created', function(event) {
         *     const { tabSelector } = event.detail;
         *     const tabElement = document.getElementById(tabSelector);
         *     const existingColor = tabElement.style.backgroundColor;
         *     tabElement.style.backgroundColor = "red";
         *     setTimeout(() => {
         *         tabElement.style.backgroundColor = existingColor;
         *     }, 2000);
         * });
         *
         * // initialize the layout into an existing HTML element with the div `my-custom-container-id`
         * // the window must have been created with a layout in its window options
         * const layout = await fin.Platform.Layout.init({ containerId });
         * ```
         */
        this.init = async (options = {}) => {
            this.wire.sendAction('layout-init').catch((e) => {
                // don't expose
            });
            if (!this.fin.me.isWindow) {
                throw new Error('Layout.init can only be called from a Window context.');
            }
            else if (__classPrivateFieldGet$4(this, _LayoutModule_layoutInitializationAttempted, "f")) {
                throw new Error('Layout.init was already called, please use Layout.create to add additional layouts.');
            }
            __classPrivateFieldSet$4(this, _LayoutModule_layoutInitializationAttempted, true, "f");
            // preload the client
            await this.fin.Platform.getCurrentSync().getClient();
            __classPrivateFieldSet$4(this, _LayoutModule_layoutManager, await this.wire.environment.initLayoutManager(this.fin, this.wire, options), "f");
            await this.wire.environment.applyLayoutSnapshot(this.fin, __classPrivateFieldGet$4(this, _LayoutModule_layoutManager, "f"), options);
            if (!options.layoutManagerOverride) {
                // in single-layout case, we return the undocumented layoutManager type (deprecate with CORE-1081)
                const layoutIdentity = { layoutName: layout_constants_1.DEFAULT_LAYOUT_KEY, ...this.fin.me.identity };
                const layoutManager = await this.wire.environment.resolveLayout(__classPrivateFieldGet$4(this, _LayoutModule_layoutManager, "f"), layoutIdentity);
                return __classPrivateFieldGet$4(this, _LayoutModule_getLayoutManagerSpy, "f").call(this, layoutIdentity, layoutManager);
            }
            return this.wrapSync(this.fin.me.identity);
        };
        _LayoutModule_getLayoutManagerSpy.set(this, (layoutIdentity, layoutManager) => {
            const msg = '[Layout] You are using a deprecated property `layoutManager` - it will throw if you access it starting in v37.';
            const managerProxy = new Proxy(layoutManager, {
                get(target, key) {
                    console.warn(`[Layout-mgr-proxy] accessing ${key.toString()}`);
                    console.warn(msg);
                    return target[key];
                }
            });
            const layout = Object.assign(this.wrapSync(layoutIdentity), { layoutManager: managerProxy });
            const layoutProxy = new Proxy(layout, {
                get(target, key) {
                    if (key === 'layoutManager') {
                        console.warn(`[Layout-proxy] accessing ${key.toString()}`);
                        console.warn(msg);
                    }
                    return target[key];
                }
            });
            return layoutProxy;
        });
        /**
         * Returns the layout manager for the current window
         * @returns
         */
        this.getCurrentLayoutManagerSync = () => {
            return __classPrivateFieldGet$4(this, _LayoutModule_instances, "m", _LayoutModule_getSafeLayoutManager).call(this, `fin.Platform.Layout.getCurrentLayoutManagerSync()`);
        };
        this.create = async (options) => {
            return this.wire.environment.createLayout(__classPrivateFieldGet$4(this, _LayoutModule_instances, "m", _LayoutModule_getSafeLayoutManager).call(this, `fin.Platform.Layout.create()`), options);
        };
        this.destroy = async (layoutIdentity) => {
            return this.wire.environment.destroyLayout(__classPrivateFieldGet$4(this, _LayoutModule_instances, "m", _LayoutModule_getSafeLayoutManager).call(this, `fin.Platform.Layout.destroy()`), layoutIdentity);
        };
    }
    /**
     * Asynchronously returns a Layout object that represents a Window's layout.
     *
     * @example
     * ```js
     * let windowIdentity;
     * if (!fin.me.isWindow) {
     *     windowIdentity = fin.me.identity;
     * } else if (fin.me.isView) {
     *     windowIdentity = (await fin.me.getCurrentWindow()).identity;
     * } else {
     *     throw new Error('Not running in a platform View or Window');
     * }
     *
     * const layout = await fin.Platform.Layout.wrap(windowIdentity);
     * // Use wrapped instance to control layout, e.g.:
     * const layoutConfig = await layout.getConfig();
     * ```
     */
    async wrap(identity) {
        this.wire.sendAction('layout-wrap').catch((e) => {
            // don't expose
        });
        return new Instance_1$2.Layout(identity, this.wire);
    }
    /**
     * Synchronously returns a Layout object that represents a Window's layout.
     *
     * @example
     * ```js
     * let windowIdentity;
     * if (!fin.me.isWindow) {
     *     windowIdentity = fin.me.identity;
     * } else if (fin.me.isView) {
     *     windowIdentity = (await fin.me.getCurrentWindow()).identity;
     * } else {
     *     throw new Error('Not running in a platform View or Window');
     * }
     *
     * const layout = fin.Platform.Layout.wrapSync(windowIdentity);
     * // Use wrapped instance to control layout, e.g.:
     * const layoutConfig = await layout.getConfig();
     * ```
     */
    wrapSync(identity) {
        this.wire.sendAction('layout-wrap-sync').catch((e) => {
            // don't expose
        });
        return new Instance_1$2.Layout(identity, this.wire);
    }
    /**
     * Asynchronously returns a Layout object that represents a Window's layout.
     *
     * @example
     * ```js
     * const layout = await fin.Platform.Layout.getCurrent();
     * // Use wrapped instance to control layout, e.g.:
     * const layoutConfig = await layout.getConfig();
     * ```
     */
    async getCurrent() {
        this.wire.sendAction('layout-get-current').catch((e) => {
            // don't expose
        });
        if (!this.fin.me.isWindow) {
            throw new Error('You are not in a Window context.  Only Windows can have a Layout.');
        }
        const { uuid, name } = this.fin.me;
        return this.wrap({ uuid, name });
    }
    /**
     * Synchronously returns a Layout object that represents a Window's layout.
     *
     * @remarks Cannot be called from a view.
     *
     *
     * @example
     * ```js
     * const layout = fin.Platform.Layout.getCurrentSync();
     * // Use wrapped instance to control layout, e.g.:
     * const layoutConfig = await layout.getConfig();
     * ```
     */
    getCurrentSync() {
        this.wire.sendAction('layout-get-current-sync').catch((e) => {
            // don't expose
        });
        if (!this.fin.me.isWindow) {
            throw new Error('You are not in a Window context.  Only Windows can have a Layout.');
        }
        const { uuid, name } = this.fin.me;
        return this.wrapSync({ uuid, name });
    }
}
Factory$2.LayoutModule = LayoutModule;
_LayoutModule_layoutInitializationAttempted = new WeakMap(), _LayoutModule_layoutManager = new WeakMap(), _LayoutModule_getLayoutManagerSpy = new WeakMap(), _LayoutModule_instances = new WeakSet(), _LayoutModule_getSafeLayoutManager = function _LayoutModule_getSafeLayoutManager(method) {
    if (!__classPrivateFieldGet$4(this, _LayoutModule_layoutManager, "f")) {
        throw new Error(`You must call init before using the API ${method}`);
    }
    return __classPrivateFieldGet$4(this, _LayoutModule_layoutManager, "f");
};

(function (exports) {
	/**
	 * Entry point for the OpenFin `Layout` subset of the `Platform` API (`fin.Platform.Layout`).
	 *
	 * * {@link LayoutModule} contains static members of the `Layout` API, accessible through `fin.Platform.Layout`.
	 * * {@link Layout} describes an instance of an OpenFin Layout, e.g. as returned by `fin.Platform.Layout.getCurrent`.
	 *
	 * These are separate code entities, and are documented separately. In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
	 * both of these were documented on the same page.
	 *
	 * @packageDocumentation
	 *
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(Factory$2, exports);
	__exportStar(Instance$1, exports); 
} (layout));

Object.defineProperty(Factory$3, "__esModule", { value: true });
Factory$3.PlatformModule = void 0;
const base_1$4 = base;
const Instance_1$1 = Instance$2;
const index_1$1 = layout;
/**
 * Static namespace for OpenFin API methods that interact with the {@link Platform} class, available under `fin.Platform`.
 */
class PlatformModule extends base_1$4.Base {
    /**
     * @internal
     */
    constructor(wire, channel) {
        super(wire);
        this._channel = channel;
        /**
         *
         * @desc Layouts give app providers the ability to embed multiple views in a single window.  The Layout namespace
         * enables the initialization and manipulation of a window's Layout.  A Layout will
         * <a href="tutorial-Layout.DOMEvents.html">emit events locally</a> on the DOM element representing the layout-container.
         */
        this.Layout = new index_1$1.LayoutModule(this.wire);
    }
    /**
     * Initializes a Platform. Must be called from the Provider when using a custom provider.
     * @param options - platform options including a callback function that can be used to extend or replace
     * default Provider behavior.
     *
     * @remarks Must be called from the Provider when using a custom provider.
     *
     * @example
     *
     * ```js
     * // From Provider context
     * await fin.Platform.init();
     * // Platform API is now hooked up and windows contained in the manifest snapshot are open.
     * ```
     *
     * `Platform.init` accepts an options object that can contain a callback function which can be used to extend or
     * replace default Provider behavior. As an argument, this function will receive the `Provider` class, which is
     * used to handle Platform actions. The function must return an object with methods to handle Platform API actions.
     * The recommended approach is to extend the `Provider` class, overriding the methods you wish to alter, and return an
     * instance of your subclass:
     *
     * ```js
     * const overrideCallback = async (PlatformProvider) => {
     *     // Actions can be performed before initialization.
     *     // e.g. we might authenticate a user, set up a Channel, etc before initializing the Platform.
     *     const { manifestUrl } = await fin.Application.getCurrentSync().getInfo();
     *
     *     // Extend or replace default PlatformProvider behavior by extending the PlatformProvider class.
     *     class MyOverride extends PlatformProvider {
     *         // Default behavior can be changed by implementing methods with the same names as those used by the default PlatformProvider.
     *         async getSnapshot() {
     *             // Since we are extending the class, we can call `super` methods to access default behavior.
     *             const snapshot = await super.getSnapshot();
     *             // But we can modify return values.
     *             return { ...snapshot, answer: 42, manifestUrl };
     *         }
     *         async replaceLayout({ opts, target }) {
     *             // To disable an API method, overwrite with a noop function.
     *             return;
     *         }
     *     }
     *     // Return instance with methods to be consumed by Platform.
     *     // The returned object must implement all methods of the PlatformProvider class.
     *     // By extending the class, we can simply inherit methods we do not wish to alter.
     *     return new MyOverride();
     * };
     *
     * fin.Platform.init({overrideCallback});
     * ```
     * @experimental
     */
    async init(options) {
        if (!fin.__internal_.isPlatform || fin.me.name !== fin.me.uuid) {
            throw new Error('fin.Platform.init should only be called from a custom platform provider running in the main window of the application.');
        }
        return this.wire.environment.initPlatform(this.fin, options);
    }
    /**
     * Asynchronously returns a Platform object that represents an existing platform.
     *
     * @example
     * ```js
     * const { identity } = fin.me;
     * const platform = await fin.Platform.wrap(identity);
     * // Use wrapped instance to control layout, e.g.:
     * const snapshot = await platform.getSnapshot();
     * ```
     */
    async wrap(identity) {
        this.wire.sendAction('platform-wrap').catch((e) => {
            // don't expose
        });
        return new Instance_1$1.Platform({ uuid: identity.uuid }, this._channel);
    }
    /**
     * Synchronously returns a Platform object that represents an existing platform.
     *
     * @example
     * ```js
     * const { identity } = fin.me;
     * const platform = fin.Platform.wrapSync(identity);
     * // Use wrapped instance to control layout, e.g.:
     * const snapshot = await platform.getSnapshot();
     * ```
     */
    wrapSync(identity) {
        this.wire.sendAction('platform-wrap-sync').catch((e) => {
            // don't expose
        });
        return new Instance_1$1.Platform({ uuid: identity.uuid }, this._channel);
    }
    /**
     * Asynchronously returns a Platform object that represents the current platform.
     *
     * @example
     * ```js
     * const platform = await fin.Platform.getCurrent();
     * // Use wrapped instance to control layout, e.g.:
     * const snapshot = await platform.getSnapshot();
     * ```
     */
    async getCurrent() {
        this.wire.sendAction('platform-get-current').catch((e) => {
            // don't expose
        });
        return this.wrap({ uuid: this.wire.me.uuid });
    }
    /**
     * Synchronously returns a Platform object that represents the current platform.
     *
     * @example
     * ```js
     * const platform = fin.Platform.getCurrentSync();
     * // Use wrapped instance to control layout, e.g.:
     * const snapshot = await platform.getSnapshot();
     * ```
     */
    getCurrentSync() {
        this.wire.sendAction('platform-get-current-sync').catch((e) => {
            // don't expose
        });
        return this.wrapSync({ uuid: this.wire.me.uuid });
    }
    /**
     * Creates and starts a Platform and returns a wrapped and running Platform instance. The wrapped Platform methods can
     * be used to launch content into the platform.  Promise will reject if the platform is already running.
     *
     * @example
     * ```js
     * try {
     *     const platform = await fin.Platform.start({
     *         uuid: 'platform-1',
     *         autoShow: false,
     *         defaultWindowOptions: {
     *             stylesheetUrl: 'css-sheet-url',
     *             cornerRounding: {
     *                 height: 10,
     *                 width: 10
     *             }
     *         }
     *     });
     *     console.log('Platform is running', platform);
     * } catch(e) {
     *     console.error(e);
     * }
     * ```
     */
    start(platformOptions) {
        this.wire.sendAction('platform-start').catch((e) => {
            // don't expose
        });
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                const { uuid } = platformOptions;
                // @ts-expect-error using private variable.
                const app = await this.fin.Application._create({ ...platformOptions, isPlatformController: true });
                // TODO: fix typing (internal)
                // @ts-expect-error
                app.once('platform-api-ready', () => resolve(this.wrapSync({ uuid })));
                // @ts-expect-error using private variable.
                app._run({ uuid });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Retrieves platforms's manifest and returns a wrapped and running Platform.  If there is a snapshot in the manifest,
     * it will be launched into the platform.
     * @param manifestUrl - The URL of platform's manifest.
     * @param opts - Parameters that the RVM will use.
     *
     * @example
     * ```js
     * try {
     *     const platform = await fin.Platform.startFromManifest('https://openfin.github.io/golden-prototype/public.json');
     *     console.log('Platform is running, wrapped platform: ', platform);
     * } catch(e) {
     *     console.error(e);
     * }
     * // For a local manifest file:
     * try {
     *     const platform = await fin.Platform.startFromManifest('file:///C:/somefolder/app.json');
     *     console.log('Platform is running, wrapped platform: ', platform);
     * } catch(e) {
     *     console.error(e);
     * }
     * ```
     */
    startFromManifest(manifestUrl, opts) {
        this.wire.sendAction('platform-start-from-manifest').catch((e) => {
            // don't expose
        });
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                // @ts-expect-error using private variable.
                const app = await this.fin.Application._createFromManifest(manifestUrl);
                // TODO: fix typing (internal)
                // @ts-expect-error
                app.once('platform-api-ready', () => resolve(this.wrapSync({ uuid: app.identity.uuid })));
                // @ts-expect-error using private method without warning.
                app._run(opts);
            }
            catch (e) {
                reject(e);
            }
        });
    }
}
Factory$3.PlatformModule = PlatformModule;

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Entry points for the OpenFin `Platform` API (`fin.Platform`)
	 *
	 * * {@link PlatformModule} contains static members of the `Platform` API, accessible through `fin.Platform`.
	 * * {@link Platform} describes an instance of an OpenFin Platform, e.g. as returned by `fin.Platform.getCurrent`.
	 *
	 * These are separate code entities, and are documented separately.  In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
	 * both of these were documented on the same page.
	 *
	 * @packageDocumentation
	 */
	__exportStar(Factory$3, exports);
	__exportStar(Instance$2, exports); 
} (platform));

var me = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getMe = exports.getBaseMe = exports.environmentUnsupportedMessage = void 0;
	const view_1 = requireView();
	const frame_1 = frame;
	const window_1 = requireWindow();
	const external_application_1 = externalApplication;
	exports.environmentUnsupportedMessage = 'You are not running in OpenFin.';
	function getBaseMe(entityType, uuid, name) {
	    const entityTypeHelpers = {
	        isView: entityType === 'view',
	        isWindow: entityType === 'window',
	        isFrame: entityType === 'iframe',
	        isExternal: entityType === 'external connection'
	    };
	    return { ...entityTypeHelpers, uuid, name, entityType };
	}
	exports.getBaseMe = getBaseMe;
	// We need to do a lot of casting as unknown here because the compiler get's confused about matching types. What matters is that it works on the outside
	function getMe(wire) {
	    const { uuid, name, entityType } = wire.me;
	    const unsupportedInterop = {
	        setContext() {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        addContextHandler() {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        getContextGroups() {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        joinContextGroup() {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        removeFromContextGroup() {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        getAllClientsInContextGroup() {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        getInfoForContextGroup() {
	            throw new Error(exports.environmentUnsupportedMessage);
	        }
	    };
	    const fallbackErrorMessage = 'Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.';
	    const fallbackInterop = {
	        setContext() {
	            throw new Error(fallbackErrorMessage);
	        },
	        addContextHandler() {
	            throw new Error(fallbackErrorMessage);
	        },
	        getContextGroups() {
	            throw new Error(fallbackErrorMessage);
	        },
	        joinContextGroup() {
	            throw new Error(fallbackErrorMessage);
	        },
	        removeFromContextGroup() {
	            throw new Error(fallbackErrorMessage);
	        },
	        getAllClientsInContextGroup() {
	            throw new Error(fallbackErrorMessage);
	        },
	        getInfoForContextGroup() {
	            throw new Error(fallbackErrorMessage);
	        }
	    };
	    const unsupportedEventBase = {
	        eventNames: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        emit: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        listeners: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        listenerCount: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        on: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        addListener: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        once: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        prependListener: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        prependOnceListener: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        removeListener: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        },
	        removeAllListeners: () => {
	            throw new Error(exports.environmentUnsupportedMessage);
	        }
	    };
	    switch (entityType) {
	        case 'view':
	            return Object.assign(new view_1.View(wire, { uuid, name }), getBaseMe(entityType, uuid, name), {
	                interop: fallbackInterop,
	                isOpenFin: true
	            });
	        case 'window':
	            return Object.assign(new window_1._Window(wire, { uuid, name }), getBaseMe(entityType, uuid, name), {
	                interop: fallbackInterop,
	                isOpenFin: true
	            });
	        case 'iframe':
	            return Object.assign(new frame_1._Frame(wire, { uuid, name }), getBaseMe(entityType, uuid, name), {
	                interop: fallbackInterop,
	                isOpenFin: true
	            });
	        case 'external connection':
	            return Object.assign(new external_application_1.ExternalApplication(wire, { uuid }), getBaseMe(entityType, uuid, name), {
	                interop: fallbackInterop,
	                isOpenFin: false
	            });
	        default:
	            return {
	                ...getBaseMe(entityType, uuid, name),
	                ...unsupportedEventBase,
	                interop: unsupportedInterop,
	                isOpenFin: false
	            };
	    }
	}
	exports.getMe = getMe; 
} (me));

var interop = {};

var Factory$1 = {};

var inaccessibleObject = {};

Object.defineProperty(inaccessibleObject, "__esModule", { value: true });
inaccessibleObject.createWarningObject = inaccessibleObject.createUnusableObject = void 0;
function createUnusableObject(message) {
    const handle = () => {
        throw new Error(message);
    };
    return new Proxy({}, {
        apply: handle,
        construct: handle,
        defineProperty: handle,
        deleteProperty: handle,
        get: handle,
        getOwnPropertyDescriptor: handle,
        getPrototypeOf: handle,
        has: handle,
        isExtensible: handle,
        ownKeys: handle,
        preventExtensions: handle,
        set: handle,
        setPrototypeOf: handle
    });
}
inaccessibleObject.createUnusableObject = createUnusableObject;
function createWarningObject(message, obj) {
    return new Proxy(obj, {
        get: (...args) => {
            // eslint-disable-next-line no-console
            console.warn(message);
            return Reflect.get(...args);
        },
        set: (...args) => {
            // eslint-disable-next-line no-console
            console.warn(message);
            return Reflect.set(...args);
        },
        getOwnPropertyDescriptor: (...args) => {
            // eslint-disable-next-line no-console
            console.warn(message);
            return Reflect.getOwnPropertyDescriptor(...args);
        },
        ownKeys: (...args) => {
            // eslint-disable-next-line no-console
            console.warn(message);
            return Reflect.ownKeys(...args);
        }
    });
}
inaccessibleObject.createWarningObject = createWarningObject;

var InteropBroker = {};

var SessionContextGroupBroker = {};

var hasRequiredSessionContextGroupBroker;

function requireSessionContextGroupBroker () {
	if (hasRequiredSessionContextGroupBroker) return SessionContextGroupBroker;
	hasRequiredSessionContextGroupBroker = 1;
	Object.defineProperty(SessionContextGroupBroker, "__esModule", { value: true });
	const _1 = requireInterop();
	let SessionContextGroupBroker$1 = class SessionContextGroupBroker {
	    constructor(provider, id) {
	        this.provider = provider;
	        this.id = id;
	        this.lastContext = undefined;
	        this.contextGroupMap = new Map();
	        this.clients = new Map();
	        this.registerListeners();
	    }
	    registerListeners() {
	        this.provider.register(`sessionContextGroup:getContext-${this.id}`, this.getCurrentContext.bind(this));
	        this.provider.register(`sessionContextGroup:setContext-${this.id}`, this.setContext.bind(this));
	        this.provider.register(`sessionContextGroup:handlerAdded-${this.id}`, this.handlerAdded.bind(this));
	        this.provider.register(`sessionContextGroup:handlerRemoved-${this.id}`, this.handlerRemoved.bind(this));
	    }
	    getCurrentContext(payload) {
	        return payload.type ? this.contextGroupMap.get(payload.type) : this.lastContext;
	    }
	    setContext(payload, clientIdentity) {
	        const { context } = payload;
	        const contextIntegrityCheckResult = _1.InteropBroker.checkContextIntegrity(context);
	        if (contextIntegrityCheckResult.isValid === false) {
	            throw new Error(`Failed to set Context - bad Context. Reason: ${contextIntegrityCheckResult.reason}. Context: ${JSON.stringify(context)}`);
	        }
	        const clientState = this.getClientState(clientIdentity);
	        if (!clientState) {
	            // This shouldn't get hit.
	            throw new Error(`Client with Identity: ${clientIdentity.uuid} ${clientIdentity.name} not in Session Client State Map`);
	        }
	        // set the context
	        this.contextGroupMap.set(context.type, context);
	        this.lastContext = context;
	        const clientSubscriptionStates = Array.from(this.clients.values());
	        clientSubscriptionStates.forEach((client) => {
	            // eslint-disable-next-line no-unused-expressions
	            client.contextHandlers.get(context.type)?.forEach((handlerId) => {
	                this.provider.dispatch(client.clientIdentity, handlerId, context);
	            });
	            if (client.globalHandler) {
	                this.provider.dispatch(client.clientIdentity, client.globalHandler, context);
	            }
	        });
	    }
	    getClientState(id) {
	        return this.clients.get(id.endpointId);
	    }
	    async handlerAdded(payload, clientIdentity) {
	        const { handlerId, contextType } = payload;
	        const clientSubscriptionState = this.getClientState(clientIdentity);
	        if (!clientSubscriptionState) {
	            throw new Error(`Client with Identity: ${clientIdentity.uuid} ${clientIdentity.name} not in Client State Map`);
	        }
	        if (contextType) {
	            const currentHandlerList = clientSubscriptionState.contextHandlers.get(contextType) || [];
	            clientSubscriptionState.contextHandlers.set(contextType, [...currentHandlerList, handlerId]);
	            const currentContext = this.contextGroupMap.get(contextType);
	            if (currentContext) {
	                await this.provider.dispatch(clientIdentity, handlerId, currentContext);
	            }
	        }
	        else {
	            clientSubscriptionState.globalHandler = handlerId;
	            const globalDispatchPromises = [...this.contextGroupMap.keys()].map(async (currentContextType) => {
	                const currentContext = this.contextGroupMap.get(currentContextType);
	                if (currentContext) {
	                    await this.provider.dispatch(clientIdentity, handlerId, currentContext);
	                }
	            });
	            await Promise.all(globalDispatchPromises);
	        }
	    }
	    handlerRemoved(payload, clientIdentity) {
	        const { handlerId } = payload;
	        const client = this.clients.get(clientIdentity.endpointId);
	        if (client) {
	            Array.from(client.contextHandlers).forEach(([, handlers]) => {
	                const index = handlers.indexOf(handlerId);
	                if (index > -1) {
	                    handlers.splice(index, 1);
	                }
	            });
	            if (client.globalHandler === handlerId) {
	                client.globalHandler = undefined;
	            }
	        }
	        else {
	            console.warn(`Trying to remove a handler from a client that isn't mapped. handlerId: ${handlerId}. clientIdentity: ${clientIdentity}`);
	        }
	    }
	    registerNewClient(clientIdentity) {
	        if (!this.clients.has(clientIdentity.endpointId)) {
	            const clientSubscriptionState = {
	                contextHandlers: new Map(),
	                clientIdentity,
	                globalHandler: undefined
	            };
	            this.clients.set(clientIdentity.endpointId, clientSubscriptionState);
	        }
	    }
	    onDisconnection(clientIdentity) {
	        this.clients.delete(clientIdentity.endpointId);
	    }
	};
	SessionContextGroupBroker.default = SessionContextGroupBroker$1;
	return SessionContextGroupBroker;
}

var utils$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.wrapIntentHandler = exports.BROKER_ERRORS = exports.generateOverrideWarning = exports.generateOverrideError = exports.wrapContextHandler = exports.wrapInTryCatch = exports.generateId = void 0;
	const generateId = () => `${Math.random()}${Date.now()}`;
	exports.generateId = generateId;
	const wrapInTryCatch = (f, prefix) => (...args) => {
	    try {
	        return f(...args);
	    }
	    catch (e) {
	        throw new Error((prefix || '') + e);
	    }
	};
	exports.wrapInTryCatch = wrapInTryCatch;
	const wrapContextHandler = (handler, handlerId) => {
	    return async (context) => {
	        try {
	            await handler(context);
	        }
	        catch (error) {
	            console.error(`Error thrown by handler ${handlerId} for context type ${context.type}: ${error}`);
	            throw error;
	        }
	    };
	};
	exports.wrapContextHandler = wrapContextHandler;
	const generateOverrideError = (clientApi, brokerApi) => {
	    return `You have tried to to use ${clientApi} but ${brokerApi} has not been overridden in the Interop Broker. Please override this function. Refer to our documentation for more info.`;
	};
	exports.generateOverrideError = generateOverrideError;
	const generateOverrideWarning = (fdc3ClientApi, brokerApi, identity, interopClientApi) => {
	    const { uuid, name } = identity;
	    const message = interopClientApi
	        ? `Entity with identity: ${uuid}/${name} has called ${interopClientApi} or ${fdc3ClientApi} but ${brokerApi} has not been overridden.`
	        : `Entity with identity: ${uuid}/${name} has called ${fdc3ClientApi} but ${brokerApi} has not been overridden.`;
	    return message;
	};
	exports.generateOverrideWarning = generateOverrideWarning;
	exports.BROKER_ERRORS = {
	    fireIntent: (0, exports.generateOverrideError)('fireIntent', 'handleFiredIntent'),
	    fireIntentForContext: (0, exports.generateOverrideError)('fireIntentForContext', 'handleFiredIntentForContext'),
	    getInfoForIntent: (0, exports.generateOverrideError)('getInfoForIntent', 'handleInfoForIntent'),
	    getInfoForIntentsByContext: (0, exports.generateOverrideError)('getInfoForIntentsByContext', 'handleInfoForIntentsByContext'),
	    joinSessionContextGroupWithJoinContextGroup: 'The Context Group you have tried to join is a Session Context Group. Custom Context Groups can only be defined by the Interop Broker through code or manifest configuration. Please use joinSessionContextGroup.',
	    fdc3Open: (0, exports.generateOverrideError)('fdc3.open', 'fdc3HandleOpen'),
	    fdc3FindInstances: (0, exports.generateOverrideError)('fdc3.findInstances', 'fdc3HandleFindInstances'),
	    fdc3GetAppMetadata: (0, exports.generateOverrideError)('fdc3.getAppMetadata', 'fdc3HandleGetAppMetadata'),
	    fdc3GetInfo: (0, exports.generateOverrideError)('fdc3.getInfo', 'fdc3HandleGetInfo')
	};
	const wrapIntentHandler = (handler, handlerId) => {
	    return async (intent) => {
	        try {
	            return handler(intent);
	        }
	        catch (error) {
	            console.error(`Error thrown by handler ${handlerId}: ${error}`);
	            throw error;
	        }
	    };
	};
	exports.wrapIntentHandler = wrapIntentHandler; 
} (utils$1));

var PrivateChannelProvider = {};

var hasRequiredPrivateChannelProvider;

function requirePrivateChannelProvider () {
	if (hasRequiredPrivateChannelProvider) return PrivateChannelProvider;
	hasRequiredPrivateChannelProvider = 1;
	Object.defineProperty(PrivateChannelProvider, "__esModule", { value: true });
	PrivateChannelProvider.PrivateChannelProvider = void 0;
	const InteropBroker_1 = requireInteropBroker();
	let PrivateChannelProvider$1 = class PrivateChannelProvider {
	    constructor(provider, id) {
	        this.provider = provider;
	        this.id = id;
	        this.clients = new Map();
	        this.registerListeners();
	        this.contextByContextType = new Map();
	        this.lastContext = undefined;
	        this.provider.onConnection((clientIdentity) => this.registerNewClient(clientIdentity));
	        this.provider.onDisconnection(async (clientIdentity) => {
	            const { endpointId } = clientIdentity;
	            if (this.clients.has(endpointId)) {
	                await this.handleClientDisconnecting(clientIdentity);
	            }
	            if ((await this.provider.getAllClientInfo()).length === 0) {
	                this.provider.destroy();
	            }
	        });
	    }
	    getClientState(id) {
	        return this.clients.get(id.endpointId);
	    }
	    registerListeners() {
	        this.provider.register('broadcast', this.broadcast.bind(this));
	        this.provider.register('getCurrentContext', this.getCurrentContext.bind(this));
	        this.provider.register('contextHandlerAdded', this.contextHandlerAdded.bind(this));
	        this.provider.register('contextHandlerRemoved', this.contextHandlerRemoved.bind(this));
	        this.provider.register('nonStandardHandlerRemoved', this.nonStandardHandlerRemoved.bind(this));
	        this.provider.register('onAddContextHandlerAdded', this.onAddContextHandlerAdded.bind(this));
	        this.provider.register('onDisconnectHandlerAdded', this.onDisconnectHandlerAdded.bind(this));
	        this.provider.register('onUnsubscribeHandlerAdded', this.onUnsubscribeHandlerAdded.bind(this));
	        this.provider.register('clientDisconnecting', (payload, clientIdentity) => {
	            this.handleClientDisconnecting(clientIdentity);
	        });
	    }
	    broadcast(payload, broadcasterClientIdentity) {
	        const { context } = payload;
	        const broadcasterClientState = this.getClientState(broadcasterClientIdentity);
	        if (!broadcasterClientState) {
	            throw new Error(`Client with Identity: ${broadcasterClientIdentity.uuid} ${broadcasterClientIdentity.name}, tried to call broadcast, is not connected to this Private Channel`);
	        }
	        const contextIntegrityCheckResult = InteropBroker_1.InteropBroker.checkContextIntegrity(context);
	        if (contextIntegrityCheckResult.isValid === false) {
	            throw new Error(`Failed to broadcast - bad Context. Reason: ${contextIntegrityCheckResult.reason}. Context: ${JSON.stringify(context)}`);
	        }
	        this.contextByContextType.set(context.type, context);
	        this.lastContext = context;
	        Array.from(this.clients.values()).forEach((currClientState) => {
	            const handlerIdsForContextType = currClientState.handlerIdsByContextTypes.get(context.type);
	            if (handlerIdsForContextType) {
	                handlerIdsForContextType.forEach((handlerId) => {
	                    this.provider.dispatch(currClientState.clientIdentity, handlerId, context);
	                });
	            }
	            if (currClientState.globalHandler) {
	                this.provider.dispatch(currClientState.clientIdentity, currClientState.globalHandler, context);
	            }
	        });
	    }
	    getCurrentContext(payload, senderClientIdentity) {
	        const { contextType } = payload;
	        const clientState = this.getClientState(senderClientIdentity);
	        if (!clientState) {
	            throw new Error(`Client with Identity: ${senderClientIdentity.uuid} ${senderClientIdentity.name}, tried to call getCurrentContext, is not connected to this Private Channel`);
	        }
	        if (contextType !== undefined) {
	            const currentContext = this.contextByContextType.get(contextType);
	            if (currentContext)
	                return currentContext;
	            return null;
	        }
	        return this.lastContext ? this.lastContext : null;
	    }
	    contextHandlerAdded(payload, senderClientIdentity) {
	        const { handlerId, contextType } = payload;
	        const senderClientState = this.getClientState(senderClientIdentity);
	        if (!senderClientState) {
	            throw new Error(`Client with Identity: ${senderClientIdentity.uuid} ${senderClientIdentity.name}, tried to call addContextListener, is not connected to this Private Channel`);
	        }
	        if (contextType) {
	            const currentHandlersList = senderClientState.handlerIdsByContextTypes.get(contextType) || [];
	            senderClientState.handlerIdsByContextTypes.set(contextType, [...currentHandlersList, handlerId]);
	        }
	        else {
	            senderClientState.globalHandler = handlerId;
	        }
	        Array.from(this.clients.values()).forEach((currClientState) => {
	            if (currClientState.clientIdentity.endpointId !== senderClientIdentity.endpointId &&
	                currClientState.onAddContextListenerHandlerId) {
	                this.provider.dispatch(currClientState.clientIdentity, currClientState.onAddContextListenerHandlerId, contextType);
	            }
	        });
	    }
	    async contextHandlerRemoved(payload, removingClientIdentity) {
	        // MC: Made this removal async to ensure that onUnsubscribe handlers are hit before anything else happens.
	        const { handlerId } = payload;
	        const removingClientState = this.getClientState(removingClientIdentity);
	        if (removingClientState) {
	            let contextType;
	            if (removingClientState.globalHandler === handlerId) {
	                removingClientState.globalHandler = undefined;
	            }
	            else {
	                for (const [currContextType, handlersIds] of removingClientState.handlerIdsByContextTypes) {
	                    const index = handlersIds.indexOf(handlerId);
	                    if (index > -1) {
	                        handlersIds.splice(index, 1);
	                        contextType = currContextType;
	                    }
	                }
	            }
	            // getting only valid client connections here, it is possible we haven't removed a disconnected client from the map yet
	            // so we need to ensure we don't dispatch to any disconnected client
	            // TODO: Take a look at our client disconnection logic and see if we can handle client disconnection cleanly
	            const clientsToDispatchTo = await this.getConnectedClients();
	            const dispatchPromises = clientsToDispatchTo.map(async (otherClientState) => {
	                const { clientIdentity, clientIdentity: { endpointId }, onUnsubscribeHandlerId } = otherClientState;
	                if (endpointId !== removingClientIdentity.endpointId && onUnsubscribeHandlerId) {
	                    await this.provider.dispatch(clientIdentity, onUnsubscribeHandlerId, contextType);
	                }
	            });
	            try {
	                await Promise.all(dispatchPromises);
	            }
	            catch (error) {
	                console.error(`Problem when attempting to dispatch to onUnsubscribeHandlers. Error: ${error} Removing Client: ${handlerId}. uuid: ${removingClientIdentity.uuid}. name: ${removingClientIdentity.name}. endpointId: ${removingClientIdentity.endpointId}`);
	                throw new Error(error);
	            }
	        }
	        else {
	            console.warn(`Trying to remove a handler from a client that isn't mapped. handlerId: ${handlerId}. uuid: ${removingClientIdentity.uuid}. name: ${removingClientIdentity.name}. endpointId: ${removingClientIdentity.endpointId}.`);
	        }
	    }
	    nonStandardHandlerRemoved(payload, id) {
	        const { handlerId } = payload;
	        const clientState = this.getClientState(id);
	        if (clientState) {
	            if (clientState.onDisconnectHandlerId === handlerId) {
	                clientState.onDisconnectHandlerId = undefined;
	            }
	            else if (clientState.onAddContextListenerHandlerId === handlerId) {
	                clientState.onAddContextListenerHandlerId = undefined;
	            }
	            else if (clientState.onUnsubscribeHandlerId === handlerId) {
	                clientState.onUnsubscribeHandlerId = undefined;
	            }
	        }
	        else {
	            console.warn(`Trying to remove a handler from a client that isn't mapped. handlerId: ${handlerId}. clientIdentity: ${id}`);
	        }
	    }
	    onAddContextHandlerAdded(payload, senderClientIdentity) {
	        const clientState = this.getClientState(senderClientIdentity);
	        const { handlerId } = payload;
	        if (!clientState) {
	            throw new Error(`Client with Identity: ${senderClientIdentity.uuid} ${senderClientIdentity.name}, tried to call onAddContextListener, is not connected to this Private Channel`);
	        }
	        clientState.onAddContextListenerHandlerId = handlerId;
	        // FDC3 Spec says that the added listener should fire for all previously-registered addContextListeners from the other client
	        Array.from(this.clients.values()).forEach((otherClientState) => {
	            if (otherClientState.clientIdentity.endpointId !== senderClientIdentity.endpointId) {
	                Array.from(otherClientState.handlerIdsByContextTypes.keys()).forEach((subscribedContextType) => {
	                    this.provider.dispatch(senderClientIdentity, handlerId, subscribedContextType);
	                });
	            }
	        });
	    }
	    onDisconnectHandlerAdded(payload, id) {
	        const clientState = this.getClientState(id);
	        const { handlerId } = payload;
	        if (!clientState) {
	            throw new Error(`Client with Identity: ${id.uuid} ${id.name}, tried to call onDisconnect, is not connected to this Private Channel`);
	        }
	        clientState.onDisconnectHandlerId = handlerId;
	    }
	    onUnsubscribeHandlerAdded(payload, id) {
	        const clientState = this.getClientState(id);
	        const { handlerId } = payload;
	        if (!clientState) {
	            throw new Error(`Client with Identity: ${id.uuid} ${id.name}, tried to call onUnsubscribe, is not connected to this Private Channel`);
	        }
	        clientState.onUnsubscribeHandlerId = handlerId;
	    }
	    removeClient(disconnectingClientIdentity) {
	        const disconnectingClientState = this.getClientState(disconnectingClientIdentity);
	        if (!disconnectingClientState) {
	            throw new Error(`Client with Identity: ${disconnectingClientIdentity.uuid} ${disconnectingClientIdentity.name}, tried to call disconnect, is not connected to this Private Channel`);
	        }
	        disconnectingClientState.handlerIdsByContextTypes.clear();
	        this.clients.delete(disconnectingClientIdentity.endpointId);
	    }
	    async fireOnDisconnectForOtherClients(disconnectingClientIdentity) {
	        // TODO: call onDisconnect Handler of the other client only.
	        // CURRENTLY, just calling the onDisconnect handler for all the other clients. Once we limit it to just one other client, we can eliminate all the iteration code.
	        const { endpointId } = disconnectingClientIdentity;
	        // getting only valid client connections here, it is possible we haven't removed a disconnected client from the map yet
	        // so we need to ensure we don't dispatch to any disconnected client
	        // TODO: Take a look at our client disconnection logic and see if we can handle client disconnection cleanly
	        const clientsToDispatchTo = await this.getConnectedClients();
	        const dispatchPromises = clientsToDispatchTo.map(async (otherClientState) => {
	            const { clientIdentity: { endpointId: otherClientEndpointId }, onDisconnectHandlerId } = otherClientState;
	            if (otherClientEndpointId !== endpointId && onDisconnectHandlerId) {
	                await this.provider.dispatch(otherClientState.clientIdentity, onDisconnectHandlerId);
	            }
	        });
	        try {
	            await Promise.all(dispatchPromises);
	        }
	        catch (error) {
	            console.error(`Problem when attempting to dispatch to onDisconnectHandlers. Error: ${error} Disconnecting Client: uuid: ${disconnectingClientIdentity.uuid}. name: ${disconnectingClientIdentity.name}. endpointId: ${disconnectingClientIdentity.endpointId}`);
	            throw new Error(error);
	        }
	    }
	    async unsubscribeAll(clientIdentity) {
	        const { endpointId } = clientIdentity;
	        const state = this.clients.get(endpointId);
	        if (state) {
	            const contextTypeHandlerIds = Array.from(state.handlerIdsByContextTypes.values()).flat();
	            const globalHandlerId = state.globalHandler;
	            if (contextTypeHandlerIds.length > 0) {
	                const unsubPromises = contextTypeHandlerIds.map(async (handlerId) => {
	                    return this.contextHandlerRemoved({ handlerId }, clientIdentity);
	                });
	                try {
	                    await Promise.all(unsubPromises);
	                }
	                catch (error) {
	                    console.error(error.message);
	                }
	            }
	            if (globalHandlerId) {
	                try {
	                    await this.contextHandlerRemoved({ handlerId: globalHandlerId }, clientIdentity);
	                }
	                catch (error) {
	                    console.error(error.message);
	                }
	            }
	        }
	    }
	    async handleClientDisconnecting(disconnectingClientIdentity) {
	        await this.unsubscribeAll(disconnectingClientIdentity);
	        this.removeClient(disconnectingClientIdentity);
	        await this.fireOnDisconnectForOtherClients(disconnectingClientIdentity);
	    }
	    registerNewClient(clientIdentity) {
	        if (!this.clients.has(clientIdentity.endpointId)) {
	            const clientSubscriptionState = {
	                clientIdentity,
	                handlerIdsByContextTypes: new Map(),
	                globalHandler: undefined,
	                onAddContextListenerHandlerId: undefined,
	                onUnsubscribeHandlerId: undefined,
	                onDisconnectHandlerId: undefined
	            };
	            this.clients.set(clientIdentity.endpointId, clientSubscriptionState);
	        }
	    }
	    async getConnectedClients() {
	        const allClientInfo = await this.provider.getAllClientInfo();
	        return Array.from(this.clients.values()).filter((clientState) => {
	            const { uuid, name } = clientState.clientIdentity;
	            return allClientInfo.some((clientInfo) => {
	                return name === clientInfo.name && uuid === clientInfo.uuid;
	            });
	        });
	    }
	    static init(channelProvider, id) {
	        return new PrivateChannelProvider(channelProvider, id);
	    }
	};
	PrivateChannelProvider.PrivateChannelProvider = PrivateChannelProvider$1;
	return PrivateChannelProvider;
}

var hasRequiredInteropBroker;

function requireInteropBroker () {
	if (hasRequiredInteropBroker) return InteropBroker;
	hasRequiredInteropBroker = 1;
	var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
	    if (kind === "m") throw new TypeError("Private method is not writable");
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
	};
	var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var _InteropBroker_fdc3Info, _InteropBroker_contextGroups;
	Object.defineProperty(InteropBroker, "__esModule", { value: true });
	InteropBroker.InteropBroker = void 0;
	const base_1 = base;
	const SessionContextGroupBroker_1 = requireSessionContextGroupBroker();
	const utils_1 = utils$1;
	const lodash_1 = require$$3;
	const PrivateChannelProvider_1 = requirePrivateChannelProvider();
	const defaultContextGroups = [
	    {
	        id: 'green',
	        displayMetadata: {
	            color: '#00CC88',
	            name: 'green'
	        }
	    },
	    {
	        id: 'purple',
	        displayMetadata: {
	            color: '#8C61FF',
	            name: 'purple'
	        }
	    },
	    {
	        id: 'orange',
	        displayMetadata: {
	            color: '#FF8C4C',
	            name: 'orange'
	        }
	    },
	    {
	        id: 'red',
	        displayMetadata: {
	            color: '#FF5E60',
	            name: 'red'
	        }
	    },
	    {
	        id: 'pink',
	        displayMetadata: {
	            color: '#FF8FB8',
	            name: 'pink'
	        }
	    },
	    {
	        id: 'yellow',
	        displayMetadata: {
	            color: '#E9FF8F',
	            name: 'yellow'
	        }
	    }
	];
	/**
	 * {@link https://developers.openfin.co/of-docs/docs/enable-color-linking}
	 *
	 * The Interop Broker is responsible for keeping track of the Interop state of the Platform, and for directing messages to the proper locations.
	 *
	 * @remarks This class contains some types related to FDC3 that are specific to OpenFin. {@link https://developers.openfin.co/of-docs/docs/fdc3-support-in-openfin OpenFin's FDC3 support} is forward- and backward-compatible.
	 * Standard types for {@link https://fdc3.finos.org/ FDC3} do not appear in OpenFin’s API documentation, to avoid duplication.
	 *
	 * ---
	 *
	 * There are 2 ways to inject custom functionality into the Interop Broker:
	 *
	 * **1. Configuration**
	 *
	 * At the moment, you can configure the default context groups for the Interop Broker without having to override it. To do so, include the `interopBrokerConfiguration` `contextGroups` option in your `platform` options in your manifest. This is the preferred method.
	 * ```js
	 * {
	 *      "runtime": {
	 *          "arguments": "--v=1 --inspect",
	 *          "version": "alpha-v19"
	 *      },
	 *      "platform": {
	 *          "uuid": "platform_customization_local",
	 *          "applicationIcon": "https://openfin.github.io/golden-prototype/favicon.ico",
	 *          "autoShow": false,
	 *          "providerUrl": "http://localhost:5555/provider.html",
	 *          "interopBrokerConfiguration": {
	 *              "contextGroups": [
	 *                  {
	 *                      "id": "green",
	 *                      "displayMetadata": {
	 *                          "color": "#00CC88",
	 *                          "name": "green"
	 *                      }
	 *                  },
	 *                  {
	 *                      "id": "purple",
	 *                      "displayMetadata": {
	 *                          "color": "#8C61FF",
	 *                          "name": "purple"
	 *                      }
	 *                  },
	 *              ]
	 *          }
	 *      }
	 * }
	 * ```
	 *
	 * By default the Interop Broker logs all actions to the console. You can disable this by using the logging option in `interopBrokerConfiguration`:
	 * ```js
	 * {
	 *      "runtime": {
	 *          "arguments": "--v=1 --inspect",
	 *          "version": "alpha-v19"
	 *      },
	 *      "platform": {
	 *          "uuid": "platform_customization_local",
	 *          "applicationIcon": "https://openfin.github.io/golden-prototype/favicon.ico",
	 *          "autoShow": false,
	 *          "providerUrl": "http://localhost:5555/provider.html",
	 *		    "interopBrokerConfiguration": {
	 *       		"logging": {
	 *   				"beforeAction": {
	 *   					"enabled": false
	 *   				},
	 *   				"afterAction": {
	 *   					"enabled": false
	 *   				}
	 *   			}
	 *		    }
	 *      }
	 * }
	 * ```
	 *
	 * ---
	 * **2. Overriding**
	 *
	 * Similarly to how {@link https://developers.openfin.co/docs/platform-customization#section-customizing-platform-behavior Platform Overriding} works, you can override functions in the Interop Broker in `fin.Platform.init`. An example of that is shown below. Overriding `isConnectionAuthorized` and `isActionAuthorized` will allow you to control allowed connections and allowed actions.
	 *
	 * However, if there is custom functionality you wish to include in the Interop Broker, please let us know. We would like to provide better configuration options so that you don't have to continually maintain your own override code.
	 *
	 * ```js
	 * fin.Platform.init({
	 *     overrideCallback: async (Provider) => {
	 *         class Override extends Provider {
	 *             async getSnapshot() {
	 *                 console.log('before getSnapshot')
	 *                 const snapshot = await super.getSnapshot();
	 *                 console.log('after getSnapshot')
	 *                 return snapshot;
	 *             }
	 *
	 *             async applySnapshot({ snapshot, options }) {
	 *                 console.log('before applySnapshot')
	 *                 const originalPromise = super.applySnapshot({ snapshot, options });
	 *                 console.log('after applySnapshot')
	 *
	 *                 return originalPromise;
	 *             }
	 *         };
	 *         return new Override();
	 *     },
	 *     interopOverride: async (InteropBroker) => {
	 *         class Override extends InteropBroker {
	 *             async joinContextGroup(channelName = 'default', target) {
	 *                 console.log('before super joinContextGroup')
	 *                 super.joinContextGroup(channelName, target);
	 *                 console.log('after super joinContextGroup')
	 *             }
	 *         }
	 *
	 *       return new Override();
	 *   }
	 * });
	 * ```
	 *
	 * ---
	 *
	 */
	let InteropBroker$1 = class InteropBroker extends base_1.Base {
	    /**
	     * @internal
	     */
	    constructor(wire, getProvider, options) {
	        // Tip from Pierre and Michael from the overrideCheck work: Don't use bound methods for overrideable InteropBroker functions.
	        super(wire);
	        this.getProvider = getProvider;
	        _InteropBroker_fdc3Info.set(this, void 0);
	        _InteropBroker_contextGroups.set(this, void 0);
	        this.interopClients = new Map();
	        this.contextGroupsById = new Map();
	        __classPrivateFieldSet(this, _InteropBroker_contextGroups, options.contextGroups ?? [...defaultContextGroups], "f");
	        __classPrivateFieldSet(this, _InteropBroker_fdc3Info, options.fdc3Info, "f");
	        if (options?.logging) {
	            this.logging = options.logging;
	        }
	        this.intentClientMap = new Map();
	        this.lastContextMap = new Map();
	        this.sessionContextGroupMap = new Map();
	        this.setContextGroupMap();
	        this.setupChannelProvider();
	    }
	    static createClosedConstructor(...args) {
	        return class OverrideableBroker extends InteropBroker {
	            constructor(...unused) {
	                if (unused.length) {
	                    const [_ignore1, ignore2, opts] = unused;
	                    if (opts && typeof opts === 'object' && !(0, lodash_1.isEqual)(opts, args[2])) {
	                        // eslint-disable-next-line no-console
	                        console.warn('You have modified the parameters of the InteropOverride constructor. This behavior is deprecated and will be removed in a future version. You can modify these options in your manifest. Please consult our Interop docs for guidance on migrating to the new override scheme.');
	                        super(args[0], args[1], opts);
	                        return;
	                    }
	                    // eslint-disable-next-line no-console
	                    console.warn('You are attempting to pass arguments to the InteropOverride constructor. This is not necessary, and these passed arguments will be ignored. You are likely using an older InteropBroker override scheme. Please consult our Interop docs for guidance on migrating to the new override scheme.');
	                }
	                super(...args);
	            }
	        };
	    }
	    /*
	    Client API
	    */
	    /**
	     * Sets a context for the context group of the incoming current entity.
	     * @param setContextOptions - New context to set.
	     * @param clientIdentity - Identity of the client sender.
	     *
	     */
	    setContext({ context }, clientIdentity) {
	        this.wire.sendAction('interop-broker-set-context').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        const clientState = this.getClientState(clientIdentity);
	        if (clientState && clientState.contextGroupId) {
	            const { contextGroupId } = clientState;
	            this.setContextForGroup({ context }, contextGroupId);
	        }
	        else if (clientState) {
	            // Client has not joined any context group behavior.
	            throw new Error('You must join a context group before you can set context.');
	        }
	        else {
	            // This shouldn't get hit.
	            throw new Error(`Client with Identity: ${clientIdentity.uuid} ${clientIdentity.name} not in Client State Map`);
	        }
	    }
	    /**
	     * Sets a context for the context group.
	     * @param setContextOptions - New context to set.
	     * @param contextGroupId - Context group id.
	     *
	     */
	    setContextForGroup({ context }, contextGroupId) {
	        this.wire.sendAction('interop-broker-set-context-for-group').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        const contextGroupState = this.contextGroupsById.get(contextGroupId);
	        if (!contextGroupState) {
	            throw new Error(`Unable to set context for context group that isn't in the context group mapping: ${contextGroupId}.`);
	        }
	        const contextIntegrityCheckResult = InteropBroker.checkContextIntegrity(context);
	        if (contextIntegrityCheckResult.isValid === false) {
	            throw new Error(`Failed to set Context - bad Context. Reason: ${contextIntegrityCheckResult.reason}. Context: ${JSON.stringify(context)}`);
	        }
	        const broadcastedContextType = context.type;
	        contextGroupState.set(broadcastedContextType, context);
	        this.lastContextMap.set(contextGroupId, broadcastedContextType);
	        const clientsInSameContextGroup = Array.from(this.interopClients.values()).filter((connectedClient) => connectedClient.contextGroupId === contextGroupId);
	        clientsInSameContextGroup.forEach((client) => {
	            for (const [, handlerInfo] of client.contextHandlers) {
	                if (InteropBroker.isContextTypeCompatible(broadcastedContextType, handlerInfo.contextType)) {
	                    this.invokeContextHandler(client.clientIdentity, handlerInfo.handlerId, context);
	                }
	            }
	        });
	    }
	    /**
	     * Get current context for a client subscribed to a Context Group.
	     *
	     * @remarks It takes an optional Context Type argument and returns the last context of that type.
	     *
	     * @param getContextOptions - Options for getting context
	     * @param clientIdentity - Identity of the client sender.
	     *
	     */
	    getCurrentContext(getCurrentContextOptions, clientIdentity) {
	        this.wire.sendAction('interop-broker-get-current-context').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        const clientState = this.getClientState(clientIdentity);
	        if (!clientState?.contextGroupId) {
	            throw new Error('You must be a member of a context group to call getCurrentContext');
	        }
	        const { contextGroupId } = clientState;
	        const contextGroupState = this.contextGroupsById.get(contextGroupId);
	        const lastContextType = this.lastContextMap.get(contextGroupId);
	        const contextType = getCurrentContextOptions?.contextType ?? lastContextType;
	        return contextGroupState && contextType ? contextGroupState.get(contextType) : undefined;
	    }
	    /*
	    Platform Window APIs
	    */
	    // joinContextGroup and addClientToContextGroup are separate functions here, for easier overrides and separation of concerns.
	    // joinContextGroup checks all connections for matching identities, in case we have multiple connection from an entity.
	    /**
	     * Join all connections at the given identity (or just one if endpointId provided) to context group `contextGroupId`.
	     * If no target is specified, it adds the sender to the context group.
	     * joinContextGroup is responsible for checking connections at the incoming identity. It calls {@link InteropBroker#addClientToContextGroup InteropBroker.addClientToContextGroup} to actually group the client.
	     * Used by Platform Windows.
	     *
	     * @param joinContextGroupOptions - Id of the Context Group and identity of the entity to join to the group.
	     * @param senderIdentity - Identity of the client sender.
	     */
	    async joinContextGroup({ contextGroupId, target }, senderIdentity) {
	        this.wire.sendAction('interop-broker-join-context-group').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        if (this.sessionContextGroupMap.has(contextGroupId)) {
	            throw new Error(utils_1.BROKER_ERRORS.joinSessionContextGroupWithJoinContextGroup);
	        }
	        if (target) {
	            // If an endpointId is provided, use that. This will likely be used by external adapters.
	            if (InteropBroker.hasEndpointId(target)) {
	                await this.addClientToContextGroup({ contextGroupId }, target);
	            }
	            // Sanity check here in case a single app has multiple connections
	            try {
	                const allConnections = this.channel.connections.filter((x) => x.uuid === target.uuid && x.name === target.name);
	                if (!allConnections.length) {
	                    throw new Error(`Given Identity ${target.uuid} ${target.name} is not connected to the Interop Broker.`);
	                }
	                if (allConnections.length > 1) {
	                    // Should figure out how we want to handle this situation. In the meantime, just change context group for all connections.
	                    console.warn(`More than one connection found for identity ${target.uuid} ${target.name}`);
	                }
	                const promises = [];
	                for (const connection of allConnections) {
	                    promises.push(this.addClientToContextGroup({ contextGroupId }, connection));
	                }
	                await Promise.all(promises);
	            }
	            catch (error) {
	                throw new Error(error);
	            }
	        }
	        else {
	            // No target provided, add the sender to the context group.
	            await this.addClientToContextGroup({ contextGroupId }, senderIdentity);
	        }
	    }
	    // addClientToContextGroup does the actual addition of the client to the Context Group
	    /**
	     * Helper function for {@link InteropBroker#joinContextGroup InteropBroker.joinContextGroup}. Does the work of actually adding the client to the Context Group.
	     * Used by Platform Windows.
	     *
	     * @param addClientToContextGroupOptions - Contains the contextGroupId
	     * @param clientIdentity - Identity of the client sender.
	     */
	    async addClientToContextGroup({ contextGroupId }, clientIdentity) {
	        this.wire.sendAction('interop-broker-add-client-to-context-group').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        const clientSubscriptionState = this.getClientState(clientIdentity);
	        if (!clientSubscriptionState) {
	            throw new Error(`Client with Identity: ${clientIdentity.uuid} ${clientIdentity.name} not in Client State Map`);
	        }
	        if (!this.getContextGroups().find((contextGroupInfo) => contextGroupInfo.id === contextGroupId)) {
	            throw new Error(`Attempting to join a context group that does not exist: ${contextGroupId}. You may only join existing context groups.`);
	        }
	        const oldContextGroupId = clientSubscriptionState.contextGroupId;
	        if (oldContextGroupId !== contextGroupId) {
	            clientSubscriptionState.contextGroupId = contextGroupId;
	            await this.setCurrentContextGroupInClientOptions(clientIdentity, contextGroupId);
	            const contextGroupMap = this.contextGroupsById.get(contextGroupId);
	            for (const [, handlerInfo] of clientSubscriptionState.contextHandlers) {
	                const { contextType, handlerId } = handlerInfo;
	                if (contextType === undefined) {
	                    // Send this single handler all of the context, because it accepts all.
	                    contextGroupMap.forEach((context, _) => {
	                        this.invokeContextHandler(clientIdentity, handlerId, context);
	                    });
	                }
	                else if (contextGroupMap.has(contextType)) {
	                    const contextForType = contextGroupMap.get(contextType);
	                    if (contextForType) {
	                        this.invokeContextHandler(clientIdentity, handlerId, contextForType);
	                    }
	                }
	            }
	        }
	    }
	    // Removes the target from its context group. Similar structure to joinContextGroup.
	    /**
	     * Removes the specified target from a context group.
	     * If no target is specified, it removes the sender from their context group.
	     * removeFromContextGroup is responsible for checking connections at the incoming identity.
	     *
	     * @remarks It calls {@link InteropBroker#removeClientFromContextGroup InteropBroker.removeClientFromContextGroup} to actually ungroup
	     * the client. Used by Platform Windows.
	     *
	     * @param removeFromContextGroupOptions - Contains the target identity to remove.
	     * @param senderIdentity - Identity of the client sender.
	     */
	    async removeFromContextGroup({ target }, senderIdentity) {
	        this.wire.sendAction('interop-broker-remove-from-context-group').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        if (target) {
	            // If an endpointId is provided, use that. This will likely be used by external adapters.
	            if (InteropBroker.hasEndpointId(target)) {
	                await this.removeClientFromContextGroup(target);
	            }
	            try {
	                // Sanity check here in case a single app has multiple connections
	                const allConnections = this.channel.connections.filter((x) => x.uuid === target.uuid && x.name === target.name);
	                if (!allConnections.length) {
	                    throw new Error(`No connection found for given Identity ${target.uuid} ${target.name}`);
	                }
	                if (allConnections.length > 1) {
	                    console.warn(`More than one connection found for identity ${target.uuid} ${target.name}`);
	                }
	                const promises = [];
	                for (const connection of allConnections) {
	                    promises.push(this.removeClientFromContextGroup(connection));
	                }
	                await Promise.all(promises);
	            }
	            catch (error) {
	                throw new Error(error);
	            }
	        }
	        else {
	            // No target provided, remove the sender from the context group.
	            await this.removeClientFromContextGroup(senderIdentity);
	        }
	    }
	    // removeClientFromContextGroup does the actual remove of the client from the Context Group
	    /**
	     * Helper function for {@link InteropBroker#removeFromContextGroup InteropBroker.removeFromContextGroup}. Does the work of actually removing the client from the Context Group.
	     * Used by Platform Windows.
	     *
	     * @property { ClientIdentity } clientIdentity - Identity of the client sender.
	     */
	    async removeClientFromContextGroup(clientIdentity) {
	        this.wire.sendAction('interop-broker-remove-client-from-context-group').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        const clientState = this.getClientState(clientIdentity);
	        if (clientState) {
	            clientState.contextGroupId = undefined;
	        }
	        await this.setCurrentContextGroupInClientOptions(clientIdentity, null);
	    }
	    // Used by platform windows to know what client groups the provider has declared. Also used internally to access context groups. Overrideable so that the platform developer can modify it.
	    /**
	     * Returns the Interop-Broker-defined context groups available for an entity to join. Because this function is used in the rest of the Interop Broker to fetch the Context Groups, overriding this allows you to customize the Context Groups for the Interop Broker. However, we recommend customizing the context groups through configuration instead.
	     * Used by Platform Windows.
	     *
	     */
	    // eslint-disable-next-line class-methods-use-this
	    getContextGroups() {
	        this.wire.sendAction('interop-broker-get-context-groups').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        // Create copy for immutability
	        return __classPrivateFieldGet(this, _InteropBroker_contextGroups, "f").map((contextGroup) => {
	            return { ...contextGroup };
	        });
	    }
	    // Used to by platform windows to get display metadata for a context group.
	    /**
	     * Gets display info for a context group
	     *
	     * @remarks Used by Platform Windows.
	     *
	     * @param getInfoForContextGroupOptions - Contains contextGroupId, the context group you wish to get display info for.
	     *
	     */
	    getInfoForContextGroup({ contextGroupId }) {
	        this.wire.sendAction('interop-broker-get-info-for-context-group').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        return this.getContextGroups().find((contextGroup) => contextGroup.id === contextGroupId);
	    }
	    // Used by platform windows to get all clients for a context group.
	    /**
	     * Gets all clients for a context group.
	     *
	     * @remarks **This is primarily used for platform windows. Views within a platform should not have to use this API.**
	     * Returns the Interop-Broker-defined context groups available for an entity to join.
	     *
	     * @param getAllClientsInContextGroupOptions - Contains contextGroupId, the context group you wish to get clients for.
	     *
	     */
	    getAllClientsInContextGroup({ contextGroupId }) {
	        this.wire.sendAction('interop-broker-get-all-clients-in-context-group').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        const clientsInContextGroup = Array.from(this.interopClients.values())
	            .filter((connectedClient) => connectedClient.contextGroupId === contextGroupId)
	            .map((subscriptionState) => {
	            return subscriptionState.clientIdentity;
	        });
	        return clientsInContextGroup;
	    }
	    /**
	     * Responsible for launching of applications that can handle a given intent, and delegation of intents to those applications.
	     * Must be overridden.
	     *
	     * @remarks To make this call FDC3-Compliant it would need to return an IntentResolution.
	     *
	     * ```js
	     * interface IntentResolution {
	     *   source: TargetApp;
	     *   // deprecated, not assignable from intent listeners
	     *   data?: object;
	     *   version: string;
	     * }
	     * ```
	     *
	     * More information on the IntentResolution type can be found in the [FDC3 documentation](https://fdc3.finos.org/docs/api/ref/IntentResolution).
	     *
	     * @param intent The combination of an action and a context that is passed to an application for resolution.
	     * @param  clientIdentity Identity of the Client making the request.
	     *
	     * @example
	     * ```js
	     * // override call so we set intent target and create view that will handle it
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker) => {
	     *         class Override extends InteropBroker {
	     *             async handleFiredIntent(intent) {
	     *                 super.setIntentTarget(intent, { uuid: 'platform-uuid', name: 'intent-view' });
	     *                 const platform = fin.Platform.getCurrentSync();
	     *                 const win = fin.Window.wrapSync({ name: 'foo', uuid: 'platform-uuid' });
	     *                 const createdView = await platform.createView({ url: 'http://openfin.co', name: 'intent-view' }, win.identity);
	     *             }
	     *         }
	     *         return new Override();
	     *     }
	     * });
	     * ```
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async handleFiredIntent(intent, clientIdentity // TODO(CORE-811): remove inline intersected type
	    ) {
	        const warning = (0, utils_1.generateOverrideWarning)('fdc3.raiseIntent', 'InteropBroker.handleFiredIntent', clientIdentity, 'interopClient.fireIntent');
	        console.warn(warning);
	        throw new Error(utils_1.BROKER_ERRORS.fireIntent);
	    }
	    /**
	     * Should be called in {@link InteropBroker#handleFiredIntent InteropBroker.handleFiredIntent}.
	     * While handleFiredIntent is responsible for launching applications, setIntentTarget is used to tell the InteropBroker which application should receive the intent when it is ready.
	     * @param intent The combination of an action and a context that is passed to an application for resolution.
	     * @param target - Identity of the target that will handle the intent.
	     *
	     */
	    async setIntentTarget(intent, target) {
	        this.wire.sendAction('interop-broker-set-intent-target').catch((e) => {
	            // don't expose, this is only for api analytics purposes
	        });
	        const targetInfo = this.intentClientMap.get(target.name);
	        const handlerId = `intent-handler-${intent.name}`;
	        if (!targetInfo) {
	            this.intentClientMap.set(target.name, new Map());
	            const newHandlerInfoMap = this.intentClientMap.get(target.name);
	            if (newHandlerInfoMap) {
	                newHandlerInfoMap.set(handlerId, { isReady: false, pendingIntents: [intent] });
	            }
	        }
	        else {
	            const handlerInfo = targetInfo.get(handlerId);
	            if (!handlerInfo) {
	                targetInfo.set(handlerId, { isReady: false, pendingIntents: [intent] });
	            }
	            else {
	                handlerInfo.pendingIntents.push(intent);
	                if (handlerInfo.clientIdentity && handlerInfo.isReady) {
	                    const { clientIdentity, pendingIntents } = handlerInfo;
	                    try {
	                        const intentToSend = pendingIntents[pendingIntents.length - 1];
	                        await this.invokeIntentHandler(clientIdentity, handlerId, intentToSend);
	                        handlerInfo.pendingIntents = [];
	                    }
	                    catch (error) {
	                        console.error(`Error invoking intent handler for client ${clientIdentity.uuid}/${clientIdentity.name}/${clientIdentity.endpointId}`);
	                        handlerInfo.isReady = false;
	                    }
	                }
	            }
	        }
	    }
	    /**
	     * Responsible for returning information on a particular Intent.
	     *
	     * @remarks Whenever InteropClient.getInfoForIntent is called this function will fire. The options argument gives you
	     * access to the intent name and any optional context that was passed and clientIdentity is the identity of the client
	     * that made the call. Ideally here you would fetch the info for the intent and return it with the shape that the
	     * InteropClient.getInfoForIntent call is expecting.
	     *
	     * To make this call FDC3-Compliant it would need to return an App Intent:
	     *
	     * ```js
	     * // {
	     * //     intent: { name: "StartChat", displayName: "Chat" },
	     * //     apps: [{ name: "Skype" }, { name: "Symphony" }, { name: "Slack" }]
	     * // }
	     * ```
	     *
	     * More information on the AppIntent type can be found in the [FDC3 documentation](https://fdc3.finos.org/docs/api/ref/AppIntent).
	     *
	     * @param options
	     * @param clientIdentity Identity of the Client making the request.
	     *
	     * @example
	     * ```js
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker) => {
	     *         class Override extends InteropBroker {
	     *             async handleInfoForIntent(options, clientIdentity) {
	     *                 // Your code goes here.
	     *             }
	     *         }
	     *         return new Override();
	     *     }
	     * });
	     * ```
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async handleInfoForIntent(options, clientIdentity // TODO(CORE-811): remove inline intersected type
	    ) {
	        const warning = (0, utils_1.generateOverrideWarning)('fdc3.findIntent', 'InteropBroker.handleInfoForIntent', clientIdentity, 'interopClient.getInfoForIntent');
	        console.warn(warning);
	        throw new Error(utils_1.BROKER_ERRORS.getInfoForIntent);
	    }
	    /**
	     * Responsible for returning information on which Intents are meant to handle a specific Context.
	     * Must be overridden.
	     *
	     * @remarks Responsible for returning information on which Intents are meant to handle a specific Context. Must be overridden.
	     *
	     * Whenever InteropClient.getInfoForIntentsByContext is called this function will fire. The context argument gives you access to the context that the client wants information on and clientIdentity is the identity of the client that made the call. Ideally here you would fetch the info for any intent that can handle and return it with the shape that the InteropClient.getInfoForIntentsByContext call is expecting.
	     *
	     * To make this call FDC3-Compliant it would need to return an array of AppIntents:
	     *
	     * ```js
	     * // [{
	     * //     intent: { name: "StartCall", displayName: "Call" },
	     * //     apps: [{ name: "Skype" }]
	     * // },
	     * // {
	     * //     intent: { name: "StartChat", displayName: "Chat" },
	     * //     apps: [{ name: "Skype" }, { name: "Symphony" }, { name: "Slack" }]
	     * // }];
	     * ```
	     *
	     * More information on the AppIntent type can be found in the [FDC3 documentation](https://fdc3.finos.org/docs/api/ref/AppIntent).
	     *
	     * @param context Data passed between entities and applications.
	     * @param clientIdentity Identity of the Client making the request.
	     *
	     * @example
	     * ```js
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker) => {
	     *         class Override extends InteropBroker {
	     *             async handleInfoForIntentsByContext(context, clientIdentity) {
	     *                 // Your code goes here.
	     *             }
	     *         }
	     *         return new Override();
	     *     }
	     * });
	     * ```
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async handleInfoForIntentsByContext(context, clientIdentity // TODO(CORE-811): remove inline intersected type
	    ) {
	        const warning = (0, utils_1.generateOverrideWarning)('fdc3.findIntentsByContext', 'InteropBroker.handleInfoForIntentsByContext', clientIdentity, 'interopClient.getInfoForIntentsByContext');
	        console.warn(warning);
	        throw new Error(utils_1.BROKER_ERRORS.getInfoForIntentsByContext);
	    }
	    /**
	     * Responsible for resolving an Intent based on a specific Context.
	     * Must be overridden.
	     *
	     * @remarks Whenever InteropClient.fireIntentForContext is called this function will fire. The contextForIntent argument
	     * gives you access to the context that will be resolved to an intent. It also can optionally contain any metadata relevant
	     * to resolving it, like a specific app the client wants the context to be handled by. The clientIdentity is the identity
	     * of the client that made the call.
	     *
	     * To make this call FDC3-Compliant it would need to return an IntentResolution:
	     *
	     * ```js
	     * // {
	     * //     intent: { name: "StartChat", displayName: "Chat" },
	     * //     apps: [{ name: "Skype" }, { name: "Symphony" }, { name: "Slack" }]
	     * // }
	     * ```
	     *
	     * More information on the IntentResolution type can be found in the [FDC3 documentation](https://fdc3.finos.org/docs/api/ref/Metadata#intentresolution).
	     *
	     * @param contextForIntent Data passed between entities and applications.
	     * @param clientIdentity Identity of the Client making the request.
	     *
	     * @example
	     * ```js
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker) => {
	     *         class Override extends InteropBroker {
	     *             async handleFiredIntentForContext(contextForIntent, clientIdentity) {
	     *                 // Your code goes here.
	     *             }
	     *         }
	     *         return new Override();
	     *     }
	     * });
	     * ```
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async handleFiredIntentForContext(contextForIntent, clientIdentity) {
	        const warning = (0, utils_1.generateOverrideWarning)('fdc3.raiseIntentForContext', 'InteropBroker.handleFiredIntentForContext', clientIdentity, 'interopClient.fireIntentForContext');
	        console.warn(warning);
	        throw new Error(utils_1.BROKER_ERRORS.fireIntentForContext);
	    }
	    /**
	     * Provides the identity of any Interop Client that disconnects from the Interop Broker. It is meant to be overriden.
	     * @param clientIdentity
	     *
	     * @example
	     * ```js
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker) => {
	     *         class Override extends InteropBroker {
	     *             async clientDisconnected(clientIdentity) {
	     *                 const { uuid, name } = clientIdentity;
	     *                 console.log(`Client with identity ${uuid}/${name} has been disconnected`);
	     *             }
	     *         }
	     *         return new Override();
	     *     }
	     * });
	     * ```
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async clientDisconnected(clientIdentity) {
	        // This function is called in channel.onDisconnection.
	        // It is meant to be overridden to inform when an Interop Client has been disconnected.
	    }
	    /**
	     * Responsible for resolving an fdc3.open call.
	     * Must be overridden.
	     * @param fdc3OpenOptions fdc3.open options
	     * @param clientIdentity Identity of the Client making the request.
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async fdc3HandleOpen({ app, context }, clientIdentity) {
	        const warning = (0, utils_1.generateOverrideWarning)('fdc3.open', 'InteropBroker.fdc3HandleOpen', clientIdentity);
	        console.warn(warning);
	        throw new Error(utils_1.BROKER_ERRORS.fdc3Open);
	    }
	    /**
	     * Responsible for resolving the fdc3.findInstances call.
	     * Must be overridden
	     * @param app AppIdentifier that was passed to fdc3.findInstances
	     * @param clientIdentity Identity of the Client making the request.
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async fdc3HandleFindInstances(app, clientIdentity) {
	        const warning = (0, utils_1.generateOverrideWarning)('fdc3.open', 'InteropBroker.fdc3HandleFindInstances', clientIdentity);
	        console.warn(warning);
	        throw new Error(utils_1.BROKER_ERRORS.fdc3FindInstances);
	    }
	    /**
	     * Responsible for resolving the fdc3.getAppMetadata call.
	     * Must be overridden
	     * @param app AppIdentifier that was passed to fdc3.getAppMetadata
	     * @param clientIdentity Identity of the Client making the request.
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async fdc3HandleGetAppMetadata(app, clientIdentity) {
	        const warning = (0, utils_1.generateOverrideWarning)('fdc3.getAppMetadata', 'InteropBroker.fdc3HandleGetAppMetadata', clientIdentity);
	        console.warn(warning);
	        throw new Error(utils_1.BROKER_ERRORS.fdc3GetAppMetadata);
	    }
	    /**
	     * This function is called by the Interop Broker whenever a Context handler would fire.
	     * For FDC3 2.0 you would need to override this function and add the contextMetadata as
	     * part of the Context object. Then would you need to call
	     * super.invokeContextHandler passing it this new Context object along with the clientIdentity and handlerId
	     * @param clientIdentity
	     * @param handlerId
	     * @param context
	     *
	     * @example
	     * ```js
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker) => {
	     *         class Override extends InteropBroker {
	     *             async invokeContextHandler(clientIdentity, handlerId, context) {
	     *                 return super.invokeContextHandler(clientIdentity, handlerId, {
	     *                     ...context,
	     *                     contextMetadata: {
	     *                         source: {
	     *                             appId: 'openfin-app',
	     *                             instanceId: '3D54D456D9HT0'
	     *                         }
	     *                     }
	     *                 });
	     *             }
	     *         }
	     *         return new Override();
	     *     }
	     * });
	     * ```
	     */
	    async invokeContextHandler(clientIdentity, handlerId, context) {
	        const provider = await this.getProvider();
	        try {
	            await provider.dispatch(clientIdentity, handlerId, context);
	        }
	        catch (error) {
	            console.error(`Error invoking context handler ${handlerId} for context type ${context.type} in client ${clientIdentity.uuid}/${clientIdentity.name}/${clientIdentity.endpointId}`, error);
	        }
	    }
	    /**
	     * This function is called by the Interop Broker whenever an Intent handler would fire.
	     * For FDC3 2.0 you would need to override this function and add the contextMetadata as
	     * part of the Context object inside the Intent object. Then would you need to call
	     * super.invokeIntentHandler passing it this new Intent object along with the clientIdentity and handlerId
	     * @param ClientIdentity
	     * @param handlerId
	     * @param context
	     *
	     * @example
	     * ```js
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker) => {
	     *         class Override extends InteropBroker {
	     *             async invokeIntentHandler(clientIdentity, handlerId, context) {
	     *                 const { context } = intent;
	     *                 return super.invokeIntentHandler(clientIdentity, handlerId, {
	     *                     ...intent,
	     *                     context: {
	     *                         ...context,
	     *                         contextMetadata: {
	     *                             source: {
	     *                                 appId: 'openfin-app',
	     *                                 instanceId: '3D54D456D9HT0'
	     *                             }
	     *                         }
	     *                     }
	     *                 });
	     *             }
	     *         }
	     *         return new Override();
	     *     }
	     * });
	     * ```
	     */
	    async invokeIntentHandler(clientIdentity, handlerId, intent) {
	        const provider = await this.getProvider();
	        await provider.dispatch(clientIdentity, handlerId, intent);
	    }
	    /**
	     * Responsible for resolving fdc3.getInfo for FDC3 2.0
	     * Would need to return the optionalFeatures and appMetadata for the {@link https://fdc3.finos.org/docs/api/ref/Metadata#implementationmetadata ImplementationMetadata}.
	     * Must be overridden.
	     * @param clientIdentity
	     *
	     */
	    // eslint-disable-next-line class-methods-use-this
	    async fdc3HandleGetInfo(payload, clientIdentity) {
	        const { fdc3Version } = payload;
	        return {
	            fdc3Version,
	            ...__classPrivateFieldGet(this, _InteropBroker_fdc3Info, "f"),
	            optionalFeatures: {
	                OriginatingAppMetadata: false,
	                UserChannelMembershipAPIs: true
	            },
	            appMetadata: {
	                appId: '',
	                instanceId: ''
	            }
	        };
	    }
	    /**
	     * Returns an array of info for each Interop Client connected to the Interop Broker.
	     *
	     * FDC3 2.0: Use the endpointId in the ClientInfo as the instanceId when generating
	     * an AppIdentifier.
	     *
	     * @remarks FDC3 2.0 Note: When needing an instanceId to generate an AppIdentifier use this call to
	     * get the endpointId and use it as the instanceId. In the Example below we override handleFiredIntent
	     * and then call super.getAllClientInfo to generate the AppIdentifier for the IntentResolution.
	     *
	     *
	     * @example
	     * ```js
	     * // FDC3 2.0 Example:
	     * fin.Platform.init({
	     *     interopOverride: async (InteropBroker, ...args) => {
	     *         class Override extends InteropBroker {
	     *             async handleFiredIntent(intent) {
	     *                 super.setIntentTarget(intent, { uuid: 'platform-uuid', name: 'intent-view' });
	     *                 const platform = fin.Platform.getCurrentSync();
	     *                 const win = fin.Window.wrapSync({ name: 'foo', uuid: 'platform-uuid' });
	     *                 const createdView = await platform.createView({ url: 'http://openfin.co', name: 'intent-view' }, win.identity);
	     *
	     *                 const allClientInfo = await super.getAllClientInfo();
	     *
	     *                 const infoForTarget = allClientInfo.find((clientInfo) => {
	     *                     return clientInfo.uuid === 'platform-uuid' && clientInfo.name === 'intent-view';
	     *                 });
	     *
	     *                 const source = {
	     *                     appId: 'intent-view',
	     *                     instanceId: infoForTarget.endpointId
	     *                 }
	     *
	     *                 return {
	     *                     source,
	     *                     intent: intent.name
	     *                 }
	     *
	     *             }
	     *         }
	     *         return new Override(...args);
	     *     }
	     * });
	     * ```
	     */
	    async getAllClientInfo() {
	        const provider = await this.getProvider();
	        return provider.getAllClientInfo();
	    }
	    /*
	    Snapshot APIs
	    */
	    // Used to save interop broker state in snapshots
	    decorateSnapshot(snapshot) {
	        return { ...snapshot, interopSnapshotDetails: { contextGroupStates: this.getContextGroupStates() } };
	    }
	    // Used to restore interop broker state in snapshots.
	    applySnapshot(snapshot, options) {
	        const contextGroupStates = snapshot?.interopSnapshotDetails?.contextGroupStates;
	        if (contextGroupStates) {
	            if (!options?.closeExistingWindows) {
	                this.updateExistingClients(contextGroupStates);
	            }
	            this.rehydrateContextGroupStates(contextGroupStates);
	        }
	    }
	    updateExistingClients(contextGroupStates) {
	        const clients = this.interopClients;
	        clients.forEach((subState) => {
	            const { clientIdentity, contextGroupId, contextHandlers } = subState;
	            if (contextGroupId) {
	                const groupContexts = contextGroupStates[contextGroupId];
	                for (const [, context] of Object.entries(groupContexts)) {
	                    contextHandlers.forEach((contextHandler) => {
	                        const { handlerId, contextType } = contextHandler;
	                        if (InteropBroker.isContextTypeCompatible(context.type, contextType)) {
	                            this.invokeContextHandler(clientIdentity, handlerId, context);
	                        }
	                    });
	                }
	            }
	        });
	    }
	    // Used to store context group state in snapshots
	    getContextGroupStates() {
	        return InteropBroker.toObject(this.contextGroupsById);
	    }
	    // Used to rehydrate the context state from a snapshot
	    rehydrateContextGroupStates(incomingContextGroupStates) {
	        const contextGroupStates = Object.entries(incomingContextGroupStates);
	        for (const [contextGroupId, contexts] of contextGroupStates) {
	            const contextObjects = Object.entries(contexts);
	            for (const [contextType, context] of contextObjects) {
	                if (this.contextGroupsById.has(contextGroupId)) {
	                    const currentContextGroupState = this.contextGroupsById.get(contextGroupId);
	                    currentContextGroupState.set(contextType, context);
	                }
	                else {
	                    // This logic will change when dynamic context group creation comes in.
	                    console.warn(`Attempting to set a context group that isn't in the context group mapping. Skipping context group rehydration for: ${contextGroupId}`);
	                }
	            }
	        }
	    }
	    /*
	    Internal Context Handler APIs
	    */
	    // Used to give context to a client that has registered their context handler
	    contextHandlerRegistered({ contextType, handlerId }, clientIdentity) {
	        const handlerInfo = { contextType, handlerId };
	        const clientState = this.getClientState(clientIdentity);
	        clientState?.contextHandlers.set(handlerId, handlerInfo);
	        if (clientState && clientState.contextGroupId) {
	            const { contextGroupId } = clientState;
	            const contextGroupMap = this.contextGroupsById.get(contextGroupId);
	            if (contextType === undefined) {
	                // Send this single handler all of the context, because it accepts all.
	                contextGroupMap.forEach((context, _) => {
	                    this.invokeContextHandler(clientIdentity, handlerId, context);
	                });
	            }
	            else if (contextGroupMap.has(contextType)) {
	                const contextForType = contextGroupMap.get(contextType);
	                if (contextForType) {
	                    this.invokeContextHandler(clientIdentity, handlerId, contextForType);
	                }
	            }
	        }
	    }
	    // eslint-disable-next-line class-methods-use-this
	    async intentHandlerRegistered(payload, clientIdentity) {
	        const { handlerId } = payload;
	        const clientIntentInfo = this.intentClientMap.get(clientIdentity.name);
	        const handlerInfo = clientIntentInfo?.get(handlerId);
	        if (!clientIntentInfo) {
	            this.intentClientMap.set(clientIdentity.name, new Map());
	            const newHandlerInfoMap = this.intentClientMap.get(clientIdentity.name);
	            if (newHandlerInfoMap) {
	                newHandlerInfoMap.set(handlerId, { isReady: true, pendingIntents: [], clientIdentity });
	            }
	        }
	        else if (!handlerInfo) {
	            clientIntentInfo.set(handlerId, { isReady: true, pendingIntents: [], clientIdentity });
	        }
	        else {
	            const { pendingIntents } = handlerInfo;
	            handlerInfo.clientIdentity = clientIdentity;
	            handlerInfo.isReady = true;
	            try {
	                if (pendingIntents.length > 0) {
	                    const intentToSend = pendingIntents[pendingIntents.length - 1];
	                    await this.invokeIntentHandler(clientIdentity, handlerId, intentToSend);
	                    handlerInfo.pendingIntents = [];
	                }
	            }
	            catch (error) {
	                console.error(`Error invoking intent handler: ${handlerId} for client ${clientIdentity.uuid}/${clientIdentity.name}/${clientIdentity.endpointId}`);
	            }
	        }
	    }
	    // Used to remove a context handler for a client
	    removeContextHandler({ handlerId }, clientIdentity) {
	        const clientState = this.getClientState(clientIdentity);
	        if (clientState) {
	            clientState.contextHandlers.delete(handlerId);
	        }
	    }
	    handleJoinSessionContextGroup({ sessionContextGroupId }, clientIdentity) {
	        try {
	            if (!sessionContextGroupId) {
	                throw new Error('Failed to join session context group: must specify group id.');
	            }
	            const sessionContextGroup = this.sessionContextGroupMap.get(sessionContextGroupId);
	            if (sessionContextGroup) {
	                sessionContextGroup.registerNewClient(clientIdentity);
	            }
	            else {
	                const newSessionContextGroupBroker = new SessionContextGroupBroker_1.default(this.channel, sessionContextGroupId);
	                newSessionContextGroupBroker.registerNewClient(clientIdentity);
	                this.sessionContextGroupMap.set(sessionContextGroupId, newSessionContextGroupBroker);
	            }
	            return { hasConflict: this.contextGroupsById.has(sessionContextGroupId) };
	        }
	        catch (error) {
	            throw new Error(error);
	        }
	    }
	    /*
	    Internal Utilties
	    */
	    // Getter for interop info for a client.
	    getClientState(id) {
	        return this.interopClients.get(id.endpointId);
	    }
	    // Util for getContextGroupStates. Serializes the contextGroupStates object so we can store it.
	    static toObject(map) {
	        const objectFromMap = Object.fromEntries(map);
	        const newObject = {};
	        Object.entries(objectFromMap).forEach(([contextGroupId, contextMap]) => {
	            const newContextObject = Object.fromEntries(contextMap);
	            newObject[contextGroupId] = newContextObject;
	        });
	        return newObject;
	    }
	    static checkContextIntegrity(context) {
	        if (!context) {
	            return { isValid: false, reason: 'No context supplied' };
	        }
	        if (typeof context !== 'object') {
	            return { isValid: false, reason: 'Context must be an Object' };
	        }
	        if (!context.type) {
	            return { isValid: false, reason: 'Context must have a type property' };
	        }
	        if (context.id && typeof context.id !== 'object') {
	            return {
	                isValid: false,
	                reason: 'Context id must be an Object populated with key-value identifiers (if set)'
	            };
	        }
	        if (context.id) {
	            const { id } = context;
	            const keys = Object.keys(id);
	            let foundBadIdentifier = false;
	            if (!keys.length) {
	                return { isValid: false, reason: 'Context id must have at least one key-value identifier' };
	            }
	            keys.forEach((key) => {
	                if (typeof key !== 'string' || typeof id[key] !== 'string') {
	                    foundBadIdentifier = true;
	                }
	            });
	            if (foundBadIdentifier) {
	                return { isValid: false, reason: 'Context id key-value identifiers must be of type string' };
	            }
	        }
	        if (context.name && typeof context.name !== 'string') {
	            return { isValid: false, reason: 'Context name must be of string type (if set)' };
	        }
	        return { isValid: true };
	    }
	    // Util to check a client identity.
	    static hasEndpointId(target) {
	        return target.endpointId !== undefined;
	    }
	    // Util to check if we should send a context to a handler.
	    static isContextTypeCompatible(contextType, registeredContextType) {
	        return typeof registeredContextType === 'undefined' || contextType === registeredContextType;
	    }
	    // Setup function for state mapping
	    setContextGroupMap() {
	        // This way, if a user overrides this.getContextGroups, it's reflected in the contextGroupMapping.
	        for (const contextGroupInfo of this.getContextGroups()) {
	            this.contextGroupsById.set(contextGroupInfo.id, new Map());
	        }
	    }
	    async setCurrentContextGroupInClientOptions(clientIdentity, contextGroupId) {
	        try {
	            const entityInfo = await this.fin.System.getEntityInfo(clientIdentity.uuid, clientIdentity.name);
	            let entity;
	            if (entityInfo.entityType === 'view') {
	                entity = await this.fin.View.wrap(clientIdentity);
	            }
	            else if (entityInfo.entityType === 'window') {
	                entity = await this.fin.Window.wrap(clientIdentity);
	            }
	            if (entity) {
	                await entity.updateOptions({
	                    interop: {
	                        currentContextGroup: contextGroupId
	                    }
	                });
	            }
	        }
	        catch (error) {
	            //  May file in interop
	        }
	    }
	    async setupChannelProvider() {
	        try {
	            const channel = await this.getProvider();
	            this.channel = channel;
	            this.wireChannel(channel);
	        }
	        catch (error) {
	            throw new Error(`Error setting up Interop Broker Channel Provider: ${error}`);
	        }
	    }
	    // Setup Channel Connection Logic
	    wireChannel(channel) {
	        channel.onConnection(async (clientIdentity, // TODO(CORE-811): remove inline intersected type
	        payload) => {
	            if (!(await this.isConnectionAuthorized(clientIdentity, payload))) {
	                throw new Error(`Connection not authorized for ${clientIdentity.uuid}, ${clientIdentity.name}`);
	            }
	            if (!clientIdentity.endpointId) {
	                throw new Error('Version too old to be compatible with Interop. Please upgrade your runtime to a more recent version.');
	            }
	            const clientSubscriptionState = {
	                contextGroupId: undefined,
	                contextHandlers: new Map(),
	                clientIdentity
	            };
	            // Only allow the client to join a contextGroup that actually exists.
	            if (payload?.currentContextGroup && this.contextGroupsById.has(payload.currentContextGroup)) {
	                clientSubscriptionState.contextGroupId = payload?.currentContextGroup;
	            }
	            this.interopClients.set(clientIdentity.endpointId, clientSubscriptionState);
	        });
	        channel.onDisconnection((clientIdentity) => {
	            this.interopClients.delete(clientIdentity.endpointId);
	            const targetInfo = this.intentClientMap.get(clientIdentity.name);
	            if (targetInfo && clientIdentity.uuid === this.fin.me.uuid) {
	                targetInfo.forEach((handler) => {
	                    handler.isReady = false;
	                });
	            }
	            this.sessionContextGroupMap.forEach((sessionContextGroup) => {
	                sessionContextGroup.onDisconnection(clientIdentity);
	            });
	            this.clientDisconnected(clientIdentity);
	        });
	        channel.beforeAction(async (action, payload, clientIdentity) => {
	            if (!(await this.isActionAuthorized(action, payload, clientIdentity))) {
	                throw new Error(`Action (${action}) not authorized for ${clientIdentity.uuid}, ${clientIdentity.name}`);
	            }
	            if (this.logging?.beforeAction?.enabled) {
	                console.log(action, payload, clientIdentity);
	            }
	        });
	        channel.afterAction((action, payload, clientIdentity) => {
	            if (this.logging?.afterAction?.enabled) {
	                console.log(action, payload, clientIdentity);
	            }
	        });
	        // Client functions
	        channel.register('setContext', this.setContext.bind(this));
	        channel.register('fireIntent', this.handleFiredIntent.bind(this));
	        channel.register('getCurrentContext', this.getCurrentContext.bind(this));
	        channel.register('getInfoForIntent', this.handleInfoForIntent.bind(this));
	        channel.register('getInfoForIntentsByContext', this.handleInfoForIntentsByContext.bind(this));
	        channel.register('fireIntentForContext', this.handleFiredIntentForContext.bind(this));
	        // Platform window functions
	        channel.register('getContextGroups', this.getContextGroups.bind(this));
	        channel.register('joinContextGroup', this.joinContextGroup.bind(this));
	        channel.register('removeFromContextGroup', this.removeFromContextGroup.bind(this));
	        channel.register('getAllClientsInContextGroup', this.getAllClientsInContextGroup.bind(this));
	        channel.register('getInfoForContextGroup', this.getInfoForContextGroup.bind(this));
	        // Internal methods
	        channel.register('contextHandlerRegistered', this.contextHandlerRegistered.bind(this));
	        channel.register('intentHandlerRegistered', this.intentHandlerRegistered.bind(this));
	        channel.register('removeContextHandler', this.removeContextHandler.bind(this));
	        channel.register('sessionContextGroup:createIfNeeded', this.handleJoinSessionContextGroup.bind(this));
	        // fdc3 only methods
	        channel.register('fdc3Open', this.fdc3HandleOpen.bind(this));
	        channel.register('fdc3v2FindIntentsByContext', this.handleInfoForIntentsByContext.bind(this));
	        channel.register('fdc3FindInstances', this.fdc3HandleFindInstances.bind(this));
	        channel.register('fdc3GetAppMetadata', this.fdc3HandleGetAppMetadata.bind(this));
	        channel.register('fdc3v2GetInfo', async (payload, clientIdentity) => {
	            return this.fdc3HandleGetInfo.bind(this)(payload, clientIdentity);
	        });
	        channel.register('createPrivateChannelProvider', async (payload) => {
	            const { channelId } = payload;
	            const channelProvider = await this.fin.InterApplicationBus.Channel.create(channelId);
	            PrivateChannelProvider_1.PrivateChannelProvider.init(channelProvider, channelId);
	        });
	    }
	    /**
	     * Can be used to completely prevent a connection. Return false to prevent connections. Allows all connections by default.
	     * @param _id the identity tryinc to connect
	     * @param _connectionPayload optional payload to use in custom implementations, will be undefined by default
	     */
	    isConnectionAuthorized(_id, _connectionPayload) {
	        this.wire.sendAction('interop-broker-is-connection-authorized').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        return Promise.resolve(true);
	    }
	    /**
	     * Called before every action to check if this entity should be allowed to take the action.
	     * Return false to prevent the action
	     * @param _action the string action to authorize in camel case
	     * @param _payload the data being sent for this action
	     * @param _identity the connection attempting to dispatch this action
	     */
	    isActionAuthorized(_action, _payload, _identity) {
	        this.wire.sendAction('interop-broker-is-action-authorized').catch((e) => {
	            // don't expose, analytics-only call
	        });
	        return Promise.resolve(true);
	    }
	};
	InteropBroker.InteropBroker = InteropBroker$1;
	_InteropBroker_fdc3Info = new WeakMap(), _InteropBroker_contextGroups = new WeakMap();
	return InteropBroker;
}

var InteropClient$1 = {};

var SessionContextGroupClient$1 = {};

var __classPrivateFieldSet$3 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$3 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SessionContextGroupClient_clientPromise;
Object.defineProperty(SessionContextGroupClient$1, "__esModule", { value: true });
const base_1$3 = base;
const utils_1$3 = utils$1;
class SessionContextGroupClient extends base_1$3.Base {
    constructor(wire, client, id) {
        super(wire);
        _SessionContextGroupClient_clientPromise.set(this, void 0);
        this.id = id;
        __classPrivateFieldSet$3(this, _SessionContextGroupClient_clientPromise, client, "f");
    }
    /**
     * Sets a context for the session context group.
     * @param context - New context to set.
     *
     * @tutorial interop.setContext
     */
    async setContext(context) {
        this.wire.sendAction('interop-session-context-group-set-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$3(this, _SessionContextGroupClient_clientPromise, "f");
        return client.dispatch(`sessionContextGroup:setContext-${this.id}`, {
            sessionContextGroupId: this.id,
            context
        });
    }
    async getCurrentContext(type) {
        this.wire.sendAction('interop-session-context-group-get-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$3(this, _SessionContextGroupClient_clientPromise, "f");
        return client.dispatch(`sessionContextGroup:getContext-${this.id}`, {
            sessionContextGroupId: this.id,
            type
        });
    }
    async addContextHandler(contextHandler, contextType) {
        this.wire.sendAction('interop-session-context-group-add-handler').catch((e) => {
            // don't expose, analytics-only call
        });
        if (typeof contextHandler !== 'function') {
            throw new Error("Non-function argument passed to the first parameter 'handler'. Be aware that the argument order does not match the FDC3 standard.");
        }
        const client = await __classPrivateFieldGet$3(this, _SessionContextGroupClient_clientPromise, "f");
        let handlerId;
        if (contextType) {
            handlerId = `sessionContextHandler:invoke-${this.id}-${contextType}-${(0, utils_1$3.generateId)()}`;
        }
        else {
            handlerId = `sessionContextHandler:invoke-${this.id}`;
        }
        client.register(handlerId, (0, utils_1$3.wrapContextHandler)(contextHandler, handlerId));
        await client.dispatch(`sessionContextGroup:handlerAdded-${this.id}`, { handlerId, contextType });
        return { unsubscribe: await this.createUnsubscribeCb(handlerId) };
    }
    async createUnsubscribeCb(handlerId) {
        const client = await __classPrivateFieldGet$3(this, _SessionContextGroupClient_clientPromise, "f");
        return async () => {
            client.remove(handlerId);
            await client.dispatch(`sessionContextGroup:handlerRemoved-${this.id}`, { handlerId });
        };
    }
    getUserInstance() {
        return {
            id: this.id,
            setContext: (0, utils_1$3.wrapInTryCatch)(this.setContext.bind(this), 'Failed to set context: '),
            getCurrentContext: (0, utils_1$3.wrapInTryCatch)(this.getCurrentContext.bind(this), 'Failed to get context: '),
            addContextHandler: (0, utils_1$3.wrapInTryCatch)(this.addContextHandler.bind(this), 'Failed to add context handler: ')
        };
    }
}
SessionContextGroupClient$1.default = SessionContextGroupClient;
_SessionContextGroupClient_clientPromise = new WeakMap();

var __classPrivateFieldSet$2 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$2 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InteropClient_clientPromise, _InteropClient_sessionContextGroups;
Object.defineProperty(InteropClient$1, "__esModule", { value: true });
InteropClient$1.InteropClient = void 0;
const base_1$2 = base;
const SessionContextGroupClient_1 = SessionContextGroupClient$1;
const utils_1$2 = utils$1;
/**
 * The Interop Client API is broken up into two groups:
 *
 * **Content Facing APIs** - For Application Developers putting Views into a Platform Window, who care about Context. These are APIs that send out and receive the Context data that flows between applications. Think of this as the Water in the Interop Pipes.
 *
 * **Context Grouping APIs** - For Platform Developers, to add and remove Views to and from Context Groups. These APIs are utilized under-the-hood in Platforms, so they don't need to be used to participate in Interop. These are the APIs that decide which entities the context data flows between. Think of these as the valves or pipes that control the flow of Context Data for Interop.
 *
 * ---
 *
 * All APIs are available at the `fin.me.interop` namespace.
 *
 * ---
 *
 * **You only need 2 things to participate in Interop Context Grouping:**
 * * A Context Handler for incoming context: {@link InteropClient#addContextHandler addContextHandler(handler, contextType?)}
 * * Call setContext on your context group when you want to share context with other group members: {@link InteropClient#setContext setContext(context)}
 *
 * ---
 *
 * ##### Constructor
 * Returned by {@link Interop.connectSync Interop.connectSync}.
 *
 * ---
 *
 * ##### Interop methods intended for Views
 *
 *
 * **Context Groups API**
 *  * {@link InteropClient#addContextHandler addContextHandler(handler, contextType?)}
 *  * {@link InteropClient#setContext setContext(context)}
 *  * {@link InteropClient#getCurrentContext getCurrentContext(contextType?)}
 *  * {@link InteropClient#joinSessionContextGroup joinSessionContextGroup(sessionContextGroupId)}
 *
 *
 * **Intents API**
 *  * {@link InteropClient#fireIntent fireIntent(intent)}
 *  * {@link InteropClient#registerIntentHandler registerIntentHandler(intentHandler, intentName)}
 *  * {@link InteropClient#getInfoForIntent getInfoForIntent(infoForIntentOptions)}
 *  * {@link InteropClient#getInfoForIntentsByContext getInfoForIntentsByContext(context)}
 *  * {@link InteropClient#fireIntentForContext fireIntentForContext(contextForIntent)}
 *
 * ##### Interop methods intended for Windows
 *  * {@link InteropClient#getContextGroups getContextGroups()}
 *  * {@link InteropClient#joinContextGroup joinContextGroup(contextGroupId, target?)}
 *  * {@link InteropClient#removeFromContextGroup removeFromContextGroup(target?)}
 *  * {@link InteropClient#getInfoForContextGroup getInfoForContextGroup(contextGroupId)}
 *  * {@link InteropClient#getAllClientsInContextGroup getAllClientsInContextGroup(contextGroupId)}
 *
 */
class InteropClient extends base_1$2.Base {
    /**
     * @internal
     */
    constructor(wire, name, interopConfig = {}) {
        super(wire);
        _InteropClient_clientPromise.set(this, void 0);
        _InteropClient_sessionContextGroups.set(this, void 0);
        __classPrivateFieldSet$2(this, _InteropClient_sessionContextGroups, new Map(), "f");
        __classPrivateFieldSet$2(this, _InteropClient_clientPromise, this.wire.environment.whenReady().then(() => {
            return this.fin.InterApplicationBus.Channel.connect(`interop-broker-${name}`, {
                payload: interopConfig
            });
        }), "f");
    }
    /*
    Client APIs
    */
    /**
     * Sets a context for the context group of the current entity.
     *
     * @remarks The entity must be part of a context group in order set a context.
     *
     * @param context - New context to set.
     *
     * @example
     * ```js
     * setInstrumentContext = async (ticker) => {
     *     fin.me.interop.setContext({type: 'instrument', id: {ticker}})
     * }
     *
     * // The user clicks an instrument of interest. We want to set that Instrument context so that the rest of our workflow updates with information for that instrument
     * instrumentElement.on('click', (evt) => {
     *     setInstrumentContext(evt.ticker)
     * })
     * ```
     */
    async setContext(context) {
        this.wire.sendAction('interop-client-set-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('setContext', { context });
    }
    /**
     * Add a context handler for incoming context. If an entity is part of a context group, and then sets its context handler,
     * it will receive all of its declared contexts.
     *
     * @param handler - Handler for incoming context.
     * @param contextType - The type of context you wish to handle.
     *
     * @example
     * ```js
     * function handleIncomingContext(contextInfo) {
     *     const { type, id } = contextInfo;
     *     switch (type) {
     *         case 'instrument':
     *             handleInstrumentContext(contextInfo);
     *             break;
     *         case 'country':
     *             handleCountryContext(contextInfo);
     *             break;
     *
     *         default:
     *             break;
     *     }
     * }
     *
     *
     * function handleInstrumentContext(contextInfo) {
     *     const { type, id } = contextInfo;
     *     console.log('contextInfo for instrument', contextInfo)
     * }
     *
     * function handleCountryContext(contextInfo) {
     *     const { type, id } = contextInfo;
     *     console.log('contextInfo for country', contextInfo)
     * }
     *
     * fin.me.interop.addContextHandler(handleIncomingContext);
     * ```
     *
     *
     * We are also testing the ability to add a context handler for specific contexts. If you would like to use
     * this, please make sure you add your context handlers at the top level of your application, on a page that
     * does not navigate/reload/re-render, to avoid memory leaks.  This feature is experimental:
     *
     * ```js
     * function handleInstrumentContext(contextInfo) {
     *     const { type, id } = contextInfo;
     *     console.log('contextInfo for instrument', contextInfo)
     * }
     *
     * function handleCountryContext(contextInfo) {
     *     const { type, id } = contextInfo;
     *     console.log('contextInfo for country', contextInfo)
     * }
     *
     *
     * fin.me.interop.addContextHandler(handleInstrumentContext, 'instrument')
     * fin.me.interop.addContextHandler(handleCountryContext, 'country')
     * ```
     */
    async addContextHandler(handler, contextType) {
        this.wire.sendAction('interop-client-add-context-handler').catch((e) => {
            // don't expose, analytics-only call
        });
        if (typeof handler !== 'function') {
            throw new Error("Non-function argument passed to the first parameter 'handler'. Be aware that the argument order does not match the FDC3 standard.");
        }
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        let handlerId;
        if (contextType) {
            handlerId = `invokeContextHandler-${contextType}-${(0, utils_1$2.generateId)()}`;
            console.warn(`Warning: By providing a contextType (${contextType}), you are using the experimental addContextHandler. To avoid issues, make sure you are adding your context handlers at the top level in your application.`);
        }
        else {
            handlerId = 'invokeContextHandler';
        }
        const wrappedHandler = (0, utils_1$2.wrapContextHandler)(handler, handlerId);
        client.register(handlerId, wrappedHandler);
        await client.dispatch('contextHandlerRegistered', { handlerId, contextType });
        return {
            unsubscribe: async () => {
                client.remove(handlerId);
                await client.dispatch('removeContextHandler', { handlerId });
            }
        };
    }
    /*
    Platform Window APIs
    */
    /**
     * Returns the Interop-Broker-defined context groups available for an entity to join.
     * Used by Platform Windows.
     *
     * @example
     * ```js
     * fin.me.interop.getContextGroups()
     *         .then(contextGroups => {
     *             contextGroups.forEach(contextGroup => {
     *                 console.log(contextGroup.displayMetadata.name)
     *                 console.log(contextGroup.displayMetadata.color)
     *             })
     *         })
     * ```
     */
    async getContextGroups() {
        this.wire.sendAction('interop-client-get-context-groups').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('getContextGroups');
    }
    /**
     * Join all Interop Clients at the given identity to context group `contextGroupId`.
     * If no target is specified, it adds the sender to the context group.
     *
     * @remarks Because multiple Channel connections/Interop Clients can potentially exist at a `uuid`/`name` combo, we currently join all Channel connections/Interop Clients at the given identity to the context group.
     * If an `endpointId` is provided (which is unlikely, unless the call is coming from an external adapter), then we only join that single connection to the context group.
     * For all intents and purposes, there will only be 1 connection present in Platform and Browser implmentations, so this point is more-or-less moot.
     * Used by Platform Windows.
     *
     * @param contextGroupId - Id of the context group.
     * @param target - Identity of the entity you wish to join to a context group.
     *
     * @example
     * ```js
     * joinViewToContextGroup = async (contextGroupId, view) => {
     *     await fin.me.interop.joinContextGroup(contextGroupId, view);
     * }
     *
     * getLastFocusedView()
     *     .then(lastFocusedViewIdentity => {
     *         joinViewToContextGroup('red', lastFocusedViewIdentity)
     *     })
     * ```
     */
    async joinContextGroup(contextGroupId, target) {
        this.wire.sendAction('interop-client-join-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        if (!contextGroupId) {
            throw new Error('No contextGroupId specified for joinContextGroup.');
        }
        return client.dispatch('joinContextGroup', { contextGroupId, target });
    }
    /**
     * Removes the specified target from a context group.
     * If no target is specified, it removes the sender from their context group.
     * Used by Platform Windows.
     *
     * @param target - Identity of the entity you wish to join to a context group.
     *
     * @example
     * ```js
     * removeViewFromContextGroup = async (view) => {
     *     await fin.me.interop.removeFromContextGroup(view);
     * }
     *
     * getLastFocusedView()
     *     .then(lastFocusedViewIdentity => {
     *         removeViewFromContextGroup(lastFocusedViewIdentity)
     *     })
     * ```
     */
    async removeFromContextGroup(target) {
        this.wire.sendAction('interop-client-remove-from-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('removeFromContextGroup', { target });
    }
    /**
     * Gets all clients for a context group.
     *
     * @remarks **This is primarily used for platform windows. Views within a platform should not have to use this API.**
     *
     * Returns the Interop-Broker-defined context groups available for an entity to join.
     * @param contextGroupId - The id of context group you wish to get clients for.
     *
     * @example
     * ```js
     * fin.me.interop.getAllClientsInContextGroup('red')
     *     .then(clientsInContextGroup => {
     *         console.log(clientsInContextGroup)
     *     })
     * ```
     */
    async getAllClientsInContextGroup(contextGroupId) {
        this.wire.sendAction('interop-client-get-all-clients-in-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        if (!contextGroupId) {
            throw new Error('No contextGroupId specified for getAllClientsInContextGroup.');
        }
        return client.dispatch('getAllClientsInContextGroup', { contextGroupId });
    }
    /**
     * Gets display info for a context group
     *
     * @remarks Used by Platform Windows.
     * @param contextGroupId - The id of context group you wish to get display info for.
     *
     * @example
     * ```js
     * fin.me.interop.getInfoForContextGroup('red')
     *     .then(contextGroupInfo => {
     *         console.log(contextGroupInfo.displayMetadata.name)
     *         console.log(contextGroupInfo.displayMetadata.color)
     *     })
     * ```
     */
    async getInfoForContextGroup(contextGroupId) {
        this.wire.sendAction('interop-client-get-info-for-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        if (!contextGroupId) {
            throw new Error('No contextGroupId specified for getInfoForContextGroup.');
        }
        return client.dispatch('getInfoForContextGroup', { contextGroupId });
    }
    /**
     * Sends an intent to the Interop Broker to resolve.
     * @param intent - The combination of an action and a context that is passed to an application for resolution.
     *
     * @example
     * ```js
     * // View wants to fire an Intent after a user clicks on a ticker
     * tickerElement.on('click', (element) => {
     *     const ticker = element.innerText;
     *     const intent = {
     *         name: 'ViewChart',
     *         context: {type: 'fdc3.instrument', id: { ticker }}
     *     }
     *
     *     fin.me.interop.fireIntent(intent);
     * })
     * ```
     */
    async fireIntent(intent) {
        this.wire.sendAction('interop-client-fire-intent').catch((e) => {
            // don't expose, this is only for api analytics purposes
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('fireIntent', intent);
    }
    /**
     * Adds an intent handler for incoming intents. The last intent sent of the name subscribed to will be received.
     * @param handler - Registered function meant to handle a specific intent type.
     * @param intentName - The name of an intent.
     *
     * @example
     * ```js
     * const intentHandler = (intent) => {
     *     const { context } = intent;
     *     myViewChartHandler(context);
     * };
     *
     * const subscription = await fin.me.interop.registerIntentHandler(intentHandler, 'ViewChart');
     *
     * function myAppCloseSequence() {
     *     // to unsubscribe the handler, simply call:
     *     subscription.unsubscribe();
     * }
     * ```
     */
    async registerIntentHandler(handler, intentName, options) {
        this.wire.sendAction('interop-client-register-intent-handler').catch((e) => {
            // don't expose, this is only for api analytics purposes
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        const handlerId = `intent-handler-${intentName}`;
        const wrappedHandler = (0, utils_1$2.wrapIntentHandler)(handler, handlerId);
        try {
            await client.register(handlerId, wrappedHandler);
            await client.dispatch('intentHandlerRegistered', { handlerId, ...options });
        }
        catch (error) {
            throw new Error('Unable to register intent handler');
        }
        return {
            unsubscribe: async () => {
                client.remove(handlerId);
            }
        };
    }
    /**
     * Gets the last context of the Context Group currently subscribed to. It takes an optional Context Type and returns the
     * last context of that type.
     * @param contextType
     *
     * @example
     * ```js
     * await fin.me.interop.joinContextGroup('yellow');
     * await fin.me.interop.setContext({ type: 'instrument', id: { ticker: 'FOO' }});
     * const currentContext = await fin.me.interop.getCurrentContext();
     *
     * // with a specific context
     * await fin.me.interop.joinContextGroup('yellow');
     * await fin.me.interop.setContext({ type: 'country', id: { ISOALPHA3: 'US' }});
     * await fin.me.interop.setContext({ type: 'instrument', id: { ticker: 'FOO' }});
     * const currentContext = await fin.me.interop.getCurrentContext('country');
     * ```
     */
    async getCurrentContext(contextType) {
        this.wire.sendAction('interop-client-get-current-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('getCurrentContext', { contextType });
    }
    /**
     * Get information for a particular Intent from the Interop Broker.
     *
     * @remarks To resolve this info, the function handleInfoForIntent is meant to be overridden in the Interop Broker.
     * The format for the response will be determined by the App Provider overriding the function.
     *
     * @param options
     *
     * @example
     * ```js
     * const intentInfo = await fin.me.interop.getInfoForIntent('ViewChart');
     * ```
     */
    async getInfoForIntent(options) {
        this.wire.sendAction('interop-client-get-info-for-intent').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('getInfoForIntent', options);
    }
    /**
     * Get information from the Interop Broker on all Intents that are meant to handle a particular context.
     *
     * @remarks To resolve this info, the function handleInfoForIntentsByContext is meant to be overridden in the Interop Broker.
     * The format for the response will be determined by the App Provider overriding the function.
     *
     * @param context
     *
     * @example
     * ```js
     * tickerElement.on('click', (element) => {
     *     const ticker = element.innerText;
     *
     *     const context = {
     *         type: 'fdc3.instrument',
     *         id: {
     *             ticker
     *         }
     *     }
     *
     *     const intentsInfo = await fin.me.interop.getInfoForIntentByContext(context);
     * })
     * ```
     */
    async getInfoForIntentsByContext(context) {
        this.wire.sendAction('interop-client-get-info-for-intents-by-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('getInfoForIntentsByContext', context);
    }
    /**
     * Sends a Context that will be resolved to an Intent by the Interop Broker.
     * This context accepts a metadata property.
     *
     * @remarks To resolve this info, the function handleFiredIntentByContext is meant to be overridden in the Interop Broker.
     * The format for the response will be determined by the App Provider overriding the function.
     *
     * @param context
     *
     * @example
     * ```js
     * tickerElement.on('click', (element) => {
     *     const ticker = element.innerText;
     *
     *     const context = {
     *         type: 'fdc3.instrument',
     *         id: {
     *             ticker
     *         }
     *     }
     *
     *     const intentResolution = await fin.me.interop.fireIntentForContext(context);
     * })
     * ```
     */
    async fireIntentForContext(context) {
        this.wire.sendAction('interop-client-fire-intent-for-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.dispatch('fireIntentForContext', context);
    }
    /**
     * Join the current entity to session context group `sessionContextGroupId` and return a sessionContextGroup instance.
     * If the sessionContextGroup doesn't exist, one will get created.
     *
     * @remarks Session Context Groups do not persist between runs and aren't present on snapshots.
     * @param sessionContextGroupId - Id of the context group.
     *
     * @example
     * Say we want to have a Session Context Group that holds UI theme information for all apps to consume:
     *
     * My color-picker View:
     * ```js
     *     const themeSessionContextGroup = await fin.me.interop.joinSessionContextGroup('theme');
     *
     *     const myColorPickerElement = document.getElementById('color-palette-picker');
     *     myColorPickerElement.addEventListener('change', event => {
     *         themeSessionContextGroup.setContext({ type: 'color-palette', selection: event.value });
     *     });
     * ```
     *
     * In other views:
     * ```js
     *     const themeSessionContextGroup = await fin.me.interop.joinSessionContextGroup('theme');
     *
     *     const changeColorPalette = ({ selection }) => {
     *         // change the color palette to the selection
     *     };
     *
     *     // If the context is already set by the time the handler was set, the handler will get invoked immediately with the current context.
     *     themeSessionContextGroup.addContextHandler(changeColorPalette, 'color-palette');
     * ```
     */
    async joinSessionContextGroup(sessionContextGroupId) {
        try {
            const currentSessionContextGroup = __classPrivateFieldGet$2(this, _InteropClient_sessionContextGroups, "f").get(sessionContextGroupId);
            if (currentSessionContextGroup) {
                return currentSessionContextGroup.getUserInstance();
            }
            const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
            const { hasConflict } = await client.dispatch('sessionContextGroup:createIfNeeded', {
                sessionContextGroupId
            });
            if (hasConflict) {
                console.warn(`A (non-session) context group with the name "${sessionContextGroupId}" already exists. If you are trying to join a Context Group, call joinContextGroup instead.`);
            }
            const newSessionContextGroup = new SessionContextGroupClient_1.default(this.wire, __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f"), sessionContextGroupId);
            __classPrivateFieldGet$2(this, _InteropClient_sessionContextGroups, "f").set(sessionContextGroupId, newSessionContextGroup);
            return newSessionContextGroup.getUserInstance();
        }
        catch (error) {
            console.error(`Error thrown trying to create Session Context Group with id "${sessionContextGroupId}": ${error}`);
            throw error;
        }
    }
    /**
     * Register a listener that is called when the Interop Client has been disconnected from the Interop Broker.
     * Only one listener per Interop Client can be set.
     * @param listener
     *
     * @example
     * ```js
     * const listener = (event) => {
     *     const { type, topic, brokerName} = event;
     *     console.log(`Disconnected from Interop Broker ${brokerName} `);
     * }
     *
     * await fin.me.interop.onDisconnection(listener);
     * ```
     */
    async onDisconnection(listener) {
        this.wire.sendAction('interop-client-add-ondisconnection-listener').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$2(this, _InteropClient_clientPromise, "f");
        return client.onDisconnection((event) => {
            const { uuid } = event;
            listener({ type: 'interop-broker', topic: 'disconnected', brokerName: uuid });
        });
    }
    /**
     * @internal
     *
     * Used to ferry fdc3-only calls from the fdc3 shim to the Interop Broker
     */
    static async ferryFdc3Call(interopClient, action, payload) {
        const client = await __classPrivateFieldGet$2(interopClient, _InteropClient_clientPromise, "f");
        return client.dispatch(action, payload || null);
    }
}
InteropClient$1.InteropClient = InteropClient;
_InteropClient_clientPromise = new WeakMap(), _InteropClient_sessionContextGroups = new WeakMap();

var overrideCheck = {};

var hasRequiredOverrideCheck;

function requireOverrideCheck () {
	if (hasRequiredOverrideCheck) return overrideCheck;
	hasRequiredOverrideCheck = 1;
	Object.defineProperty(overrideCheck, "__esModule", { value: true });
	overrideCheck.overrideCheck = overrideCheck.checkFDC32Overrides = overrideCheck.getDefaultViewFdc3VersionFromAppInfo = void 0;
	const InteropBroker_1 = requireInteropBroker();
	function getDefaultViewFdc3VersionFromAppInfo({ manifest, initialOptions }) {
	    const setVersion = manifest?.platform?.defaultViewOptions?.fdc3InteropApi ?? initialOptions.defaultViewOptions?.fdc3InteropApi;
	    return ['1.2', '2.0'].includes(setVersion ?? '') ? setVersion : undefined;
	}
	overrideCheck.getDefaultViewFdc3VersionFromAppInfo = getDefaultViewFdc3VersionFromAppInfo;
	function checkFDC32Overrides(overriddenBroker) {
	    // These are the APIs that must be overridden for FDC3 2.0 compliance
	    const mustOverrideAPIs = [
	        'fdc3HandleFindInstances',
	        'handleInfoForIntent',
	        'handleInfoForIntentsByContext',
	        'fdc3HandleGetAppMetadata',
	        'fdc3HandleGetInfo',
	        'fdc3HandleOpen',
	        'handleFiredIntent',
	        'handleFiredIntentForContext'
	    ];
	    return mustOverrideAPIs.filter((api) => {
	        return overriddenBroker[api] === InteropBroker_1.InteropBroker.prototype[api];
	    });
	}
	overrideCheck.checkFDC32Overrides = checkFDC32Overrides;
	function overrideCheck$1(overriddenBroker, fdc3InteropApi) {
	    if (fdc3InteropApi && fdc3InteropApi === '2.0') {
	        const notOverridden = checkFDC32Overrides(overriddenBroker);
	        if (notOverridden.length > 0) {
	            console.warn(`WARNING: FDC3 2.0 has been set as a default option for Views in this Platform, but the required InteropBroker APIs for FDC3 2.0 compliance have not all been overridden.\nThe following APIs need to be overridden:\n${notOverridden.join('\n')}`);
	        }
	    }
	}
	overrideCheck.overrideCheck = overrideCheck$1;
	return overrideCheck;
}

var hasRequiredFactory;

function requireFactory () {
	if (hasRequiredFactory) return Factory$1;
	hasRequiredFactory = 1;
	Object.defineProperty(Factory$1, "__esModule", { value: true });
	Factory$1.InteropModule = void 0;
	const lodash_1 = require$$3;
	const inaccessibleObject_1 = inaccessibleObject;
	const base_1 = base;
	const InteropBroker_1 = requireInteropBroker();
	const InteropClient_1 = InteropClient$1;
	const overrideCheck_1 = requireOverrideCheck();
	const common_utils_1 = commonUtils;
	const defaultOverride = (Class) => new Class();
	const BrokerParamAccessError = 'You have attempted to use or modify InteropBroker parameters, which is not allowed. You are likely using an older InteropBroker override scheme. Please consult our Interop docs for guidance on migrating to the new override scheme.';
	/**
	 * Manages creation of Interop Brokers and Interop Clients. These APIs are called under-the-hood in Platforms.
	 *
	 */
	class InteropModule extends base_1.Base {
	    /**
	     * Initializes an Interop Broker. This is called under-the-hood for Platforms.
	     *
	     * @remarks For Platforms, this is set up automatically. We advise to only create your own Interop Broker
	     * when not using a Platform app. You can override functions in the Interop Broker. More info {@link InteropBroker here}.
	     *
	     * @param name - Name of the Interop Broker.
	     * @param override - A callback function or array of callback functions that can be used to extend or replace default Interop Broker behavior.
	     *
	     * @example
	     * ``` js
	     * const interopBroker = await fin.Interop.init('openfin');
	     * const contextGroups = await interopBroker.getContextGroups();
	     * console.log(contextGroups);
	     * ```
	     */
	    async init(name, override = defaultOverride) {
	        this.wire.sendAction('interop-init').catch(() => {
	            // don't expose, analytics-only call
	        });
	        // Allows for manifest-level configuration, without having to override. (e.g. specifying custom context groups)
	        const options = await this.wire.environment.getInteropInfo(this.wire.getFin());
	        const objectThatThrows = (0, inaccessibleObject_1.createUnusableObject)(BrokerParamAccessError);
	        const warningOptsClone = (0, inaccessibleObject_1.createWarningObject)(BrokerParamAccessError, (0, lodash_1.cloneDeep)(options));
	        let provider;
	        const getProvider = () => {
	            if (!provider) {
	                provider = this.fin.InterApplicationBus.Channel.create(`interop-broker-${name}`);
	            }
	            return provider;
	        };
	        const throwingGetProvider = async () => {
	            // eslint-disable-next-line no-console
	            throw new Error(BrokerParamAccessError);
	        };
	        const OverrideableBroker = InteropBroker_1.InteropBroker.createClosedConstructor(this.wire, getProvider, options);
	        let broker;
	        if (Array.isArray(override)) {
	            const BrokerConstructor = (0, common_utils_1.overrideFromComposables)(...override)(OverrideableBroker);
	            // We need to use these objects because removing them entirely would be a breaking change and we want an informative error
	            // @ts-expect-error
	            broker = new BrokerConstructor(objectThatThrows, throwingGetProvider, warningOptsClone);
	        }
	        else {
	            // We need to use these objects because removing them entirely would be a breaking change and we want an informative error
	            // @ts-expect-error
	            broker = await override(OverrideableBroker, objectThatThrows, throwingGetProvider, warningOptsClone);
	        }
	        (0, overrideCheck_1.overrideCheck)(broker, options.fdc3Version);
	        return broker;
	    }
	    /**
	     * Connects a client to an Interop broker. This is called under-the-hood for Views in a Platform.
	     *
	     * @remarks
	     * @param name - The name of the Interop Broker to connect to. For Platforms, this will default to the uuid of the Platform.
	     * @param interopConfig - Information relevant to the Interop Broker. Typically a declaration of
	     * what context(s) the entity wants to subscribe to, and the current Context Group of the entity.
	     *
	     * @example
	     * ```js
	     * const interopConfig = {
	     *     currentContextGroup: 'green'
	     * }
	     *
	     * const interopBroker = await fin.Interop.init('openfin');
	     * const client = await fin.Interop.connectSync('openfin', interopConfig);
	     * const contextGroupInfo = await client.getInfoForContextGroup();
	     * console.log(contextGroupInfo);
	     * ```
	     */
	    connectSync(name, interopConfig) {
	        this.wire.sendAction('interop-connect-sync').catch(() => {
	            // don't expose, analytics-only call
	        });
	        return new InteropClient_1.InteropClient(this.wire, name, interopConfig);
	    }
	}
	Factory$1.InteropModule = InteropModule;
	return Factory$1;
}

var hasRequiredInterop;

function requireInterop () {
	if (hasRequiredInterop) return interop;
	hasRequiredInterop = 1;
	(function (exports) {
		/**
		 * Entry point for the OpenFin `Interop` API (`fin.Interop`).
		 *
		 * * {@link InteropModule} contains static members of the `Interop` API (available under `fin.Interop`)
		 * * {@link InteropClient} and {@link InteropBroker} document instances of their respective classes.
		 *
		 * @packageDocumentation
		 */
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireFactory(), exports);
		__exportStar(InteropClient$1, exports);
		__exportStar(requireInteropBroker(), exports); 
	} (interop));
	return interop;
}

var snapshotSource = {};

var Factory = {};

var Instance = {};

var utils = {};

Object.defineProperty(utils, "__esModule", { value: true });
utils.getSnapshotSourceChannelName = void 0;
const channelPrefix = 'snapshot-source-provider-';
const getSnapshotSourceChannelName = (id) => `${channelPrefix}${id.uuid}`;
utils.getSnapshotSourceChannelName = getSnapshotSourceChannelName;

var __classPrivateFieldSet$1 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$1 = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SnapshotSource_identity, _SnapshotSource_getConnection, _SnapshotSource_getClient, _SnapshotSource_startConnection, _SnapshotSource_setUpConnectionListener;
Object.defineProperty(Instance, "__esModule", { value: true });
Instance.SnapshotSource = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const base_1$1 = base;
const utils_1$1 = utils;
const connectionMap = new Map();
/**
 * Enables configuring a SnapshotSource with custom getSnapshot and applySnapshot methods.
 *
 * @typeParam Snapshot Implementation-defined shape of an application snapshot.  Allows
 * custom snapshot implementations for legacy applications to define their own snapshot format.
 */
class SnapshotSource extends base_1$1.Base {
    /**
     * @internal
     */
    constructor(wire, id) {
        super(wire);
        _SnapshotSource_identity.set(this, void 0);
        _SnapshotSource_getConnection.set(this, () => {
            if (!connectionMap.has(this.identity.uuid)) {
                connectionMap.set(this.identity.uuid, { eventFired: null, clientPromise: null });
            }
            return connectionMap.get(this.identity.uuid);
        });
        _SnapshotSource_getClient.set(this, () => {
            if (!__classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).clientPromise) {
                __classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).clientPromise = __classPrivateFieldGet$1(this, _SnapshotSource_startConnection, "f").call(this);
            }
            return __classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).clientPromise;
        });
        _SnapshotSource_startConnection.set(this, async () => {
            const channelName = (0, utils_1$1.getSnapshotSourceChannelName)(this.identity);
            try {
                if (!__classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).eventFired) {
                    await __classPrivateFieldGet$1(this, _SnapshotSource_setUpConnectionListener, "f").call(this);
                }
                const client = await this.fin.InterApplicationBus.Channel.connect(channelName, { wait: false });
                client.onDisconnection(() => {
                    __classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).clientPromise = null;
                    __classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).eventFired = null;
                });
                return client;
            }
            catch (e) {
                __classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).clientPromise = null;
                throw new Error("The targeted SnapshotSource is not currently initialized. Await this object's ready() method.");
            }
        });
        _SnapshotSource_setUpConnectionListener.set(this, async () => {
            const channelName = (0, utils_1$1.getSnapshotSourceChannelName)(this.identity);
            let resolve;
            let reject;
            const eventFired = new Promise((y, n) => {
                resolve = y;
                reject = n;
            });
            __classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).eventFired = eventFired;
            const listener = async (e) => {
                try {
                    if (e.channelName === channelName) {
                        resolve();
                        await this.fin.InterApplicationBus.Channel.removeListener('connected', listener);
                    }
                }
                catch (err) {
                    reject(err);
                }
            };
            await this.fin.InterApplicationBus.Channel.on('connected', listener);
        });
        __classPrivateFieldSet$1(this, _SnapshotSource_identity, id, "f");
    }
    get identity() {
        return __classPrivateFieldGet$1(this, _SnapshotSource_identity, "f");
    }
    /**
     * Method to determine if the SnapshotSource has been initialized.
     *
     * @remarks Use when the parent application is starting up to ensure the SnapshotSource is able to accept and
     * apply a snapshot using the {@link SnapshotSource#applySnapshot applySnapshot} method.
     *
     * @example
     * ```js
     * let snapshotSource = fin.SnapshotSource.wrapSync(fin.me);
     *
     * const snapshotProvider = {
     *     async getSnapshot() { return 'foo' },
     *     async applySnapshot(snapshot) {
     *       console.log(snapshot);
     *       return undefined;
     *     }
     * }
     * await fin.SnapshotSource.init(snapshotProvider);
     *
     * try {
     *   await snapshotSource.ready();
     *   await snapshotSource.applySnapshot('foo');
     * } catch (err) {
     *   console.log(err)
     * }
     * ```
     */
    async ready() {
        this.wire.sendAction('snapshot-source-ready').catch((e) => {
            // don't expose, analytics-only call
        });
        // eslint-disable-next-line no-async-promise-executor
        try {
            // If getClient was already called before this, do we have a timing issue where the channel might have been created but we missed the event but this still fails?
            await __classPrivateFieldGet$1(this, _SnapshotSource_getClient, "f").call(this);
        }
        catch (e) {
            // it was not running.
            await __classPrivateFieldGet$1(this, _SnapshotSource_getConnection, "f").call(this).eventFired;
        }
    }
    /**
     * Call the SnapshotSource's getSnapshot method defined by {@link SnapshotSource.SnapshotSourceModule#init init}.
     *
     */
    async getSnapshot() {
        this.wire.sendAction('snapshot-source-get-snapshot').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$1(this, _SnapshotSource_getClient, "f").call(this);
        const response = (await client.dispatch('get-snapshot'));
        return (await response).snapshot;
    }
    /**
     * Call the SnapshotSource's applySnapshot method defined by {@link SnapshotSource.SnapshotSourceModule#init init}.
     *
     */
    async applySnapshot(snapshot) {
        this.wire.sendAction('snapshot-source-apply-snapshot').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet$1(this, _SnapshotSource_getClient, "f").call(this);
        return client.dispatch('apply-snapshot', { snapshot });
    }
}
Instance.SnapshotSource = SnapshotSource;
_SnapshotSource_identity = new WeakMap(), _SnapshotSource_getConnection = new WeakMap(), _SnapshotSource_getClient = new WeakMap(), _SnapshotSource_startConnection = new WeakMap(), _SnapshotSource_setUpConnectionListener = new WeakMap();

Object.defineProperty(Factory, "__esModule", { value: true });
Factory.SnapshotSourceModule = void 0;
const base_1 = base;
const Instance_1 = Instance;
const utils_1 = utils;
/**
 * Static namespace for OpenFin API methods that interact with the {@link SnapshotSource} class, available under `fin.SnapshotSource`.
 */
class SnapshotSourceModule extends base_1.Base {
    /**
     * Initializes a SnapshotSource with the getSnapshot and applySnapshot methods defined.
     *
     * @typeParam Snapshot Implementation-defined shape of an application snapshot.  Allows
     * custom snapshot implementations for legacy applications to define their own snapshot format.
     *
     * @example
     * ```js
     * const snapshotProvider = {
     *     async getSnapshot() {
     *       const bounds = await fin.me.getBounds();
     *       return bounds;
     *      },
     *     async applySnapshot(snapshot) {
     *       await fin.me.setBounds(snapshot);
     *       return undefined;
     *     }
     * }
     *
     * await fin.SnapshotSource.init(snapshotProvider);
     * ```
     *
     */
    async init(provider) {
        this.wire.sendAction('snapshot-source-init').catch((e) => {
            // don't expose, analytics-only call
        });
        if (typeof provider !== 'object' ||
            typeof provider.getSnapshot !== 'function' ||
            typeof provider.applySnapshot !== 'function') {
            throw new Error('you must pass in a valid SnapshotProvider');
        }
        const channel = await this.fin.InterApplicationBus.Channel.create((0, utils_1.getSnapshotSourceChannelName)(this.fin.me));
        channel.register('get-snapshot', async () => {
            const snapshot = await provider.getSnapshot();
            return { snapshot };
        });
        channel.register('apply-snapshot', ({ snapshot }) => provider.applySnapshot(snapshot));
    }
    /**
     * Synchronously returns a SnapshotSource object that represents the current SnapshotSource.
     *
     * @example
     * ```js
     * const snapshotSource = fin.SnapshotSource.wrapSync(fin.me);
     * // Use wrapped instance's getSnapshot method, e.g.:
     * const snapshot = await snapshotSource.getSnapshot();
     * ```
     */
    wrapSync(identity) {
        this.wire.sendAction('snapshot-source-wrap-sync').catch((e) => {
            // don't expose, analytics-only call
        });
        return new Instance_1.SnapshotSource(this.wire, identity);
    }
    /**
     * Asynchronously returns a SnapshotSource object that represents the current SnapshotSource.
     *
     * @example
     * ```js
     * const snapshotSource = await fin.SnapshotSource.wrap(fin.me);
     * // Use wrapped instance's getSnapshot method, e.g.:
     * const snapshot = await snapshotSource.getSnapshot();
     * ```
     */
    async wrap(identity) {
        this.wire.sendAction('snapshot-source-wrap').catch((e) => {
            // don't expose, analytics-only call
        });
        return this.wrapSync(identity);
    }
}
Factory.SnapshotSourceModule = SnapshotSourceModule;

(function (exports) {
	/**
	 * Entry points for the OpenFin `SnapshotSource` API (`fin.SnapshotSource`).
	 *
	 * * {@link SnapshotSourceModule} contains static members of the `SnapshotSource` API, accessible through `fin.SnapshotSource`.
	 * * {@link SnapshotSource} describes an instance of an OpenFin SnapshotSource, e.g. as returned by `fin.SnapshotSource.wrap`.
	 *
	 * These are separate code entities, and are documented separately.  In the [previous version of the API documentation](https://cdn.openfin.co/docs/javascript/32.114.76.10/index.html),
	 * both of these were documented on the same page.
	 *
	 * @packageDocumentation
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(Factory, exports);
	__exportStar(Instance, exports); 
} (snapshotSource));

Object.defineProperty(fin$1, "__esModule", { value: true });
fin$1.Fin = void 0;
const events_1$3 = require$$0;
// Import from the file rather than the directory in case someone consuming types is using module resolution other than "node"
const index_1 = system;
const index_2 = requireWindow();
const index_3 = requireApplication();
const index_4 = interappbus;
const index_5 = clipboard;
const index_6 = externalApplication;
const index_7 = frame;
const index_8 = globalHotkey;
const index_9 = requireView();
const index_10 = platform;
const me_1$2 = me;
const interop_1 = requireInterop();
const snapshot_source_1 = snapshotSource;
/**
 * @internal
 */
class Fin extends events_1$3.EventEmitter {
    /**
     * @internal
     */
    constructor(wire) {
        super();
        this.wire = wire;
        this.System = new index_1.System(wire);
        this.Window = new index_2._WindowModule(wire);
        this.Application = new index_3.ApplicationModule(wire);
        this.InterApplicationBus = new index_4.InterApplicationBus(wire);
        this.Clipboard = new index_5.Clipboard(wire);
        this.ExternalApplication = new index_6.ExternalApplicationModule(wire);
        this.Frame = new index_7._FrameModule(wire);
        this.GlobalHotkey = new index_8.GlobalHotkey(wire);
        this.Platform = new index_10.PlatformModule(wire, this.InterApplicationBus.Channel);
        this.View = new index_9.ViewModule(wire);
        this.Interop = new interop_1.InteropModule(wire);
        this.SnapshotSource = new snapshot_source_1.SnapshotSourceModule(wire);
        wire.registerFin(this);
        this.me = (0, me_1$2.getMe)(wire);
        // Handle disconnect events
        wire.on('disconnected', () => {
            this.emit('disconnected');
        });
    }
}
fin$1.Fin = Fin;

var transport = {};

var wire = {};

Object.defineProperty(wire, "__esModule", { value: true });
wire.isInternalConnectConfig = wire.isPortDiscoveryConfig = wire.isNewConnectConfig = wire.isConfigWithReceiver = wire.isRemoteConfig = wire.isExistingConnectConfig = wire.isExternalConfig = void 0;
function isExternalConfig(config) {
    if (typeof config.manifestUrl === 'string') {
        return true;
    }
    return false;
}
wire.isExternalConfig = isExternalConfig;
function isExistingConnectConfig(config) {
    return hasUuid(config) && typeof config.address === 'string';
}
wire.isExistingConnectConfig = isExistingConnectConfig;
function isRemoteConfig(config) {
    return isExistingConnectConfig(config) && typeof config.token === 'string';
}
wire.isRemoteConfig = isRemoteConfig;
function isConfigWithReceiver(config) {
    return typeof config.receiver === 'object' && isRemoteConfig({ ...config, address: '' });
}
wire.isConfigWithReceiver = isConfigWithReceiver;
function hasUuid(config) {
    return typeof config.uuid === 'string';
}
function hasRuntimeVersion(config) {
    return config.runtime && typeof config.runtime.version === 'string';
}
function isNewConnectConfig(config) {
    return hasUuid(config) && hasRuntimeVersion(config);
}
wire.isNewConnectConfig = isNewConnectConfig;
function isPortDiscoveryConfig(config) {
    return (isExternalConfig(config) && hasRuntimeVersion(config)) || isNewConnectConfig(config);
}
wire.isPortDiscoveryConfig = isPortDiscoveryConfig;
function isInternalConnectConfig(config) {
    return isExistingConnectConfig(config) || isNewConnectConfig(config);
}
wire.isInternalConnectConfig = isInternalConnectConfig;

var eventAggregator = {};

var emitterMap = {};

Object.defineProperty(emitterMap, "__esModule", { value: true });
emitterMap.EmitterMap = void 0;
const events_1$2 = require$$0;
class EmitterMap {
    constructor() {
        this.storage = new Map();
    }
    // eslint-disable-next-line class-methods-use-this
    hashKeys(keys) {
        const hashed = keys.map(normalizeString);
        return hashed.join('/');
    }
    getOrCreate(keys) {
        const hash = this.hashKeys(keys);
        if (!this.storage.has(hash)) {
            this.storage.set(hash, new events_1$2.EventEmitter());
        }
        // We set it above
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.storage.get(hash);
    }
    has(keys) {
        return this.storage.has(this.hashKeys(keys));
    }
    delete(keys) {
        const hash = this.hashKeys(keys);
        return this.storage.delete(hash);
    }
}
emitterMap.EmitterMap = EmitterMap;
function normalizeString(s) {
    const b = Buffer.from(s);
    return b.toString('base64');
}

Object.defineProperty(eventAggregator, "__esModule", { value: true });
const emitterMap_1 = emitterMap;
function isEventMessage(message) {
    return message.action === 'process-desktop-event';
}
function mapKeyFromEvent(event) {
    const { topic } = event;
    if (topic === 'frame' || topic === 'window' || topic === 'view') {
        const { uuid, name } = event;
        return [topic, uuid, name];
    }
    if (topic === 'application') {
        const { uuid } = event;
        return [topic, uuid];
    }
    return [topic];
}
class EventAggregator extends emitterMap_1.EmitterMap {
    constructor() {
        super(...arguments);
        this.dispatchEvent = (message) => {
            if (isEventMessage(message)) {
                const { payload } = message;
                const accessor = mapKeyFromEvent(payload);
                if (this.has(accessor)) {
                    this.getOrCreate(accessor).emit(payload.type, payload);
                    return true;
                }
            }
            return false;
        };
    }
}
eventAggregator.default = EventAggregator;

var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Transport_wire, _Transport_fin;
Object.defineProperty(transport, "__esModule", { value: true });
transport.Transport = void 0;
const events_1$1 = require$$0;
const wire_1 = wire;
const transport_errors_1 = transportErrors;
const eventAggregator_1 = eventAggregator;
const me_1$1 = me;
const errors_1 = errors;
class Transport extends events_1$1.EventEmitter {
    constructor(WireType, environment, config) {
        super();
        this.wireListeners = new Map();
        this.topicRefMap = new Map();
        this.eventAggregator = new eventAggregator_1.default();
        this.messageHandlers = [this.eventAggregator.dispatchEvent];
        _Transport_wire.set(this, void 0);
        // Typing as unknown to avoid circular dependency, should not be used directly.
        _Transport_fin.set(this, void 0);
        this.connectSync = () => {
            const wire = __classPrivateFieldGet(this, _Transport_wire, "f");
            wire.connectSync();
        };
        // This function is only used in our tests.
        this.getPort = () => {
            const wire = __classPrivateFieldGet(this, _Transport_wire, "f");
            return wire.getPort();
        };
        __classPrivateFieldSet(this, _Transport_wire, new WireType(this.onmessage.bind(this)), "f");
        this.environment = environment;
        this.sendRaw = __classPrivateFieldGet(this, _Transport_wire, "f").send.bind(__classPrivateFieldGet(this, _Transport_wire, "f"));
        this.registerMessageHandler(this.handleMessage.bind(this));
        __classPrivateFieldGet(this, _Transport_wire, "f").on('disconnected', () => {
            for (const [, { handleNack }] of this.wireListeners) {
                handleNack({ reason: 'Remote connection has closed' });
            }
            this.wireListeners.clear();
            this.emit('disconnected');
        });
        const { uuid, name } = config;
        const entityType = this.environment.getCurrentEntityType();
        this.me = (0, me_1$1.getBaseMe)(entityType, uuid, name);
    }
    getFin() {
        if (!__classPrivateFieldGet(this, _Transport_fin, "f")) {
            throw new Error('No Fin object registered for this transport');
        }
        return __classPrivateFieldGet(this, _Transport_fin, "f");
    }
    registerFin(_fin) {
        if (__classPrivateFieldGet(this, _Transport_fin, "f")) {
            throw new Error('Fin object has already been registered for this transport');
        }
        __classPrivateFieldSet(this, _Transport_fin, _fin, "f");
    }
    shutdown() {
        const wire = __classPrivateFieldGet(this, _Transport_wire, "f");
        return wire.shutdown();
    }
    async connect(config) {
        if ((0, wire_1.isConfigWithReceiver)(config)) {
            await __classPrivateFieldGet(this, _Transport_wire, "f").connect(config.receiver);
            return this.authorize(config);
        }
        if ((0, wire_1.isRemoteConfig)(config)) {
            return this.connectRemote(config);
        }
        if ((0, wire_1.isExistingConnectConfig)(config)) {
            return this.connectByPort(config);
        }
        if ((0, wire_1.isNewConnectConfig)(config)) {
            const port = await this.environment.retrievePort(config);
            return this.connectByPort({ ...config, address: `ws://localhost:${port}` });
        }
        return undefined;
    }
    async connectRemote(config) {
        await __classPrivateFieldGet(this, _Transport_wire, "f").connect(new (this.environment.getWsConstructor())(config.address));
        return this.authorize(config);
    }
    async connectByPort(config) {
        const { address, uuid } = config;
        const reqAuthPayload = { ...config, type: 'file-token' };
        const wire = __classPrivateFieldGet(this, _Transport_wire, "f");
        await wire.connect(new (this.environment.getWsConstructor())(config.address));
        const requestExtAuthRet = await this.sendAction('request-external-authorization', {
            uuid,
            type: 'file-token'
        }, true);
        if (requestExtAuthRet.action !== 'external-authorization-response') {
            throw new transport_errors_1.UnexpectedActionError(requestExtAuthRet.action);
        }
        await this.environment.writeToken(requestExtAuthRet.payload.file, requestExtAuthRet.payload.token);
        return this.authorize(reqAuthPayload);
    }
    async authorize(reqAuthPayload) {
        const requestAuthRet = await this.sendAction('request-authorization', reqAuthPayload, true);
        if (requestAuthRet.action !== 'authorization-response') {
            throw new transport_errors_1.UnexpectedActionError(requestAuthRet.action);
        }
        else if (requestAuthRet.payload.success !== true) {
            throw new transport_errors_1.RuntimeError(requestAuthRet.payload);
        }
    }
    sendAction(action, payload = {}, uncorrelated = false
    // specialResponse type is only used for 'requestAuthorization'
    ) {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        let cancel = () => { };
        // We want the callsite from the caller of this function, not from here.
        const callSites = transport_errors_1.RuntimeError.getCallSite(1);
        const messageId = this.environment.getNextMessageId();
        const prom = new Promise((resolve, reject) => {
            cancel = reject;
            const msg = {
                action,
                payload,
                messageId
            };
            const wire = __classPrivateFieldGet(this, _Transport_wire, "f");
            this.addWireListener(messageId, resolve, (payload) => this.nackHandler(payload, reject, callSites), uncorrelated);
            return wire.send(msg).catch(reject);
        });
        return Object.assign(prom, { cancel, messageId });
    }
    nackHandler(payloadOrMessage, reject, callSites) {
        if (typeof payloadOrMessage === 'string') {
            // NOTE: this is for backwards compatibility to support plain string rejections
            reject(payloadOrMessage);
        }
        else {
            reject(new transport_errors_1.RuntimeError(payloadOrMessage, callSites));
        }
    }
    ferryAction(origData) {
        return new Promise((resolve, reject) => {
            const id = this.environment.getNextMessageId();
            origData.messageId = id;
            const resolver = (data) => {
                resolve(data.payload);
            };
            const wire = __classPrivateFieldGet(this, _Transport_wire, "f");
            return wire
                .send(origData)
                .then(() => this.addWireListener(id, resolver, (payload) => this.nackHandler(payload, reject), false))
                .catch(reject);
        });
    }
    registerMessageHandler(handler) {
        this.messageHandlers.push(handler);
    }
    addWireListener(id, resolve, handleNack, uncorrelated) {
        if (uncorrelated) {
            this.uncorrelatedListener = resolve;
        }
        else if (this.wireListeners.has(id)) {
            handleNack({
                reason: 'Duplicate handler id',
                error: (0, errors_1.errorToPOJO)(new transport_errors_1.DuplicateCorrelationError(String(id)))
            });
        }
        else {
            this.wireListeners.set(id, { resolve, handleNack });
        }
        // Timeout and reject()?
    }
    // This method executes message handlers until the _one_ that handles the message (returns truthy) has run
    onmessage(data) {
        for (const h of this.messageHandlers) {
            h.call(null, data);
        }
    }
    handleMessage(data) {
        const id = data.correlationId || NaN;
        if (!('correlationId' in data)) {
            if (this.uncorrelatedListener) {
                this.uncorrelatedListener.call(null, data);
            }
            this.uncorrelatedListener = () => {
                // empty block
            };
        }
        else if (!this.wireListeners.has(id)) {
            return false;
        }
        else {
            // We just checked for existence above
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const { resolve, handleNack } = this.wireListeners.get(id);
            if (data.action !== 'ack') {
                handleNack({ reason: 'Did not receive ack action', error: (0, errors_1.errorToPOJO)(new transport_errors_1.NoAckError(data.action)) });
            }
            else if (!('payload' in data)) {
                // I'm not sure when this code would actually run, but passing in something that doeesn't have a reason to the runtimeerror constructor will not end well.
                // @ts-expect-error
                if (typeof data.reason === 'string') {
                    handleNack(data);
                }
                else {
                    console.warn('Received invalid response from core', data);
                    handleNack({ reason: 'invalid response shape' });
                }
            }
            else if (!data.payload.success) {
                handleNack(data.payload);
            }
            else {
                resolve.call(null, data);
            }
            this.wireListeners.delete(id);
        }
        return true;
    }
}
transport.Transport = Transport;
_Transport_wire = new WeakMap(), _Transport_fin = new WeakMap();

var mockEnvironment = {};

Object.defineProperty(mockEnvironment, "__esModule", { value: true });
mockEnvironment.MockEnvironment = void 0;
const me_1 = me;
class MockEnvironment {
    constructor() {
        this.type = 'other';
        this.childViews = true;
    }
    async getInteropInfo() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getDefaultChannelOptions() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getRtcPeer() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    initLayoutManager() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    applyLayoutSnapshot() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    async createLayout() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    async destroyLayout() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    async resolveLayout() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    initPlatform() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    observeBounds() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    writeToken(path, token) {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    retrievePort(config) {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getNextMessageId() {
        return `mock-message-id-${Math.random()}`;
    }
    getRandomId() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    createChildContent(options) {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getWebWindow(identity) {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getCurrentEntityIdentity() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getCurrentEntityType() {
        return 'unknown';
    }
    raiseEvent(eventName, eventArgs) {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getUrl() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    whenReady() {
        throw new Error(me_1.environmentUnsupportedMessage);
    }
    getWsConstructor() {
        throw new Error('Method not implemented.');
    }
}
mockEnvironment.MockEnvironment = MockEnvironment;

var mockWire = {};

Object.defineProperty(mockWire, "__esModule", { value: true });
mockWire.MockWire = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const events_1 = require$$0;
class MockWire extends events_1.EventEmitter {
    connect() {
        throw new Error('You are not running in OpenFin.');
    }
    connectSync() {
        throw new Error('You are not running in OpenFin.');
    }
    send(data) {
        throw new Error('You are not running in OpenFin.');
    }
    shutdown() {
        throw new Error('You are not running in OpenFin.');
    }
    getPort() {
        throw new Error('This transport has no port');
    }
    // eslint-disable-next-line no-useless-constructor
    constructor() {
        super();
    }
}
mockWire.MockWire = MockWire;

Object.defineProperty(mock, "__esModule", { value: true });
exports.fin = mock.fin = void 0;
const OpenFin = OpenFin$1;
const fin_1 = fin$1;
const transport_1 = transport;
const mockEnvironment_1 = mockEnvironment;
const mockWire_1 = mockWire;
exports.fin = mock.fin = ((typeof window !== 'undefined' && window?.fin) ||
    (() => {
        const environment = new mockEnvironment_1.MockEnvironment();
        const transport = new transport_1.Transport(mockWire_1.MockWire, environment, {
            uuid: '',
            name: ''
        });
        return new fin_1.Fin(transport);
    })());
var _default = mock.default = OpenFin;

exports["default"] = _default;


/***/ }),

/***/ "../../node_modules/events/events.js":
/*!*******************************************!*\
  !*** ../../node_modules/events/events.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "../../node_modules/lodash/lodash.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/lodash.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***************************!*\
  !*** ./client/src/app.ts ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _openfin_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openfin/core */ "../../node_modules/@openfin/core/out/mock.js");

let fileName;
let debugLogStr;
let debugLogFile;
document.addEventListener("DOMContentLoaded", async () => {
    try {
        await initDom();
    }
    catch (error) {
        console.error(error);
    }
});
/**
 * Populates DOM with the UI elements and adds listeners obtaining selected/submitted options.
 */
async function initDom() {
    const logListElement = document.querySelector("#log-list");
    if (logListElement) {
        await createLogDropDown(logListElement);
        logListElement.addEventListener("change", async (selectionChangeEvent) => {
            fileName = selectionChangeEvent.target.value;
        });
    }
    const upload = document.querySelector("#upload-form");
    if (upload) {
        upload.addEventListener("submit", uploadHandler);
    }
    const sendAppLogBtn = document.querySelector("#send-app-log");
    if (sendAppLogBtn) {
        sendAppLogBtn.addEventListener("click", sendApplicationLogs);
    }
}
/**
 * Handle uploads.
 * 1. Creates a FormData object.
 * 2. Creates a File object from the string of the Runtime debug log file contents.
 * 3. Populates the FormData object with necessary parameters to be read by the server.
 * 4. Uploads the created runtime debug log file to a server endpoint.
 * @param submitEvent The event to handle.
 */
async function uploadHandler(submitEvent) {
    submitEvent.preventDefault();
    if (!fileName) {
        fileName = "debug.log";
    }
    const formData = new FormData();
    debugLogStr = await getLogFromName(fileName);
    debugLogFile = new File([debugLogStr], fileName, { type: "text/plain" });
    formData.append("file", debugLogFile);
    formData.append("filename", fileName);
    formData.append("uuid", _openfin_core__WEBPACK_IMPORTED_MODULE_0__.fin.me.uuid);
    const uploadState = await fetch("https://built-on-openfin.github.io/container-starter/v36/use-logging-apis/uploads", {
        method: "POST",
        body: formData
    });
    const uploadStateJson = await uploadState.json();
    const uploadStateJsonString = JSON.stringify(uploadStateJson, null, 5);
    const logs = `${new Date().toLocaleTimeString()}: ${uploadStateJsonString}\n`;
    const logPreview = document.querySelector("#preview");
    if (logPreview) {
        logPreview.textContent += logs;
    }
}
/**
 * Sends a message to the OpenFin RVM to send the application logs.
 */
async function sendApplicationLogs() {
    try {
        const appLogResponse = await _openfin_core__WEBPACK_IMPORTED_MODULE_0__.fin.Application.getCurrentSync().sendApplicationLog();
        console.log(`Log ID: ${appLogResponse.logId}`);
    }
    catch {
        // swallow unnecessary errors.
    }
}
/**
 * Retrieves the runtime debug log from a filename.
 * @param name file name of the runtime debug log to retrieve.
 * @returns the log content.
 */
async function getLogFromName(name) {
    const log = await _openfin_core__WEBPACK_IMPORTED_MODULE_0__.fin.System.getLog({ name });
    return log;
}
/**
 * Creates an HTMLOptionElement for each of the Runtime debug logs.
 * @param parentElement HTML Element to append the log filename HTMLOptionElement to.
 */
async function createLogDropDown(parentElement) {
    const logList = await _openfin_core__WEBPACK_IMPORTED_MODULE_0__.fin.System.getLogList();
    for (const log of logList) {
        const logElement = document.createElement("option");
        logElement.id = log.date;
        logElement.textContent = log.name;
        logElement.value = log.name;
        parentElement.append(logElement);
    }
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQixJQUFJLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFR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aUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsU0FBUztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHlCQUF5QjtBQUNoRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixTQUFTO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBMEM7QUFDbkU7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlDQUF5QztBQUNsRTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxTQUFTO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFNBQVM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFNBQVM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlEQUFpRDtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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VyxTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEVBQTRFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFNBQVM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtDQUFrQztBQUM5RjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLCtFQUErRSxrQ0FBa0M7QUFDakg7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7O0FBRUEsa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGFBQWE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUE4RDtBQUMxRixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsc0RBQXNELE1BQU07QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RCxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxzREFBc0QsTUFBTTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUscURBQXFELE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQ0FBZ0M7QUFDckY7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXlCO0FBQ3pCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtSUFBbUkseUJBQXlCO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELFlBQVk7QUFDMUU7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyREFBMkQ7O0FBRTNE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b0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLFFBQVE7QUFDUixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDLGdFQUFnRTtBQUNoRSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSxJQUFJLFFBQVEsTUFBTSxRQUFRO0FBQzNELGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsSUFBSSxnQkFBZ0I7QUFDNUQ7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BELGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLG9DQUFvQztBQUMvQyxXQUFXO0FBQ1g7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQztBQUMvQyxXQUFXLG9DQUFvQztBQUMvQyxXQUFXO0FBQ1g7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1DQUFtQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVc7QUFDWDtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsV0FBVyxvQ0FBb0M7QUFDL0MsV0FBVztBQUNYO0FBQ0E7QUFDQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxNQUFNLFFBQVEsSUFBSSxRQUFRO0FBQzdELGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLElBQUksZ0JBQWdCO0FBQzVELHVCQUF1QixnQkFBZ0IsSUFBSSxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVE7QUFDbEU7QUFDQSw2QkFBNkIsUUFBUSxJQUFJLFFBQVE7QUFDakQ7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCLElBQUksZ0JBQWdCLElBQUksZ0JBQWdCO0FBQzlFO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBLGdCQUFnQixnQkFBZ0IsSUFBSSxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0Esa0NBQWtDLFFBQVEsZ0JBQWdCLGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0Esc0NBQXNDLFFBQVEsZ0JBQWdCLGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLFdBQVc7QUFDbEMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLDBCQUEwQjtBQUN6QztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsV0FBVztBQUNsQyxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw4QkFBOEIsbUJBQW1CLGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQixpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxtQkFBbUI7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJB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aUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLFdBQVc7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QyxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0EsdUVBQXVFLDBCQUEwQixHQUFHO0FBQ3BHLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRCxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMEJBQTBCLEdBQUc7QUFDbkYseUNBQXlDLGFBQWEsZ0JBQWdCO0FBQ3RFLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9DQUFvQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZELDJDQUEyQyxPQUFPO0FBQ2xELGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGdDQUFnQyxnQ0FBZ0M7QUFDaEUsY0FBYztBQUNkO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLFdBQVc7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEMsYUFBYSxRQUFRLFFBQVEsVUFBVSxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHNCQUFzQjtBQUNyQyxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5Qix1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXO0FBQ1g7QUFDQTtBQUNBLHNDQUFzQyxtQkFBbUIsaUJBQWlCO0FBQzFFLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxJQUFJLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBNkM7QUFDeEQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQ0FBa0M7QUFDdEUsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVc7QUFDWDtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRCxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQSxpREFBaUQsUUFBUSxlQUFlLFFBQVE7QUFDaEYsZ0JBQWdCLHdCQUF3QixJQUFJLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCLElBQUksd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxzQkFBc0I7QUFDeEMsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLFdBQVc7QUFDbEMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCLElBQUksZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixvREFBb0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSxJQUFJLFFBQVE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxVQUFVO0FBQzVCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBLHdCQUF3QixRQUFRLElBQUksUUFBUTtBQUM1QztBQUNBLHNDQUFzQyxhQUFhO0FBQ25ELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVE7QUFDcEU7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxJQUFJLFFBQVE7QUFDNUM7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUTtBQUNwRTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxPQUFPLGdCQUFnQjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkRBQTJEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3Q0FBd0M7QUFDdEU7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUEwRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsa0dBQUM7QUFDTjtBQUNBO0FBQ0EsT0FBTyxFQVNKO0FBQ0gsQ0FBQzs7Ozs7OztVQ3h6aEJEO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N6QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIb0M7QUFFcEMsSUFBSSxRQUFnQixDQUFDO0FBQ3JCLElBQUksV0FBbUIsQ0FBQztBQUN4QixJQUFJLFlBQWtCLENBQUM7QUFFdkIsUUFBUSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFLEtBQUssSUFBSSxFQUFFO0lBQ3hELElBQUksQ0FBQztRQUNKLE1BQU0sT0FBTyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0QixDQUFDO0FBQ0YsQ0FBQyxDQUFDLENBQUM7QUFFSDs7R0FFRztBQUNILEtBQUssVUFBVSxPQUFPO0lBQ3JCLE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQW9CLFdBQVcsQ0FBQyxDQUFDO0lBQzlFLElBQUksY0FBYyxFQUFFLENBQUM7UUFDcEIsTUFBTSxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN4QyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxvQkFBb0IsRUFBRSxFQUFFO1lBQ3hFLFFBQVEsR0FBSSxvQkFBb0IsQ0FBQyxNQUE0QixDQUFDLEtBQUssQ0FBQztRQUNyRSxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFrQixjQUFjLENBQUMsQ0FBQztJQUN2RSxJQUFJLE1BQU0sRUFBRSxDQUFDO1FBQ1osTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBQ0QsTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBb0IsZUFBZSxDQUFDLENBQUM7SUFDakYsSUFBSSxhQUFhLEVBQUUsQ0FBQztRQUNuQixhQUFhLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDOUQsQ0FBQztBQUNGLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsS0FBSyxVQUFVLGFBQWEsQ0FBQyxXQUFrQjtJQUM5QyxXQUFXLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDN0IsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2YsUUFBUSxHQUFHLFdBQVcsQ0FBQztJQUN4QixDQUFDO0lBQ0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQztJQUNoQyxXQUFXLEdBQUcsTUFBTSxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0MsWUFBWSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxDQUFDLENBQUM7SUFDekUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDdEMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdEMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsOENBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckMsTUFBTSxXQUFXLEdBQUcsTUFBTSxLQUFLLENBQUMsK0JBQStCLEVBQUU7UUFDaEUsTUFBTSxFQUFFLE1BQU07UUFDZCxJQUFJLEVBQUUsUUFBUTtLQUNkLENBQUMsQ0FBQztJQUVILE1BQU0sZUFBZSxHQUFHLE1BQU0sV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2pELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLE1BQU0sSUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLHFCQUFxQixJQUFJLENBQUM7SUFDOUUsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN0RCxJQUFJLFVBQVUsRUFBRSxDQUFDO1FBQ2hCLFVBQVUsQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDO0lBQ2hDLENBQUM7QUFDRixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxLQUFLLFVBQVUsbUJBQW1CO0lBQ2pDLElBQUksQ0FBQztRQUNKLE1BQU0sY0FBYyxHQUFHLE1BQU0sOENBQUcsQ0FBQyxXQUFXLENBQUMsY0FBYyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUNuRixPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUFDLE1BQU0sQ0FBQztRQUNSLDhCQUE4QjtJQUMvQixDQUFDO0FBQ0YsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxLQUFLLFVBQVUsY0FBYyxDQUFDLElBQVk7SUFDekMsTUFBTSxHQUFHLEdBQUcsTUFBTSw4Q0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzlDLE9BQU8sR0FBRyxDQUFDO0FBQ1osQ0FBQztBQUVEOzs7R0FHRztBQUNILEtBQUssVUFBVSxpQkFBaUIsQ0FBQyxhQUFnQztJQUNoRSxNQUFNLE9BQU8sR0FBc0IsTUFBTSw4Q0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUVqRSxLQUFLLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQzNCLE1BQU0sVUFBVSxHQUFzQixRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZFLFVBQVUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUN6QixVQUFVLENBQUMsV0FBVyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDbEMsVUFBVSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQzVCLGFBQWEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbEMsQ0FBQztBQUNGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91c2UtbG9nZ2luZy1hcGlzLy4uLy4uL25vZGVfbW9kdWxlcy9Ab3BlbmZpbi9jb3JlL291dC9tb2NrLmpzIiwid2VicGFjazovL3VzZS1sb2dnaW5nLWFwaXMvLi4vLi4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vdXNlLWxvZ2dpbmctYXBpcy8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly91c2UtbG9nZ2luZy1hcGlzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3VzZS1sb2dnaW5nLWFwaXMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly91c2UtbG9nZ2luZy1hcGlzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdXNlLWxvZ2dpbmctYXBpcy93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL3VzZS1sb2dnaW5nLWFwaXMvLi9jbGllbnQvc3JjL2FwcC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciByZXF1aXJlJCQwID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgcmVxdWlyZSQkMyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIG1vY2sgPSB7fTtcblxudmFyIE9wZW5GaW4kMSA9IHt9O1xuXG52YXIgZXZlbnRzID0ge307XG5cbnZhciBhcHBsaWNhdGlvbiQxID0ge307XG5cbi8qKlxuICogTmFtZXNwYWNlIGZvciBldmVudHMgdGhhdCBjYW4gYmUgZW1pdHRlZCBieSBhbiB7QGxpbmsgT3BlbkZpbi5BcHBsaWNhdGlvbn0uICBJbmNsdWRlcyBldmVudHNcbiAqIHJlLXByb3BhZ2F0ZWQgZnJvbSB0aGUge0BsaW5rIE9wZW5GaW4uV2luZG93fSAoYW5kLCB0cmFuc2l0aXZlbHksIHtAbGluayBPcGVuRmluLlZpZXd9KSBsZXZlbCwgcHJlZml4ZWQgd2l0aCBgd2luZG93LWAgKGFuZCBhbHNvLCBpZiBhcHBsaWNhYmxlLCBgdmlldy1gKS5cbiAqIEZvciBleGFtcGxlLCBhIHZpZXcncyBcImF0dGFjaGVkXCIgZXZlbnQgd2lsbCBmaXJlIGFzICd3aW5kb3ctdmlldy1hdHRhY2hlZCcgYXQgdGhlIGFwcGxpY2F0aW9uIGxldmVsLlxuICpcbiAqIEV2ZW50IHBheWxvYWRzIGFyZSBkb2N1bWVudGVkIGFzIGludGVyZmFjZXMsIHdoaWxlIGFsZ2VicmFpYyBoZWxwZXIgdHlwZXMgYW5kIGRlcml2ZWQgdHlwZXMgYXJlIGRvY3VtZW50ZWQgYXMgdHlwZSBhbGlhc2VzLlxuICpcbiAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIG9ubHkgcGF5bG9hZCBzaGFwZXMgZm9yIGV2ZW50cyB0aGF0IGFyZSB1bmlxdWUgdG8gYEFwcGxpY2F0aW9uYC4gIEV2ZW50cyB0aGF0IHByb3BhZ2F0ZSB0byBgQXBwbGljYXRpb25gIGZyb21cbiAqIGNoaWxkIHtAbGluayBPcGVuRmluLldpbmRvdyB3aW5kb3dzfSBhbmQge0BsaW5rIE9wZW5GaW4uVmlldyB2aWV3c30gYXJlIGRlZmluZWQgaW4gdGhlIHtAbGluayBPcGVuRmluLldpbmRvd0V2ZW50c30gYW5kXG4gKiB7QGxpbmsgT3BlbkZpbi5WaWV3RXZlbnRzfSBuYW1lc3BhY2VzLiAgRm9yIGEgbGlzdCBvZiB2YWxpZCBzdHJpbmcga2V5cyBmb3IgKmFsbCogYXBwbGljYXRpb24gZXZlbnRzLCBzZWUge0BsaW5rIEFwcGxpY2F0aW9uLm9uIEFwcGxpY2F0aW9uLm9ufS5cbiAqXG4gKiB7QGxpbmsgQXBwbGljYXRpb25Tb3VyY2VkRXZlbnQgQXBwbGljYXRpb24tc291cmNlZCBldmVudHN9IChpLmUuIHRob3NlIHRoYXQgaGF2ZSBub3QgcHJvcGFnYXRlZCBmcm9tIHtAbGluayBPcGVuRmluLlZpZXdFdmVudHMgVmlld3N9XG4gKiBvciB7QGxpbmsgT3BlbkZpbi5XaW5kb3dFdmVudHMgV2luZG93c30gcmUtcHJvcGFnYXRlIHRvIHtAbGluayBPcGVuRmluLlN5c3RlbUV2ZW50cyBTeXN0ZW19IHdpdGggdGhlaXIgdHlwZSBzdHJpbmcgcHJlZml4ZWQgd2l0aCBgYXBwbGljYXRpb24tYC5cbiAqIHtAbGluayBBcHBsaWNhdGlvbldpbmRvd0V2ZW50IEFwcGxpY2F0aW9uIGV2ZW50cyB0aGF0IGFyZSB0aWVkIHRvIFdpbmRvd3MgYnV0IGRvIG5vdCBwcm9wYWdhdGUgZnJvbSB0aGVtfVxuICogYXJlIHByb3BhZ2F0ZWQgdG8gYFN5c3RlbWAgd2l0aG91dCBhbnkgdHlwZSBzdHJpbmcgcHJlZml4aW5nLlxuICpcbiAqIFwiUmVxdWVzdGVkXCIgZXZlbnRzIChlLmcuIHtAbGluayBSdW5SZXF1ZXN0ZWRFdmVudH0pIGRvIG5vdCBwcm9wYWdhdGUuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHBsaWNhdGlvbiQxLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJhc2UkMSA9IHt9O1xuXG4vKipcbiAqIE5hbWVzcGFjZSBmb3Igc2hhcmVkIGV2ZW50IHBheWxvYWRzIGFuZCB1dGlsaXR5IHR5cGVzIGNvbW1vbiB0byBhbGwgZXZlbnQgZW1pdHRlcnMuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYXNlJDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXh0ZXJuYWxBcHBsaWNhdGlvbiQxID0ge307XG5cbi8qKlxuICogTmFtZXNwYWNlIGZvciBldmVudHMgdGhhdCBjYW4gYmUgdHJhbnNtaXR0ZWQgYnkgYW4ge0BsaW5rIE9wZW5GaW4uRXh0ZXJuYWxBcHBsaWNhdGlvbn0uXG4gKlxuICogRXZlbnQgcGF5bG9hZHMgYXJlIGRvY3VtZW50ZWQgYXMgaW50ZXJmYWNlcywgd2hpbGUgYWxnZWJyYWljIGhlbHBlciB0eXBlcyBhbmQgZGVyaXZlZCB0eXBlcyBhcmUgZG9jdW1lbnRlZCBhcyB0eXBlIGFsaWFzZXMuXG4gKlxuICogRm9yIGEgbGlzdCBvZiB2YWxpZCBzdHJpbmcga2V5cyBmb3IgZXh0ZXJuYWwgYXBwbGljYXRpb24gZXZlbnRzLCBzZWUge0BsaW5rIEV4dGVybmFsQXBwbGljYXRpb24ub24gRXh0ZXJuYWxBcHBsaWNhdGlvbi5vbn0uXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHRlcm5hbEFwcGxpY2F0aW9uJDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZnJhbWUkMSA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZnJhbWUkMSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbG9iYWxIb3RrZXkkMSA9IHt9O1xuXG4vKipcbiAqXG4gKiBOYW1lc3BhY2UgZm9yIGV2ZW50cyB0aGF0IGNhbiBiZSB0cmFuc21pdHRlZCBieSB7QGxpbmsgR2xvYmFsSG90a2V5Lkdsb2JhbEhvdGtleX0uXG4gKlxuICogRXZlbnQgcGF5bG9hZHMgYXJlIGRvY3VtZW50ZWQgYXMgaW50ZXJmYWNlcywgd2hpbGUgYWxnZWJyYWljIGhlbHBlciB0eXBlcyBhbmQgZGVyaXZlZCB0eXBlcyBhcmUgZG9jdW1lbnRlZCBhcyB0eXBlIGFsaWFzZXMuXG4gKlxuICogRm9yIGEgbGlzdCBvZiB2YWxpZCBzdHJpbmcga2V5cyBmb3IgZ2xvYmFsIGhvdGtleSBldmVudHMsIHNlZSB7QGxpbmsgR2xvYmFsSG90a2V5Lkdsb2JhbEhvdGtleS5vbiBHbG9iYWxIb3RrZXkub259LlxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsSG90a2V5JDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgcGxhdGZvcm0kMSA9IHt9O1xuXG4vKipcbiAqXG4gKiBOYW1lc3BhY2UgZm9yIGV2ZW50cyB0aGF0IGNhbiBlbWl0dGVkIGJ5IGEge0BsaW5rIE9wZW5GaW4uUGxhdGZvcm19LlxuICpcbiAqIEV2ZW50IHBheWxvYWRzIGFyZSBkb2N1bWVudGVkIGFzIGludGVyZmFjZXMsIHdoaWxlIGFsZ2VicmFpYyBoZWxwZXIgdHlwZXMgYW5kIGRlcml2ZWQgdHlwZXMgYXJlIGRvY3VtZW50ZWQgYXMgdHlwZSBhbGlhc2VzLlxuICpcbiAqIFRoZSBQbGF0Zm9ybSBgRXZlbnRFbWl0dGVyYCBpcyBhIHN1cGVyc2V0IG9mIHRoZSB7QGxpbmsgT3BlbkZpbi5BcHBsaWNhdGlvbn0gYEV2ZW50RW1pdHRlcmAsXG4gKiBtZWFuaW5nIGl0IGNhbiBsaXN0ZW4gdG8gYWxsIHtAbGluayBPcGVuRmluLkFwcGxpY2F0aW9uRXZlbnRzIEFwcGxpY2F0aW9uIGV2ZW50c30gaW4gYWRkaXRpb24gdG8gdGhlXG4gKiBQbGF0Zm9ybS1zcGVjaWZpYyBldmVudHMgbGlzdGVkIGhlcmUuICBGb3IgYSBsaXN0IG9mIHZhbGlkIHN0cmluZyBrZXlzIGZvciAqYWxsKiBwbGF0Zm9ybSBldmVudHMsIHNlZVxuICoge0BsaW5rIFBsYXRmb3JtLm9uIFBsYXRmb3JtLm9ufS5cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXRmb3JtJDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc3lzdGVtJDEgPSB7fTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgZm9yIHJ1bnRpbWUtd2lkZSBPcGVuRmluIGV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBTeXN0ZW0uU3lzdGVtfS4gIEluY2x1ZGVzIGV2ZW50c1xuICogcmUtcHJvcGFnYXRlZCBmcm9tIHtAbGluayBPcGVuRmluLkFwcGxpY2F0aW9ufSwge0BsaW5rIE9wZW5GaW4uV2luZG93fSwgYW5kIHtAbGluayBPcGVuRmluLlZpZXd9IChwcmVmaXhlZCB3aXRoIGBhcHBsaWNhdGlvbi1gLCBgd2luZG93LWAsIGFuZCBgdmlldy1gKS4gIEFsbFxuICogZXZlbnQgcHJvcGFnYXRpb25zIGFyZSB2aXNpYmxlIGF0IHRoZSBTeXN0ZW0gbGV2ZWwuIFByb3BhZ2F0ZWQgZXZlbnRzIGZyb20gV2ViQ29udGVudHMgKHdpbmRvd3MsIHZpZXdzLCBmcmFtZXMpIHRvIHRoZSBBcHBsaWNhdGlvbiBsZXZlbCB3aWxsICpub3QqXG4gKiB0cmFuc2l0aXZlbHkgcmUtcHJvcGFnYXRlIHRvIHRoZSBTeXN0ZW0gbGV2ZWwsIGJlY2F1c2UgdGhleSBhcmUgYWxyZWFkeSB2aXNpYmxlIGF0IHRoZSBzeXN0ZW0gbGV2ZWwgYW5kIGNvbnRhaW4gdGhlIGlkZW50aXR5XG4gKiBvZiB0aGUgYXBwbGljYXRpb24uICBGb3IgZXhhbXBsZSwgYW4gYXBwbGljYXRpb24ncyBcImNsb3NlZFwiIGV2ZW50IHdpbGwgZmlyZSBhcyAnYXBwbGljYXRpb24tY2xvc2VkJyBhdCB0aGUgc3lzdGVtIGxldmVsLiAgQSB2aWV3J3MgJ3Nob3duJyBldmVudFxuICogd2lsbCBiZSB2aXNpYmxlIGFzICd2aWV3LXNob3duJyBhdCB0aGUgc3lzdGVtIGxldmVsLCBidXQgKm5vdCogYXMgYGFwcGxpY2F0aW9uLXdpbmRvdy12aWV3LXNob3duYC5cbiAqXG4gKiBFdmVudCBwYXlsb2FkcyBhcmUgZG9jdW1lbnRlZCBhcyBpbnRlcmZhY2VzLCB3aGlsZSBhbGdlYnJhaWMgaGVscGVyIHR5cGVzIGFuZCBkZXJpdmVkIHR5cGVzIGFyZSBkb2N1bWVudGVkIGFzIHR5cGUgYWxpYXNlcy5cbiAqXG4gKiBUaGlzIG5hbWVzcGFjZSBjb250YWlucyBvbmx5IHBheWxvYWQgc2hhcGVzIGZvciBldmVudHMgdGhhdCBhcmUgdW5pcXVlIHRvIGBTeXN0ZW1gLiAgRXZlbnRzIHRoYXQgcHJvcGFnYXRlIHRvIGBTeXN0ZW1gIGZyb21cbiAqIGNoaWxkIHtAbGluayBPcGVuRmluLkFwcGxpY2F0aW9uIGFwcGxpY2F0aW9uc30sIHtAbGluayBPcGVuRmluLldpbmRvdyB3aW5kb3dzfSwgYW5kIHtAbGluayBPcGVuRmluLlZpZXcgdmlld3N9IGFyZSBkZWZpbmVkIGluIHRoZVxuICoge0BsaW5rIE9wZW5GaW4uQXBwbGljYXRpb25FdmVudHN9LCB7QGxpbmsgT3BlbkZpbi5XaW5kb3dFdmVudHN9LCBhbmQge0BsaW5rIE9wZW5GaW4uVmlld0V2ZW50c30gbmFtZXNwYWNlcy4gIEZvciBhIGxpc3Qgb2YgdmFsaWQgc3RyaW5nIGtleXMgZm9yICphbGwqXG4gKiBzeXN0ZW0gZXZlbnRzLCBzZWUge0BsaW5rIFN5c3RlbS5vbiBTeXN0ZW0ub259LlxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc3lzdGVtJDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdmlldyQxID0ge307XG5cbi8qKlxuICogTmFtZXNwYWNlIGZvciBldmVudHMgdGhhdCBjYW4gYmUgZW1pdHRlZCBieSBhIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICpcbiAqIEV2ZW50IHBheWxvYWRzIGFyZSBkb2N1bWVudGVkIGFzIGludGVyZmFjZXMsIHdoaWxlIGFsZ2VicmFpYyBoZWxwZXIgdHlwZXMgYW5kIGRlcml2ZWQgdHlwZXMgYXJlIGRvY3VtZW50ZWQgYXMgdHlwZSBhbGlhc2VzLlxuICpcbiAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIG9ubHkgcGF5bG9hZCBzaGFwZXMgZm9yIGV2ZW50cyB0aGF0IGFyZSB1bmlxdWUgdG8gYFZpZXdgLiAgRXZlbnRzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBgV2ViQ29udGVudHNgXG4gKiAoaS5lLiB7QGxpbmsgT3BlbkZpbi5XaW5kb3d9LCB7QGxpbmsgT3BlbkZpbi5WaWV3fSkgYXJlIGRlZmluZWQgaW4ge0BsaW5rIE9wZW5GaW4uV2ViQ29udGVudHNFdmVudHN9LiAgRm9yIGEgbGlzdFxuICogb2YgdmFsaWQgc3RyaW5nIGtleXMgZm9yICphbGwqIFZpZXcgZXZlbnRzLCBzZWUge0BsaW5rIFZpZXcub24gVmlldy5vbn0uXG4gKlxuICogVmlldyBldmVudHMgcHJvcGFnYXRlIHRvIHRoZWlyIHBhcmVudCB7QGxpbmsgT3BlbkZpbi5XaW5kb3dFdmVudHMgV2luZG93fSwge0BsaW5rIE9wZW5GaW4uQXBwbGljYXRpb25FdmVudHMgQXBwbGljYXRpb259LFxuICogYW5kIHtAbGluayBPcGVuRmluLlN5c3RlbUV2ZW50cyBTeXN0ZW19IHdpdGggYW4gYWRkZWQgYHZpZXdJZGVudGl0eWAgcHJvcGVydHkgYW5kIHRoZWlyIGV2ZW50IHR5cGVzIHByZWZpeGVkIHdpdGggYCd2aWV3LSdgLlxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodmlldyQxLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHdlYmNvbnRlbnRzID0ge307XG5cbi8qKlxuICogTmFtZXNwYWNlIGZvciBldmVudHMgc2hhcmVkIGJ5IGFsbCBPcGVuRmluIFdlYkNvbnRlbnRzIGVsZW1lbnRzIChpLmUuIHtAbGluayBPcGVuRmluLldpbmRvd30sXG4gKiB7QGxpbmsgT3BlbkZpbi5WaWV3fSkuXG4gKlxuICogV2ViQ29udGVudHMgZXZlbnRzIHdpbGwgcmUtZW1pdCBvbiBwYXJlbnQgZW50aXRpZXMgLSBlLmcuLCBhIHByb3BhZ2F0aW5nIGV2ZW50IGluIGEgdmlldyB3aWxsIGFsc28gYmUgZW1pdHRlZCBvbiB0aGUgdmlldydzXG4gKiBwYXJlbnQgd2luZG93LCBhbmQgcHJvcGFnYXRpbmcgZXZlbnRzIGluIGEgd2luZG93IHdpbGwgYWxzbyBiZSBlbWl0dGVkIG9uIHRoZSB3aW5kb3cncyBwYXJlbnQge0BsaW5rIE9wZW5GaW4uQXBwbGljYXRpb259LlxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2ViY29udGVudHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgd2luZG93JDIgPSB7fTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgZm9yIGV2ZW50cyB0aGF0IGNhbiBiZSBlbWl0dGVkIGJ5IGEge0BsaW5rIE9wZW5GaW4uV2luZG93fS5cbiAqXG4gKiBFdmVudCBwYXlsb2FkcyBhcmUgZG9jdW1lbnRlZCBhcyBpbnRlcmZhY2VzLCB3aGlsZSBhbGdlYnJhaWMgaGVscGVyIHR5cGVzIGFuZCBkZXJpdmVkIHR5cGVzIGFyZSBkb2N1bWVudGVkIGFzIHR5cGUgYWxpYXNlcy5cbiAqXG4gKiBUaGlzIG5hbWVzcGFjZSBjb250YWlucyBvbmx5IHBheWxvYWQgc2hhcGVzIGZvciBldmVudHMgdGhhdCBhcmUgdW5pcXVlIHRvIGBXaW5kb3dgLiAgRXZlbnRzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBgV2ViQ29udGVudHNgXG4gKiAoaS5lLiB7QGxpbmsgT3BlbkZpbi5XaW5kb3d9LCB7QGxpbmsgT3BlbkZpbi5WaWV3fSkgYXJlIGRlZmluZWQgaW4ge0BsaW5rIE9wZW5GaW4uV2ViQ29udGVudHNFdmVudHN9LiBFdmVudHMgdGhhdFxuICogcHJvcGFnYXRlIGZyb20gYFZpZXdgIGFyZSBkZWZpbmVkIGluIHtAbGluayBPcGVuRmluLlZpZXdFdmVudHN9LiBGb3IgYSBsaXN0IG9mIHZhbGlkIHN0cmluZyBrZXlzIGZvciAqYWxsKiBXaW5kb3cgZXZlbnRzLCBzZWVcbiAqIHtAbGluayBXaW5kb3cub24gV2luZG93Lm9ufVxuICpcbiAqIHtAbGluayBPcGVuRmluLldpbmRvd0V2ZW50cy5XaW5kb3dTb3VyY2VkRXZlbnQgV2luZG93LXNvdXJjZWQgZXZlbnRzfSAoaS5lLiB0aG9zZSB0aGF0IGFyZSBub3QgcHJvcGFnYXRlZCBmcm9tIGFcbiAqIHtAbGluayBPcGVuRmluLlZpZXdFdmVudHMgVmlld30pIHByb3BhZ2F0ZSB0byB0aGVpciBwYXJlbnQge0BsaW5rIE9wZW5GaW4uQXBwbGljYXRpb25FdmVudHMgQXBwbGljYXRpb259IGFuZFxuICoge0BsaW5rIE9wZW5GaW4uU3lzdGVtRXZlbnRzIFN5c3RlbX0gd2l0aCB0aGVpciBldmVudCB0eXBlcyBwcmVmaXhlZCB3aXRoIGAnd2luZG93LSdgKS5cbiAqXG4gKiBcIlJlcXVlc3RlZFwiIGV2ZW50cyAoZS5nLiB7QGxpbmsgQXV0aFJlcXVlc3RlZEV2ZW50fSkgZG8gbm90IHByb3BhZ2F0ZSB0byBgU3lzdGVtLiAgVGhlIHtAbGluayBPcGVuRmluLldpbmRvd0V2ZW50cy5XaW5kb3dDbG9zZVJlcXVlc3RlZEV2ZW50fVxuICogZG9lcyBub3QgcHJvcGFnYXRlIGF0IGFsbC5cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdyQyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgZm9yIE9wZW5GaW4gZXZlbnQgdHlwZXMuIEVhY2ggZW50aXR5IHRoYXQgZW1pdHMgT3BlbkZpbiBldmVudHMgaGFzIGl0cyBvd24gc3ViLW5hbWVzcGFjZS4gRXZlbnQgcGF5bG9hZHNcbiAqIHRoZW1zZWx2ZXMgYXJlIGRvY3VtZW50ZWQgYXMgaW50ZXJmYWNlcywgd2hpbGUgYWxnZWJyYWljIGhlbHBlciB0eXBlcyBhbmQgZGVyaXZlZCB0eXBlcyBhcmUgZG9jdW1lbnRlZCBhcyB0eXBlIGFsaWFzZXMuXG4gKlxuICogIyMjIyBFdmVudCBlbWl0dGVyc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZW50aXRpZXMgZW1pdCBPcGVuRmluIGV2ZW50cywgYW5kIGhhdmUgY29ycmVzcG9uZGluZyBzdWItbmFtZXNwYWNlczpcbiAqXG4gKiAqIHtAbGluayBPcGVuRmluLkFwcGxpY2F0aW9ufToge0BsaW5rIE9wZW5GaW4uQXBwbGljYXRpb25FdmVudHN9XG4gKiAqIHtAbGluayBPcGVuRmluLkV4dGVybmFsQXBwbGljYXRpb259OiB7QGxpbmsgT3BlbkZpbi5FeHRlcm5hbEFwcGxpY2F0aW9uRXZlbnRzfVxuICogKiB7QGxpbmsgT3BlbkZpbi5GcmFtZX06IHtAbGluayBPcGVuRmluLkZyYW1lRXZlbnRzfVxuICogKiB7QGxpbmsgT3BlbkZpbi5HbG9iYWxIb3RrZXl9OiB7QGxpbmsgT3BlbkZpbi5HbG9iYWxIb3RrZXlFdmVudHN9XG4gKiAqIHtAbGluayBPcGVuRmluLlBsYXRmb3JtfToge0BsaW5rIE9wZW5GaW4uUGxhdGZvcm1FdmVudHN9XG4gKiAqIHtAbGluayBPcGVuRmluLlN5c3RlbX06IHtAbGluayBPcGVuRmluLlN5c3RlbUV2ZW50c31cbiAqICoge0BsaW5rIE9wZW5GaW4uVmlld306IHtAbGluayBPcGVuRmluLlZpZXdFdmVudHN9XG4gKiAqIHtAbGluayBPcGVuRmluLldpbmRvd306IHtAbGluayBPcGVuRmluLldpbmRvd0V2ZW50c31cbiAqXG4gKiBUaGVzZSBgRXZlbnRFbWl0dGVyYCBlbnRpdGllcyBzaGFyZSBhIGNvbW1vbiBzZXQgb2YgbWV0aG9kcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgT3BlbkZpbiBldmVudCBidXMsIHdoaWNoIGNhbiBiZVxuICogc2VlbiBvbiB0aGUgaW5kaXZpZHVhbCBkb2N1bWVudGF0aW9uIHBhZ2VzIGZvciBlYWNoIGVudGl0eSB0eXBlLlxuICpcbiAqIFJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzIGlzIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIEl0IGlzIGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCB0aGUgcmV0dXJuZWQgUHJvbWlzZXMgYXJlIGF3YWl0ZWQgdG8gcmVkdWNlIHRoZVxuICogcmlzayBvZiByYWNlIGNvbmRpdGlvbnMuXG4gKlxuICogV2hlbiB0aGUgYEV2ZW50RW1pdHRlcmAgcmVjZWl2ZXMgYW4gZXZlbnQgZnJvbSB0aGUgYnJvd3NlciBwcm9jZXNzIGFuZCBlbWl0cyBvbiB0aGUgcmVuZGVyZXIsIGFsbCBvZiB0aGUgZnVuY3Rpb25zIGF0dGFjaGVkIHRvIHRoYXRcbiAqIHNwZWNpZmljIGV2ZW50IGFyZSBjYWxsZWQgc3luY2hyb25vdXNseS4gQW55IHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGVkIGxpc3RlbmVycyBhcmUgaWdub3JlZCBhbmQgd2lsbCBiZSBkaXNjYXJkZWQuICBJZiB0aGUgd2luZG93IGRvY3VtZW50XG4gKiBpcyBkZXN0cm95ZWQgYnkgcGFnZSBuYXZpZ2F0aW9uIG9yIHJlbG9hZCwgaXRzIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC5cbiAqXG4gKiBXZSByZWNvbW1lbmQgdXNpbmcgQXJyb3cgRnVuY3Rpb25zIGZvciBldmVudCBsaXN0ZW5lcnMgdG8gZW5zdXJlIHRoZSB0aGlzIHNjb3BlIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gY29udGV4dC5cbiAqXG4gKiBFdmVudHMgcmUtcHJvcGFnYXRlIGZyb20gc21hbGxlci9tb3JlLWxvY2FsIHNjb3BlcyB0byBsYXJnZXIvbW9yZS1nbG9iYWwgc2NvcGVzLiAgRm9yIGV4YW1wbGUsIGFuIGV2ZW50IGVtaXR0ZWQgb24gYSBzcGVjaWZpY1xuICogdmlldyB3aWxsIHByb3BhZ2F0ZSB0byB0aGUgd2luZG93IGluIHdoaWNoIHRoZSB2aWV3IGlzIGVtYmVkZGVkLCBhbmQgdGhlbiB0byB0aGUgYXBwbGljYXRpb24gaW4gd2hpY2ggdGhlIHdpbmRvdyBpcyBydW5uaW5nLCBhbmRcbiAqIGZpbmFsbHkgdG8gdGhlIE9wZW5GaW4gcnVudGltZSBpdHNlbGYgYXQgdGhlIFwic3lzdGVtXCIgbGV2ZWwuICBGb3IgZGV0YWlscyBvbiBwcm9wYWdhdGlvbiBzZW1hbnRpY3MsIHNlZSB0aGUgbmFtZXNwYWNlIGZvclxuICogdGhlIHByb3BhZ2F0aW5nIChvciBwcm9wYWdhdGVkLXRvKSBlbnRpdHkuXG4gKlxuICogSWYgeW91IG5lZWQgdGhlIHBheWxvYWQgdHlwZSBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mIGV2ZW50IChlc3BlY2lhbGx5IHByb3BhZ2F0ZWQgZXZlbnRzKSwgdXNlIHRoZSBlbWl0dGluZyB0b3BpYydzIGBQYXlsb2FkYCBnZW5lcmljXG4gKiAoZS5nLiB7QGxpbmsgV2luZG93RXZlbnRzLlBheWxvYWR9KSB3aXRoIHRoZSBldmVudCdzIGB0eXBlYCBzdHJpbmcuICBGb3IgZXhhbXBsZSwgdGhlIHBheWxvYWQgb2ZcbiAqIGEge0BsaW5rIFZpZXdFdmVudHMuQ3JlYXRlZEV2ZW50fSBhZnRlciBpdCBoYXMgcHJvcGFnYXRlZCB0byBpdHMgcGFyZW50IHtAbGluayBXaW5kb3dFdmVudHMgV2luZG93fSBjYW4gYmUgZm91bmQgd2l0aFxuICogYFdpbmRvd0V2ZW50cy5QYXlsb2FkPCd2aWV3LWNyZWF0ZWQnPmAuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXZlbnRzLldpbmRvd0V2ZW50cyA9IGV2ZW50cy5XZWJDb250ZW50c0V2ZW50cyA9IGV2ZW50cy5WaWV3RXZlbnRzID0gZXZlbnRzLlN5c3RlbUV2ZW50cyA9IGV2ZW50cy5QbGF0Zm9ybUV2ZW50cyA9IGV2ZW50cy5HbG9iYWxIb3RrZXlFdmVudHMgPSBldmVudHMuRnJhbWVFdmVudHMgPSBldmVudHMuRXh0ZXJuYWxBcHBsaWNhdGlvbkV2ZW50cyA9IGV2ZW50cy5CYXNlRXZlbnRzID0gZXZlbnRzLkFwcGxpY2F0aW9uRXZlbnRzID0gdm9pZCAwO1xuY29uc3QgQXBwbGljYXRpb25FdmVudHMgPSBhcHBsaWNhdGlvbiQxO1xuZXZlbnRzLkFwcGxpY2F0aW9uRXZlbnRzID0gQXBwbGljYXRpb25FdmVudHM7XG5jb25zdCBCYXNlRXZlbnRzID0gYmFzZSQxO1xuZXZlbnRzLkJhc2VFdmVudHMgPSBCYXNlRXZlbnRzO1xuY29uc3QgRXh0ZXJuYWxBcHBsaWNhdGlvbkV2ZW50cyA9IGV4dGVybmFsQXBwbGljYXRpb24kMTtcbmV2ZW50cy5FeHRlcm5hbEFwcGxpY2F0aW9uRXZlbnRzID0gRXh0ZXJuYWxBcHBsaWNhdGlvbkV2ZW50cztcbmNvbnN0IEZyYW1lRXZlbnRzID0gZnJhbWUkMTtcbmV2ZW50cy5GcmFtZUV2ZW50cyA9IEZyYW1lRXZlbnRzO1xuY29uc3QgR2xvYmFsSG90a2V5RXZlbnRzID0gZ2xvYmFsSG90a2V5JDE7XG5ldmVudHMuR2xvYmFsSG90a2V5RXZlbnRzID0gR2xvYmFsSG90a2V5RXZlbnRzO1xuY29uc3QgUGxhdGZvcm1FdmVudHMgPSBwbGF0Zm9ybSQxO1xuZXZlbnRzLlBsYXRmb3JtRXZlbnRzID0gUGxhdGZvcm1FdmVudHM7XG5jb25zdCBTeXN0ZW1FdmVudHMgPSBzeXN0ZW0kMTtcbmV2ZW50cy5TeXN0ZW1FdmVudHMgPSBTeXN0ZW1FdmVudHM7XG5jb25zdCBWaWV3RXZlbnRzID0gdmlldyQxO1xuZXZlbnRzLlZpZXdFdmVudHMgPSBWaWV3RXZlbnRzO1xuY29uc3QgV2ViQ29udGVudHNFdmVudHMgPSB3ZWJjb250ZW50cztcbmV2ZW50cy5XZWJDb250ZW50c0V2ZW50cyA9IFdlYkNvbnRlbnRzRXZlbnRzO1xuY29uc3QgV2luZG93RXZlbnRzID0gd2luZG93JDI7XG5ldmVudHMuV2luZG93RXZlbnRzID0gV2luZG93RXZlbnRzO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0LyoqXG5cdCAqIFRvcC1sZXZlbCBuYW1lc3BhY2UgZm9yIHR5cGVzIHJlZmVyZW5jZWQgYnkgdGhlIE9wZW5GaW4gQVBJLiAgQ29udGFpbnM6XG5cdCAqXG5cdCAqICogVGhlIHR5cGUgb2YgdGhlIGdsb2JhbCBgZmluYCBlbnRyeSBwb2ludCAoe0BsaW5rIEZpbkFwaX0pXG5cdCAqICogQ2xhc3NlcyB0aGF0IGFjdCBhcyBzdGF0aWMgbmFtZXNwYWNlcyByZXR1cm5lZCBmcm9tIHRoZSBgZmluYCBnbG9iYWwgKGUuZy4ge0BsaW5rIEFwcGxpY2F0aW9uTW9kdWxlfSwgYWNjZXNzaWJsZSB2aWEgYGZpbi5BcHBsaWNhdGlvbmApXG5cdCAqICogSW5zdGFuY2UgY2xhc3NlcyB0aGF0IGFyZSByZXR1cm5lZCBmcm9tIEFQSSBjYWxscyAoZS5nLiB7QGxpbmsgQXBwbGljYXRpb259LCBhY2Nlc3NpYmxlIHZpYSBgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnRTeW5jKClgKVxuXHQgKiAqIFBhcmFtZXRlciBzaGFwZXMgZm9yIEFQSSBtZXRob2RzIChlLmcuIHtAbGluayBBcHBsaWNhdGlvbk9wdGlvbnN9LCB1c2VkIGluIGBmaW4uQXBwbGljYXRpb24uc3RhcnQoKWApXG5cdCAqICogRXZlbnQgbmFtZXNwYWNlcyBhbmQgcGF5bG9hZCB1bmlvbiB0eXBlcyAoZS5nLiB7QGxpbmsgQXBwbGljYXRpb25FdmVudHN9IGFuZCB7QGxpbmsgQXBwbGljYXRpb25FdmVudH0pXG5cdCAqXG5cdCAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuXHQgKi9cblx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX2V4cG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gRGVwcmVjYXRlZCBzaGltIHRvIHByZXNlcnZlIHYzMCBuYW1lc3BhY2UgbmFtZXNcblx0X19leHBvcnRTdGFyKGV2ZW50cywgZXhwb3J0cyk7IFxufSAoT3BlbkZpbiQxKSk7XG5cbnZhciBmaW4kMSA9IHt9O1xuXG52YXIgc3lzdGVtID0ge307XG5cbnZhciBiYXNlID0ge307XG5cbnZhciBwcm9taXNlcyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZXMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucHJvbWlzZXMucHJvbWlzZU1hcFNlcmlhbCA9IHByb21pc2VzLnNlcmlhbCA9IHByb21pc2VzLnByb21pc2VNYXAgPSBwcm9taXNlcy5wcm9taXNpZnkgPSB2b2lkIDA7XG5mdW5jdGlvbiBwcm9taXNpZnkoZnVuYykge1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmdW5jKC4uLmFyZ3MsIChlcnIsIHZhbCkgPT4gKGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSh2YWwpKSk7XG4gICAgfSk7XG59XG5wcm9taXNlcy5wcm9taXNpZnkgPSBwcm9taXNpZnk7XG5hc3luYyBmdW5jdGlvbiBwcm9taXNlTWFwKGFyciwgYXN5bmNGKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFyci5tYXAoYXN5bmNGKSk7XG59XG5wcm9taXNlcy5wcm9taXNlTWFwID0gcHJvbWlzZU1hcDtcbmFzeW5jIGZ1bmN0aW9uIHNlcmlhbChhcnIpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZ1bmMgb2YgYXJyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgIGNvbnN0IG5leHQgPSBhd2FpdCBmdW5jKCk7XG4gICAgICAgIHJldC5wdXNoKG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxucHJvbWlzZXMuc2VyaWFsID0gc2VyaWFsO1xuYXN5bmMgZnVuY3Rpb24gcHJvbWlzZU1hcFNlcmlhbChhcnIsIGZ1bmMpIHtcbiAgICByZXR1cm4gc2VyaWFsKGFyci5tYXAoKHZhbHVlLCBpbmRleCwgYXJyYXkpID0+ICgpID0+IGZ1bmModmFsdWUsIGluZGV4LCBhcnJheSkpKTtcbn1cbnByb21pc2VzLnByb21pc2VNYXBTZXJpYWwgPSBwcm9taXNlTWFwU2VyaWFsO1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCRkID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGYgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRW1pdHRlckJhc2VfZW1pdHRlckFjY2Vzc29yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGJhc2UsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYmFzZS5SZXBseSA9IGJhc2UuRW1pdHRlckJhc2UgPSBiYXNlLkJhc2UgPSB2b2lkIDA7XG5jb25zdCBwcm9taXNlc18xID0gcHJvbWlzZXM7XG5jbGFzcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aXJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNOb2RlRW52aXJvbm1lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLmVudmlyb25tZW50LnR5cGUgPT09ICdub2RlJztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc09wZW5GaW5FbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpcmUuZW52aXJvbm1lbnQudHlwZSA9PT0gJ29wZW5maW4nO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQnJvd3NlckVudmlyb25tZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5lbnZpcm9ubWVudC50eXBlID09PSAnb3RoZXInO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndpcmUgPSB3aXJlO1xuICAgIH1cbiAgICBnZXQgZmluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLmdldEZpbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIE9wZW5GaW4gcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgY29kZSBjb250ZXh0ICh1c3VhbGx5IGEgZG9jdW1lbnRcbiAgICAgKiBzdWNoIGFzIGEge0BsaW5rIE9wZW5GaW4uVmlld30gb3Ige0BsaW5rIE9wZW5GaW4uV2luZG93fSksIGFzIHdlbGwgYXMgdG8gdGhlIGN1cnJlbnQgYEludGVyb3BgIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgZm9yIGRlYnVnZ2luZyBpbiB0aGUgZGV2dG9vbHMgY29uc29sZSwgd2hlcmUgdGhpcyB3aWxsIGludGVsbGlnZW50bHkgdHlwZSBpdHNlbGYgYmFzZWRcbiAgICAgKiBvbiB0aGUgY29udGV4dCBpbiB3aGljaCB0aGUgZGV2dG9vbHMgcGFuZWwgd2FzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBnZXQgbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUubWU7XG4gICAgfVxufVxuYmFzZS5CYXNlID0gQmFzZTtcbi8qKlxuICogQW4gZW50aXR5IHRoYXQgZW1pdHMgT3BlbkZpbiBldmVudHMuXG4gKlxuICogQHJlbWFya3MgRXZlbnQtYmluZGluZyBtZXRob2RzIGFyZSBhc3luY2hyb25vdXMgYXMgdGhleSBtdXN0IGNyb3NzIHByb2Nlc3MgYm91bmRhcmllc1xuICogYW5kIHNldHVwIHRoZSBsaXN0ZW5lciBpbiB0aGUgYnJvd3NlciBwcm9jZXNzLiAgV2hlbiB0aGUgYEV2ZW50RW1pdHRlcmAgcmVjZWl2ZXMgYW4gZXZlbnQgZnJvbSB0aGUgYnJvd3NlciBwcm9jZXNzXG4gKiBhbmQgZW1pdHMgb24gdGhlIHJlbmRlcmVyLCBhbGwgb2YgdGhlIGZ1bmN0aW9ucyBhdHRhY2hlZCB0byB0aGF0IHNwZWNpZmljIGV2ZW50IGFyZSBjYWxsZWQgc3luY2hyb25vdXNseS4gIEFueSB2YWx1ZXNcbiAqIHJldHVybmVkIGJ5IHRoZSBjYWxsZWQgbGlzdGVuZXJzIGFyZSBpZ25vcmVkIGFuZCB3aWxsIGJlIGRpc2NhcmRlZC4gIElmIHRoZSBleGVjdXRpb24gY29udGV4dCBvZiB0aGUgd2luZG93IGlzIGRlc3Ryb3llZFxuICogYnkgcGFnZSBuYXZpZ2F0aW9uIG9yIHJlbG9hZCwgYW55IGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBzZXR1cCBpbiB0aGF0IGNvbnRleHQgd2lsbCBiZSBkZXN0cm95ZWQuXG4gKlxuICogSXQgaXMgaW1wb3J0YW50IHRvIGtlZXAgaW4gbWluZCB0aGF0IHdoZW4gYW4gb3JkaW5hcnkgbGlzdGVuZXIgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgc3RhbmRhcmQgYHRoaXNgIGtleXdvcmQgaXMgaW50ZW50aW9uYWxseVxuICogc2V0IHRvIHJlZmVyZW5jZSB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UgdG8gd2hpY2ggdGhlIGxpc3RlbmVyIGlzIGF0dGFjaGVkLiAgSXQgaXMgcG9zc2libGUgdG8gdXNlIEVTNiBBcnJvdyBGdW5jdGlvbnMgYXNcbiAqIGxpc3RlbmVycywgaG93ZXZlciwgd2hlbiBkb2luZyBzbywgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgbm8gbG9uZ2VyIHJlZmVyZW5jZSB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKlxuICogRXZlbnRzIHJlLXByb3BhZ2F0ZSBmcm9tIHNtYWxsZXIvbW9yZS1sb2NhbCBzY29wZXMgdG8gbGFyZ2VyL21vcmUtZ2xvYmFsIHNjb3Blcy4gIEZvciBleGFtcGxlLCBhbiBldmVudCBlbWl0dGVkIG9uIGEgc3BlY2lmaWNcbiAqIHZpZXcgd2lsbCBwcm9wYWdhdGUgdG8gdGhlIHdpbmRvdyBpbiB3aGljaCB0aGUgdmlldyBpcyBlbWJlZGRlZCwgYW5kIHRoZW4gdG8gdGhlIGFwcGxpY2F0aW9uIGluIHdoaWNoIHRoZSB3aW5kb3cgaXMgcnVubmluZywgYW5kXG4gKiBmaW5hbGx5IHRvIHRoZSBPcGVuRmluIHJ1bnRpbWUgaXRzZWxmIGF0IHRoZSBcInN5c3RlbVwiIGxldmVsLiAgUmUtcHJvcGFnYXRlZCBldmVudHMgYXJlIHByZWZpeGVkIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNjb3BlIGluIHdoaWNoXG4gKiB0aGV5IG9yaWdpbmF0ZWQgLSBmb3IgZXhhbXBsZSwgYSBcInNob3duXCIgZXZlbnQgZW1pdHRlZCBvbiBhIHZpZXcgd2lsbCBiZSByZS1wcm9wYWdhdGVkIGF0IHRoZSB3aW5kb3cgbGV2ZWwgYXMgXCJ2aWV3LXNob3duXCIsIGFuZFxuICogdGhlbiB0byB0aGUgYXBwbGljYXRpb24gYXMgXCJ3aW5kb3ctdmlldy1zaG93blwiLCBhbmQgZmluYWxseSBhdCB0aGUgc3lzdGVtIGxldmVsIGFzIFwiYXBwbGljYXRpb24td2luZG93LXZpZXctc2hvd25cIi5cbiAqXG4gKiBBbGwgZXZlbnQgcHJvcGFnYXRpb25zIGFyZSB2aXNpYmxlIGF0IHRoZSBTeXN0ZW0gbGV2ZWwsIHJlZ2FyZGxlc3Mgb2Ygc291cmNlLCBzbyB0cmFuc2l0aXZlIHJlLXByb3BhZ2F0aW9ucyAoZS5nLiBmcm9tIHZpZXcgdG8gd2luZG93XG4gKiB0byBhcHBsaWNhdGlvbikgYXJlIHZpc2libGUgaW4gdGhlaXIgZW50aXJldHkgYXQgdGhlIHN5c3RlbSBsZXZlbC4gIFNvLCB3ZSBjYW4gbGlzdGVuIHRvIHRoZSBhYm92ZSBldmVudCBhcyBcInNob3duXCIsIFwidmlldy1zaG93blwiLFxuICogXCJ3aW5kb3ctdmlldy1zaG93blwiLCBvciBcImFwcGxpY2F0aW9uLXdpbmRvdy12aWV3LXNob3duLlwiXG4gKi9cbmNsYXNzIEVtaXR0ZXJCYXNlIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSwgdG9waWMsIC4uLmFkZGl0aW9uYWxBY2Nlc3NvcnMpIHtcbiAgICAgICAgc3VwZXIod2lyZSk7XG4gICAgICAgIHRoaXMudG9waWMgPSB0b3BpYztcbiAgICAgICAgX0VtaXR0ZXJCYXNlX2VtaXR0ZXJBY2Nlc3Nvci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5ldmVudE5hbWVzID0gKCkgPT4gKHRoaXMuaGFzRW1pdHRlcigpID8gdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIoKS5ldmVudE5hbWVzKCkgOiBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCA9IChldmVudFR5cGUsIHBheWxvYWQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0VtaXR0ZXIoKSA/IHRoaXMuZ2V0T3JDcmVhdGVFbWl0dGVyKCkuZW1pdChldmVudFR5cGUsIHBheWxvYWQsIC4uLmFyZ3MpIDogZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFzRW1pdHRlciA9ICgpID0+IHRoaXMud2lyZS5ldmVudEFnZ3JlZ2F0b3IuaGFzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZih0aGlzLCBfRW1pdHRlckJhc2VfZW1pdHRlckFjY2Vzc29yLCBcImZcIikpO1xuICAgICAgICB0aGlzLmdldE9yQ3JlYXRlRW1pdHRlciA9ICgpID0+IHRoaXMud2lyZS5ldmVudEFnZ3JlZ2F0b3IuZ2V0T3JDcmVhdGUoX19jbGFzc1ByaXZhdGVGaWVsZEdldCRmKHRoaXMsIF9FbWl0dGVyQmFzZV9lbWl0dGVyQWNjZXNzb3IsIFwiZlwiKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gKHR5cGUpID0+IHRoaXMuaGFzRW1pdHRlcigpID8gdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIoKS5saXN0ZW5lcnModHlwZSkgOiBbXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50ID0gKHR5cGUpID0+IHRoaXMuaGFzRW1pdHRlcigpID8gdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIoKS5saXN0ZW5lckNvdW50KHR5cGUpIDogMDtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXIgPSBhc3luYyAoZXZlbnRUeXBlLCBvcHRpb25zID0ge30sIGFwcGx5U3Vic2NyaXB0aW9uLCB1bmRvU3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydW50aW1lRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgdG9waWM6IHRoaXMudG9waWMsXG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZW1pdHRlciA9IHRoaXMuZ2V0T3JDcmVhdGVFbWl0dGVyKCk7XG4gICAgICAgICAgICAvLyBXZSBhcHBseSB0aGUgc3Vic2NyaXB0aW9uIGFuZCB0aGVuIHVuZG8gaWYgdGhlIGFzeW5jIGNhbGwgZmFpbHMgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGluZGV0ZXJtaW5hY3kgaW4gc3Vic2NyaXB0aW9uIGFwcGxpY2F0aW9uIG9yZGVyLCB3aGljaCBjYW4gYnJlYWsgdGhpbmdzIGVsc2V3aGVyZVxuICAgICAgICAgICAgYXBwbHlTdWJzY3JpcHRpb24oZW1pdHRlcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzdWJzY3JpYmUtdG8tZGVza3RvcC1ldmVudCcsIHJ1bnRpbWVFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHVuZG9TdWJzY3JpcHRpb24oZW1pdHRlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVFbWl0dGVySWZOb3RoaW5nUmVnaXN0ZXJlZChlbWl0dGVyKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJFdmVudExpc3RlbmVyID0gYXN5bmMgKGV2ZW50VHlwZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNFbWl0dGVyKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW50aW1lRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgdG9waWM6IHRoaXMudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50VHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Vuc3Vic2NyaWJlLXRvLWRlc2t0b3AtZXZlbnQnLCBydW50aW1lRXZlbnQpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzLmdldE9yQ3JlYXRlRW1pdHRlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIG9ubHkgYmUgcmVhY2hlZCBpZiB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IHRoYXQgZG9lcyBub3QgZXhpc3QgYnV0IGRvIG5vdCB3YW50IHRvIGVycm9yIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCRkKHRoaXMsIF9FbWl0dGVyQmFzZV9lbWl0dGVyQWNjZXNzb3IsIFt0b3BpYywgLi4uYWRkaXRpb25hbEFjY2Vzc29yc10sIFwiZlwiKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSAoZXZlbnQpID0+IHRoaXMuaGFzRW1pdHRlcigpID8gdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIoKS5saXN0ZW5lcnMoZXZlbnQpIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBFdmVudCBwYXlsb2FkcyBhcmUgZG9jdW1lbnRlZCBpbiB0aGUge0BsaW5rIE9wZW5GaW4uRXZlbnRzfSBuYW1lc3BhY2UuXG4gICAgICovXG4gICAgYXN5bmMgb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIG9wdGlvbnMsIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICB9LCAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LiBUaGUgbGlzdGVuZXIgaXMgaW52b2tlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIEV2ZW50IHBheWxvYWRzIGFyZSBkb2N1bWVudGVkIGluIHRoZSB7QGxpbmsgT3BlbkZpbi5FdmVudHN9IG5hbWVzcGFjZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbmNlKGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZGVyZWdpc3RlciA9ICgpID0+IHRoaXMuZGVyZWdpc3RlckV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBvcHRpb25zLCAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgZW1pdHRlci5vbmNlKGV2ZW50VHlwZSwgZGVyZWdpc3Rlcik7XG4gICAgICAgICAgICBlbWl0dGVyLm9uY2UoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIH0sIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgZGVyZWdpc3Rlcik7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBFdmVudCBwYXlsb2FkcyBhcmUgZG9jdW1lbnRlZCBpbiB0aGUge0BsaW5rIE9wZW5GaW4uRXZlbnRzfSBuYW1lc3BhY2UuXG4gICAgICovXG4gICAgYXN5bmMgcHJlcGVuZExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBvcHRpb25zLCAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIH0sIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LiBUaGUgbGlzdGVuZXIgaXMgaW52b2tlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCxcbiAgICAgKiBhZnRlciB3aGljaCBpdCBpcyByZW1vdmVkLiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqXG4gICAgICogQHJlbWFya3MgRXZlbnQgcGF5bG9hZHMgYXJlIGRvY3VtZW50ZWQgaW4gdGhlIHtAbGluayBPcGVuRmluLkV2ZW50c30gbmFtZXNwYWNlLlxuICAgICAqL1xuICAgIGFzeW5jIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkZXJlZ2lzdGVyID0gKCkgPT4gdGhpcy5kZXJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudFR5cGUpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIG9wdGlvbnMsIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLnByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBlbWl0dGVyLm9uY2UoZXZlbnRUeXBlLCBkZXJlZ2lzdGVyKTtcbiAgICAgICAgfSwgKGVtaXR0ZXIpID0+IHtcbiAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgZGVyZWdpc3Rlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBDYXV0aW9uOiBDYWxsaW5nIHRoaXMgbWV0aG9kIGNoYW5nZXMgdGhlIGFycmF5IGluZGljZXMgaW4gdGhlIGxpc3RlbmVyIGFycmF5IGJlaGluZCB0aGUgbGlzdGVuZXIuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBlbWl0dGVyID0gYXdhaXQgdGhpcy5kZXJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlRW1pdHRlcklmTm90aGluZ1JlZ2lzdGVyZWQoZW1pdHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIGRlcmVnaXN0ZXJBbGxMaXN0ZW5lcnMoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNvbnN0IHJ1bnRpbWVFdmVudCA9IHsgLi4udGhpcy5pZGVudGl0eSwgdHlwZTogZXZlbnRUeXBlLCB0b3BpYzogdGhpcy50b3BpYyB9O1xuICAgICAgICBpZiAodGhpcy5oYXNFbWl0dGVyKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzLmdldE9yQ3JlYXRlRW1pdHRlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVmQ291bnQgPSBlbWl0dGVyLmxpc3RlbmVyQ291bnQocnVudGltZUV2ZW50LnR5cGUpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVQcm9taXNlcy5wdXNoKHRoaXMud2lyZS5zZW5kQWN0aW9uKCd1bnN1YnNjcmliZS10by1kZXNrdG9wLWV2ZW50JywgcnVudGltZUV2ZW50KS5jYXRjaCgoKSA9PiBudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh1bnN1YnNjcmliZVByb21pc2VzKTtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudFR5cGUpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlQnlFdmVudCA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1pdHRlciA9IGF3YWl0IHRoaXMuZGVyZWdpc3RlckFsbExpc3RlbmVycyhldmVudCk7XG4gICAgICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZUVtaXR0ZXJJZk5vdGhpbmdSZWdpc3RlcmVkKGVtaXR0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVCeUV2ZW50KGV2ZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFbWl0dGVyKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZ2V0T3JDcmVhdGVFbWl0dGVyKCkuZXZlbnROYW1lcygpO1xuICAgICAgICAgICAgYXdhaXQgKDAsIHByb21pc2VzXzEucHJvbWlzZU1hcCkoZXZlbnRzLCByZW1vdmVCeUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlRW1pdHRlcklmTm90aGluZ1JlZ2lzdGVyZWQoZW1pdHRlcikge1xuICAgICAgICBpZiAoZW1pdHRlci5ldmVudE5hbWVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLndpcmUuZXZlbnRBZ2dyZWdhdG9yLmRlbGV0ZShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGYodGhpcywgX0VtaXR0ZXJCYXNlX2VtaXR0ZXJBY2Nlc3NvciwgXCJmXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmJhc2UuRW1pdHRlckJhc2UgPSBFbWl0dGVyQmFzZTtcbl9FbWl0dGVyQmFzZV9lbWl0dGVyQWNjZXNzb3IgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgUmVwbHkge1xufVxuYmFzZS5SZXBseSA9IFJlcGx5O1xuXG52YXIgdHJhbnNwb3J0RXJyb3JzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFuc3BvcnRFcnJvcnMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudHJhbnNwb3J0RXJyb3JzLlJ1bnRpbWVFcnJvciA9IHRyYW5zcG9ydEVycm9ycy5Ob3RTdXBwb3J0ZWRFcnJvciA9IHRyYW5zcG9ydEVycm9ycy5Ob3RJbXBsZW1lbnRlZEVycm9yID0gdHJhbnNwb3J0RXJyb3JzLk5vQWNrRXJyb3IgPSB0cmFuc3BvcnRFcnJvcnMuRHVwbGljYXRlQ29ycmVsYXRpb25FcnJvciA9IHRyYW5zcG9ydEVycm9ycy5VbmV4cGVjdGVkQWN0aW9uRXJyb3IgPSB0cmFuc3BvcnRFcnJvcnMuRGlzY29ubmVjdGVkRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBEaXNjb25uZWN0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkeVN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGBFeHBlY3RlZCB3ZWJzb2NrZXQgc3RhdGUgT1BFTiBidXQgZm91bmQgJHtyZWFkeVN0YXRlfWApO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSByZWFkeVN0YXRlO1xuICAgIH1cbn1cbnRyYW5zcG9ydEVycm9ycy5EaXNjb25uZWN0ZWRFcnJvciA9IERpc2Nvbm5lY3RlZEVycm9yO1xuY2xhc3MgVW5leHBlY3RlZEFjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxudHJhbnNwb3J0RXJyb3JzLlVuZXhwZWN0ZWRBY3Rpb25FcnJvciA9IFVuZXhwZWN0ZWRBY3Rpb25FcnJvcjtcbmNsYXNzIER1cGxpY2F0ZUNvcnJlbGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG50cmFuc3BvcnRFcnJvcnMuRHVwbGljYXRlQ29ycmVsYXRpb25FcnJvciA9IER1cGxpY2F0ZUNvcnJlbGF0aW9uRXJyb3I7XG5jbGFzcyBOb0Fja0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxudHJhbnNwb3J0RXJyb3JzLk5vQWNrRXJyb3IgPSBOb0Fja0Vycm9yO1xuY2xhc3MgTm90SW1wbGVtZW50ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbnRyYW5zcG9ydEVycm9ycy5Ob3RJbXBsZW1lbnRlZEVycm9yID0gTm90SW1wbGVtZW50ZWRFcnJvcjtcbmNsYXNzIE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxudHJhbnNwb3J0RXJyb3JzLk5vdFN1cHBvcnRlZEVycm9yID0gTm90U3VwcG9ydGVkRXJyb3I7XG5jbGFzcyBJbnRlcm5hbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycikge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIG5hbWUsIHN0YWNrLCAuLi5yZXN0IH0gPSBlcnI7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjayA/PyB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHJlc3Rba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8gRm9yIGRvY3VtZW50YXRpb24gb2YgdGhlIGVycm9yIG1ldGhvZHMgYmVpbmcgdXNlZCBzZWUgaGVyZTogaHR0cHM6Ly92OC5kZXYvZG9jcy9zdGFjay10cmFjZS1hcGlcbmNsYXNzIFJ1bnRpbWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0aWMgZ2V0Q2FsbFNpdGUoY2FsbHNUb1JlbW92ZSA9IDApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgICAgICBjb25zdCByZWFsQ2FsbHNUb1JlbW92ZSA9IGNhbGxzVG9SZW1vdmUgKyAxOyAvLyByZW1vdmUgdGhpcyBjYWxsO1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsZW5ndGggKyByZWFsQ2FsbHNUb1JlbW92ZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgICAgIGNvbnN0IF9wcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gd2UgYWNjZXNzIHRoZSBgc3RhY2tgIHByb3BlcnR5XG4gICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gKF8sIHN0YWNrKSA9PiBzdGFjaztcbiAgICAgICAgLy8gc3RhY2sgaXMgb3B0aW9uYWwgaW4gbm9uIGNocm9taXVtIGNvbnRleHRzXG4gICAgICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s/LnNsaWNlKHJlYWxDYWxsc1RvUmVtb3ZlKSA/PyBbXTtcbiAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBfcHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH1cbiAgICBzdGF0aWMgcHJlcGFyZVN0YWNrVHJhY2UoZXJyLCBjYWxsU2l0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yLnByZXBhcmVTdGFja1RyYWNlKGVyciwgY2FsbFNpdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgc3RyaW5nICs9IGVyci5uYW1lIHx8IFwiRXJyb3JcIjtcbiAgICAgICAgc3RyaW5nICs9IGA6ICR7ZXJyLm1lc3NhZ2UgfHwgXCJcIn1gO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxTaXRlIG9mIGNhbGxTaXRlcykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGBcXG4gICAgYXQgJHtjYWxsU2l0ZS50b1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gICAgO1xuICAgIGNvbnN0cnVjdG9yKHBheWxvYWQsIGNhbGxTaXRlcykge1xuICAgICAgICBjb25zdCB7IHJlYXNvbiwgZXJyb3IgfSA9IHBheWxvYWQ7XG4gICAgICAgIHN1cGVyKHJlYXNvbik7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSdW50aW1lRXJyb3InO1xuICAgICAgICBpZiAoZXJyb3I/LnN0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gbmV3IEludGVybmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsU2l0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBSdW50aW1lRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UodGhpcywgY2FsbFNpdGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnRyYW5zcG9ydEVycm9ycy5SdW50aW1lRXJyb3IgPSBSdW50aW1lRXJyb3I7XG5cbnZhciB3aW5kb3ckMSA9IHt9O1xuXG52YXIgRmFjdG9yeSQ4ID0ge307XG5cbnZhciB2YWxpZGF0ZSA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFsaWRhdGUudmFsaWRhdGVJZGVudGl0eSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHZhbGlkYXRlSWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICBsZXQgZXJyb3JNc2c7XG4gICAgaWYgKHR5cGVvZiBpZGVudGl0eSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGlkZW50aXR5LnV1aWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yTXNnID0gJ05vdCBhIHZhbGlkIGlkZW50aXR5IG9iamVjdCc7XG4gICAgfVxuICAgIHJldHVybiBlcnJvck1zZztcbn1cbnZhbGlkYXRlLnZhbGlkYXRlSWRlbnRpdHkgPSB2YWxpZGF0ZUlkZW50aXR5O1xuXG52YXIgSW5zdGFuY2UkNyA9IHt9O1xuXG52YXIgYXBwbGljYXRpb24gPSB7fTtcblxudmFyIEZhY3RvcnkkNyA9IHt9O1xuXG52YXIgSW5zdGFuY2UkNiA9IHt9O1xuXG52YXIgdmlldyA9IHt9O1xuXG52YXIgRmFjdG9yeSQ2ID0ge307XG5cbnZhciB3YXJuaW5ncyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2FybmluZ3MsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xud2FybmluZ3MuaGFuZGxlRGVwcmVjYXRlZFdhcm5pbmdzID0gdm9pZCAwO1xuY29uc3QgaGFuZGxlRGVwcmVjYXRlZFdhcm5pbmdzID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAob3B0aW9ucy5jb250ZW50TmF2aWdhdGlvbj8ud2hpdGVsaXN0IHx8XG4gICAgICAgIG9wdGlvbnMuY29udGVudE5hdmlnYXRpb24/LmJsYWNrbGlzdCB8fFxuICAgICAgICBvcHRpb25zLmNvbnRlbnRSZWRpcmVjdD8ud2hpdGVsaXN0IHx8XG4gICAgICAgIG9wdGlvbnMuY29udGVudFJlZGlyZWN0Py5ibGFja2xpc3QpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBUaGUgcHJvcGVydGllcyAnd2hpdGVsaXN0JyBhbmQgJ2JsYWNrbGlzdCcgaGF2ZSBiZWVuIG1hcmtlZCBhcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIHVzZSAnYWxsb3dsaXN0JyBhbmQgJ2RlbnlsaXN0Jy5gKTtcbiAgICB9XG59O1xud2FybmluZ3MuaGFuZGxlRGVwcmVjYXRlZFdhcm5pbmdzID0gaGFuZGxlRGVwcmVjYXRlZFdhcm5pbmdzO1xuXG52YXIgaGFzUmVxdWlyZWRGYWN0b3J5JDM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVGYWN0b3J5JDMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRGYWN0b3J5JDMpIHJldHVybiBGYWN0b3J5JDY7XG5cdGhhc1JlcXVpcmVkRmFjdG9yeSQzID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY3RvcnkkNiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdEZhY3RvcnkkNi5WaWV3TW9kdWxlID0gdm9pZCAwO1xuXHRjb25zdCBiYXNlXzEgPSBiYXNlO1xuXHRjb25zdCB2YWxpZGF0ZV8xID0gdmFsaWRhdGU7XG5cdGNvbnN0IGluZGV4XzEgPSByZXF1aXJlVmlldygpO1xuXHRjb25zdCB3YXJuaW5nc18xID0gd2FybmluZ3M7XG5cdC8qKlxuXHQgKiBTdGF0aWMgbmFtZXNwYWNlIGZvciBPcGVuRmluIEFQSSBtZXRob2RzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUge0BsaW5rIFZpZXd9IGNsYXNzLCBhdmFpbGFibGUgdW5kZXIgYGZpbi5WaWV3YC5cblx0ICovXG5cdGNsYXNzIFZpZXdNb2R1bGUgZXh0ZW5kcyBiYXNlXzEuQmFzZSB7XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBuZXcgVmlldy5cblx0ICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVmlldyBjcmVhdGlvbiBvcHRpb25zXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBsZXQgdmlldztcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVZpZXcoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgbWUgPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gZmluLlZpZXcuY3JlYXRlKHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ3ZpZXdOYW1lQ3JlYXRlJyxcblx0ICAgICAqICAgICAgICAgdGFyZ2V0OiBtZS5pZGVudGl0eSxcblx0ICAgICAqICAgICAgICAgYm91bmRzOiB7dG9wOiAxMCwgbGVmdDogMTAsIHdpZHRoOiAyMDAsIGhlaWdodDogMjAwfVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGNyZWF0ZVZpZXcoKVxuXHQgICAgICogICAgIC50aGVuKChjcmVhdGVkVmlldykgPT4ge1xuXHQgICAgICogICAgICAgICB2aWV3ID0gY3JlYXRlZFZpZXc7XG5cdCAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdWaWV3IGNyZWF0ZWQuJywgdmlldyk7XG5cdCAgICAgKiAgICAgICAgIHZpZXcubmF2aWdhdGUoJ2h0dHBzOi8vZ29vZ2xlLmNvbScpO1xuXHQgICAgICogICAgICAgICBjb25zb2xlLmxvZygnVmlldyBuYXZpZ2F0ZWQgdG8gZ2l2ZW4gdXJsLicpO1xuXHQgICAgICogICAgIH0pXG5cdCAgICAgKiAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICogTm90ZSB0aGF0IGNyZWF0ZWQgdmlld3MgbmVlZHMgdG8gbmF2aWdhdGUgc29tZXdoZXJlIGZvciB0aGVtIHRvIGFjdHVhbGx5IHJlbmRlciBhIHdlYnNpdGUuXG5cdCAgICAgKiBAZXhwZXJpbWVudGFsXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIGNyZWF0ZShvcHRpb25zKSB7XG5cdCAgICAgICAgY29uc3QgeyB1dWlkIH0gPSB0aGlzLndpcmUubWU7XG5cdCAgICAgICAgaWYgKCFvcHRpb25zLm5hbWUgfHwgdHlwZW9mIG9wdGlvbnMubmFtZSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIG5hbWUgcHJvcGVydHkgYXMgYSBzdHJpbmcgaW4gb3JkZXIgdG8gY3JlYXRlIGEgVmlldy4nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIHdhcm5pbmdzXzEuaGFuZGxlRGVwcmVjYXRlZFdhcm5pbmdzKShvcHRpb25zKTtcblx0ICAgICAgICBpZiAodGhpcy53aXJlLmVudmlyb25tZW50LmNoaWxkVmlld3MpIHtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLmVudmlyb25tZW50LmNyZWF0ZUNoaWxkQ29udGVudCh7XG5cdCAgICAgICAgICAgICAgICBlbnRpdHlUeXBlOiAndmlldycsXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zOiB7IC4uLm9wdGlvbnMsIHV1aWQgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjcmVhdGUtdmlldycsIHsgLi4ub3B0aW9ucywgdXVpZCB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN5bmMoeyB1dWlkLCBuYW1lOiBvcHRpb25zLm5hbWUgfSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYSBWaWV3IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gZXhpc3Rpbmcgdmlldy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGZpbi5WaWV3LndyYXAoeyB1dWlkOiAndGVzdFZpZXdVdWlkJywgbmFtZTogJ3Rlc3RWaWV3TmFtZScgfSkpXG5cdCAgICAgKiAgICAgLnRoZW4odmlldyA9PiBjb25zb2xlLmxvZygnd3JhcHBlZCB2aWV3JywgdmlldykpXG5cdCAgICAgKiAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICovXG5cdCAgICBhc3luYyB3cmFwKGlkZW50aXR5KSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ZpZXctd3JhcCcpO1xuXHQgICAgICAgIGNvbnN0IGVycm9yTXNnID0gKDAsIHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eSkoaWRlbnRpdHkpO1xuXHQgICAgICAgIGlmIChlcnJvck1zZykge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuVmlldyh0aGlzLndpcmUsIGlkZW50aXR5KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgVmlldyBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIGV4aXN0aW5nIHZpZXcuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCB2aWV3ID0gZmluLlZpZXcud3JhcFN5bmMoeyB1dWlkOiAndGVzdFZpZXcnLCBuYW1lOiAndGVzdFZpZXdOYW1lJyB9KTtcblx0ICAgICAqIGF3YWl0IHZpZXcuaGlkZSgpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKiBAZXhwZXJpbWVudGFsXG5cdCAgICAgKi9cblx0ICAgIHdyYXBTeW5jKGlkZW50aXR5KSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ZpZXctd3JhcC1zeW5jJykuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29uc3QgZXJyb3JNc2cgPSAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUlkZW50aXR5KShpZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKGVycm9yTXNnKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgaW5kZXhfMS5WaWV3KHRoaXMud2lyZSwgaWRlbnRpdHkpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGEgVmlldyBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHZpZXdcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGZpbi5WaWV3LmdldEN1cnJlbnQoKVxuXHQgICAgICogICAgIC50aGVuKHZpZXcgPT4gY29uc29sZS5sb2coJ2N1cnJlbnQgdmlldycsIHZpZXcpKVxuXHQgICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKlxuXHQgICAgICogYGBgXG5cdCAgICAgKiBAZXhwZXJpbWVudGFsXG5cdCAgICAgKi9cblx0ICAgIGdldEN1cnJlbnQoKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ZpZXctZ2V0LWN1cnJlbnQnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAoIXRoaXMud2lyZS5tZS5pc1ZpZXcpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBpbiBhIFZpZXcgY29udGV4dCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IHRoaXMud2lyZS5tZTtcblx0ICAgICAgICByZXR1cm4gdGhpcy53cmFwKHsgdXVpZCwgbmFtZSB9KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgVmlldyBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHZpZXdcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGNvbnN0IHZpZXcgPSBmaW4uVmlldy5nZXRDdXJyZW50U3luYygpO1xuXHQgICAgICogY29uc29sZS5sb2codmlldyk7XG5cdCAgICAgKlxuXHQgICAgICogYGBgXG5cdCAgICAgKiBAZXhwZXJpbWVudGFsXG5cdCAgICAgKi9cblx0ICAgIGdldEN1cnJlbnRTeW5jKCkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd2aWV3LWdldC1jdXJyZW50LXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAoIXRoaXMud2lyZS5tZS5pc1ZpZXcpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBpbiBhIFZpZXcgY29udGV4dCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IHRoaXMud2lyZS5tZTtcblx0ICAgICAgICByZXR1cm4gdGhpcy53cmFwU3luYyh7IHV1aWQsIG5hbWUgfSk7XG5cdCAgICB9XG5cdH1cblx0RmFjdG9yeSQ2LlZpZXdNb2R1bGUgPSBWaWV3TW9kdWxlO1xuXHRyZXR1cm4gRmFjdG9yeSQ2O1xufVxuXG52YXIgSW5zdGFuY2UkNSA9IHt9O1xuXG52YXIgbGF6eSA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5sYXp5LkFzeW5jUmV0cnlhYmxlTGF6eSA9IGxhenkuTGF6eSA9IHZvaWQgMDtcbi8qKlxuICogSGFuZHkgY2xhc3MgZm9yIG1hbmFnaW5nIGFzeW5jaHJvbm91cyBkZXBlbmRlbmNpZXMgb2YgY2xhc3Nlcy5cbiAqXG4gKiBXaWxsIGNhbGwgdGhlIHByb2R1Y2VyIGZ1bmN0aW9uIG9uY2UgYW5kIG9ubHkgb25jZSB3aGVuIGdldFZhbHVlIGlzIGNhbGxlZCxcbiAqIHJldHVybmluZyB0aGUgcmVzdWx0YW50IHZhbHVlIGZvciBldmVyeSBzdWJzZXF1ZW50IGNhbGwuXG4gKi9cbmNsYXNzIExhenkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0cnVjdG9yKHByb2R1Y2VyRm4pIHtcbiAgICAgICAgdGhpcy5wcm9kdWNlckZuID0gcHJvZHVjZXJGbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6aWx5IGdldCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIHByb2R1Y2VyLlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBwcm9kdWNlciBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnByb2R1Y2VyRm4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59XG5sYXp5LkxhenkgPSBMYXp5O1xuLyoqXG4gKiBIYW5keSBjbGFzcyBmb3IgbWFuYWdpbmcgYXN5bmNocm9ub3VzIGRlcGVuZGVuY2llcyBvZiBjbGFzc2VzLlxuICpcbiAqIFdpbGwgY2FsbCBhc3luY2hyb25vdXMgcHJvZHVjZXIgb25seSBhZnRlciBgZ2V0VmFsdWVgIGlzIGNhbGxlZC4gIElmIHRoZVxuICogZGVmZXJyZWQgY29kZSBlcnJvcnMsIHdlIGNhbiB0cnkgaXQgYWdhaW4gYnkgcmUtY2FsbGluZyBgZ2V0VmFsdWVgIGFmdGVyXG4gKiB0aGUgcHJvbWlzZSByZWplY3RzLlxuICovXG5jbGFzcyBBc3luY1JldHJ5YWJsZUxhenkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0cnVjdG9yKHByb2R1Y2VyRm4pIHtcbiAgICAgICAgdGhpcy5wcm9kdWNlckZuID0gcHJvZHVjZXJGbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6aWx5IGdldCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGFzeW5jIHByb2R1Y2VyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHByb2R1Y2VyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb2R1Y2VyRm4oKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxufVxubGF6eS5Bc3luY1JldHJ5YWJsZUxhenkgPSBBc3luY1JldHJ5YWJsZUxhenk7XG5cbnZhciBsYXlvdXRFbnRpdGllcyA9IHt9O1xuXG52YXIgYXBpRXhwb3NlciQxID0ge307XG5cbnZhciBhcGlDb25zdW1lciA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpQ29uc3VtZXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXBpQ29uc3VtZXIuQXBpQ29uc3VtZXIgPSB2b2lkIDA7XG4vKipcbiAqIENvbnN1bWVyIGZvciBhcGlzIGV4cG9zZWQgd2l0aCB7QHNlZSBBcGlFeHBvc2VyfS5cbiAqXG4gKiBBIHN0cmF0ZWd5IHRoYXQgbWF0Y2hlcyB0aGUgc3RyYXRlZ3kgdXNlZCB0byBleHBvc2UgYSB0YXJnZXQgQVBJIG11c3QgYmUgcHJvdmlkZWQuXG4gKi9cbmNsYXNzIEFwaUNvbnN1bWVyIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVneSkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdW1lcyBhbiBhcGkgZXhwb3NlZCB1c2luZyBhIGdpdmVuIHRyYW5zcG9ydCBzdHJhdGVneSwgYW5kIGdlbmVyYXRlcyBhIGNsaWVudFxuICAgICAgICAgKiBmb3IgZWFzeSwgdHlwZSBzYWZlIGNvbnN1bXB0aW9uIG9mIHRoYXQgY2xpZW50LlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBTdHJhdGVneSBzcGVjaWZpYyBjb25zdW1wdGlvbiBvcHRpb25zLlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcGkgY2xpZW50IG1hdGNoaW5nIHRoZSBnaXZlbiB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25zdW1lID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9zZWRQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy5zdHJhdGVneS5nZXRFeHBvc2VkRnVuY3Rpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9zZWRQcm9wZXJ0aWVzLnJlZHVjZSgoY2xpZW50LCBwcm9wKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmNsaWVudCxcbiAgICAgICAgICAgICAgICBbcHJvcC5rZXldOiB0aGlzLnN0cmF0ZWd5LmNyZWF0ZUZ1bmN0aW9uKHByb3AsIG9wdGlvbnMpXG4gICAgICAgICAgICB9KSwge30pO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmFwaUNvbnN1bWVyLkFwaUNvbnN1bWVyID0gQXBpQ29uc3VtZXI7XG5cbnZhciBhcGlFeHBvc2VyID0ge307XG5cbnZhciBkZWNvcmF0b3JzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvcmF0b3JzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmRlY29yYXRvcnMuZXhwb3NlID0gZGVjb3JhdG9ycy5nZXRFeHBvc2VkUHJvcGVydGllcyA9IHZvaWQgMDtcbmNvbnN0IGV4cG9zZWRQcm9wZXJ0aWVzID0gU3ltYm9sKCdleHBvc2VkUHJvcGVydGllcycpO1xuY29uc3QgZ2V0RXhwb3NlZFByb3BlcnRpZXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldFtleHBvc2VkUHJvcGVydGllc10gfHwgdGFyZ2V0LnByb3RvdHlwZVtleHBvc2VkUHJvcGVydGllc10gfHwgW107XG59O1xuZGVjb3JhdG9ycy5nZXRFeHBvc2VkUHJvcGVydGllcyA9IGdldEV4cG9zZWRQcm9wZXJ0aWVzO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIGNsYXNzIG1lbWJlciBmdW5jdGlvbiBjYW4gYmUgZXhwb3NlZCB1c2luZyB7QGxpbmsgQXBpRXhwb3Nlcn0uXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHNwZWNpZmljIHRvIHRoZSBzdHJhdGVneSB1c2VkIGluIHtAbGluayBBcGlFeHBvc2VyfVxuICovXG4vLyBSZXR1cm5zIGFueSBhcyBkZWNvcmF0b3IgdHlwaW5nIGlzIHdlaXJkLlxuY29uc3QgZXhwb3NlID0gKG9wdGlvbnMpID0+ICh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikgPT4ge1xuICAgIHRhcmdldFtleHBvc2VkUHJvcGVydGllc10gPSB0YXJnZXRbZXhwb3NlZFByb3BlcnRpZXNdIHx8IFtdO1xuICAgIHRhcmdldFtleHBvc2VkUHJvcGVydGllc10ucHVzaCh7IGtleSwgZGVzY3JpcHRvciwgb3B0aW9ucyB9KTtcbn07XG5kZWNvcmF0b3JzLmV4cG9zZSA9IGV4cG9zZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUV4cG9zZXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXBpRXhwb3Nlci5BcGlFeHBvc2VyID0gdm9pZCAwO1xuY29uc3QgZGVjb3JhdG9yc18xID0gZGVjb3JhdG9ycztcbi8qKlxuICogRXhwb3NlcyBhcGkgc2VydmljZXMgb24gdGhlIHRyYW5zcG9ydCBvZiBjaG9pY2UuXG4gKi9cbmNsYXNzIEFwaUV4cG9zZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzdHJhdGVneSBUaGUgZXhwb3NlIHN0cmF0ZWd5IHRvIHVzZSB0byBleHBvc2UgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cG9zZXMgYW4gaW5zdGFuY2Ugb2YgYSBnaXZlbiBhcGkgb25cbiAgICAgICAgICogQHBhcmFtIGluc3RhbmNlIEluc3RhbmNlIG9mIGEgY2xhc3Mgd2hpY2ggaGFzIGJlZW4gZGVjb3JhdGVkIHRvIGluZGljYXRlIHdoaWNoIGZ1bmN0aW9ucyBjYW4gYmUgZXhwb3NlZC5cbiAgICAgICAgICogQHBhcmFtIGluc3RhbmNlT3B0aW9ucyBUcmFuc3BvcnQgc3RyYXRlZ3kgc3BlY2lmaWMgb3B0aW9ucyB0byB1c2Ugd2hlbiBleHBvc2luZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwb3NlSW5zdGFuY2UgPSBhc3luYyAoaW5zdGFuY2UsIGluc3RhbmNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwb3NhYmxlUHJvcHMgPSAoMCwgZGVjb3JhdG9yc18xLmdldEV4cG9zZWRQcm9wZXJ0aWVzKShpbnN0YW5jZSk7XG4gICAgICAgICAgICBjb25zdCBleHBvc2VkUHJvcHMgPSBhd2FpdCBQcm9taXNlLmFsbChleHBvc2FibGVQcm9wcy5tYXAoYXN5bmMgKHsga2V5LCBvcHRpb25zIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXN0b21Db25zdW1wdGlvbk9wdGlvbnMgPSBhd2FpdCB0aGlzLnN0cmF0ZWd5LmV4cG9zZUZ1bmN0aW9uKGluc3RhbmNlW2tleV0uYmluZChpbnN0YW5jZSksIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBpbnN0YW5jZU9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGN1c3RvbUNvbnN1bXB0aW9uT3B0aW9uc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0cmF0ZWd5LmV4cG9zZU1ldGEoaW5zdGFuY2VPcHRpb25zLCBleHBvc2VkUHJvcHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG59XG5hcGlFeHBvc2VyLkFwaUV4cG9zZXIgPSBBcGlFeHBvc2VyO1xuXG52YXIgc3RyYXRlZ2llcyA9IHt9O1xuXG52YXIgb3BlbmZpbkNoYW5uZWxzID0ge307XG5cbnZhciBjaGFubmVsc0NvbnN1bWVyID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFubmVsc0NvbnN1bWVyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNoYW5uZWxzQ29uc3VtZXIuQ2hhbm5lbHNDb25zdW1lciA9IHZvaWQgMDtcbmNsYXNzIENoYW5uZWxzQ29uc3VtZXIge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5nZXRFeHBvc2VkRnVuY3Rpb25zID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBhd2FpdCB0aGlzLmNoYW5uZWwuZGlzcGF0Y2goYGFwaS1tZXRhOiR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlRnVuY3Rpb24gPSAocHJvcCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWN0aW9uIH0gPSBwcm9wLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmRpc3BhdGNoKGFjdGlvbiwgeyBhcmdzIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG59XG5jaGFubmVsc0NvbnN1bWVyLkNoYW5uZWxzQ29uc3VtZXIgPSBDaGFubmVsc0NvbnN1bWVyO1xuXG52YXIgY2hhbm5lbHNFeHBvc2VyID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFubmVsc0V4cG9zZXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2hhbm5lbHNFeHBvc2VyLkNoYW5uZWxzRXhwb3NlciA9IHZvaWQgMDtcbmNsYXNzIENoYW5uZWxzRXhwb3NlciB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbFByb3ZpZGVyT3JDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsUHJvdmlkZXJPckNsaWVudCA9IGNoYW5uZWxQcm92aWRlck9yQ2xpZW50O1xuICAgICAgICB0aGlzLmV4cG9zZUZ1bmN0aW9uID0gYXN5bmMgKHRhcmdldCwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9ucywgbWV0YSB9ID0gY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gbWV0YTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGAke2lkfS4ke29wdGlvbnM/LmFjdGlvbiB8fCBrZXl9YDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2hhbm5lbFByb3ZpZGVyT3JDbGllbnQucmVnaXN0ZXIoYWN0aW9uLCBhc3luYyAoeyBhcmdzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBhY3Rpb24gfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvc2VNZXRhID0gYXN5bmMgKHsgaWQgfSwgcHJvcHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGBhcGktbWV0YToke2lkfWA7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoYW5uZWxQcm92aWRlck9yQ2xpZW50LnJlZ2lzdGVyKGFjdGlvbiwgKCkgPT4gKHsgcHJvcHMgfSkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmNoYW5uZWxzRXhwb3Nlci5DaGFubmVsc0V4cG9zZXIgPSBDaGFubmVsc0V4cG9zZXI7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXHR2YXIgX19jcmVhdGVCaW5kaW5nID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdCAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cdCAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuXHQgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcblx0fSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdCAgICBvW2syXSA9IG1ba107XG5cdH0pKTtcblx0dmFyIF9fZXhwb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcblx0ICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRfX2V4cG9ydFN0YXIoY2hhbm5lbHNDb25zdW1lciwgZXhwb3J0cyk7XG5cdF9fZXhwb3J0U3RhcihjaGFubmVsc0V4cG9zZXIsIGV4cG9ydHMpOyBcbn0gKG9wZW5maW5DaGFubmVscykpO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX2V4cG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X19leHBvcnRTdGFyKG9wZW5maW5DaGFubmVscywgZXhwb3J0cyk7IFxufSAoc3RyYXRlZ2llcykpO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX2V4cG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X19leHBvcnRTdGFyKGFwaUNvbnN1bWVyLCBleHBvcnRzKTtcblx0X19leHBvcnRTdGFyKGFwaUV4cG9zZXIsIGV4cG9ydHMpO1xuXHRfX2V4cG9ydFN0YXIoc3RyYXRlZ2llcywgZXhwb3J0cyk7XG5cdF9fZXhwb3J0U3RhcihkZWNvcmF0b3JzLCBleHBvcnRzKTsgXG59IChhcGlFeHBvc2VyJDEpKTtcblxudmFyIGNoYW5uZWxBcGlSZWxheSA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhbm5lbEFwaVJlbGF5LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNoYW5uZWxBcGlSZWxheS5jcmVhdGVSZWxheWVkRGlzcGF0Y2ggPSBjaGFubmVsQXBpUmVsYXkucmVsYXlDaGFubmVsQ2xpZW50QXBpID0gdm9pZCAwO1xuY29uc3QgRVhQRUNURURfRVJST1JTID0gW1xuICAgICdubyBsb25nZXIgY29ubmVjdGVkJyxcbiAgICAnUlRDRGF0YUNoYW5uZWwgY2xvc2VkIHVuZXhwZWN0ZWRseScsXG4gICAgJ1RoZSBjbGllbnQgeW91IGFyZSB0cnlpbmcgdG8gZGlzcGF0Y2ggZnJvbSBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgdGFyZ2V0IHByb3ZpZGVyJyxcbl07XG4vLyBDaGVja3MgcG9zc2libGUgZXJyb3IgbWVzc2FnZXMgdGhhdCB3ZSB3YW50IHRvIHRyYXAsIGNsaWVudCBlcnJvciBtZXNzYWdlIGNhbiBvcmlnaW5hdGVcbi8vIGZyb20gQ2hhbm5lbFByb3ZpZGVyOjpkaXNwYXRjaCBPUiBDbGFzc2ljU3RyYXRlZ3k6OmNsb3NlRW5kcG9pbnQgT1IgUlRDRW5kUG9pbnQ6OmRhdGFDaGFubmVsOjpvbmNsb3NlXG5jb25zdCBpc0Rpc2Nvbm5lY3RlZEVycm9yID0gKGVycm9yTXNnKSA9PiB7XG4gICAgcmV0dXJuIEVYUEVDVEVEX0VSUk9SUy5zb21lKGUgPT4gZXJyb3JNc2cuaW5jbHVkZXMoZSkpO1xufTtcbi8qKlxuICogQGludGVybmFsXG4gKiBDcmVhdGUgYSBjaGFubmVsIHJlbGF5IGZvciBhIGdpdmVuIGNoYW5uZWwgZXhwb3NpdGlvbiwgYWxsb3dpbmcgYSBzaW5nbGUgcHJvdmlkZXIgdG8gcm91dGVcbiAqIGFjdGlvbnMgdG8gdGhlIGRlc2lnbmF0ZWQgY2xpZW50cy5cbiAqXG4gKiBEZXNpZ25lZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggQGV4cG9zZVxuICpcbiAqIEBwYXJhbSBjaGFubmVsUHJvdmlkZXIgVGhlIGNoYW5uZWwgcHJvdmlkZXIgdG8gcmVsYXkgdGhlIGFjdGlvbnMgb24uXG4gKiBAcGFyYW0gY29uZmlnIERldGVybWluZXMgd2hpY2ggYWN0aW9ucyB0byByZWxheS4gUGxlYXNlIGVuc3VyZSBhY3Rpb24gcHJlZml4IG1hdGNoZXMgdGhlIGV4cG9zZWQgYXBpLlxuICovXG5jb25zdCByZWxheUNoYW5uZWxDbGllbnRBcGkgPSBhc3luYyAoY2hhbm5lbFByb3ZpZGVyLCByZWxheUlkKSA9PiB7XG4gICAgY2hhbm5lbFByb3ZpZGVyLnJlZ2lzdGVyKGByZWxheToke3JlbGF5SWR9YCwgKHsgYWN0aW9uLCB0YXJnZXQsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hhbm5lbFByb3ZpZGVyLmRpc3BhdGNoKHRhcmdldCwgYWN0aW9uLCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5jaGFubmVsQXBpUmVsYXkucmVsYXlDaGFubmVsQ2xpZW50QXBpID0gcmVsYXlDaGFubmVsQ2xpZW50QXBpO1xuY29uc3QgY3JlYXRlUmVsYXllZERpc3BhdGNoID0gKGNsaWVudCwgdGFyZ2V0LCByZWxheUlkLCByZWxheUVycm9yTXNnKSA9PiBhc3luYyAoYWN0aW9uLCBwYXlsb2FkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaXNwYXRjaChgcmVsYXk6JHtyZWxheUlkfWAsIHtcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc0Rpc2Nvbm5lY3RlZEVycm9yKGUubWVzc2FnZSkgJiYgcmVsYXlFcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlbGF5RXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufTtcbmNoYW5uZWxBcGlSZWxheS5jcmVhdGVSZWxheWVkRGlzcGF0Y2ggPSBjcmVhdGVSZWxheWVkRGlzcGF0Y2g7XG5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JGMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9MYXlvdXROb2RlX2NsaWVudCwgX1RhYlN0YWNrX2NsaWVudCwgX0NvbHVtbk9yUm93X2NsaWVudDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXlvdXRFbnRpdGllcywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5sYXlvdXRFbnRpdGllcy5Db2x1bW5PclJvdyA9IGxheW91dEVudGl0aWVzLlRhYlN0YWNrID0gbGF5b3V0RW50aXRpZXMuTGF5b3V0Tm9kZSA9IHZvaWQgMDtcbmNvbnN0IGFwaV9leHBvc2VyXzEgPSBhcGlFeHBvc2VyJDE7XG5jb25zdCBjaGFubmVsX2FwaV9yZWxheV8xID0gY2hhbm5lbEFwaVJlbGF5O1xuLypcbiAgICBUaGlzIGZpbGUgaW5jbHVkZXMgTGF5b3V0Tm9kZSwgQ29sdW1uT3JSb3cgYW5kIFRhYlN0YWNrIGNsYXNzZXMsIHdoaWNoIGFyZSBhbGwgY2xvc2VseVxuICAgIGludGVydHdpbmVkLCBhbmQgc2hhcmUgbWVtYmVycyB2aWEgcGFyZW50IGFic3RyYWN0IGNsYXNzIExheW91dE5vZGUuIFRvIHByZXZlbnQgY2lyY3VsYXJcbiAgICByZWZzLCB3ZSBkZWZpbmUgYW5kIGV4cG9ydCBhbGwgdGhlIGNsYXNzZXMgaGVyZS5cbiovXG4vKipcbiAqIEBpZ25vcmVcbiAqIEBpbnRlcm5hbFxuICogU3VwcGxpZXMgYW4gQXBpQ2xpZW50IGZvciB7QGxpbmsgTGF5b3V0RW50aXRpZXNDb250cm9sbGVyfSBhbmQgaGVscGVyIG1ldGhvZHNcbiAqIGZvciB0aGUgZW50aXRpZXMge0BsaW5rIFRhYlN0YWNrfSBBTkQge0BsaW5rIENvbHVtbk9yUm93fSB0byB1c2UuXG4gKi9cbmNsYXNzIExheW91dE5vZGUge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIGVudGl0eUlkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBBcGlDbGllbnQgZm9yIHtAbGluayBMYXlvdXRFbnRpdGllc0NvbnRyb2xsZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfTGF5b3V0Tm9kZV9jbGllbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIFRhYlN0YWNrIG9yIENvbHVtbk9yUm93IGlzIHRoZSByb290IGNvbnRlbnQgaXRlbVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiBpZiAoIWZpbi5tZS5pc1ZpZXcpIHtcbiAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3LicpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHN0YWNrID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiBjb25zdCBpc1Jvb3QgPSBhd2FpdCBzdGFjay5pc1Jvb3QoKTtcbiAgICAgICAgICogLy8gVGhlIFRhYlN0YWNrIGlzIHJvb3Q6IGZhbHNlXG4gICAgICAgICAqIGNvbnNvbGUubG9nKGBUaGUgVGFiU3RhY2sgaXMgcm9vdDogJHtpc1Jvb3R9YCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFJldHJpZXZlcyB0aGUgcGFyZW50IENvbHVtbk9yUm93XG4gICAgICAgICAqIGNvbnN0IHBhcmVudCA9IGF3YWl0IHN0YWNrLmdldFBhcmVudCgpO1xuICAgICAgICAgKiBjb25zdCBwYXJlbnRJc1Jvb3QgPSBhd2FpdCBwYXJlbnQuaXNSb290KCk7XG4gICAgICAgICAqIC8vIFRoZSBwYXJlbnQgQ29sdW1uT3JSb3cgaXMgcm9vdDogdHJ1ZVxuICAgICAgICAgKiBjb25zb2xlLmxvZyhgVGhlIHBhcmVudCBDb2x1bW5PclJvdyBpcyByb290OiAke3BhcmVudElzUm9vdH1gKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUm9vdCA9ICgpID0+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZSh0aGlzLCBfTGF5b3V0Tm9kZV9jbGllbnQsIFwiZlwiKS5pc1Jvb3QodGhpcy5lbnRpdHlJZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIFRhYlN0YWNrIG9yIENvbHVtbk9yUm93IGV4aXN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiBpZiAoIWZpbi5tZS5pc1ZpZXcpIHtcbiAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3LicpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHN0YWNrID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiAvLyBSZXRyaWV2ZXMgdGhlIHBhcmVudCBDb2x1bW5PclJvd1xuICAgICAgICAgKiBjb25zdCBjb2x1bW5PclJvdyA9IGF3YWl0IHN0YWNrLmdldFBhcmVudCgpO1xuICAgICAgICAgKiBsZXQgZXhpc3RzID0gYXdhaXQgc3RhY2suZXhpc3RzKCk7XG4gICAgICAgICAqIC8vIG9yXG4gICAgICAgICAqIGxldCBleGlzdHMgPSBhd2FpdCBjb2x1bW5PclJvdy5leGlzdHMoKTtcbiAgICAgICAgICogLy8gVGhlIGVudGl0eSBleGlzdHM6IHRydWVcbiAgICAgICAgICogY29uc29sZS5sb2coYFRoZSBlbnRpdHkgZXhpc3RzOiAke2V4aXN0c31gKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4aXN0cyA9ICgpID0+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZSh0aGlzLCBfTGF5b3V0Tm9kZV9jbGllbnQsIFwiZlwiKS5leGlzdHModGhpcy5lbnRpdHlJZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIHBhcmVudCBvZiB0aGUgVGFiU3RhY2sgb3IgQ29sdW1uT3JSb3dcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogaWYgKCFmaW4ubWUuaXNWaWV3KSB7XG4gICAgICAgICAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBydW5uaW5nIGluIGEgcGxhdGZvcm0gVmlldy4nKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBzdGFjayA9IGF3YWl0IGZpbi5tZS5nZXRDdXJyZW50U3RhY2soKTtcbiAgICAgICAgICogLy8gUmV0cmlldmVzIHRoZSBwYXJlbnQgQ29sdW1uT3JSb3dcbiAgICAgICAgICogY29uc3QgY29sdW1uT3JSb3cgPSBhd2FpdCBzdGFjay5nZXRQYXJlbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gdW5kZWZpbmVkIGlmIGVudGl0eSBpcyB0aGUgcm9vdCBpdGVtXG4gICAgICAgICAqIGxldCBwYXJlbnQgPSBhd2FpdCBjb2x1bW5PclJvdy5nZXRQYXJlbnQoKTtcbiAgICAgICAgICogLy8gb3JcbiAgICAgICAgICogbGV0IHBhcmVudCA9IGF3YWl0IHN0YWNrLmdldFBhcmVudCgpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFyZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRlKHRoaXMsIF9MYXlvdXROb2RlX2NsaWVudCwgXCJmXCIpLmdldFBhcmVudCh0aGlzLmVudGl0eUlkKTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBMYXlvdXROb2RlLmdldEVudGl0eShwYXJlbnQsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZSh0aGlzLCBfTGF5b3V0Tm9kZV9jbGllbnQsIFwiZlwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRhYlN0YWNrIGFkamFjZW50IHRvIHRoZSBnaXZlbiBUYWJTdGFjayBvciBDb2x1bW5PclJvdy4gSW5wdXRzIGNhbiBiZSBuZXcgdmlld3MgdG8gY3JlYXRlLCBvciBleGlzdGluZyB2aWV3cy5cbiAgICAgICAgICpcbiAgICAgICAgICogS25vd24gSXNzdWU6IElmIHRoZSBudW1iZXIgb2Ygdmlld3MgdG8gYWRkIG92ZXJmbG93cyB0aGUgdGFiLWNvbnRhaW5lciwgdGhlIGFkZGVkIHZpZXdzIHdpbGwgYmUgc2V0IGFzIGFjdGl2ZVxuICAgICAgICAgKiBkdXJpbmcgZWFjaCByZW5kZXIsIGFuZCB0aGVuIHBsYWNlZCBhdCB0aGUgZnJvbnQgb2YgdGhlIHRhYi1zdGFjaywgd2hpbGUgdGhlIHVuZGVybHlpbmcgb3JkZXIgb2YgdGFicyB3aWxsIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgICAgICAqIFRoaXMgbWVhbnMgdGhlIHZpZXdzIHlvdSBwYXNzIHRvIGNyZWF0ZUFkamFjZW50U3RhY2soKSBtYXkgbm90IHJlbmRlciBpbiB0aGUgb3JkZXIgZ2l2ZW4gYnkgdGhlIGFycmF5LlxuICAgICAgICAgKiBVbnRpbCBmaXhlZCwgdGhpcyBwcm9ibGVtIGNhbiBiZSBhdm9pZGVkIG9ubHkgaWYgeW91ciB3aW5kb3cgaXMgd2lkZSBlbm91Z2ggdG8gZml0IGNyZWF0aW5nIGFsbCB0aGUgdmlld3MgaW4gdGhlIHRhYnN0YWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlld3MgVGhlIHZpZXdzIHRoYXQgd2lsbCBwb3B1bGF0ZSB0aGUgbmV3IFRhYlN0YWNrLlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdGhhdCBjb250cm9sIG5ldyBUYWJTdGFjayBjcmVhdGlvbi5cbiAgICAgICAgICogQHJldHVybnMgVGhlIG5ld2x5LWNyZWF0ZWQgVGFiU3RhY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIGlmICghZmluLm1lLmlzVmlldykge1xuICAgICAgICAgKiAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgcnVubmluZyBpbiBhIHBsYXRmb3JtIFZpZXcuJyk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3Qgc3RhY2sgPSBhd2FpdCBmaW4ubWUuZ2V0Q3VycmVudFN0YWNrKCk7XG4gICAgICAgICAqIGNvbnN0IGNvbHVtbk9yUm93ID0gYXdhaXQgc3RhY2suZ2V0UGFyZW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSB2aWV3IHJlZmVyZW5jZXMgYnkgc3VwcGx5aW5nIGEgJ25hbWUnIGFuZCAndXJsJ1xuICAgICAgICAgKiBjb25zdCB2aWV3cyA9IFtcbiAgICAgICAgICogICAgIC8vIGlmICduYW1lJyBpcyB1bmRlZmluZWQsIG9uZSB3aWxsIGJlIGdlbmVyYXRlZFxuICAgICAgICAgKiAgICAgLy8gaWYgJ3VybCcgaXMgdW5kZWZpbmVkLCBpdCB3aWxsIGRlZmF1bHQgdGhlIHZpZXcgVVJMIHRvICdhYm91dDpibGFuaydcbiAgICAgICAgICogICAgIHsgbmFtZTogJ2dvb2dsZS12aWV3JywgdXJsOiAnaHR0cDovL2dvb2dsZS5jb20vJ30sXG4gICAgICAgICAqICAgICB7IG5hbWU6ICdvZi1kZXZlbG9wZXJzLXZpZXcnLCB1cmw6ICdodHRwOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvLyd9LFxuICAgICAgICAgKiBdO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBDcmVhdGUgYSB2aWV3IGJlZm9yZWhhbmQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyB0YWIgc3RhY2tcbiAgICAgICAgICogY29uc3Qgb3V0c2lkZVZpZXcgPSBhd2FpdCBmaW4uVmlldy5jcmVhdGUoe1xuICAgICAgICAgKiAgICAgbmFtZTogJ291dHNpZGUtYmxvb21iZXJnLXZpZXcnLFxuICAgICAgICAgKiAgICAgdXJsOiAnaHR0cHM6Ly9ibG9vbWJlcmcuY29tLycsXG4gICAgICAgICAqICAgICB0YXJnZXQ6IGZpbi5tZS5pZGVudGl0eSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFZpZXdzIHRvIGFkZCBjYW4gYmUgaWRlbnRpdGllcywgb3IgdGhlIHJlZmVyZW5jZSB2aWV3cyBtZW50aW9uZWQgYWJvdmVcbiAgICAgICAgICogY29uc3Qgdmlld3NUb0FkZCA9IFtvdXRzaWRlVmlldy5pZGVudGl0eSwgLi4udmlld3NdO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBQb3NzaWJsZSBwb3NpdGlvbiBpbnB1dHM6ICdyaWdodCcgfCAnbGVmdCcgfCAndG9wJyB8ICdib3R0b20nXG4gICAgICAgICAqIGxldCBzdGFja0Zyb20gPSBhd2FpdCBjb2x1bW5PclJvdy5jcmVhdGVBZGphY2VudFN0YWNrKHZpZXdzVG9BZGQsIHsgcG9zaXRpb246ICdyaWdodCcgfSk7XG4gICAgICAgICAqIC8vIE9yXG4gICAgICAgICAqIGxldCBuZXdTdGFjayA9IGF3YWl0IHN0YWNrLmNyZWF0ZUFkamFjZW50U3RhY2sodmlld3NUb0FkZCwgeyBwb3NpdGlvbjogJ3JpZ2h0JyB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2coYEEgbmV3IFRhYlN0YWNrIGNyZWF0ZWQgdG8gdGhlIHJpZ2h0IGhhcyAke25ld1N0YWNrLmxlbmd0aH0gdmlld3MgaW4gaXRgKTtcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlQWRqYWNlbnRTdGFjayA9IGFzeW5jICh2aWV3cywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50aXR5SWQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGUodGhpcywgX0xheW91dE5vZGVfY2xpZW50LCBcImZcIikuY3JlYXRlQWRqYWNlbnRTdGFjayh0aGlzLmVudGl0eUlkLCB2aWV3cywgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gTGF5b3V0Tm9kZS5nZXRFbnRpdHkoeyBlbnRpdHlJZCwgdHlwZTogJ3N0YWNrJyB9LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGUodGhpcywgX0xheW91dE5vZGVfY2xpZW50LCBcImZcIikpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBhZGphY2VudCBUYWJTdGFja3Mgb2YgdGhlIGdpdmVuIFRhYlN0YWNrIG9yIENvbHVtbk9yUm93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWRnZSBFZGdlIHdob3NlIGFkamFjZW50IFRhYlN0YWNrcyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiBpZiAoIWZpbi5tZS5pc1ZpZXcpIHtcbiAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3LicpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHN0YWNrID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiBjb25zdCBjb2x1bW5PclJvdyA9IGF3YWl0IHN0YWNrLmdldFBhcmVudCgpO1xuICAgICAgICAgKiAvLyBQb3NzaWJsZSBwb3NpdGlvbiBpbnB1dHM6ICdyaWdodCcgfCAnbGVmdCcgfCAndG9wJyB8ICdib3R0b20nXG4gICAgICAgICAqIGxldCByaWdodFN0YWNrcyA9IGF3YWl0IGNvbHVtbk9yUm93LmdldEFkamFjZW50U3RhY2tzKCdyaWdodCcpO1xuICAgICAgICAgKiBsZXQgbGVmdFN0YWNrcyA9IGF3YWl0IGNvbHVtbk9yUm93LmdldEFkamFjZW50U3RhY2tzKCdsZWZ0Jyk7XG4gICAgICAgICAqIC8vIG9yXG4gICAgICAgICAqIGxldCByaWdodFN0YWNrcyA9IGF3YWl0IHN0YWNrLmdldEFkamFjZW50U3RhY2tzKCdyaWdodCcpO1xuICAgICAgICAgKiBsZXQgbGVmdFN0YWNrcyA9IGF3YWl0IHN0YWNrLmdldEFkamFjZW50U3RhY2tzKCdsZWZ0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKGBUaGUgZW50aXR5IGhhcyAke3JpZ2h0U3RhY2tzLmxlbmd0aH0gc3RhY2tzIHRvIHRoZSByaWdodCwgYW5kICR7bGVmdFN0YWNrcy5sZW5ndGh9IHN0YWNrcyB0byB0aGUgbGVmdGApO1xuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRBZGphY2VudFN0YWNrcyA9IGFzeW5jIChlZGdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGphY2VudFN0YWNrcyA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZSh0aGlzLCBfTGF5b3V0Tm9kZV9jbGllbnQsIFwiZlwiKS5nZXRBZGphY2VudFN0YWNrcyh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHRoaXMuZW50aXR5SWQsXG4gICAgICAgICAgICAgICAgZWRnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWRqYWNlbnRTdGFja3MubWFwKChzdGFjaykgPT4gTGF5b3V0Tm9kZS5nZXRFbnRpdHkoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdGFjaycsXG4gICAgICAgICAgICAgICAgZW50aXR5SWQ6IHN0YWNrLmVudGl0eUlkXG4gICAgICAgICAgICB9LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGUodGhpcywgX0xheW91dE5vZGVfY2xpZW50LCBcImZcIikpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCRjKHRoaXMsIF9MYXlvdXROb2RlX2NsaWVudCwgY2xpZW50LCBcImZcIik7XG4gICAgICAgIHRoaXMuZW50aXR5SWQgPSBlbnRpdHlJZDtcbiAgICB9XG59XG5sYXlvdXRFbnRpdGllcy5MYXlvdXROb2RlID0gTGF5b3V0Tm9kZTtcbl9MYXlvdXROb2RlX2NsaWVudCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEBpZ25vcmVcbiAqIEBpbnRlcm5hbFxuICogRW5jYXBzdWxhdGVzIEFwaSBjb25zdW1wdGlvbiBvZiB7QGxpbmsgTGF5b3V0RW50aXRpZXNDbGllbnR9IHdpdGggYSByZWxheWVkIGRpc3BhdGNoXG4gKiBAcGFyYW0gY2xpZW50XG4gKiBAcGFyYW0gY29udHJvbGxlcklkXG4gKiBAcGFyYW0gaWRlbnRpdHlcbiAqIEByZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBMYXlvdXRFbnRpdGllc0NsaWVudH0gd2l0aCBib3VuZCB0byB0aGUgY29udHJvbGxlcklkXG4gKi9cbkxheW91dE5vZGUubmV3TGF5b3V0RW50aXRpZXNDbGllbnQgPSBhc3luYyAoY2xpZW50LCBjb250cm9sbGVySWQsIGlkZW50aXR5KSA9PiB7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoMCwgY2hhbm5lbF9hcGlfcmVsYXlfMS5jcmVhdGVSZWxheWVkRGlzcGF0Y2gpKGNsaWVudCwgaWRlbnRpdHksICdsYXlvdXQtcmVsYXknLCAnWW91IGFyZSB0cnlpbmcgdG8gaW50ZXJhY3Qgd2l0aCBhIGxheW91dCBjb21wb25lbnQgb24gYSB3aW5kb3cgdGhhdCBkb2VzIG5vdCBleGlzdCBvciBoYXMgYmVlbiBkZXN0cm95ZWQuJyk7XG4gICAgY29uc3QgY29uc3VtZXIgPSBuZXcgYXBpX2V4cG9zZXJfMS5BcGlDb25zdW1lcihuZXcgYXBpX2V4cG9zZXJfMS5DaGFubmVsc0NvbnN1bWVyKHsgZGlzcGF0Y2ggfSkpO1xuICAgIHJldHVybiBjb25zdW1lci5jb25zdW1lKHsgaWQ6IGNvbnRyb2xsZXJJZCB9KTtcbn07XG5MYXlvdXROb2RlLmdldEVudGl0eSA9IChkZWZpbml0aW9uLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCB7IGVudGl0eUlkLCB0eXBlIH0gPSBkZWZpbml0aW9uO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICBjYXNlICdyb3cnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2x1bW5PclJvdyhjbGllbnQsIGVudGl0eUlkLCB0eXBlKTtcbiAgICAgICAgY2FzZSAnc3RhY2snOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJTdGFjayhjbGllbnQsIGVudGl0eUlkKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pc2VkIExheW91dCBFbnRpdHkgZW5jb3VudGVyZWQgKCcke0pTT04uc3RyaW5naWZ5KGRlZmluaXRpb24pfSlgKTtcbiAgICB9XG59O1xuLyoqXG4gKiBBIFRhYlN0YWNrIGlzIHVzZWQgdG8gbWFuYWdlIHRoZSBzdGF0ZSBvZiBhIHN0YWNrIG9mIHRhYnMgd2l0aGluIGFuIE9wZW5GaW4gTGF5b3V0LlxuICovXG5jbGFzcyBUYWJTdGFjayBleHRlbmRzIExheW91dE5vZGUge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIGVudGl0eUlkKSB7XG4gICAgICAgIHN1cGVyKGNsaWVudCwgZW50aXR5SWQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEFwaUNsaWVudCBmb3Ige0BsaW5rIExheW91dEVudGl0aWVzQ29udHJvbGxlcn1cbiAgICAgICAgICovXG4gICAgICAgIF9UYWJTdGFja19jbGllbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlIG9mIHRoZSBjb250ZW50IGl0ZW0uIEFsd2F5cyBzdGFjaywgYnV0IHVzZWZ1bCBmb3IgZGlzdGluZ3Vpc2hpbmcgYmV0d2VlbiBhIHtAbGluayBUYWJTdGFja30gYW5kIHtAbGluayBDb2x1bW5PclJvd30uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhY2snO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgdmlld3MgYmVsb25naW5nIHRvIHRoaXMge0BsaW5rIFRhYlN0YWNrfS5cbiAgICAgICAgICpcbiAgICAgICAgICogS25vd24gSXNzdWU6IElmIGFkZGluZyBhIHZpZXcgb3ZlcmZsb3dzIHRoZSB0YWItY29udGFpbmVyIHdpZHRoLCB0aGUgYWRkZWQgdmlldyB3aWxsIGJlIHNldCBhcyBhY3RpdmVcbiAgICAgICAgICogYW5kIHJlbmRlcmVkIGF0IHRoZSBmcm9udCBvZiB0aGUgdGFiLXN0YWNrLCB3aGlsZSB0aGUgdW5kZXJseWluZyBvcmRlciBvZiB0YWJzIHdpbGwgcmVtYWluIHVuY2hhbmdlZC5cbiAgICAgICAgICogSWYgdGhhdCBoYXBwZW5zIGFuZCB0aGVuIGdldFZpZXdzKCkgaXMgY2FsbGVkLCBpdCB3aWxsIHJldHVybiB0aGUgaWRlbnRpdGllcyBpbiBhIGRpZmZlcmVudCBvcmRlciB0aGFuXG4gICAgICAgICAqIHRoYW4gdGhlIGN1cnJlbnRseSByZW5kZXJlZCB0YWIgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgSWYgdGhlIHtAbGluayBUYWJTdGFja30gaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiBpZiAoIWZpbi5tZS5pc1ZpZXcpIHtcbiAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3LicpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHN0YWNrID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiAvLyBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHdyYXAgYW55IHZpZXcgYW5kIGdldCB0aGUgc3RhY2sgZnJvbSB0aGVyZVxuICAgICAgICAgKiAvLyBjb25zdCB2aWV3RnJvbVNvbWV3aGVyZSA9IGZpbi5WaWV3LndyYXBTeW5jKHNvbWVWaWV3LmlkZW50aXR5KTtcbiAgICAgICAgICogLy8gY29uc3Qgc3RhY2sgPSBhd2FpdCB2aWV3RnJvbVNvbWV3aGVyZS5nZXRDdXJyZW50U3RhY2soKTtcbiAgICAgICAgICogY29uc3Qgdmlld3MgPSBhd2FpdCBzdGFjay5nZXRWaWV3cygpO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhgU3RhY2sgY29udGFpbnMgJHt2aWV3cy5sZW5ndGh9IHZpZXcocylgKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Vmlld3MgPSAoKSA9PiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGUodGhpcywgX1RhYlN0YWNrX2NsaWVudCwgXCJmXCIpLmdldFN0YWNrVmlld3ModGhpcy5lbnRpdHlJZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIG9yIGNyZWF0ZXMgYSB2aWV3IGluIHRoaXMge0BsaW5rIFRhYlN0YWNrfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlbWFya3MgS25vd24gSXNzdWU6IElmIGFkZGluZyBhIHZpZXcgb3ZlcmZsb3dzIHRoZSB0YWItY29udGFpbmVyLCB0aGUgYWRkZWQgdmlldyB3aWxsIGJlIHNldCBhcyBhY3RpdmVcbiAgICAgICAgICogYW5kIHJlbmRlcmVkIGF0IHRoZSBmcm9udCBvZiB0aGUgdGFiLXN0YWNrLCB3aGlsZSB0aGUgdW5kZXJseWluZyBvcmRlciBvZiB0YWJzIHdpbGwgcmVtYWluIHVuY2hhbmdlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZXcgVGhlIGlkZW50aXR5IG9mIGFuIGV4aXN0aW5nIHZpZXcgdG8gYWRkLCBvciBvcHRpb25zIHRvIGNyZWF0ZSBhIHZpZXcuXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHZpZXcgb3B0aW9uczogaW5kZXggbnVtYmVyIHVzZWQgdG8gaW5zZXJ0IHRoZSB2aWV3IGludG8gdGhlIHN0YWNrIGF0IHRoYXQgaW5kZXguIERlZmF1bHRzIHRvIDAgKGZyb250IG9mIHRoZSBzdGFjaylcbiAgICAgICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2l0aCB0aGUge0BsaW5rIE9wZW5GaW4uSWRlbnRpdHkgaWRlbnRpdHl9IG9mIHRoZSBhZGRlZCB2aWV3LlxuICAgICAgICAgKiBAdGhyb3dzIElmIHRoZSB2aWV3IGRvZXMgbm90IGV4aXN0IG9yIGZhaWxzIHRvIGNyZWF0ZS5cbiAgICAgICAgICogQHRocm93cyBJZiB0aGUge0BsaW5rIFRhYlN0YWNrfSBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIGlmICghZmluLm1lLmlzVmlldykge1xuICAgICAgICAgKiAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgcnVubmluZyBpbiBhIHBsYXRmb3JtIFZpZXcuJyk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3Qgc3RhY2sgPSBhd2FpdCBmaW4ubWUuZ2V0Q3VycmVudFN0YWNrKCk7XG4gICAgICAgICAqIC8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gd3JhcCBhbnkgdmlldyBhbmQgZ2V0IHRoZSBzdGFjayBmcm9tIHRoZXJlXG4gICAgICAgICAqIC8vIGNvbnN0IHZpZXdGcm9tU29tZXdoZXJlID0gZmluLlZpZXcud3JhcFN5bmMoc29tZVZpZXcuaWRlbnRpdHkpO1xuICAgICAgICAgKiAvLyBjb25zdCBzdGFjayA9IGF3YWl0IHZpZXdGcm9tU29tZXdoZXJlLmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiBjb25zdCBnb29nbGVWaWV3SWRlbnRpdHkgPSBhd2FpdCBzdGFjay5hZGRWaWV3KHsgbmFtZTogJ2dvb2dsZS12aWV3JywgdXJsOiAnaHR0cDovL2dvb2dsZS5jb20vJyB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2coJ0lkZW50aXR5IG9mIHRoZSBnb29nbGUgdmlldyBqdXN0IGFkZGVkJywgeyBnb29nbGVWaWV3SWRlbnRpdHkgfSk7XG4gICAgICAgICAqIC8vIHBhc3MgaW4geyBpbmRleDogbnVtYmVyIH0gdG8gc2V0IHRoZSBpbmRleCBpbiB0aGUgc3RhY2suIEhlcmUgMSBtZWFucywgZW5kIG9mIHRoZSBzdGFjayAoZGVmYXVsdHMgdG8gMClcbiAgICAgICAgICogY29uc3QgYXBwbGVWaWV3SWRlbnRpdHkgPSBhd2FpdCBzdGFjay5hZGRWaWV3KHsgbmFtZTogJ2FwcGxlLXZpZXcnLCB1cmw6ICdodHRwOi8vYXBwbGUuY29tLycgfSwgeyBpbmRleDogMSB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2coJ0lkZW50aXR5IG9mIHRoZSBhcHBsZSB2aWV3IGp1c3QgYWRkZWQnLCB7IGFwcGxlVmlld0lkZW50aXR5IH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGRWaWV3ID0gYXN5bmMgKHZpZXcsIG9wdGlvbnMgPSB7IGluZGV4OiAwIH0pID0+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZSh0aGlzLCBfVGFiU3RhY2tfY2xpZW50LCBcImZcIikuYWRkVmlld1RvU3RhY2sodGhpcy5lbnRpdHlJZCwgdmlldywgb3B0aW9ucyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgdmlldyBmcm9tIHRoaXMge0BsaW5rIFRhYlN0YWNrfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlbWFya3MgVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgdmlldyBpZGVudGl0eSBkb2VzIG5vdCBleGlzdCBvciB3YXMgYWxyZWFkeSBkZXN0cm95ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWV3IC0gSWRlbnRpdHkgb2YgdGhlIHZpZXcgdG8gcmVtb3ZlLlxuICAgICAgICAgKiBAdGhyb3dzIElmIHRoZSB2aWV3IGRvZXMgbm90IGV4aXN0IG9yIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgc3RhY2suXG4gICAgICAgICAqIEB0aHJvd3MgSWYgdGhlIHtAbGluayBUYWJTdGFja30gaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiBpZiAoIWZpbi5tZS5pc1ZpZXcpIHtcbiAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3LicpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHN0YWNrID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiBjb25zdCBnb29nbGVWaWV3SWRlbnRpdHkgPSBhd2FpdCBzdGFjay5hZGRWaWV3KHsgbmFtZTogJ2dvb2dsZS12aWV3JywgdXJsOiAnaHR0cDovL2dvb2dsZS5jb20vJyB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogYXdhaXQgc3RhY2sucmVtb3ZlVmlldyhnb29nbGVWaWV3SWRlbnRpdHkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiB0cnkge1xuICAgICAgICAgKiAgICAgYXdhaXQgc3RhY2sucmVtb3ZlVmlldyhnb29nbGVWaWV3SWRlbnRpdHkpO1xuICAgICAgICAgKiB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgKiAgICAgLy8gVHJpZWQgdG8gcmVtb3ZlIGEgdmlldyAoJ2dvb2dsZS12aWV3Jykgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoZSBzdGFjay5cbiAgICAgICAgICogICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlVmlldyA9IGFzeW5jICh2aWV3KSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGUodGhpcywgX1RhYlN0YWNrX2NsaWVudCwgXCJmXCIpLnJlbW92ZVZpZXdGcm9tU3RhY2sodGhpcy5lbnRpdHlJZCwgdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBhY3RpdmUgdmlldyBvZiB0aGUge0BsaW5rIFRhYlN0YWNrfSB3aXRob3V0IGZvY3VzaW5nIGl0LlxuICAgICAgICAgKiBAcGFyYW0gdmlldyAtIElkZW50aXR5IG9mIHRoZSB2aWV3IHRvIGFjdGl2YXRlLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggdm9pZCBvbmNlIHRoZSB2aWV3IGhhcyBiZWVuIGFjdGl2YXRlZC5cbiAgICAgICAgICogQHRocm93cyBJZiB0aGUge0BsaW5rIFRhYlN0YWNrfSBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAqIEB0aHJvd3MgSWYgdGhlIHZpZXcgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIENoYW5nZSB0aGUgYWN0aXZlIHRhYiBvZiBhIGtub3duIFZpZXcncyBUYWJTdGFjazpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogY29uc3QgdGFyZ2V0VmlldyA9IGZpbi5WaWV3LndyYXBTeW5jKHsgdXVpZDogJ3V1aWQnLCBuYW1lOiAndmlldy1uYW1lJyB9KTtcbiAgICAgICAgICogY29uc3Qgc3RhY2sgPSBhd2FpdCB0YXJnZXRWaWV3LmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiBhd2FpdCBzdGFjay5zZXRBY3RpdmVWaWV3KHRhcmdldFZpZXcuaWRlbnRpdHkpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogU2V0IHRoZSBjdXJyZW50IFZpZXcgYXMgYWN0aXZlIHdpdGhpbiBpdHMgVGFiU3RhY2s6XG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIGNvbnN0IHN0YWNrID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRTdGFjaygpO1xuICAgICAgICAgKiBhd2FpdCBzdGFjay5zZXRBY3RpdmVWaWV3KGZpbi5tZS5pZGVudGl0eSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldEFjdGl2ZVZpZXcgPSBhc3luYyAodmlldykgPT4ge1xuICAgICAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRlKHRoaXMsIF9UYWJTdGFja19jbGllbnQsIFwiZlwiKS5zZXRTdGFja0FjdGl2ZVZpZXcodGhpcy5lbnRpdHlJZCwgdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkYyh0aGlzLCBfVGFiU3RhY2tfY2xpZW50LCBjbGllbnQsIFwiZlwiKTtcbiAgICB9XG59XG5sYXlvdXRFbnRpdGllcy5UYWJTdGFjayA9IFRhYlN0YWNrO1xuX1RhYlN0YWNrX2NsaWVudCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEEgQ29sdW1uT3JSb3cgaXMgdXNlZCB0byBtYW5hZ2UgdGhlIHN0YXRlIG9mIENvbHVtbiBhbmQgUm93cyB3aXRoaW4gYW4gT3BlbkZpbiBMYXlvdXQuXG4gKi9cbmNsYXNzIENvbHVtbk9yUm93IGV4dGVuZHMgTGF5b3V0Tm9kZSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBlbnRpdHlJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihjbGllbnQsIGVudGl0eUlkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEFwaUNsaWVudCBmb3Ige0BsaW5rIExheW91dEVudGl0aWVzQ29udHJvbGxlcn1cbiAgICAgICAgICovXG4gICAgICAgIF9Db2x1bW5PclJvd19jbGllbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbnRlbnQgYXJyYXkgb2YgdGhlIENvbHVtbk9yUm93XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIGlmICghZmluLm1lLmlzVmlldykge1xuICAgICAgICAgKiAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgcnVubmluZyBpbiBhIHBsYXRmb3JtIFZpZXcuJyk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3Qgc3RhY2sgPSBhd2FpdCBmaW4ubWUuZ2V0Q3VycmVudFN0YWNrKCk7XG4gICAgICAgICAqIC8vIFJldHJpZXZlcyB0aGUgcGFyZW50IENvbHVtbk9yUm93XG4gICAgICAgICAqIGNvbnN0IGNvbHVtbk9yUm93ID0gYXdhaXQgc3RhY2suZ2V0UGFyZW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHJldHVybnMgW1RhYlN0YWNrXVxuICAgICAgICAgKiBjb25zdCBjb250ZW50QXJyYXkgPSBhd2FpdCBjb2x1bW5PclJvdy5nZXRDb250ZW50KCk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKGBUaGUgQ29sdW1uT3JSb3cgaGFzICR7Y29udGVudEFycmF5Lmxlbmd0aH0gaXRlbShzKWApO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q29udGVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRJdGVtRW50aXRpZXMgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGUodGhpcywgX0NvbHVtbk9yUm93X2NsaWVudCwgXCJmXCIpLmdldENvbnRlbnQodGhpcy5lbnRpdHlJZCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudEl0ZW1FbnRpdGllcy5tYXAoKGVudGl0eSkgPT4gTGF5b3V0Tm9kZS5nZXRFbnRpdHkoZW50aXR5LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGUodGhpcywgX0NvbHVtbk9yUm93X2NsaWVudCwgXCJmXCIpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkYyh0aGlzLCBfQ29sdW1uT3JSb3dfY2xpZW50LCBjbGllbnQsIFwiZlwiKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG5sYXlvdXRFbnRpdGllcy5Db2x1bW5PclJvdyA9IENvbHVtbk9yUm93O1xuX0NvbHVtbk9yUm93X2NsaWVudCA9IG5ldyBXZWFrTWFwKCk7XG5cbnZhciBsYXlvdXRfY29uc3RhbnRzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXlvdXRfY29uc3RhbnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmxheW91dF9jb25zdGFudHMuREVGQVVMVF9MQVlPVVRfS0VZID0gbGF5b3V0X2NvbnN0YW50cy5MQVlPVVRfQ09OVFJPTExFUl9JRCA9IHZvaWQgMDtcbmxheW91dF9jb25zdGFudHMuTEFZT1VUX0NPTlRST0xMRVJfSUQgPSAnbGF5b3V0LWVudGl0aWVzJztcbi8vIFRPRE86IGV2ZW50dWFsbHkgZXhwb3J0IHRoaXMgc29tZWhvd1xubGF5b3V0X2NvbnN0YW50cy5ERUZBVUxUX0xBWU9VVF9LRVkgPSAnX19kZWZhdWx0X18nO1xuXG52YXIgbWFpbiA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobWFpbiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5tYWluLldlYkNvbnRlbnRzID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xJGsgPSBiYXNlO1xuY2xhc3MgV2ViQ29udGVudHMgZXh0ZW5kcyBiYXNlXzEkay5FbWl0dGVyQmFzZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGlkZW50aXR5IFRoZSBpZGVudGl0eSBvZiB0aGUge0BsaW5rIE9wZW5GaW4uV2ViQ29udGVudHNFdmVudHMgV2ViQ29udGVudHN9LlxuICAgICAqIEBwYXJhbSBlbnRpdHlUeXBlIFRoZSB0eXBlIG9mIHRoZSB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBXZWJDb250ZW50c30uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod2lyZSwgaWRlbnRpdHksIGVudGl0eVR5cGUpIHtcbiAgICAgICAgc3VwZXIod2lyZSwgZW50aXR5VHlwZSwgaWRlbnRpdHkudXVpZCwgaWRlbnRpdHkubmFtZSk7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgdGhpcy5lbnRpdHlUeXBlID0gZW50aXR5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJhc2U2NCBlbmNvZGVkIGltYWdlIG9mIGFsbCBvciBwYXJ0IG9mIHRoZSBXZWJDb250ZW50cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgY2FwdHVyZVBhZ2UgY2FsbC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBWaWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgdmlldyA9IGZpbi5WaWV3LmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICpcbiAgICAgKiAvLyBQTkcgaW1hZ2Ugb2YgYSBmdWxsIHZpc2libGUgVmlld1xuICAgICAqIGNvbnNvbGUubG9nKGF3YWl0IHZpZXcuY2FwdHVyZVBhZ2UoKSk7XG4gICAgICpcbiAgICAgKiAvLyBMb3ctcXVhbGl0eSBKUEVHIGltYWdlIG9mIGEgZGVmaW5lZCB2aXNpYmxlIGFyZWEgb2YgdGhlIHZpZXdcbiAgICAgKiBjb25zdCBvcHRpb25zID0ge1xuICAgICAqICAgICBhcmVhOiB7XG4gICAgICogICAgICAgICBoZWlnaHQ6IDEwMCxcbiAgICAgKiAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICogICAgICAgICB4OiAxMCxcbiAgICAgKiAgICAgICAgIHk6IDEwLFxuICAgICAqICAgICB9LFxuICAgICAqICAgICBmb3JtYXQ6ICdqcGcnLFxuICAgICAqICAgICBxdWFsaXR5OiAyMFxuICAgICAqIH1cbiAgICAgKiBjb25zb2xlLmxvZyhhd2FpdCB2aWV3LmNhcHR1cmVQYWdlKG9wdGlvbnMpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdpbmRvdzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHduZCA9IGF3YWl0IGZpbi5XaW5kb3cuZ2V0Q3VycmVudCgpO1xuICAgICAqXG4gICAgICogLy8gUE5HIGltYWdlIG9mIGEgZnVsbCB2aXNpYmxlIHdpbmRvd1xuICAgICAqIGNvbnNvbGUubG9nKGF3YWl0IHduZC5jYXB0dXJlUGFnZSgpKTtcbiAgICAgKlxuICAgICAqIC8vIExvdy1xdWFsaXR5IEpQRUcgaW1hZ2Ugb2YgYSBkZWZpbmVkIHZpc2libGUgYXJlYSBvZiB0aGUgd2luZG93XG4gICAgICogY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgYXJlYToge1xuICAgICAqICAgICAgICAgaGVpZ2h0OiAxMDAsXG4gICAgICogICAgICAgICB3aWR0aDogMTAwLFxuICAgICAqICAgICAgICAgeDogMTAsXG4gICAgICogICAgICAgICB5OiAxMCxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZm9ybWF0OiAnanBnJyxcbiAgICAgKiAgICAgcXVhbGl0eTogMjBcbiAgICAgKiB9XG4gICAgICogY29uc29sZS5sb2coYXdhaXQgd25kLmNhcHR1cmVQYWdlKG9wdGlvbnMpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogYFdlYkNvbnRlbnRzYCByZWZlcnMgdG8gc2hhcmVkIGZ1bmN0aW9uYWxpdHkgYmV0d2VlbiB7QGxpbmsgT3BlbkZpbi5XaW5kb3d9IGFuZCB7QGxpbmsgT3BlbkZpbi5WaWV3fS5cbiAgICAgKiBXZSBkbyBub3QgZXhwb3NlIGFuIGV4cGxpY2l0IHN1cGVyY2xhc3MgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSwgYnV0IGl0IGRvZXMgaGF2ZSBpdHMgb3duXG4gICAgICoge0BsaW5rIE9wZW5GaW4uV2ViQ29udGVudHNFdmVudHMgZXZlbnQgbmFtZXNwYWNlfS5cbiAgICAgKi9cbiAgICBjYXB0dXJlUGFnZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignY2FwdHVyZS1wYWdlJywgeyBvcHRpb25zLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBKYXZhc2NyaXB0IG9uIHRoZSBXZWJDb250ZW50cywgcmVzdHJpY3RlZCB0byBjb250ZW50cyB5b3Ugb3duIG9yIGNvbnRlbnRzIG93bmVkIGJ5XG4gICAgICogYXBwbGljYXRpb25zIHlvdSBoYXZlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIGNvZGUgSmF2YVNjcmlwdCBjb2RlIHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSB2aWV3LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBWaWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUphdmFTY3JpcHQoY29kZSkge1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcud3JhcCh7dXVpZDogJ3V1aWQnLCBuYW1lOiAndmlldyBuYW1lJ30pO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgdmlldy5leGVjdXRlSmF2YVNjcmlwdChjb2RlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBleGVjdXRlSmF2YVNjcmlwdChgY29uc29sZS5sb2coJ0hlbGxvLCBPcGVuZmluJylgKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdKYXZhc2NyaXB0IGV4Y3V0ZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2luZG93OlxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUphdmFTY3JpcHQoY29kZSkge1xuICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcbiAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG4gICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmV4ZWN1dGVKYXZhU2NyaXB0Lmh0bWwnLFxuICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcbiAgICAgKiAgICAgfSk7XG4gICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5leGVjdXRlSmF2YVNjcmlwdChjb2RlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBleGVjdXRlSmF2YVNjcmlwdChgY29uc29sZS5sb2coJ0hlbGxvLCBPcGVuZmluJylgKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdKYXZhc2NyaXB0IGV4Y3V0ZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqIEByZW1hcmtzXG4gICAgICogYFdlYkNvbnRlbnRzYCByZWZlcnMgdG8gc2hhcmVkIGZ1bmN0aW9uYWxpdHkgYmV0d2VlbiB7QGxpbmsgT3BlbkZpbi5XaW5kb3d9IGFuZCB7QGxpbmsgT3BlbkZpbi5WaWV3fS5cbiAgICAgKiBXZSBkbyBub3QgZXhwb3NlIGFuIGV4cGxpY2l0IHN1cGVyY2xhc3MgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSwgYnV0IGl0IGRvZXMgaGF2ZSBpdHMgb3duXG4gICAgICoge0BsaW5rIE9wZW5GaW4uV2ViQ29udGVudHNFdmVudHMgZXZlbnQgbmFtZXNwYWNlfS5cbiAgICAgKi9cbiAgICBleGVjdXRlSmF2YVNjcmlwdChjb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdleGVjdXRlLWphdmFzY3JpcHQtaW4td2luZG93JywgeyAuLi50aGlzLmlkZW50aXR5LCBjb2RlIH0pXG4gICAgICAgICAgICAudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIFdlYkNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBWaWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0Wm9vbUxldmVsKCkge1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuZ2V0Q3VycmVudCgpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgdmlldy5nZXRab29tTGV2ZWwoKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBnZXRab29tTGV2ZWwoKS50aGVuKHpvb21MZXZlbCA9PiBjb25zb2xlLmxvZyh6b29tTGV2ZWwpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVXaW4oKSB7XG4gICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG4gICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcbiAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuZ2V0Wm9vbUxldmVsLmh0bWwnLFxuICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcbiAgICAgKiAgICAgfSk7XG4gICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0Wm9vbUxldmVsKCkge1xuICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBjcmVhdGVXaW4oKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5nZXRab29tTGV2ZWwoKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBnZXRab29tTGV2ZWwoKS50aGVuKHpvb21MZXZlbCA9PiBjb25zb2xlLmxvZyh6b29tTGV2ZWwpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIGdldFpvb21MZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtem9vbS1sZXZlbCcsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBXZWJDb250ZW50cy5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgVGhlIHpvb20gbGV2ZWxcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNldFpvb21MZXZlbChudW1iZXIpIHtcbiAgICAgKiAgICAgY29uc3QgdmlldyA9IGF3YWl0IGZpbi5WaWV3LmdldEN1cnJlbnQoKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHZpZXcuc2V0Wm9vbUxldmVsKG51bWJlcik7XG4gICAgICogfVxuICAgICAqXG4gICAgICogc2V0Wm9vbUxldmVsKDQpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1NldHRpbmcgYSAgem9vbSBsZXZlbCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVXaW4oKSB7XG4gICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG4gICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcbiAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuc2V0Wm9vbUxldmVsLmh0bWwnLFxuICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcbiAgICAgKiAgICAgfSk7XG4gICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogYXN5bmMgZnVuY3Rpb24gc2V0Wm9vbUxldmVsKG51bWJlcikge1xuICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBjcmVhdGVXaW4oKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5zZXRab29tTGV2ZWwobnVtYmVyKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBzZXRab29tTGV2ZWwoNCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU2V0dGluZyBhICB6b29tIGxldmVsJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIGBXZWJDb250ZW50c2AgcmVmZXJzIHRvIHNoYXJlZCBmdW5jdGlvbmFsaXR5IGJldHdlZW4ge0BsaW5rIE9wZW5GaW4uV2luZG93fSBhbmQge0BsaW5rIE9wZW5GaW4uVmlld30uXG4gICAgICogV2UgZG8gbm90IGV4cG9zZSBhbiBleHBsaWNpdCBzdXBlcmNsYXNzIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHksIGJ1dCBpdCBkb2VzIGhhdmUgaXRzIG93blxuICAgICAqIHtAbGluayBPcGVuRmluLldlYkNvbnRlbnRzRXZlbnRzIGV2ZW50IG5hbWVzcGFjZX0uXG4gICAgICovXG4gICAgc2V0Wm9vbUxldmVsKGxldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LXpvb20tbGV2ZWwnLCB7IC4uLnRoaXMuaWRlbnRpdHksIGxldmVsIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRoZSBXZWJDb250ZW50cyB0byBhIHNwZWNpZmllZCBVUkwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgdXJsIG11c3QgY29udGFpbiB0aGUgcHJvdG9jb2wgcHJlZml4IHN1Y2ggYXMgaHR0cDovLyBvciBodHRwczovLy5cbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBuYXZpZ2F0ZSB0aGUgV2ViQ29udGVudHMgdG8uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFZpZXc6XG4gICAgICogYGBganNcbiAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuICAgICAqICAgICBjb25zdCBtZSA9IGF3YWl0IGZpbi5XaW5kb3cuZ2V0Q3VycmVudCgpO1xuICAgICAqICAgICByZXR1cm4gZmluLlZpZXcuY3JlYXRlKHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICd2aWV3TmFtZScsXG4gICAgICogICAgICAgICB0YXJnZXQ6IG1lLmlkZW50aXR5LFxuICAgICAqICAgICAgICAgYm91bmRzOiB7dG9wOiAxMCwgbGVmdDogMTAsIHdpZHRoOiAyMDAsIGhlaWdodDogMjAwfVxuICAgICAqICAgICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjcmVhdGVWaWV3KClcbiAgICAgKiAgICAgLnRoZW4odmlldyA9PiB2aWV3Lm5hdmlnYXRlKCdodHRwczovL2V4YW1wbGUuY29tJykpXG4gICAgICogICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCduYXZpZ2F0aW9uIGNvbXBsZXRlJykpXG4gICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSgpIHtcbiAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy5nZXRDdXJyZW50KCk7XG4gICAgICogICAgIHJldHVybiBhd2FpdCB3aW4ubmF2aWdhdGUoJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cubmF2aWdhdGUuaHRtbCcpO1xuICAgICAqIH1cbiAgICAgKiBuYXZpZ2F0ZSgpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ05hdmlnYXRlIHRvIHR1dG9yaWFsJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIG5hdmlnYXRlKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ25hdmlnYXRlLXdpbmRvdycsIHsgLi4udGhpcy5pZGVudGl0eSwgdXJsIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRoZSBXZWJDb250ZW50cyBiYWNrIG9uZSBwYWdlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBWaWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGVCYWNrKCkge1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcud3JhcCh7IG5hbWU6ICd0ZXN0YXBwLXZpZXcnLCB1dWlkOiAndGVzdGFwcCcgfSk7XG4gICAgICogICAgIGF3YWl0IHZpZXcubmF2aWdhdGUoJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20nKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHZpZXcubmF2aWdhdGVCYWNrKCk7XG4gICAgICogfVxuICAgICAqIG5hdmlnYXRlQmFjaygpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ05hdmlnYXRlZCBiYWNrJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdpbmRvdzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlQmFjaygpIHtcbiAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy53cmFwKHsgbmFtZTogJ3Rlc3RhcHAnLCB1dWlkOiAndGVzdGFwcCcgfSk7XG4gICAgICogICAgIGF3YWl0IHdpbi5uYXZpZ2F0ZSgnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbScpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLm5hdmlnYXRlQmFjaygpO1xuICAgICAqIH1cbiAgICAgKiBuYXZpZ2F0ZUJhY2soKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdOYXZpZ2F0ZWQgYmFjaycpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIG5hdmlnYXRlQmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCduYXZpZ2F0ZS13aW5kb3ctYmFjaycsIHsgLi4udGhpcy5pZGVudGl0eSB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlcyB0aGUgV2ViQ29udGVudHMgZm9yd2FyZCBvbmUgcGFnZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlRm9yd2FyZCgpIHtcbiAgICAgKiAgICAgY29uc3QgdmlldyA9IGF3YWl0IGZpbi5WaWV3LmdldEN1cnJlbnQoKTtcbiAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbScpO1xuICAgICAqICAgICBhd2FpdCB2aWV3Lm5hdmlnYXRlQmFjaygpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgdmlldy5uYXZpZ2F0ZUZvcndhcmQoKTtcbiAgICAgKiB9XG4gICAgICogbmF2aWdhdGVGb3J3YXJkKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnTmF2aWdhdGVkIGZvcndhcmQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2luZG93OlxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGVGb3J3YXJkKCkge1xuICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcbiAgICAgKiAgICAgYXdhaXQgd2luLm5hdmlnYXRlKCdodHRwczovL3d3dy5nb29nbGUuY29tJyk7XG4gICAgICogICAgIGF3YWl0IHdpbi5uYXZpZ2F0ZUJhY2soKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5uYXZpZ2F0ZUZvcndhcmQoKTtcbiAgICAgKiB9XG4gICAgICogbmF2aWdhdGVGb3J3YXJkKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnTmF2aWdhdGVkIGZvcndhcmQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqIEByZW1hcmtzXG4gICAgICogYFdlYkNvbnRlbnRzYCByZWZlcnMgdG8gc2hhcmVkIGZ1bmN0aW9uYWxpdHkgYmV0d2VlbiB7QGxpbmsgT3BlbkZpbi5XaW5kb3d9IGFuZCB7QGxpbmsgT3BlbkZpbi5WaWV3fS5cbiAgICAgKiBXZSBkbyBub3QgZXhwb3NlIGFuIGV4cGxpY2l0IHN1cGVyY2xhc3MgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSwgYnV0IGl0IGRvZXMgaGF2ZSBpdHMgb3duXG4gICAgICoge0BsaW5rIE9wZW5GaW4uV2ViQ29udGVudHNFdmVudHMgZXZlbnQgbmFtZXNwYWNlfS5cbiAgICAgKi9cbiAgICBhc3luYyBuYXZpZ2F0ZUZvcndhcmQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCduYXZpZ2F0ZS13aW5kb3ctZm9yd2FyZCcsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgYW55IGN1cnJlbnQgbmF2aWdhdGlvbiB0aGUgV2ViQ29udGVudHMgaXMgcGVyZm9ybWluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIHN0b3BOYXZpZ2F0aW9uKCkge1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcud3JhcCh7IG5hbWU6ICd0ZXN0YXBwLXZpZXcnLCB1dWlkOiAndGVzdGFwcCcgfSk7XG4gICAgICogICAgIGF3YWl0IHZpZXcubmF2aWdhdGUoJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20nKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHZpZXcuc3RvcE5hdmlnYXRpb24oKTtcbiAgICAgKiB9XG4gICAgICogc3RvcE5hdmlnYXRpb24oKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCd5b3Ugc2hhbGwgbm90IG5hdmlnYXRlJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdpbmRvdzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIHN0b3BOYXZpZ2F0aW9uKCkge1xuICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBmaW4uV2luZG93LndyYXAoeyBuYW1lOiAndGVzdGFwcCcsIHV1aWQ6ICd0ZXN0YXBwJyB9KTtcbiAgICAgKiAgICAgYXdhaXQgd2luLm5hdmlnYXRlKCdodHRwczovL3d3dy5nb29nbGUuY29tJyk7XG4gICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uc3RvcE5hdmlnYXRpb24oKTtcbiAgICAgKiB9XG4gICAgICogc3RvcE5hdmlnYXRpb24oKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCd5b3Ugc2hhbGwgbm90IG5hdmlnYXRlJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIGBXZWJDb250ZW50c2AgcmVmZXJzIHRvIHNoYXJlZCBmdW5jdGlvbmFsaXR5IGJldHdlZW4ge0BsaW5rIE9wZW5GaW4uV2luZG93fSBhbmQge0BsaW5rIE9wZW5GaW4uVmlld30uXG4gICAgICogV2UgZG8gbm90IGV4cG9zZSBhbiBleHBsaWNpdCBzdXBlcmNsYXNzIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHksIGJ1dCBpdCBkb2VzIGhhdmUgaXRzIG93blxuICAgICAqIHtAbGluayBPcGVuRmluLldlYkNvbnRlbnRzRXZlbnRzIGV2ZW50IG5hbWVzcGFjZX0uXG4gICAgICovXG4gICAgc3RvcE5hdmlnYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc3RvcC13aW5kb3ctbmF2aWdhdGlvbicsIHsgLi4udGhpcy5pZGVudGl0eSB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIFdlYkNvbnRlbnRzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFZpZXc6XG4gICAgICogYGBganNcbiAgICAgKiBhc3luYyBmdW5jdGlvbiByZWxvYWQoKSB7XG4gICAgICogXHRjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuZ2V0Q3VycmVudCgpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgdmlldy5yZWxvYWQoKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiByZWxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgKiBcdFx0Y29uc29sZS5sb2coJ1JlbG9hZGVkIHZpZXcnKVxuICAgICAqIH0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdpbmRvdzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIHJlbG9hZFdpbmRvdygpIHtcbiAgICAgKiBcdFx0Y29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcbiAgICAgKiBcdFx0XHRcdG5hbWU6ICdteUFwcCcsXG4gICAgICogXHRcdFx0XHR1dWlkOiAnYXBwLTEnLFxuICAgICAqIFx0XHRcdFx0dXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5yZWxvYWQuaHRtbCcsXG4gICAgICogXHRcdFx0XHRhdXRvU2hvdzogdHJ1ZVxuICAgICAqIFx0XHR9KTtcbiAgICAgKiBcdFx0Y29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLnJlbG9hZCgpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHJlbG9hZFdpbmRvdygpLnRoZW4oKCkgPT4ge1xuICAgICAqIFx0XHRjb25zb2xlLmxvZygnUmVsb2FkZWQgd2luZG93JylcbiAgICAgKiB9KS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIHJlbG9hZChpZ25vcmVDYWNoZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdyZWxvYWQtd2luZG93Jywge1xuICAgICAgICAgICAgaWdub3JlQ2FjaGUsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmludHMgdGhlIFdlYkNvbnRlbnRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFByaW50ZXIgT3B0aW9uc1xuICAgICAqXG4gICAgICogTm90ZTogV2hlbiBgc2lsZW50YCBpcyBzZXQgdG8gYHRydWVgLCB0aGUgQVBJIHdpbGwgcGljayB0aGUgc3lzdGVtJ3MgZGVmYXVsdCBwcmludGVyIGlmIGRldmljZU5hbWVcbiAgICAgKiBpcyBlbXB0eSBhbmQgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIHByaW50aW5nLlxuICAgICAqXG4gICAgICogVXNlIHRoZSBDU1Mgc3R5bGUgYHBhZ2UtYnJlYWstYmVmb3JlOiBhbHdheXM7YCB0byBmb3JjZSBwcmludCB0byBhIG5ldyBwYWdlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHZpZXcgPSBmaW4uVmlldy5nZXRDdXJyZW50U3luYygpO1xuICAgICAqXG4gICAgICogdmlldy5wcmludCh7IHNpbGVudDogZmFsc2UsIGRldmljZU5hbWU6ICdzeXN0ZW0tcHJpbnRlci1uYW1lJyB9KS50aGVuKCgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ3ByaW50IGNhbGwgaGFzIGJlZW4gc2VudCB0byB0aGUgc3lzdGVtJyk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIHByaW50KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ByaW50JywgeyAuLi50aGlzLmlkZW50aXR5LCBvcHRpb25zIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgaGlnaGxpZ2h0IHRleHQgb24gYSBwYWdlLlxuICAgICAqIEBwYXJhbSBzZWFyY2hUZXJtIFRlcm0gdG8gZmluZCBpbiBwYWdlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU2VhcmNoIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIE5vdGU6IEJ5IGRlZmF1bHQsIGVhY2ggc3Vic2VxdWVudCBjYWxsIHdpbGwgaGlnaGxpZ2h0IHRoZSBuZXh0IHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWFyY2ggdGVybS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdHMgZm9yIHRoZSByZXF1ZXN0LiBCeSBzdWJzY3JpYmluZyB0byB0aGVcbiAgICAgKiBmb3VuZC1pbi1wYWdlIGV2ZW50LCB5b3UgY2FuIGdldCB0aGUgcmVzdWx0cyBvZiB0aGlzIGNhbGwgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHZpZXcgPSBmaW4uVmlldy5nZXRDdXJyZW50U3luYygpO1xuICAgICAqXG4gICAgICogLy9CeSBzdWJzY3JpYmluZyB0byB0aGUgJ2ZvdW5kIGluIHBhZ2UnIGV2ZW50IHdlIGNhbiBnZXQgdGhlIHJlc3VsdHMgb2YgZWFjaCBmaW5kSW5QYWdlIGNhbGwgbWFkZS5cbiAgICAgKiB2aWV3LmFkZExpc3RlbmVyKCdmb3VuZC1pbi1wYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBwcm9taXNlIGFsc28gcmV0dXJucyB0aGUgcmVzdWx0cyBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiB2aWV3LmZpbmRJblBhZ2UoJ2EnKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0KVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2luZG93OlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgd2luID0gZmluLldpbmRvdy5nZXRDdXJyZW50U3luYygpO1xuICAgICAqXG4gICAgICogLy9CeSBzdWJzY3JpYmluZyB0byB0aGUgJ2ZvdW5kIGluIHBhZ2UnIGV2ZW50IHdlIGNhbiBnZXQgdGhlIHJlc3VsdHMgb2YgZWFjaCBmaW5kSW5QYWdlIGNhbGwgbWFkZS5cbiAgICAgKiB3aW4uYWRkTGlzdGVuZXIoJ2ZvdW5kLWluLXBhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gVGhlIHByb21pc2UgYWxzbyByZXR1cm5zIHRoZSByZXN1bHRzIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIHdpbi5maW5kSW5QYWdlKCdhJykudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdClcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIGBXZWJDb250ZW50c2AgcmVmZXJzIHRvIHNoYXJlZCBmdW5jdGlvbmFsaXR5IGJldHdlZW4ge0BsaW5rIE9wZW5GaW4uV2luZG93fSBhbmQge0BsaW5rIE9wZW5GaW4uVmlld30uXG4gICAgICogV2UgZG8gbm90IGV4cG9zZSBhbiBleHBsaWNpdCBzdXBlcmNsYXNzIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHksIGJ1dCBpdCBkb2VzIGhhdmUgaXRzIG93blxuICAgICAqIHtAbGluayBPcGVuRmluLldlYkNvbnRlbnRzRXZlbnRzIGV2ZW50IG5hbWVzcGFjZX0uXG4gICAgICovXG4gICAgZmluZEluUGFnZShzZWFyY2hUZXJtLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdmaW5kLWluLXBhZ2UnLCB7IC4uLnRoaXMuaWRlbnRpdHksIHNlYXJjaFRlcm0sIG9wdGlvbnMgfSlcbiAgICAgICAgICAgIC50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBhIHtAbGluayBWaWV3I2ZpbmRJblBhZ2UgZmluZEluUGFnZX0gY2FsbCBieSBzcGVjaWZ5aW5nIGFueSBvZiB0aGVzZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogKiBjbGVhclNlbGVjdGlvbiAtIENsZWFyIHRoZSBzZWxlY3Rpb24uXG4gICAgICogKiBrZWVwU2VsZWN0aW9uIC0gVHJhbnNsYXRlIHRoZSBzZWxlY3Rpb24gaW50byBhIG5vcm1hbCBzZWxlY3Rpb24uXG4gICAgICogKiBhY3RpdmF0ZVNlbGVjdGlvbiAtIEZvY3VzIGFuZCBjbGljayB0aGUgc2VsZWN0aW9uIG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFZpZXc6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB2aWV3ID0gZmluLlZpZXcuZ2V0Q3VycmVudFN5bmMoKTtcbiAgICAgKlxuICAgICAqIHZpZXcuYWRkTGlzdGVuZXIoJ2ZvdW5kLWluLXBhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgKiAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICogICAgICAgICB2aWV3LnN0b3BGaW5kSW5QYWdlKCdjbGVhclNlbGVjdGlvbicpO1xuICAgICAqICAgICB9LCA1MDAwKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZpZXcuZmluZEluUGFnZSgnYScpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2luZG93OlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgd2luID0gZmluLldpbmRvdy5nZXRDdXJyZW50U3luYygpO1xuICAgICAqXG4gICAgICogd2luLmFkZExpc3RlbmVyKCdmb3VuZC1pbi1wYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICogICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAqICAgICAgICAgd2luLnN0b3BGaW5kSW5QYWdlKCdjbGVhclNlbGVjdGlvbicpO1xuICAgICAqICAgICB9LCA1MDAwKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHdpbi5maW5kSW5QYWdlKCdhJykudGhlbihyZXN1bHRzID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIHN0b3BGaW5kSW5QYWdlKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3N0b3AtZmluZC1pbi1wYWdlJywgeyAuLi50aGlzLmlkZW50aXR5LCBhY3Rpb24gfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggYWxsIHN5c3RlbSBwcmludGVyc1xuICAgICAqIEBkZXByZWNhdGVkIHVzZSBTeXN0ZW0uZ2V0UHJpbnRlcnMgaW5zdGVhZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBWaWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgdmlldyA9IGZpbi5WaWV3LmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICpcbiAgICAgKiB2aWV3LmdldFByaW50ZXJzKClcbiAgICAgKiAgICAgLnRoZW4oKHByaW50ZXJzKSA9PiB7XG4gICAgICogICAgICAgICBwcmludGVycy5mb3JFYWNoKChwcmludGVyKSA9PiB7XG4gICAgICogICAgICAgICAgICAgaWYgKHByaW50ZXIuaXNEZWZhdWx0KSB7XG4gICAgICogICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHByaW50ZXIpO1xuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqICAgICB9KVxuICAgICAqICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB3aW4gPSBmaW4uV2luZG93LmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICpcbiAgICAgKiB3aW4uZ2V0UHJpbnRlcnMoKVxuICAgICAqICAgICAudGhlbigocHJpbnRlcnMpID0+IHtcbiAgICAgKiAgICAgICAgIHByaW50ZXJzLmZvckVhY2goKHByaW50ZXIpID0+IHtcbiAgICAgKiAgICAgICAgICAgICBpZiAocHJpbnRlci5pc0RlZmF1bHQpIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocHJpbnRlcik7XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgfSk7XG4gICAgICogICAgIH0pXG4gICAgICogICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIGBXZWJDb250ZW50c2AgcmVmZXJzIHRvIHNoYXJlZCBmdW5jdGlvbmFsaXR5IGJldHdlZW4ge0BsaW5rIE9wZW5GaW4uV2luZG93fSBhbmQge0BsaW5rIE9wZW5GaW4uVmlld30uXG4gICAgICogV2UgZG8gbm90IGV4cG9zZSBhbiBleHBsaWNpdCBzdXBlcmNsYXNzIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHksIGJ1dCBpdCBkb2VzIGhhdmUgaXRzIG93blxuICAgICAqIHtAbGluayBPcGVuRmluLldlYkNvbnRlbnRzRXZlbnRzIGV2ZW50IG5hbWVzcGFjZX0uXG4gICAgICovXG4gICAgZ2V0UHJpbnRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXByaW50ZXJzJywgeyAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlcyBmb2N1cyB0byB0aGUgV2ViQ29udGVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gZm9jdXNXaW5kb3coKSB7XG4gICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG4gICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcbiAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuZm9jdXMuaHRtbCcsXG4gICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuICAgICAqICAgICB9KTtcbiAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLmZvY3VzKCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZm9jdXNXaW5kb3coKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdXaW5kb3cgZm9jdXNlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIGFzeW5jIGZvY3VzKHsgZW1pdFN5bnRoRm9jdXNlZCB9ID0geyBlbWl0U3ludGhGb2N1c2VkOiB0cnVlIH0pIHtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ZvY3VzLXdpbmRvdycsIHsgZW1pdFN5bnRoRm9jdXNlZCwgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIENocm9taXVtIERldmVsb3BlciBUb29sc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBWaWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gc2hvd0RldmVsb3BlclRvb2xzKCkge1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuZ2V0Q3VycmVudCgpO1xuICAgICAqICAgICByZXR1cm4gdmlldy5zaG93RGV2ZWxvcGVyVG9vbHMoKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBzaG93RGV2ZWxvcGVydG9vbHMoKVxuICAgICAqIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdTaG93aW5nIGRldiB0b29scycpKVxuICAgICAqIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdpbmRvdzpcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNob3dEZXZlbG9wZXJUb29scygpIHtcbiAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy5nZXRDdXJyZW50KCk7XG4gICAgICogICAgIHJldHVybiB3aW4uc2hvd0RldmVsb3BlclRvb2xzKCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogc2hvd0RldmVsb3BlcnRvb2xzKClcbiAgICAgKiAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU2hvd2luZyBkZXYgdG9vbHMnKSlcbiAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIGFzeW5jIHNob3dEZXZlbG9wZXJUb29scygpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGhpdHMgdGhlIHN5c3RlbSBhY3Rpb24gbWFwIGluIGNvcmUgc3RhdGUgZm9yIGxlZ2FjeSByZWFzb25zLlxuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2hvdy1kZXZlbG9wZXItdG9vbHMnLCB0aGlzLmlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBwcm9jZXNzIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCBhIFdlYkNvbnRlbnRzLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpbmNsdWRlcyBhbnkgaWZyYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIFdlYkNvbnRlbnRzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFZpZXc6XG4gICAgICogYGBganNcbiAgICAgKiAgICAgY29uc3QgdmlldyA9IGF3YWl0IGZpbi5WaWV3LmdldEN1cnJlbnQoKTtcbiAgICAgKiAgICAgY29uc3QgcHJvY2Vzc0luZm8gPSBhd2FpdCB2aWV3LmdldFByb2Nlc3NJbmZvKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy5nZXRDdXJyZW50KCk7XG4gICAgICogICAgIGNvbnN0IHByb2Nlc3NJbmZvID0gYXdhaXQgd2luLmdldFByb2Nlc3NJbmZvKCk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2Nlc3NJbmZvKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YSB9IH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXByb2Nlc3MtaW5mbycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIG9uIGFsbCBTaGFyZWQgV29ya2Vycy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuY3JlYXRlKHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICd2aWV3TmFtZScsXG4gICAgICogICAgICAgICB0YXJnZXQ6IGZpbi5tZS5pZGVudGl0eSxcbiAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cDovL21kbi5naXRodWIuaW8vc2ltcGxlLXNoYXJlZC13b3JrZXIvaW5kZXgyLmh0bWwnKTtcbiAgICAgKlxuICAgICAqICAgICBjb25zdCBzaGFyZWRXb3JrZXJzID0gYXdhaXQgdmlldy5nZXRTaGFyZWRXb3JrZXJzKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiAgICAgY29uc3Qgd2luT3B0aW9uID0ge1xuICAgICAqICAgICAgICAgbmFtZTonY2hpbGQnLFxuICAgICAqICAgICAgICAgZGVmYXVsdFdpZHRoOiAzMDAsXG4gICAgICogICAgICAgICBkZWZhdWx0SGVpZ2h0OiAzMDAsXG4gICAgICogICAgICAgICB1cmw6ICdodHRwOi8vbWRuLmdpdGh1Yi5pby9zaW1wbGUtc2hhcmVkLXdvcmtlci9pbmRleDIuaHRtbCcsXG4gICAgICogICAgICAgICBmcmFtZTogdHJ1ZSxcbiAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG4gICAgICogICAgIH07XG4gICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGZpbi5XaW5kb3cuY3JlYXRlKHdpbk9wdGlvbik7XG4gICAgICogICAgIGNvbnN0IHNoYXJlZFdvcmtlcnMgPSBhd2FpdCB3aW4uZ2V0U2hhcmVkV29ya2VycygpO1xuICAgICAqIGBgYFxuICAgICAqIEByZW1hcmtzXG4gICAgICogYFdlYkNvbnRlbnRzYCByZWZlcnMgdG8gc2hhcmVkIGZ1bmN0aW9uYWxpdHkgYmV0d2VlbiB7QGxpbmsgT3BlbkZpbi5XaW5kb3d9IGFuZCB7QGxpbmsgT3BlbkZpbi5WaWV3fS5cbiAgICAgKiBXZSBkbyBub3QgZXhwb3NlIGFuIGV4cGxpY2l0IHN1cGVyY2xhc3MgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSwgYnV0IGl0IGRvZXMgaGF2ZSBpdHMgb3duXG4gICAgICoge0BsaW5rIE9wZW5GaW4uV2ViQ29udGVudHNFdmVudHMgZXZlbnQgbmFtZXNwYWNlfS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaGFyZWRXb3JrZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1zaGFyZWQtd29ya2VycycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgZGV2ZWxvcGVyIHRvb2xzIGZvciB0aGUgc2hhcmVkIHdvcmtlciBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBWaWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogICAgIGNvbnN0IHZpZXcgPSBhd2FpdCBmaW4uVmlldy5jcmVhdGUoe1xuICAgICAqICAgICAgICAgbmFtZTogJ3ZpZXdOYW1lJyxcbiAgICAgKiAgICAgICAgIHRhcmdldDogZmluLm1lLmlkZW50aXR5LFxuICAgICAqICAgICAgICAgYm91bmRzOiB7dG9wOiAxMCwgbGVmdDogMTAsIHdpZHRoOiAyMDAsIGhlaWdodDogMjAwfVxuICAgICAqICAgICB9KTtcbiAgICAgKlxuICAgICAqICAgICBhd2FpdCB2aWV3Lm5hdmlnYXRlKCdodHRwOi8vbWRuLmdpdGh1Yi5pby9zaW1wbGUtc2hhcmVkLXdvcmtlci9pbmRleDIuaHRtbCcpO1xuICAgICAqXG4gICAgICogICAgIGF3YWl0IHZpZXcuaW5zcGVjdFNoYXJlZFdvcmtlcigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBjb25zdCB3aW5PcHRpb24gPSB7XG4gICAgICogICAgICAgICBuYW1lOidjaGlsZCcsXG4gICAgICogICAgICAgICBkZWZhdWx0V2lkdGg6IDMwMCxcbiAgICAgKiAgICAgICAgIGRlZmF1bHRIZWlnaHQ6IDMwMCxcbiAgICAgKiAgICAgICAgIHVybDogJ2h0dHA6Ly9tZG4uZ2l0aHViLmlvL3NpbXBsZS1zaGFyZWQtd29ya2VyL2luZGV4Mi5odG1sJyxcbiAgICAgKiAgICAgICAgIGZyYW1lOiB0cnVlLFxuICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcbiAgICAgKiAgICAgfTtcbiAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy5jcmVhdGUod2luT3B0aW9uKTtcbiAgICAgKiAgICAgYXdhaXQgd2luLmluc3BlY3RTaGFyZWRXb3JrZXIoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIGBXZWJDb250ZW50c2AgcmVmZXJzIHRvIHNoYXJlZCBmdW5jdGlvbmFsaXR5IGJldHdlZW4ge0BsaW5rIE9wZW5GaW4uV2luZG93fSBhbmQge0BsaW5rIE9wZW5GaW4uVmlld30uXG4gICAgICogV2UgZG8gbm90IGV4cG9zZSBhbiBleHBsaWNpdCBzdXBlcmNsYXNzIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHksIGJ1dCBpdCBkb2VzIGhhdmUgaXRzIG93blxuICAgICAqIHtAbGluayBPcGVuRmluLldlYkNvbnRlbnRzRXZlbnRzIGV2ZW50IG5hbWVzcGFjZX0uXG4gICAgICovXG4gICAgYXN5bmMgaW5zcGVjdFNoYXJlZFdvcmtlcigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2luc3BlY3Qtc2hhcmVkLXdvcmtlcicsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zcGVjdHMgdGhlIHNoYXJlZCB3b3JrZXIgYmFzZWQgb24gaXRzIElELlxuICAgICAqIEBwYXJhbSB3b3JrZXJJZCAtIFRoZSBpZCBvZiB0aGUgc2hhcmVkIHdvcmtlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuY3JlYXRlKHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICd2aWV3TmFtZScsXG4gICAgICogICAgICAgICB0YXJnZXQ6IGZpbi5tZS5pZGVudGl0eSxcbiAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cDovL21kbi5naXRodWIuaW8vc2ltcGxlLXNoYXJlZC13b3JrZXIvaW5kZXgyLmh0bWwnKTtcbiAgICAgKlxuICAgICAqICAgICBjb25zdCBzaGFyZWRXb3JrZXJzID0gYXdhaXQgdmlldy5nZXRTaGFyZWRXb3JrZXJzKCk7XG4gICAgICogICAgIGF3YWl0IHZpZXcuaW5zcGVjdFNoYXJlZFdvcmtlckJ5SWQoc2hhcmVkV29ya2Vyc1swXS5pZCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiAgICAgY29uc3Qgd2luT3B0aW9uID0ge1xuICAgICAqICAgICAgICAgbmFtZTonY2hpbGQnLFxuICAgICAqICAgICAgICAgZGVmYXVsdFdpZHRoOiAzMDAsXG4gICAgICogICAgICAgICBkZWZhdWx0SGVpZ2h0OiAzMDAsXG4gICAgICogICAgICAgICB1cmw6ICdodHRwOi8vbWRuLmdpdGh1Yi5pby9zaW1wbGUtc2hhcmVkLXdvcmtlci9pbmRleDIuaHRtbCcsXG4gICAgICogICAgICAgICBmcmFtZTogdHJ1ZSxcbiAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG4gICAgICogICAgIH07XG4gICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGZpbi5XaW5kb3cuY3JlYXRlKHdpbk9wdGlvbik7XG4gICAgICogICAgIGNvbnN0IHNoYXJlZFdvcmtlcnMgPSBhd2FpdCB3aW4uZ2V0U2hhcmVkV29ya2VycygpO1xuICAgICAqICAgICBhd2FpdCB3aW4uaW5zcGVjdFNoYXJlZFdvcmtlckJ5SWQoc2hhcmVkV29ya2Vyc1swXS5pZCk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIGFzeW5jIGluc3BlY3RTaGFyZWRXb3JrZXJCeUlkKHdvcmtlcklkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnNwZWN0LXNoYXJlZC13b3JrZXItYnktaWQnLCB7IC4uLnRoaXMuaWRlbnRpdHksIHdvcmtlcklkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgZGV2ZWxvcGVyIHRvb2xzIGZvciB0aGUgc2VydmljZSB3b3JrZXIgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuY3JlYXRlKHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICd2aWV3TmFtZScsXG4gICAgICogICAgICAgICB0YXJnZXQ6IGZpbi5tZS5pZGVudGl0eSxcbiAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cDovL2dvb2dsZWNocm9tZS5naXRodWIuaW8vc2FtcGxlcy9zZXJ2aWNlLXdvcmtlci9iYXNpYy9pbmRleC5odG1sJyk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgdmlldy5pbnNwZWN0U2VydmljZVdvcmtlcigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2luZG93OlxuICAgICAqIGBgYGpzXG4gICAgICogICAgIGNvbnN0IHdpbk9wdGlvbiA9IHtcbiAgICAgKiAgICAgICAgIG5hbWU6J2NoaWxkJyxcbiAgICAgKiAgICAgICAgIGRlZmF1bHRXaWR0aDogMzAwLFxuICAgICAqICAgICAgICAgZGVmYXVsdEhlaWdodDogMzAwLFxuICAgICAqICAgICAgICAgdXJsOiAnaHR0cDovL2dvb2dsZWNocm9tZS5naXRodWIuaW8vc2FtcGxlcy9zZXJ2aWNlLXdvcmtlci9iYXNpYy9pbmRleC5odG1sJyxcbiAgICAgKiAgICAgICAgIGZyYW1lOiB0cnVlLFxuICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcbiAgICAgKiAgICAgfTtcbiAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy5jcmVhdGUod2luT3B0aW9uKTtcbiAgICAgKiAgICAgYXdhaXQgd2luLmluc3BlY3RTZXJ2aWNlV29ya2VyKCk7XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBgV2ViQ29udGVudHNgIHJlZmVycyB0byBzaGFyZWQgZnVuY3Rpb25hbGl0eSBiZXR3ZWVuIHtAbGluayBPcGVuRmluLldpbmRvd30gYW5kIHtAbGluayBPcGVuRmluLlZpZXd9LlxuICAgICAqIFdlIGRvIG5vdCBleHBvc2UgYW4gZXhwbGljaXQgc3VwZXJjbGFzcyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LCBidXQgaXQgZG9lcyBoYXZlIGl0cyBvd25cbiAgICAgKiB7QGxpbmsgT3BlbkZpbi5XZWJDb250ZW50c0V2ZW50cyBldmVudCBuYW1lc3BhY2V9LlxuICAgICAqL1xuICAgIGFzeW5jIGluc3BlY3RTZXJ2aWNlV29ya2VyKCkge1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignaW5zcGVjdC1zZXJ2aWNlLXdvcmtlcicsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBwb3B1cCB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiB0aGlzIFdlYkNvbnRlbnRzIGlzIGEgdmlldyBhbmQgaXRzIGF0dGFjaGVkIHdpbmRvdyBoYXMgYSBwb3B1cCBvcGVuLCB0aGlzIHdpbGwgY2xvc2UgaXQuXG4gICAgICpcbiAgICAgKiBTaG93cyBhIHBvcHVwIHdpbmRvdy4gSW5jbHVkaW5nIGEgYG5hbWVgIGluIGBvcHRpb25zYCB3aWxsIGF0dGVtcHQgdG8gc2hvdyBhbiBleGlzdGluZyB3aW5kb3cgYXMgYSBwb3B1cCwgaWZcbiAgICAgKiB0aGF0IHdpbmRvdyBkb2Vzbid0IGV4aXN0IG9yIG5vIGBuYW1lYCBpcyBpbmNsdWRlZCBhIHdpbmRvdyB3aWxsIGJlIGNyZWF0ZWQuIElmIHRoZSBjYWxsZXIgdmlldyBvciB0aGUgY2FsbGVyXG4gICAgICogdmlldydzIHBhcmVudCB3aW5kb3cgY3VycmVudGx5IGhhcyBhIHBvcHVwIHdpbmRvdyBvcGVuLCBjYWxsaW5nIGBzaG93UG9wdXBXaW5kb3dgIGFnYWluIHdpbGwgZGlzbWlzcyB0aGUgY3VycmVudGx5XG4gICAgICogb3BlbiBwb3B1cCB3aW5kb3cgYmVmb3JlIHNob3dpbmcgdGhlIG5ldyBwb3B1cCB3aW5kb3cuIEFsc28sIGlmIHRoZSBjYWxsZXIgdmlldyBpcyBkZXN0cm95ZWQgb3IgZGV0YWNoZWQsIHRoZSBwb3B1cFxuICAgICAqIHdpbGwgYmUgZGlzbWlzc2VkLlxuICAgICAqXG4gICAgICogTm90ZTogaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHdpbmRvdyBiZWluZyBzaG93biBhcyBhIHBvcHVwIG5lZWRzIHRvIGJlIGNyZWF0ZWQsIGl0IGlzIGEgY2hpbGQgb2YgdGhlIGNhbGxlciB2aWV3J3MgcGFyZW50IHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYW5kIHNob3cgYSBzaW5nbGUtdXNlIHBvcHVwIHdpbmRvdyB0aGF0IHJldHVybnMgYSBzaW5nbGUgcmVzdWx0IHRvIHRoZSBjYWxsZXIuIGBpbml0aWFsT3B0aW9uc2AgYWxsb3dzXG4gICAgICogdXMgdG8gcGFzcyB3aW5kb3cgb3B0aW9ucyB0byB0aGUgcG9wdXAgd2luZG93IHRoYXQgd2lsbCBiZSBjcmVhdGVkLiBgcmVzdWx0RGlzcGF0Y2hCZWhhdmlvcjogJ2Nsb3NlJ2AgZW5zdXJlc1xuICAgICAqIHRoYXQgb25jZSB0aGUgcG9wdXAgd2luZG93IGNhbGxzIGBkaXNwYXRjaFBvcHVwUmVzdWx0YCBpdCBpcyBjbG9zZWQuIGBibHVyQmVoYXZpb3I6ICdjbG9zZSdgIHdpbGwgeWllbGQgYSBkaXNtaXNzZWRcbiAgICAgKiByZXN1bHQgc2hvdWxkIHRoZSBwb3B1cCB3aW5kb3cgbG9zZSBmb2N1cy5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZmluLm1lLnNob3dQb3B1cFdpbmRvdyh7XG4gICAgICogICAgIGluaXRpYWxPcHRpb25zOiB7XG4gICAgICogICAgICAgICBmcmFtZTogZmFsc2VcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgdXJsOiAnPG15X3BvcHVwX3VybD4nLFxuICAgICAqICAgICByZXN1bHREaXNwYXRjaEJlaGF2aW9yOiAnY2xvc2UnLFxuICAgICAqICAgICBibHVyQmVoYXZpb3I6ICdjbG9zZScsXG4gICAgICogICAgIGZvY3VzOiB0cnVlLFxuICAgICAqICAgICBoZWlnaHQ6IDMwMCxcbiAgICAgKiAgICAgd2lkdGg6IDMwMCxcbiAgICAgKiAgICAgeDogMCxcbiAgICAgKiAgICAgeTogMFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2FtZSBhcyBhYm92ZSBidXQgdXNpbmcgYW4gZXhpc3Rpbmcgd2luZG93IGFzIGEgcG9wdXAgYnkgcmVmZXJlbmNpbmcgaXRzIGBuYW1lYDpcbiAgICAgKlxuICAgICAqIE5vdGU6IGlmIGEgd2luZG93IHdpdGggdGhlIGBuYW1lYCBwcm92aWRlZCBkb2Vzbid0IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbi5tZS5zaG93UG9wdXBXaW5kb3coe1xuICAgICAqICAgICBpbml0aWFsT3B0aW9uczoge1xuICAgICAqICAgICAgICAgZnJhbWU6IHRydWVcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbmFtZTogJ215LXBvcHVwJywgLy8gc2hvd3MgdGhlICdteS1wb3B1cCcgd2luZG93IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGNyZWF0ZXMgaXRcbiAgICAgKiAgICAgdXJsOiAnPG15X3BvcHVwX3VybD4nLCAvLyBuYXZpZ2F0ZXMgdG8gdGhpcyB1cmwgaWYgaXQgZG9lc24ndCBtYXRjaCB0aGUgbG9jYXRpb24uaHJlZiBvZiB0aGUgJ215LXBvcHVwJyB3aW5kb3dcbiAgICAgKiAgICAgcmVzdWx0RGlzcGF0Y2hCZWhhdmlvcjogJ2Nsb3NlJyxcbiAgICAgKiAgICAgYmx1ckJlaGF2aW9yOiAnY2xvc2UnLFxuICAgICAqICAgICBmb2N1czogdHJ1ZSxcbiAgICAgKiAgICAgaGlkZU9uQ2xvc2U6IHRydWUsIC8vIHBlcnNpc3Qgd2luZG93IG9uICdkaXNtaXNzZWQnIHJlc3VsdCwgYWx0ZXJuYXRpdmVseSBjaGFuZ2Ugb25SZXN1bHREaXNwYXRjaCBhbmQgYmx1ckJlaGF2aW9yIHRvICdoaWRlJ1xuICAgICAqICAgICBoZWlnaHQ6IDMwMCxcbiAgICAgKiAgICAgd2lkdGg6IDMwMCxcbiAgICAgKiAgICAgeDogMCxcbiAgICAgKiAgICAgeTogMFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQ3JlYXRlIGFuZCBzaG93IGEgcG9wdXAgd2luZG93IHRoYXQgaXMgYWJsZSB0byByZXR1cm4gbXVsdGlwbGUgcmVzdWx0cyB0byB0aGUgY2FsbGVyIHZpYSBhbiBgb25Qb3B1cFJlc3VsdGAgY2FsbGJhY2suIEVhY2hcbiAgICAgKiB0aW1lIHRoZSBwb3B1cCB3aW5kb3cgY2FsbHMgYGRpc3BhdGNoUG9wdXBSZXN1bHRgLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbiB0aGUgcmVzdWx0LiBPbmNlIHRoZSBwb3B1cCB3aW5kb3cgaXNcbiAgICAgKiBjbG9zZWQgb3IgaGlkZGVuLCB0aGUgYHNob3dQb3B1cFdpbmRvd2AgcHJvbWlzZSB3aWxsIHJlc29sdmUgd2l0aCBhIGBkaXNtaXNzZWRgIHJlc3VsdCB0aGF0IHdpbGwgaW5jbHVkZSB0aGUgbW9zdCByZWNlbnRseVxuICAgICAqIGRpc3BhdGNoZWQgcmVzdWx0IGFzIGBsYXN0RGlzcGF0Y2hSZXN1bHRgOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwb3B1cFJlc3VsdENhbGxiYWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgKiAgICAgICAgaWYgKHBheWxvYWQucmVzdWx0ID09PSAnY2xpY2tlZCcpIHtcbiAgICAgKiAgICAgICAgICAgIGlmIChwYXlsb2FkLmRhdGEudG9waWMgPT09ICdjb2xvci1jaGFuZ2VkJykge1xuICAgICAqICAgICAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBsaWtlXG4gICAgICogICAgICAgICAgICAgICAgLy8gc2V0Q29sb3IocGF5bG9hZC5kYXRhLnZhbHVlKTtcbiAgICAgKiAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBhd2FpdCBmaW4ubWUuc2hvd1BvcHVwV2luZG93KHtcbiAgICAgKiAgICAgaW5pdGlhbE9wdGlvbnM6IHtcbiAgICAgKiAgICAgICAgIGZyYW1lOiBmYWxzZVxuICAgICAqICAgICB9LFxuICAgICAqICAgICB1cmw6ICc8bXlfcG9wdXBfdXJsPicsXG4gICAgICogICAgIHJlc3VsdERpc3BhdGNoQmVoYXZpb3I6ICdub25lJyxcbiAgICAgKiAgICAgYmx1ckJlaGF2aW9yOiAnY2xvc2UnLFxuICAgICAqICAgICBmb2N1czogdHJ1ZSxcbiAgICAgKiAgICAgaGVpZ2h0OiAzMDAsXG4gICAgICogICAgIHdpZHRoOiAzMDAsXG4gICAgICogICAgIHg6IDAsXG4gICAgICogICAgIHk6IDAsXG4gICAgICogICAgIG9uUG9wdXBSZXN1bHQ6IHBvcHVwUmVzdWx0Q2FsbGJhY2tcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNhbWUgYXMgYWJvdmUgYnV0IHVzaW5nIGFuIGV4aXN0aW5nIHdpbmRvdyBhcyBhIHBvcHVwOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwb3B1cFJlc3VsdENhbGxiYWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgKiAgICAgICAgaWYgKHBheWxvYWQucmVzdWx0ID09PSAnY2xpY2tlZCcpIHtcbiAgICAgKiAgICAgICAgICAgIGlmIChwYXlsb2FkLmRhdGEudG9waWMgPT09ICdjb2xvci1jaGFuZ2VkJykge1xuICAgICAqICAgICAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBsaWtlXG4gICAgICogICAgICAgICAgICAgICAgLy8gc2V0Q29sb3IocGF5bG9hZC5kYXRhLnZhbHVlKTtcbiAgICAgKiAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBhd2FpdCBmaW4ubWUuc2hvd1BvcHVwV2luZG93KHtcbiAgICAgKiAgICAgaW5pdGlhbE9wdGlvbnM6IHtcbiAgICAgKiAgICAgICAgIGZyYW1lOiBmYWxzZVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBuYW1lOiAnbXktcG9wdXAnLCAvLyBzaG93cyB0aGUgJ215LXBvcHVwJyB3aW5kb3cgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgY3JlYXRlcyBpdFxuICAgICAqICAgICB1cmw6ICc8bXlfcG9wdXBfdXJsPicsIC8vIG5hdmlnYXRlcyB0byB0aGlzIHVybCBpZiBpdCBkb2Vzbid0IG1hdGNoIHRoZSBsb2NhdGlvbi5ocmVmIG9mIHRoZSAnbXktcG9wdXAnIHdpbmRvd1xuICAgICAqICAgICByZXN1bHREaXNwYXRjaEJlaGF2aW9yOiAnbm9uZScsXG4gICAgICogICAgIGJsdXJCZWhhdmlvcjogJ2hpZGUnLFxuICAgICAqICAgICBmb2N1czogdHJ1ZSxcbiAgICAgKiAgICAgaGlkZU9uQ2xvc2U6IHRydWUsIC8vIHdlIGNhbiBqdXN0IHVzZSB0aGlzIG9yIHdlIGNhbiBjaGFuZ2UgYmx1ckJlaGF2aW9yIHRvICdoaWRlJ1xuICAgICAqICAgICBoZWlnaHQ6IDMwMCxcbiAgICAgKiAgICAgd2lkdGg6IDMwMCxcbiAgICAgKiAgICAgeDogMCxcbiAgICAgKiAgICAgeTogMCxcbiAgICAgKiAgICAgb25Qb3B1cFJlc3VsdDogcG9wdXBSZXN1bHRDYWxsYmFja1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQ3JlYXRlIG9yIHNob3cgYSBwb3B1cCB3aW5kb3cgdGhhdCBkaXNhYmxlcyB1c2VyIG1vdmVtZW50IChwb3NpdGlvbmluZyBhbmQgcmVzaXppbmcpIGluIHRoZSBjYWxsZXJcbiAgICAgKiB2aWV3J3MgcGFyZW50IHdpbmRvdyBieSB1c2luZyBgYmx1ckJlaGF2aW9yOiAnbW9kYWwnYDpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZmluLm1lLnNob3dQb3B1cFdpbmRvdyh7XG4gICAgICogICAgIGluaXRpYWxPcHRpb25zOiB7XG4gICAgICogICAgICAgICBmcmFtZTogZmFsc2VcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgdXJsOiAnPG15X3BvcHVwX3VybD4nLFxuICAgICAqICAgICByZXN1bHREaXNwYXRjaEJlaGF2aW9yOiAnY2xvc2UnLFxuICAgICAqICAgICBibHVyQmVoYXZpb3I6ICdtb2RhbCcsXG4gICAgICogICAgIGZvY3VzOiB0cnVlLFxuICAgICAqICAgICBoZWlnaHQ6IDMwMCxcbiAgICAgKiAgICAgd2lkdGg6IDMwMCxcbiAgICAgKiAgICAgeDogMCxcbiAgICAgKiAgICAgeTogMFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgcG9wdXAgd2luZG93IGFzIGEgbW9kYWw6XG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgb25seSB3YXkgdG8gZW5zdXJlIHRydWUgbW9kYWwgYmVoYXZpb3IgaXMgdG8gY3JlYXRlIHRoZSB3aW5kb3cgYmVpbmcgc2hvd24gYXMgYSBwb3B1cCB3aXRoIGFcbiAgICAgKiBgbW9kYWxQYXJlbnRJZGVudGl0eWAgdGhhdCB1c2VzIHRoZSBjYWxsZXIgdmlldydzIHBhcmVudCB3aW5kb3cgaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbi5tZS5zaG93UG9wdXBXaW5kb3coe1xuICAgICAqICAgICBpbml0aWFsT3B0aW9uczoge1xuICAgICAqICAgICAgICAgZnJhbWU6IGZhbHNlLFxuICAgICAqICAgICAgICAgbW9kYWxQYXJlbnRJZGVudGl0eTogZmluLm1lLmlkZW50aXR5XG4gICAgICogICAgIH0sXG4gICAgICogICAgIHVybDogJzxteV9wb3B1cF91cmw+JyxcbiAgICAgKiAgICAgcmVzdWx0RGlzcGF0Y2hCZWhhdmlvcjogJ2Nsb3NlJyxcbiAgICAgKiAgICAgYmx1ckJlaGF2aW9yOiAnbW9kYWwnLFxuICAgICAqICAgICBmb2N1czogdHJ1ZSxcbiAgICAgKiAgICAgaGVpZ2h0OiAzMDAsXG4gICAgICogICAgIHdpZHRoOiAzMDAsXG4gICAgICogICAgIHg6IDAsXG4gICAgICogICAgIHk6IDBcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFBhc3MgZGF0YSB0byBhIHBvcHVwIHdpbmRvdyB0aGF0IGlzIGF2YWlsYWJsZSB3aGVuIHRoZSBwb3B1cCBpcyBzaG93bi5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgaXMganVzdCBvbmUgZXhhbXBsZSBmb3IgYSB1c2Ugb2YgYGFkZGl0aW9uYWxPcHRpb25zYCwgaXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGFueSB1cGRhdGFibGVcbiAgICAgKiB3aW5kb3cgb3B0aW9ucyB3aGVuIGNyZWF0aW5nIG9yIHNob3dpbmcgYW4gZXhpc3Rpbmcgd2luZG93IGFzIGEgcG9wdXAuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbi5tZS5zaG93UG9wdXBXaW5kb3coe1xuICAgICAqICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xuICAgICAqICAgICAgICAgY3VzdG9tRGF0YToge1xuICAgICAqICAgICAgICAgICAgIGZvbzogJ2JhcidcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgdXJsOiAnPG15X3BvcHVwX3VybD4nLFxuICAgICAqICAgICByZXN1bHREaXNwYXRjaEJlaGF2aW9yOiAnY2xvc2UnLFxuICAgICAqICAgICBibHVyQmVoYXZpb3I6ICdjbG9zZScsXG4gICAgICogICAgIGZvY3VzOiB0cnVlLFxuICAgICAqICAgICBoZWlnaHQ6IDMwMCxcbiAgICAgKiAgICAgd2lkdGg6IDMwMCxcbiAgICAgKiAgICAgeDogMCxcbiAgICAgKiAgICAgeTogMFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gQWNjZXNzIGZyb20gdGhlIHBvcHVwIHdpbmRvdyBjb250ZXh0IGxpa2Ugc286XG4gICAgICogY29uc3QgeyBjdXN0b21EYXRhIH0gPSBhd2FpdCBmaW4ubWUuZ2V0T3B0aW9ucygpO1xuICAgICAqIGNvbnN0IHsgZm9vIH0gPSBjdXN0b21EYXRhO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIG9uIHRoZSBwb3B1cCdzIE9wZW5GaW4gd2luZG93IHdoZW4gdGhlIHBvcHVwIGlzIHNob3duOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwb3B1cFdpbmRvd0NhbGxiYWNrID0gYXN5bmMgKHdpbikgPT4ge1xuICAgICAqICAgICBhd2FpdCB3aW4uZmxhc2goKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZmluLm1lLnNob3dQb3B1cFdpbmRvdyh7XG4gICAgICogICAgIHVybDogJzxteV9wb3B1cF91cmw+JyxcbiAgICAgKiAgICAgcmVzdWx0RGlzcGF0Y2hCZWhhdmlvcjogJ2Nsb3NlJyxcbiAgICAgKiAgICAgYmx1ckJlaGF2aW9yOiAnY2xvc2UnLFxuICAgICAqICAgICBmb2N1czogdHJ1ZSxcbiAgICAgKiAgICAgaGVpZ2h0OiAzMDAsXG4gICAgICogICAgIHdpZHRoOiAzMDAsXG4gICAgICogICAgIHg6IDAsXG4gICAgICogICAgIHk6IDAsXG4gICAgICogICAgIG9uUG9wdXBSZWFkeTogcG9wdXBXaW5kb3dDYWxsYmFjaztcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIGBXZWJDb250ZW50c2AgcmVmZXJzIHRvIHNoYXJlZCBmdW5jdGlvbmFsaXR5IGJldHdlZW4ge0BsaW5rIE9wZW5GaW4uV2luZG93fSBhbmQge0BsaW5rIE9wZW5GaW4uVmlld30uXG4gICAgICogV2UgZG8gbm90IGV4cG9zZSBhbiBleHBsaWNpdCBzdXBlcmNsYXNzIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHksIGJ1dCBpdCBkb2VzIGhhdmUgaXRzIG93blxuICAgICAqIHtAbGluayBPcGVuRmluLldlYkNvbnRlbnRzRXZlbnRzIGV2ZW50IG5hbWVzcGFjZX0uXG4gICAgICovXG4gICAgYXN5bmMgc2hvd1BvcHVwV2luZG93KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oYCR7dGhpcy5lbnRpdHlUeXBlfS1zaG93LXBvcHVwLXdpbmRvd2AsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm9uUG9wdXBSZWFkeSkge1xuICAgICAgICAgICAgY29uc3QgcmVhZHlMaXN0ZW5lciA9IGFzeW5jICh7IHBvcHVwTmFtZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9wdXBXaW5kb3cgPSB0aGlzLmZpbi5XaW5kb3cud3JhcFN5bmMoeyB1dWlkOiB0aGlzLmZpbi5tZS51dWlkLCBuYW1lOiBwb3B1cE5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG9wdGlvbnMub25Qb3B1cFJlYWR5KHBvcHVwV2luZG93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIG9uUG9wdXBSZWFkeSBleGVjdXRpb246ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRPRE86IGZpeCB0eXBpbmcgKGludGVybmFsKVxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5vbmNlKCdwb3B1cC1yZWFkeScsIHJlYWR5TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZDogdHJ5Q3JlYXRlUGF5bG9hZCB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3RyeS1jcmVhdGUtcG9wdXAtd2luZG93Jywge1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGhhc1Jlc3VsdENhbGxiYWNrOiAhIW9wdGlvbnM/Lm9uUG9wdXBSZXN1bHQsXG4gICAgICAgICAgICAgICAgaGFzUmVhZHlDYWxsYmFjazogISFvcHRpb25zPy5vblBvcHVwUmVhZHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgd2lsbE9wZW4sIG9wdGlvbnM6IHBvcHVwT3B0aW9ucyB9IH0gPSB0cnlDcmVhdGVQYXlsb2FkO1xuICAgICAgICBpZiAod2lsbE9wZW4pIHtcbiAgICAgICAgICAgIC8vIFNvbHZlIHRoZSBpc3N1ZSB3aGVyZSBJbnRlcm9wIGluIGEgcG9wdXAgd2luZG93IHdpdGggbm9uIGNyb3NzLW9yaWdpbiB1cmwgaXMgbm90IHdvcmtpbmcoY29yZS0xMDc2KS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmluLldpbmRvdy5jcmVhdGUocG9wdXBPcHRpb25zLmluaXRpYWxPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3JtYWxpemVQb3B1cFJlc3VsdCA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHV1aWQsIHJlc3VsdCwgZGF0YSB9ID0gcGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IHBvcHVwUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGlkZW50aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHV1aWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcG9wdXBSZXN1bHQuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9wdXBSZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zPy5vblBvcHVwUmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwYXRjaFJlc3VsdExpc3RlbmVyID0gYXN5bmMgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvcHRpb25zLm9uUG9wdXBSZXN1bHQobm9ybWFsaXplUG9wdXBSZXN1bHQocGF5bG9hZCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRlYXJkb3duTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZml4IHR5cGluZyAoaW50ZXJuYWwpXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3BvcHVwLXJlc3VsdCcsIGRpc3BhdGNoUmVzdWx0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRPRE86IGZpeCB0eXBpbmcgKGludGVybmFsKVxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5vbigncG9wdXAtcmVzdWx0JywgZGlzcGF0Y2hSZXN1bHRMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggdHlwaW5nIChpbnRlcm5hbClcbiAgICAgICAgICAgIC8vIGhpbGFyaW91c2x5IHRoaXMgZG9lcyBub3QgbmVlZCBhIHRzLWV4cGVjdC1lcnJvciAtIHRoaXMgaXMgZ2FwIGluIHR5cGUgc291bmRuZXNzXG4gICAgICAgICAgICAvLyBzaG91bGQgaW52ZXN0aWdhdGUgLSBwcm9iYWJseSBkdWUgdG8gYHRlYXJkb3duTGlzdGVuZXJgIHRha2luZyBhIHZvaWQgYXJndW1lbnRcbiAgICAgICAgICAgIC8vIHdoaWNoIG1pZ2h0IHBsYXkgbmljZWx5IHdpdGggdGhlIGBuZXZlcmAgdHlwZT8gIGh1aC4uLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5vbmNlKCdwb3B1cC10ZWFyZG93bicsIHRlYXJkb3duTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Nob3ctcG9wdXAtd2luZG93Jywge1xuICAgICAgICAgICAgb3B0aW9uczogcG9wdXBPcHRpb25zLFxuICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcbiAgICB9XG59XG5tYWluLldlYkNvbnRlbnRzID0gV2ViQ29udGVudHM7XG5cbnZhciBoYXNSZXF1aXJlZEluc3RhbmNlJDI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbnN0YW5jZSQyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5zdGFuY2UkMikgcmV0dXJuIEluc3RhbmNlJDU7XG5cdGhhc1JlcXVpcmVkSW5zdGFuY2UkMiA9IDE7XG5cdHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcblx0ICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcblx0ICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuXHQgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcblx0fTtcblx0dmFyIF9WaWV3X3Byb3ZpZGVyQ2hhbm5lbENsaWVudDtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbmNlJDUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRJbnN0YW5jZSQ1LlZpZXcgPSB2b2lkIDA7XG5cdGNvbnN0IHRyYW5zcG9ydF9lcnJvcnNfMSA9IHRyYW5zcG9ydEVycm9ycztcblx0Y29uc3QgbGF6eV8xID0gbGF6eTtcblx0Y29uc3QgbGF5b3V0X2VudGl0aWVzXzEgPSBsYXlvdXRFbnRpdGllcztcblx0Y29uc3QgbGF5b3V0X2NvbnN0YW50c18xID0gbGF5b3V0X2NvbnN0YW50cztcblx0Y29uc3QgbWFpbl8xID0gbWFpbjtcblx0Y29uc3Qgd2luZG93XzEgPSByZXF1aXJlV2luZG93KCk7XG5cdC8qKlxuXHQgKiBBIFZpZXcgY2FuIGJlIHVzZWQgdG8gZW1iZWQgYWRkaXRpb25hbCB3ZWIgY29udGVudCBpbnRvIGEgV2luZG93LlxuXHQgKiBJdCBpcyBsaWtlIGEgY2hpbGQgd2luZG93LCBleGNlcHQgaXQgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0byBpdHMgb3duaW5nIHdpbmRvdy5cblx0ICogSXQgaGFzIHRoZSBhYmlsaXR5IHRvIGxpc3RlbiBmb3Ige0BsaW5rIE9wZW5GaW4uVmlld0V2ZW50cyBWaWV3LXNwZWNpZmljIGV2ZW50c30uXG5cdCAqXG5cdCAqIEJ5IGRlZmF1bHQsIGEgVmlldyB3aWxsIHRyeSB0byBzaGFyZSB0aGUgc2FtZSByZW5kZXJlciBwcm9jZXNzIGFzIG90aGVyIFZpZXdzIG93bmVkIGJ5IGl0cyBwYXJlbnQgQXBwbGljYXRpb24uXG5cdCAqIFRvIGNoYW5nZSB0aGF0IGJlaGF2aW9yLCBzZWUgdGhlIHByb2Nlc3NBZmZpbml0eSB7QGxpbmsgT3BlbkZpbi5WaWV3T3B0aW9ucyB2aWV3IG9wdGlvbn0uXG5cdCAqXG5cdCAqIEEgVmlldydzIGxpZmVjeWNsZSBpcyB0aWVkIHRvIGl0cyBvd25pbmcgd2luZG93IGFuZCBjYW4gYmUgcmUtYXR0YWNoZWQgdG8gYSBkaWZmZXJlbnQgd2luZG93IGF0IGFueSBwb2ludCBkdXJpbmcgaXRzIGxpZmVjeWNsZS5cblx0ICovXG5cdGNsYXNzIFZpZXcgZXh0ZW5kcyBtYWluXzEuV2ViQ29udGVudHMge1xuXHQgICAgLyoqXG5cdCAgICAgKiBAaW50ZXJuYWxcblx0ICAgICAqL1xuXHQgICAgY29uc3RydWN0b3Iod2lyZSwgaWRlbnRpdHkpIHtcblx0ICAgICAgICBzdXBlcih3aXJlLCBpZGVudGl0eSwgJ3ZpZXcnKTtcblx0ICAgICAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5cdCAgICAgICAgX1ZpZXdfcHJvdmlkZXJDaGFubmVsQ2xpZW50LnNldCh0aGlzLCBuZXcgbGF6eV8xLkxhenkoKCkgPT4ge1xuXHQgICAgICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMuZmluLlBsYXRmb3JtLndyYXBTeW5jKHRoaXMuaWRlbnRpdHkpO1xuXHQgICAgICAgICAgICByZXR1cm4gcGxhdGZvcm0uZ2V0Q2xpZW50KCk7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEF0dGFjaGVzIHRoZSBjdXJyZW50IHZpZXcgdG8gdGhlIGdpdmVuIHdpbmRvdyBpZGVudGl0eS5cblx0ICAgICAgICAgKiBJZGVudGl0eSBtdXN0IGJlIHRoZSBpZGVudGl0eSBvZiBhIHdpbmRvdyBpbiB0aGUgc2FtZSBhcHBsaWNhdGlvbi5cblx0ICAgICAgICAgKiBUaGlzIGRldGFjaGVzIHRoZSB2aWV3IGZyb20gaXRzIGN1cnJlbnQgd2luZG93LCBhbmQgc2V0cyB0aGUgdmlldyB0byBiZSBkZXN0cm95ZWQgd2hlbiBpdHMgbmV3IHdpbmRvdyBjbG9zZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIGBgYGpzXG5cdCAgICAgICAgICogbGV0IHZpZXc7XG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmlldygpIHtcblx0ICAgICAgICAgKiAgICAgY29uc3QgbWUgPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAgICAgKiAgICAgcmV0dXJuIGZpbi5WaWV3LmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBuYW1lOiAndmlld05hbWVBdHRhY2gnLFxuXHQgICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBtZS5pZGVudGl0eSxcblx0ICAgICAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gYXR0YWNoVmlldygpIHtcblx0ICAgICAgICAgKiAgICAgdmlldyA9IGF3YWl0IGNyZWF0ZVZpZXcoKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgY3JlYXRlZC4nKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBhd2FpdCB2aWV3Lm5hdmlnYXRlKCdodHRwczovL2dvb2dsZS5jb20nKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgbmF2aWdhdGVkIHRvIGdpdmVuIHVybC4nKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBjb25zdCB3aW5PcHRpb24gPSB7XG5cdCAgICAgICAgICogICAgICAgICBuYW1lOid3aW5PcHRpb25OYW1lJyxcblx0ICAgICAgICAgKiAgICAgICAgIGRlZmF1bHRXaWR0aDogMzAwLFxuXHQgICAgICAgICAqICAgICAgICAgZGVmYXVsdEhlaWdodDogMzAwLFxuXHQgICAgICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5jcmVhdGUuaHRtbCcsXG5cdCAgICAgICAgICogICAgICAgICBmcmFtZTogdHJ1ZSxcblx0ICAgICAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgICAgICogICAgIH07XG5cdCAgICAgICAgICogICAgIGNvbnN0IG5ld1dpbmRvdyA9IGF3YWl0IGZpbi5XaW5kb3cuY3JlYXRlKHdpbk9wdGlvbik7XG5cdCAgICAgICAgICogICAgIHZpZXcuYXR0YWNoKG5ld1dpbmRvdy5pZGVudGl0eSk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogYXR0YWNoVmlldygpXG5cdCAgICAgICAgICogICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdWaWV3IGF0dGFjaGVkIHRvIG5ldyB3aW5kb3cuJykpXG5cdCAgICAgICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgICAgICogYGBgXG5cdCAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMuYXR0YWNoID0gYXN5bmMgKHRhcmdldCkgPT4ge1xuXHQgICAgICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignYXR0YWNoLXZpZXcnLCB7IHRhcmdldCwgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlc3Ryb3lzIHRoZSBjdXJyZW50IHZpZXdcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogYGBganNcblx0ICAgICAgICAgKiBjb25zdCB2aWV3ID0gZmluLlZpZXcud3JhcFN5bmMoeyB1dWlkOiAndmlld1V1aWQnLCBuYW1lOiAndmlld05hbWUnIH0pO1xuXHQgICAgICAgICAqIHZpZXcuZGVzdHJveSgpO1xuXHQgICAgICAgICAqIGBgYFxuXHQgICAgICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLmRlc3Ryb3kgPSBhc3luYyAoKSA9PiB7XG5cdCAgICAgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdkZXN0cm95LXZpZXcnLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTaG93cyB0aGUgY3VycmVudCB2aWV3IGlmIGl0IGlzIGN1cnJlbnRseSBoaWRkZW4uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIGBgYGpzXG5cdCAgICAgICAgICogbGV0IHZpZXc7XG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmlldygpIHtcblx0ICAgICAgICAgKiAgICAgY29uc3QgbWUgPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAgICAgKiAgICAgcmV0dXJuIGZpbi5WaWV3LmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBuYW1lOiAndmlld05hbWVTaG93Jyxcblx0ICAgICAgICAgKiAgICAgICAgIHRhcmdldDogbWUuaWRlbnRpdHksXG5cdCAgICAgICAgICogICAgICAgICBib3VuZHM6IHt0b3A6IDEwLCBsZWZ0OiAxMCwgd2lkdGg6IDIwMCwgaGVpZ2h0OiAyMDB9XG5cdCAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAqIH1cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIGFzeW5jIGZ1bmN0aW9uIGhpZGVBbmRTaG93VmlldygpIHtcblx0ICAgICAgICAgKiAgICAgdmlldyA9IGF3YWl0IGNyZWF0ZVZpZXcoKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgY3JlYXRlZC4nKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBhd2FpdCB2aWV3Lm5hdmlnYXRlKCdodHRwczovL2dvb2dsZS5jb20nKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgbmF2aWdhdGVkIHRvIGdpdmVuIHVybCBvcHRpb24uJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYXdhaXQgdmlldy5oaWRlKCk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKFwiVmlldyBoaWRkZW4uXCIpO1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZpZXcuc2hvdygpO1xuXHQgICAgICAgICAqICAgICBjb25zb2xlLmxvZyhcIlZpZXcgc2hvd24uXCIpO1xuXHQgICAgICAgICAqIH1cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIGhpZGVBbmRTaG93VmlldygpXG5cdCAgICAgICAgICogICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdWaWV3IGhpZGRlbiBhbmQgc2hvd24uJykpXG5cdCAgICAgICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgICAgICogYGBgXG5cdCAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMuc2hvdyA9IGFzeW5jICgpID0+IHtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Nob3ctdmlldycsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNldHMgdGhlIGJvdW5kcyAodG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KSBvZiB0aGUgdmlldyByZWxhdGl2ZSB0byBpdHMgd2luZG93IGFuZCBzaG93cyBpdCBpZiBpdCBpcyBoaWRkZW4uXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgdmlldyBpcyBib3RoIHBvc2l0aW9uZWQgYW5kIHNob3dpbmcuIEl0IHdpbGwgcmVwb3NpdGlvbiBhIHZpc2libGUgdmlldyBhbmQgYm90aCBzaG93IGFuZCByZXBvc2l0aW9uIGEgaGlkZGVuIHZpZXcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmVtYXJrcyBWaWV3IHBvc2l0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIHdpbmRvdy5cblx0ICAgICAgICAgKiAoe3RvcDogMCwgbGVmdDogMH0gcmVwcmVzZW50cyB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3cpXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIGBgYGpzXG5cdCAgICAgICAgICogbGV0IHZpZXc7XG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmlldygpIHtcblx0ICAgICAgICAgKiAgICAgY29uc3QgbWUgPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAgICAgKiAgICAgcmV0dXJuIGZpbi5WaWV3LmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBuYW1lOiAndmlld05hbWVTZXRCb3VuZHMnLFxuXHQgICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBtZS5pZGVudGl0eSxcblx0ICAgICAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gc2hvd1ZpZXdBdCgpIHtcblx0ICAgICAgICAgKiAgICAgdmlldyA9IGF3YWl0IGNyZWF0ZVZpZXcoKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgY3JlYXRlZC4nKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBhd2FpdCB2aWV3Lm5hdmlnYXRlKCdodHRwczovL2dvb2dsZS5jb20nKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgbmF2aWdhdGVkIHRvIGdpdmVuIHVybC4nKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBhd2FpdCB2aWV3LnNob3dBdCh7XG5cdCAgICAgICAgICogICAgICAgICB0b3A6IDEwMCxcblx0ICAgICAgICAgKiAgICAgICAgIGxlZnQ6IDEwMCxcblx0ICAgICAgICAgKiAgICAgICAgIHdpZHRoOiAzMDAsXG5cdCAgICAgICAgICogICAgICAgICBoZWlnaHQ6IDMwMFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKiB9XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBzaG93Vmlld0F0KClcblx0ICAgICAgICAgKiAgICAgLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1ZpZXcgc2V0IHRvIG5ldyBib3VuZHMgYW5kIHNob3duLicpKVxuXHQgICAgICAgICAqICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICAgICAqIGBgYFxuXHQgICAgICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLnNob3dBdCA9IGFzeW5jIChib3VuZHMpID0+IHtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Nob3ctdmlldy1hdCcsIHsgYm91bmRzLCAuLi50aGlzLmlkZW50aXR5IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSGlkZXMgdGhlIGN1cnJlbnQgdmlldyBpZiBpdCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogYGBganNcblx0ICAgICAgICAgKiBsZXQgdmlldztcblx0ICAgICAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuXHQgICAgICAgICAqICAgICBjb25zdCBtZSA9IGF3YWl0IGZpbi5XaW5kb3cuZ2V0Q3VycmVudCgpO1xuXHQgICAgICAgICAqICAgICByZXR1cm4gZmluLlZpZXcuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIG5hbWU6ICd2aWV3TmFtZUhpZGUnLFxuXHQgICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBtZS5pZGVudGl0eSxcblx0ICAgICAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gaGlkZVZpZXcoKSB7XG5cdCAgICAgICAgICogICAgIHZpZXcgPSBhd2FpdCBjcmVhdGVWaWV3KCk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IGNyZWF0ZWQuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cHM6Ly9nb29nbGUuY29tJyk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IG5hdmlnYXRlZCB0byBnaXZlbiB1cmwuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYXdhaXQgdmlldy5oaWRlKCk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogaGlkZVZpZXcoKVxuXHQgICAgICAgICAqICAgICAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnVmlldyBoaWRkZW4uJykpXG5cdCAgICAgICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgICAgICogYGBgXG5cdCAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMuaGlkZSA9IGFzeW5jICgpID0+IHtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2hpZGUtdmlldycsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNldHMgdGhlIGJvdW5kcyAodG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KSBvZiB0aGUgdmlldyByZWxhdGl2ZSB0byBpdHMgd2luZG93LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJlbWFya3MgVmlldyBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSB3aW5kb3cuXG5cdCAgICAgICAgICogKHt0b3A6IDAsIGxlZnQ6IDB9IHJlcHJlc2VudHMgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93KVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKiBgYGBqc1xuXHQgICAgICAgICAqIGxldCB2aWV3O1xuXHQgICAgICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVZpZXcoKSB7XG5cdCAgICAgICAgICogICAgIGNvbnN0IG1lID0gYXdhaXQgZmluLldpbmRvdy5nZXRDdXJyZW50KCk7XG5cdCAgICAgICAgICogICAgIHJldHVybiBmaW4uVmlldy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgbmFtZTogJ3ZpZXdOYW1lU2V0Qm91bmRzJyxcblx0ICAgICAgICAgKiAgICAgICAgIHRhcmdldDogbWUuaWRlbnRpdHksXG5cdCAgICAgICAgICogICAgICAgICBib3VuZHM6IHt0b3A6IDEwLCBsZWZ0OiAxMCwgd2lkdGg6IDIwMCwgaGVpZ2h0OiAyMDB9XG5cdCAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAqIH1cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdCb3VuZHMoKSB7XG5cdCAgICAgICAgICogICAgIHZpZXcgPSBhd2FpdCBjcmVhdGVWaWV3KCk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IGNyZWF0ZWQuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cHM6Ly9nb29nbGUuY29tJyk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IG5hdmlnYXRlZCB0byBnaXZlbiB1cmwuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYXdhaXQgdmlldy5zZXRCb3VuZHMoe1xuXHQgICAgICAgICAqICAgICAgICAgdG9wOiAxMDAsXG5cdCAgICAgICAgICogICAgICAgICBsZWZ0OiAxMDAsXG5cdCAgICAgICAgICogICAgICAgICB3aWR0aDogMzAwLFxuXHQgICAgICAgICAqICAgICAgICAgaGVpZ2h0OiAzMDBcblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogc2V0Vmlld0JvdW5kcygpXG5cdCAgICAgICAgICogICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdWaWV3IHNldCB0byBuZXcgYm91bmRzLicpKVxuXHQgICAgICAgICAqICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICAgICAqIGBgYFxuXHQgICAgICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLnNldEJvdW5kcyA9IGFzeW5jIChib3VuZHMpID0+IHtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3NldC12aWV3LWJvdW5kcycsIHsgYm91bmRzLCAuLi50aGlzLmlkZW50aXR5IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogR2V0cyB0aGUgYm91bmRzICh0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQpIG9mIHRoZSB2aWV3IHJlbGF0aXZlIHRvIGl0cyB3aW5kb3cuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmVtYXJrcyBWaWV3IHBvc2l0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIHdpbmRvdy5cblx0ICAgICAgICAgKiAoe3RvcDogMCwgbGVmdDogMH0gcmVwcmVzZW50cyB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3cpXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIGBgYGpzXG5cdCAgICAgICAgICogY29uc3QgdmlldyA9IGF3YWl0IGZpbi5WaWV3LmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgIG5hbWU6ICd2aWV3TmFtZVNldEJvdW5kcycsXG5cdCAgICAgICAgICogICAgIHRhcmdldDogZmluLm1lLmlkZW50aXR5LFxuXHQgICAgICAgICAqICAgICBib3VuZHM6IHt0b3A6IDEwLCBsZWZ0OiAxMCwgd2lkdGg6IDIwMCwgaGVpZ2h0OiAyMDB9XG5cdCAgICAgICAgICogfSk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBhd2FpdCB2aWV3Lm5hdmlnYXRlKCdodHRwczovL2dvb2dsZS5jb20nKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIGF3YWl0IHZpZXcuc2V0Qm91bmRzKHtcblx0ICAgICAgICAgKiAgICAgdG9wOiAxMDAsXG5cdCAgICAgICAgICogICAgIGxlZnQ6IDEwMCxcblx0ICAgICAgICAgKiAgICAgd2lkdGg6IDMwMCxcblx0ICAgICAgICAgKiAgICAgaGVpZ2h0OiAzMDBcblx0ICAgICAgICAgKiB9KTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIGNvbnNvbGUubG9nKGF3YWl0IHZpZXcuZ2V0Qm91bmRzKCkpO1xuXHQgICAgICAgICAqIGBgYFxuXHQgICAgICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLmdldEJvdW5kcyA9IGFzeW5jICgpID0+IHtcblx0ICAgICAgICAgICAgY29uc3QgYWNrID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC12aWV3LWJvdW5kcycsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGFjay5wYXlsb2FkLmRhdGE7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBHZXRzIHRoZSBWaWV3J3MgaW5mby5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogYGBganNcblx0ICAgICAgICAgKiBsZXQgdmlldztcblx0ICAgICAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuXHQgICAgICAgICAqICAgICBjb25zdCBtZSA9IGF3YWl0IGZpbi5XaW5kb3cuZ2V0Q3VycmVudCgpO1xuXHQgICAgICAgICAqICAgICByZXR1cm4gZmluLlZpZXcuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIG5hbWU6ICd2aWV3TmFtZUdldEluZm8nLFxuXHQgICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBtZS5pZGVudGl0eSxcblx0ICAgICAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0Vmlld0luZm8oKSB7XG5cdCAgICAgICAgICogICAgIHZpZXcgPSBhd2FpdCBjcmVhdGVWaWV3KCk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IGNyZWF0ZWQuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cHM6Ly9nb29nbGUuY29tJyk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IG5hdmlnYXRlZCB0byBnaXZlbiB1cmwuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgcmV0dXJuIHZpZXcuZ2V0SW5mbygpO1xuXHQgICAgICAgICAqIH1cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIGdldFZpZXdJbmZvKClcblx0ICAgICAgICAgKiAgICAgLnRoZW4oKGluZm8pID0+IGNvbnNvbGUubG9nKCdWaWV3IGluZm8gZmV0Y2hlZC4nLCBpbmZvKSlcblx0ICAgICAgICAgKiAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAgICAgKiBgYGBcblx0ICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy5nZXRJbmZvID0gYXN5bmMgKCkgPT4ge1xuXHQgICAgICAgICAgICBjb25zdCBhY2sgPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXZpZXctaW5mbycsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGFjay5wYXlsb2FkLmRhdGE7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGxheW91dCBmb3IgdGhlIHdpbmRvdyB0aGUgdmlldyBpcyBhdHRhY2hlZCB0by5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogYGBganNcblx0ICAgICAgICAgKiAgICAgLy9nZXQgdGhlIGN1cnJlbnQgVmlld1xuXHQgICAgICAgICAqICAgICBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuZ2V0Q3VycmVudCgpO1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIC8vZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBMYXlvdXQgZm9yIHRoZSBXaW5kb3cgdGhlIHZpZXcgaXMgcGFydCBvZlxuXHQgICAgICAgICAqICAgICBjb25zdCBsYXlvdXQgPSBhd2FpdCB2aWV3LmdldFBhcmVudExheW91dCgpO1xuXHQgICAgICAgICAqIGBgYFxuXHQgICAgICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLmdldFBhcmVudExheW91dCA9IGFzeW5jICgpID0+IHtcblx0ICAgICAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ZpZXctZ2V0LXBhcmVudC1sYXlvdXQnLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSkuY2F0Y2goKCkgPT4ge1xuXHQgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBjb25zdCBsYXlvdXRXaW5kb3cgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRXaW5kb3coKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyQ2hhbm5lbENsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZXdfcHJvdmlkZXJDaGFubmVsQ2xpZW50LCBcImZcIikuZ2V0VmFsdWUoKTtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGxheW91dF9lbnRpdGllc18xLkxheW91dE5vZGUubmV3TGF5b3V0RW50aXRpZXNDbGllbnQocHJvdmlkZXJDaGFubmVsQ2xpZW50LCBsYXlvdXRfY29uc3RhbnRzXzEuTEFZT1VUX0NPTlRST0xMRVJfSUQsIGxheW91dFdpbmRvdy5pZGVudGl0eSk7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBsYXlvdXRJZGVudGl0eSA9IGF3YWl0IGNsaWVudC5nZXRMYXlvdXRJZGVudGl0eUZvclZpZXdPclRocm93KHRoaXMuaWRlbnRpdHkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluLlBsYXRmb3JtLkxheW91dC53cmFwKGxheW91dElkZW50aXR5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZEVycm9ycyA9IFtcblx0ICAgICAgICAgICAgICAgICAgICAnTm8gYWN0aW9uIHJlZ2lzdGVyZWQgYXQgdGFyZ2V0IGZvcicsXG5cdCAgICAgICAgICAgICAgICAgICAgJ2dldExheW91dElkZW50aXR5Rm9yVmlld09yVGhyb3cgaXMgbm90IGEgZnVuY3Rpb24nXG5cdCAgICAgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkRXJyb3JzLnNvbWUoKG0pID0+IGUubWVzc2FnZS5pbmNsdWRlcyhtKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgbG9naWMgZm9yIG1pc3NpbmcgZW5kcG9pbnRcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbi5QbGF0Zm9ybS5MYXlvdXQud3JhcChsYXlvdXRXaW5kb3cuaWRlbnRpdHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBHZXRzIHRoZSBWaWV3J3Mgb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogYGBganNcblx0ICAgICAgICAgKiBsZXQgdmlldztcblx0ICAgICAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuXHQgICAgICAgICAqICAgICBjb25zdCBtZSA9IGF3YWl0IGZpbi5XaW5kb3cuZ2V0Q3VycmVudCgpO1xuXHQgICAgICAgICAqICAgICByZXR1cm4gZmluLlZpZXcuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIG5hbWU6ICd2aWV3TmFtZUdldE9wdGlvbnMnLFxuXHQgICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBtZS5pZGVudGl0eSxcblx0ICAgICAgICAgKiAgICAgICAgIGJvdW5kczoge3RvcDogMTAsIGxlZnQ6IDEwLCB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMH1cblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICogfVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0Vmlld09wdGlvbnMoKSB7XG5cdCAgICAgICAgICogICAgIHZpZXcgPSBhd2FpdCBjcmVhdGVWaWV3KCk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IGNyZWF0ZWQuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSgnaHR0cHM6Ly9nb29nbGUuY29tJyk7XG5cdCAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdWaWV3IG5hdmlnYXRlZCB0byBnaXZlbiB1cmwuJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgY29uc3QgbWUgPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAgICAgKiAgICAgdmlldyA9IGZpbi5WaWV3LndyYXBTeW5jKHsgdXVpZDogbWUuaWRlbnRpdHkudXVpZCwgbmFtZTogJ3ZpZXdOYW1lR2V0T3B0aW9ucycgfSk7XG5cdCAgICAgICAgICogICAgIHJldHVybiB2aWV3LmdldE9wdGlvbnMoKTtcblx0ICAgICAgICAgKiB9XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBnZXRWaWV3T3B0aW9ucygpXG5cdCAgICAgICAgICogICAgIC50aGVuKChpbmZvKSA9PiBjb25zb2xlLmxvZygnVmlldyBvcHRpb25zIGZldGNoZWQuJywgaW5mbykpXG5cdCAgICAgICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgICAgICogYGBgXG5cdCAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyA9IGFzeW5jICgpID0+IHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtdmlldy1vcHRpb25zJywgeyAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGUgdmlldydzIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIGBgYGpzXG5cdCAgICAgICAgICogbGV0IHZpZXc7XG5cdCAgICAgICAgICogYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmlldygpIHtcblx0ICAgICAgICAgKiAgICAgY29uc3QgbWUgPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAgICAgKiAgICAgcmV0dXJuIGZpbi5WaWV3LmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2dvb2dsZS5jb20nLFxuXHQgICAgICAgICAqICAgICAgICAgbmFtZTogJ3ZpZXdOYW1lVXBkYXRlT3B0aW9ucycsXG5cdCAgICAgICAgICogICAgICAgICB0YXJnZXQ6IG1lLmlkZW50aXR5LFxuXHQgICAgICAgICAqICAgICAgICAgYm91bmRzOiB7dG9wOiAxMCwgbGVmdDogMTAsIHdpZHRoOiAyMDAsIGhlaWdodDogMjAwfVxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKiB9XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBhc3luYyBmdW5jdGlvbiB1cGRhdGVWaWV3T3B0aW9ucygpIHtcblx0ICAgICAgICAgKiAgICAgdmlldyA9IGF3YWl0IGNyZWF0ZVZpZXcoKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgY3JlYXRlZC4nKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBhd2FpdCB2aWV3Lm5hdmlnYXRlKCdodHRwczovL2dvb2dsZS5jb20nKTtcblx0ICAgICAgICAgKiAgICAgY29uc29sZS5sb2coJ1ZpZXcgbmF2aWdhdGVkIHRvIGdpdmVuIHVybCBvcHRpb24uJyk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHsgYXV0b1Jlc2l6ZToge1xuXHQgICAgICAgICAqICAgICAgICAgd2lkdGg6IHRydWUsXG5cdCAgICAgICAgICogICAgICAgICBob3Jpem9udGFsOiB0cnVlXG5cdCAgICAgICAgICogICAgIH19O1xuXHQgICAgICAgICAqICAgICByZXR1cm4gdmlldy51cGRhdGVPcHRpb25zKG5ld09wdGlvbnMpO1xuXHQgICAgICAgICAqIH1cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIHVwZGF0ZVZpZXdPcHRpb25zKClcblx0ICAgICAgICAgKiAgICAgLnRoZW4ocGF5bG9hZCA9PiBjb25zb2xlLmxvZygnVmlldyBvcHRpb25zIHVwZGF0ZWQ6ICcsIHBheWxvYWQpKVxuXHQgICAgICAgICAqICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICAgICAqIGBgYFxuXHQgICAgICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3VwZGF0ZS12aWV3LW9wdGlvbnMnLCB7IG9wdGlvbnMsIC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0cmlldmVzIHRoZSB3aW5kb3cgdGhlIHZpZXcgaXMgY3VycmVudGx5IGF0dGFjaGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKiBgYGBqc1xuXHQgICAgICAgICAqIGNvbnN0IHZpZXcgPSBmaW4uVmlldy53cmFwU3luYyh7IHV1aWQ6ICd2aWV3VXVpZCcsIG5hbWU6ICd2aWV3TmFtZScgfSk7XG5cdCAgICAgICAgICogdmlldy5nZXRDdXJyZW50V2luZG93KClcblx0ICAgICAgICAgKiAgICAgLnRoZW4od2luID0+IGNvbnNvbGUubG9nKCdjdXJyZW50IHdpbmRvdycsIHdpbikpXG5cdCAgICAgICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7KVxuXHQgICAgICAgICAqIGBgYFxuXHQgICAgICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLmdldEN1cnJlbnRXaW5kb3cgPSBhc3luYyAoKSA9PiB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhIH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtdmlldy13aW5kb3cnLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93XzEuX1dpbmRvdyh0aGlzLndpcmUsIGRhdGEpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHtAbGluayBPcGVuRmluLlRhYlN0YWNrfSBvZiB0aGUgdmlldyBpZiBpdCBiZWxvbmdzIHRvIG9uZS5cblx0ICAgICAgICAgKiBAcmV0dXJucyB0aGlzIHZpZXcgYmVsb25ncyB0by5cblx0ICAgICAgICAgKiBAdGhyb3dzIGlmIHRoaXMgdmlldyBkb2VzIG5vdCBiZWxvbmcgdG8gYSBUYWJTdGFjayBvciBpZiB0aGUgd2luZG93IGhhcyBiZWVuIGRlc3Ryb3llZC5cblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIGBgYGpzXG5cdCAgICAgICAgICogaWYgKCFmaW4ubWUuaXNWaWV3KSB7XG5cdCAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3LicpO1xuXHQgICAgICAgICAqIH1cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIGNvbnN0IHN0YWNrID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRTdGFjaygpO1xuXHQgICAgICAgICAqIC8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gd3JhcCBhbnkgdmlldyBhbmQgZ2V0IHRoZSBzdGFjayBmcm9tIHRoZXJlXG5cdCAgICAgICAgICogLy8gY29uc3Qgdmlld0Zyb21Tb21ld2hlcmUgPSBmaW4uVmlldy53cmFwU3luYyhzb21lVmlldy5pZGVudGl0eSk7XG5cdCAgICAgICAgICogLy8gY29uc3Qgc3RhY2sgPSBhd2FpdCB2aWV3RnJvbVNvbWV3aGVyZS5nZXRDdXJyZW50U3RhY2soKTtcblx0ICAgICAgICAgKiBjb25zdCB2aWV3cyA9IGF3YWl0IHN0YWNrLmdldFZpZXdzKCk7XG5cdCAgICAgICAgICogY29uc29sZS5sb2coYFN0YWNrIGNvbnRhaW5zICR7dmlld3MubGVuZ3RofSB2aWV3KHMpYCk7XG5cdCAgICAgICAgICogYGBgXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy5nZXRDdXJyZW50U3RhY2sgPSBhc3luYyAoKSA9PiB7XG5cdCAgICAgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd2aWV3LWdldC1jdXJyZW50LXN0YWNrJykuY2F0Y2goKCkgPT4ge1xuXHQgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0V2luZG93ID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50V2luZG93KCk7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlckNoYW5uZWxDbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWV3X3Byb3ZpZGVyQ2hhbm5lbENsaWVudCwgXCJmXCIpLmdldFZhbHVlKCk7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBsYXlvdXRfZW50aXRpZXNfMS5MYXlvdXROb2RlLm5ld0xheW91dEVudGl0aWVzQ2xpZW50KHByb3ZpZGVyQ2hhbm5lbENsaWVudCwgbGF5b3V0X2NvbnN0YW50c18xLkxBWU9VVF9DT05UUk9MTEVSX0lELCBsYXlvdXRXaW5kb3cuaWRlbnRpdHkpO1xuXHQgICAgICAgICAgICAgICAgY29uc3Qgc3RhY2tEZWZpbml0aW9uID0gKGF3YWl0IGNsaWVudC5nZXRTdGFja0J5Vmlldyh0aGlzLmlkZW50aXR5KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGF5b3V0X2VudGl0aWVzXzEuTGF5b3V0Tm9kZS5nZXRFbnRpdHkoc3RhY2tEZWZpbml0aW9uLCBjbGllbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHRyYW5zcG9ydF9lcnJvcnNfMS5SdW50aW1lRXJyb3IoeyByZWFzb246ICdUaGlzIHZpZXcgZG9lcyBub3QgYmVsb25nIHRvIGEgc3RhY2suJywgZXJyb3IgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFRyaWdnZXJzIHRoZSBiZWZvcmUtdW5sb2FkIGhhbmRsZXIgZm9yIHRoZSBWaWV3LCBpZiBvbmUgaXMgc2V0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJlbWFya3MgUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgdHJ5aW5nIHRvIHByZXZlbnQgdGhlIFZpZXcgZnJvbSB1bmxvYWRpbmcsIGFuZCBgZmFsc2VgIGlmIGl0IGlzbid0LlxuXHQgICAgICAgICAqIE9ubHkgZW5hYmxlZCB3aGVuIHNldHRpbmcgZW5hYmxlQmVmb3JlVW5sb2FkOiB0cnVlIGluIHlvdXIgVmlldyBvcHRpb25zLiBJZiB0aGlzIG9wdGlvbiBpcyBub3QgZW5hYmxlZCBpdCB3aWxsXG5cdCAgICAgICAgICogYWx3YXlzIHJldHVybiBmYWxzZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgUGxhdGZvcm0gUHJvdmlkZXIgdG8gZGV0ZXJtaW5lIHRoZSBzdGF0dXMgb2YgZWFjaCBiZWZvcmUgdW5sb2FkIGhhbmRsZXIgaW4gVmlld3Mgd2hlbiBjbG9zaW5nIHRoZSBXaW5kb3cuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogYGBganNcblx0ICAgICAgICAgKiAvLyBmcm9tIGluc2lkZSBhIFZpZXcgY29udGV4dFxuXHQgICAgICAgICAqIGNvbnN0IHVubG9hZFByZXZlbnRlZCA9IGF3YWl0IGZpbi5tZS50cmlnZ2VyQmVmb3JlVW5sb2FkKCk7XG5cdCAgICAgICAgICogYGBgXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQmVmb3JlVW5sb2FkID0gYXN5bmMgKCkgPT4ge1xuXHQgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3RyaWdnZXItYmVmb3JlLXVubG9hZCcsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UucGF5bG9hZC5kYXRhO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogKipOT1RFKio6IEludGVybmFsIHVzZSBvbmx5LlxuXHQgICAgICAgICAqIEF0dGFjaGVzIHRoaXMgdmlldyB0byBhbiBIVE1MIGVsZW1lbnQgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gVGhlIHZpZXcgd2lsbCByZXNpemUgcmVzcG9uc2l2ZWx5IHdoZW4gdGhlIGVsZW1lbnQgYm91bmRzIGNoYW5nZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICoqS25vd24gaXNzdWUqKjogVmlldy5iaW5kVG9FbGVtZW50IGRvZXMgbm90IHRyYWNrIHBvc2l0aW9uIGNoYW5nZXMsIGlmIHRoZSBlbGVtZW50IGhhcyBmaXhlZCBweCB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHZpZXcgdG8gbm90IHVwZGF0ZSByZXNwb25zaXZlbHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAqKktub3duIGlzc3VlKio6IFdoZW4gVmlldy5iaW5kVG9FbGVtZW50IGlzIHVzZWQgb24gYSBlbGVtZW50IHRoYXQgdGFrZXMgdXAgdGhlIGVudGlyZSBwYWdlIGluIGEgcGxhdGZvcm0gd2luZG93LCB0aGUgYm91bmQgdmlldyB3aWxsIG5vdCByZXNwb25kIHJlc3BvbnNpdmVseSB3aGVuIHRoZSB3aW5kb3cgaXMgcmVzaXplZCB0byBiZSBzbWFsbGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgLSBIVE1MIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSB2aWV3IHRvLlxuXHQgICAgICAgICAqIEByZXR1cm5zIC0gQ2xlYW51cCBmdW5jdGlvbiB0aGF0IHdpbGwgZGlzY29ubmVjdCB0aGUgZWxlbWVudCByZXNpemUgb2JzZXJ2ZXIuXG5cdCAgICAgICAgICogQGludGVybmFsXG5cdCAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICAgICAqIEByZW1hcmtzIFZpZXcgd2lsbCByZXNpemUgYWNjb3JkaW5nbHkgd2hlbiB0aGUgZWxlbWVudCBpcyByZXNpemVkLiBJZiB0aGUgZWxlbWVudCBpcyByZXBvc2l0aW9uZWQgaW4gdGhlIERPTSB0aGUgdmlldyB3aWxsIG5vdCBiZSByZXBvc2l0aW9uZWQsIHRvIGhhbmRsZSB0aGlzIGNhc2UgY2FsbCBgYmluZFRvRWxlbWVudGAgYWdhaW4gb25jZSB0aGUgZWxlbWVudCBjaGFuZ2VzIHBvc2l0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKiBgYGBodG1sXG5cdCAgICAgICAgICogPGRpdiBpZD1cInZpZXctY29udGFpbmVyXCI+PC9kaXY+XG5cdCAgICAgICAgICogPHNjcmlwdD5cblx0ICAgICAgICAgKiAgICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQW5kQXR0YWNoVmlldygpIHtcblx0ICAgICAgICAgKiAgICAgICAgIGNvbnN0IHVybCA9ICdodHRwczovL2V4YW1wbGUuY29tJztcblx0ICAgICAgICAgKiAgICAgICAgIGNvbnN0IGVsZW1lbnRJZCA9ICd2aWV3LWNvbnRhaW5lcic7XG5cdCAgICAgICAgICogICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKTtcblx0ICAgICAgICAgKiAgICAgICAgIGNvbnN0IHZpZXcgPSBhd2FpdCBmaW4uVmlldy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgICAgIG5hbWU6ICdteS12aWV3Jyxcblx0ICAgICAgICAgKiAgICAgICAgICAgICB1cmwsXG5cdCAgICAgICAgICogICAgICAgICAgICAgdGFyZ2V0OiBmaW4ubWUuaWRlbnRpdHlcblx0ICAgICAgICAgKiAgICAgICAgIH0pO1xuXHQgICAgICAgICAqICAgICAgICAgYXdhaXQgdmlldy5uYXZpZ2F0ZSh1cmwpO1xuXHQgICAgICAgICAqICAgICAgICAgYXdhaXQgdmlldy5iaW5kVG9FbGVtZW50KGVsZW1lbnQpO1xuXHQgICAgICAgICAqICAgICB9XG5cdCAgICAgICAgICogICAgIGNyZWF0ZUFuZEF0dGFjaFZpZXcoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcblx0ICAgICAgICAgKiA8L3NjcmlwdD5cblx0ICAgICAgICAgKiBgYGBcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLmJpbmRUb0VsZW1lbnQgPSBhc3luYyAoZWxlbWVudCkgPT4ge1xuXHQgICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBub3QgZm91bmQuJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAoYm91bmRzKSA9PiB0aGlzLnNldEJvdW5kcyhib3VuZHMpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLmVudmlyb25tZW50Lm9ic2VydmVCb3VuZHMoZWxlbWVudCwgb25DaGFuZ2UpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEZvY3VzZXMgdGhlIHZpZXdcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGNvbnN0IHZpZXcgPSBmaW4uVmlldy53cmFwU3luYyh7IHV1aWQ6ICd2aWV3VXVpZCcsIG5hbWU6ICd2aWV3TmFtZScgfSk7XG5cdCAgICAgKiBhd2FpdCB2aWV3LmZvY3VzKCk7XG5cdCAgICAgKiAvLyBkbyB0aGluZ3Mgd2l0aCB0aGUgZm9jdXNlZCB2aWV3XG5cdCAgICAgKiBgYGBcblx0ICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAqL1xuXHQgICAgYXN5bmMgZm9jdXMoeyBlbWl0U3ludGhGb2N1c2VkIH0gPSB7IGVtaXRTeW50aEZvY3VzZWQ6IHRydWUgfSkge1xuXHQgICAgICAgIGNvbnN0IHdpbiA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFdpbmRvdygpO1xuXHQgICAgICAgIGF3YWl0IHdpbi5mb2N1c2VkV2ViVmlld1dhc0NoYW5nZWQoKTtcblx0ICAgICAgICBhd2FpdCBzdXBlci5mb2N1cyh7IGVtaXRTeW50aEZvY3VzZWQgfSk7XG5cdCAgICB9XG5cdH1cblx0SW5zdGFuY2UkNS5WaWV3ID0gVmlldztcblx0X1ZpZXdfcHJvdmlkZXJDaGFubmVsQ2xpZW50ID0gbmV3IFdlYWtNYXAoKTtcblx0cmV0dXJuIEluc3RhbmNlJDU7XG59XG5cbnZhciBoYXNSZXF1aXJlZFZpZXc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVWaWV3ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVmlldykgcmV0dXJuIHZpZXc7XG5cdGhhc1JlcXVpcmVkVmlldyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdHZhciBfX2NyZWF0ZUJpbmRpbmcgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuXHRcdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHRcdCAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cdFx0ICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG5cdFx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuXHRcdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdFx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdFx0ICAgIG9bazJdID0gbVtrXTtcblx0XHR9KSk7XG5cdFx0dmFyIF9fZXhwb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcblx0XHQgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xuXHRcdH07XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdC8qKlxuXHRcdCAqIEVudHJ5IHBvaW50cyBmb3IgdGhlIE9wZW5GaW4gYFZpZXdgIEFQSSAoYGZpbi5WaWV3YCkuXG5cdFx0ICpcblx0XHQgKiAqIHtAbGluayBWaWV3TW9kdWxlfSBjb250YWlucyBzdGF0aWMgbWVtYmVycyBvZiB0aGUgYFZpZXdgIEFQSSwgYWNjZXNzaWJsZSB0aHJvdWdoIGBmaW4uVmlld2AuXG5cdFx0ICogKiB7QGxpbmsgVmlld30gZGVzY3JpYmVzIGFuIGluc3RhbmNlIG9mIGFuIE9wZW5GaW4gVmlldywgZS5nLiBhcyByZXR1cm5lZCBieSBgZmluLlZpZXcuZ2V0Q3VycmVudGAuXG5cdFx0ICpcblx0XHQgKiBUaGVzZSBhcmUgc2VwYXJhdGUgY29kZSBlbnRpdGllcywgYW5kIGFyZSBkb2N1bWVudGVkIHNlcGFyYXRlbHkuICBJbiB0aGUgW3ByZXZpb3VzIHZlcnNpb24gb2YgdGhlIEFQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC8zMi4xMTQuNzYuMTAvaW5kZXguaHRtbCksXG5cdFx0ICogYm90aCBvZiB0aGVzZSB3ZXJlIGRvY3VtZW50ZWQgb24gdGhlIHNhbWUgcGFnZS5cblx0XHQgKlxuXHRcdCAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuXHRcdCAqL1xuXHRcdF9fZXhwb3J0U3RhcihyZXF1aXJlRmFjdG9yeSQzKCksIGV4cG9ydHMpO1xuXHRcdF9fZXhwb3J0U3RhcihyZXF1aXJlSW5zdGFuY2UkMigpLCBleHBvcnRzKTsgXG5cdH0gKHZpZXcpKTtcblx0cmV0dXJuIHZpZXc7XG59XG5cbnZhciBoYXNSZXF1aXJlZEluc3RhbmNlJDE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbnN0YW5jZSQxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5zdGFuY2UkMSkgcmV0dXJuIEluc3RhbmNlJDY7XG5cdGhhc1JlcXVpcmVkSW5zdGFuY2UkMSA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW5jZSQ2LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0SW5zdGFuY2UkNi5BcHBsaWNhdGlvbiA9IHZvaWQgMDtcblx0LyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuXHRjb25zdCBiYXNlXzEgPSBiYXNlO1xuXHRjb25zdCB3aW5kb3dfMSA9IHJlcXVpcmVXaW5kb3coKTtcblx0Y29uc3Qgdmlld18xID0gcmVxdWlyZVZpZXcoKTtcblx0LyoqXG5cdCAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYW4gYXBwbGljYXRpb24uIEFsbG93cyB0aGUgZGV2ZWxvcGVyIHRvIGNyZWF0ZSxcblx0ICogZXhlY3V0ZSwgc2hvdy9jbG9zZSBhbiBhcHBsaWNhdGlvbiBhcyB3ZWxsIGFzIGxpc3RlbiB0byB7QGxpbmsgT3BlbkZpbi5BcHBsaWNhdGlvbkV2ZW50cyBhcHBsaWNhdGlvbiBldmVudHN9LlxuXHQgKi9cblx0Y2xhc3MgQXBwbGljYXRpb24gZXh0ZW5kcyBiYXNlXzEuRW1pdHRlckJhc2Uge1xuXHQgICAgLyoqXG5cdCAgICAgKiBAaW50ZXJuYWxcblx0ICAgICAqL1xuXHQgICAgY29uc3RydWN0b3Iod2lyZSwgaWRlbnRpdHkpIHtcblx0ICAgICAgICBzdXBlcih3aXJlLCAnYXBwbGljYXRpb24nLCBpZGVudGl0eS51dWlkKTtcblx0ICAgICAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5cdCAgICAgICAgdGhpcy53aW5kb3cgPSBuZXcgd2luZG93XzEuX1dpbmRvdyh0aGlzLndpcmUsIHtcblx0ICAgICAgICAgICAgdXVpZDogdGhpcy5pZGVudGl0eS51dWlkLFxuXHQgICAgICAgICAgICBuYW1lOiB0aGlzLmlkZW50aXR5LnV1aWRcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHdpbmRvd0xpc3RGcm9tSWRlbnRpdHlMaXN0KGlkZW50aXR5TGlzdCkge1xuXHQgICAgICAgIGNvbnN0IHdpbmRvd0xpc3QgPSBbXTtcblx0ICAgICAgICBpZGVudGl0eUxpc3QuZm9yRWFjaCgoaWRlbnRpdHkpID0+IHtcblx0ICAgICAgICAgICAgd2luZG93TGlzdC5wdXNoKG5ldyB3aW5kb3dfMS5fV2luZG93KHRoaXMud2lyZSwge1xuXHQgICAgICAgICAgICAgICAgdXVpZDogaWRlbnRpdHkudXVpZCxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IGlkZW50aXR5Lm5hbWVcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB3aW5kb3dMaXN0O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBhcHBsaWNhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBpc0FwcFJ1bm5pbmcoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmlzUnVubmluZygpO1xuXHQgICAgICogfVxuXHQgICAgICogaXNBcHBSdW5uaW5nKCkudGhlbihydW5uaW5nID0+IGNvbnNvbGUubG9nKGBDdXJyZW50IGFwcCBpcyBydW5uaW5nOiAke3J1bm5pbmd9YCkpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBpc1J1bm5pbmcoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpcy1hcHBsaWNhdGlvbi1ydW5uaW5nJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIENsb3NlcyB0aGUgYXBwbGljYXRpb24gYW5kIGFueSBjaGlsZCB3aW5kb3dzIGNyZWF0ZWQgYnkgdGhlIGFwcGxpY2F0aW9uLlxuXHQgICAgICogQ2xlYW5zIHRoZSBhcHBsaWNhdGlvbiBmcm9tIHN0YXRlIHNvIGl0IGlzIG5vIGxvbmdlciBmb3VuZCBpbiBnZXRBbGxBcHBsaWNhdGlvbnMuXG5cdCAgICAgKiBAcGFyYW0gZm9yY2UgQ2xvc2Ugd2lsbCBiZSBwcmV2ZW50ZWQgZnJvbSBjbG9zaW5nIHdoZW4gZm9yY2UgaXMgZmFsc2UgYW5kXG5cdCAgICAgKiAg4oCYY2xvc2UtcmVxdWVzdGVk4oCZIGhhcyBiZWVuIHN1YnNjcmliZWQgdG8gZm9yIGFwcGxpY2F0aW9u4oCZcyBtYWluIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBjbG9zZUFwcCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhbGxBcHBzMSA9IGF3YWl0IGZpbi5TeXN0ZW0uZ2V0QWxsQXBwbGljYXRpb25zKCk7IC8vW3t1dWlkOiAnYXBwMScsIGlzUnVubmluZzogdHJ1ZX0sIHt1dWlkOiAnYXBwMicsIGlzUnVubmluZzogdHJ1ZX1dXG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLndyYXAoe3V1aWQ6ICdhcHAyJ30pO1xuXHQgICAgICogICAgIGF3YWl0IGFwcC5xdWl0KCk7XG5cdCAgICAgKiAgICAgY29uc3QgYWxsQXBwczIgPSBhd2FpdCBmaW4uU3lzdGVtLmdldEFsbEFwcGxpY2F0aW9ucygpOyAvL1t7dXVpZDogJ2FwcDEnLCBpc1J1bm5pbmc6IHRydWV9XVxuXHQgICAgICpcblx0ICAgICAqIH1cblx0ICAgICAqIGNsb3NlQXBwKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGljYXRpb24gcXVpdCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgYXN5bmMgcXVpdChmb3JjZSA9IGZhbHNlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xvc2UoZm9yY2UpO1xuXHQgICAgICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZGVzdHJveS1hcHBsaWNhdGlvbicsIHsgZm9yY2UsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBjb25zdCBhY2NlcHRhYmxlRXJyb3JzID0gWydSZW1vdGUgY29ubmVjdGlvbiBoYXMgY2xvc2VkJywgJ0NvdWxkIG5vdCBsb2NhdGUgdGhlIHJlcXVlc3RlZCBhcHBsaWNhdGlvbiddO1xuXHQgICAgICAgICAgICBpZiAoIWFjY2VwdGFibGVFcnJvcnMuc29tZSgobXNnKSA9PiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKG1zZykpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGFzeW5jIF9jbG9zZShmb3JjZSA9IGZhbHNlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Nsb3NlLWFwcGxpY2F0aW9uJywgeyBmb3JjZSwgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnUmVtb3RlIGNvbm5lY3Rpb24gaGFzIGNsb3NlZCcpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQGRlcHJlY2F0ZWQgdXNlIEFwcGxpY2F0aW9uLnF1aXQgaW5zdGVhZFxuXHQgICAgICogQ2xvc2VzIHRoZSBhcHBsaWNhdGlvbiBhbmQgYW55IGNoaWxkIHdpbmRvd3MgY3JlYXRlZCBieSB0aGUgYXBwbGljYXRpb24uXG5cdCAgICAgKiBAcGFyYW0gZm9yY2UgLSBDbG9zZSB3aWxsIGJlIHByZXZlbnRlZCBmcm9tIGNsb3Npbmcgd2hlbiBmb3JjZSBpcyBmYWxzZSBhbmQg4oCYY2xvc2UtcmVxdWVzdGVk4oCZIGhhcyBiZWVuIHN1YnNjcmliZWQgdG8gZm9yIGFwcGxpY2F0aW9u4oCZcyBtYWluIHdpbmRvdy5cblx0ICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGNhbGxlZCBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRzLlxuXHQgICAgICogQHBhcmFtIGVycm9yQ2FsbGJhY2sgLSBjYWxsZWQgaWYgdGhlIG1ldGhvZCBmYWlscy4gVGhlIHJlYXNvbiBmb3IgZmFpbHVyZSBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gY2xvc2VBcHAoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmNsb3NlKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKiBjbG9zZUFwcCgpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0FwcGxpY2F0aW9uIGNsb3NlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgY2xvc2UoZm9yY2UgPSBmYWxzZSkge1xuXHQgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQXBwbGljYXRpb24uY2xvc2UgaXMgZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEFwcGxpY2F0aW9uLnF1aXQnKTtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignYXBwbGljYXRpb24tY2xvc2UnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2UoZm9yY2UpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2Ygd3JhcHBlZCBmaW4uV2luZG93cyBmb3IgZWFjaCBvZiB0aGUgYXBwbGljYXRpb27igJlzIGNoaWxkIHdpbmRvd3MuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0Q2hpbGRXaW5kb3dzKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5nZXRDdXJyZW50KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGFwcC5nZXRDaGlsZFdpbmRvd3MoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRDaGlsZFdpbmRvd3MoKS50aGVuKGNoaWxkcmVuID0+IGNvbnNvbGUubG9nKGNoaWxkcmVuKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGdldENoaWxkV2luZG93cygpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1jaGlsZC13aW5kb3dzJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHtcblx0ICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlMaXN0ID0gW107XG5cdCAgICAgICAgICAgIHBheWxvYWQuZGF0YS5mb3JFYWNoKCh3aW5OYW1lKSA9PiB7XG5cdCAgICAgICAgICAgICAgICBpZGVudGl0eUxpc3QucHVzaCh7IHV1aWQ6IHRoaXMuaWRlbnRpdHkudXVpZCwgbmFtZTogd2luTmFtZSB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLndpbmRvd0xpc3RGcm9tSWRlbnRpdHlMaXN0KGlkZW50aXR5TGlzdCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJldHJpZXZlcyB0aGUgSlNPTiBtYW5pZmVzdCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYXBwbGljYXRpb24uIEludm9rZXMgdGhlIGVycm9yIGNhbGxiYWNrXG5cdCAgICAgKiBpZiB0aGUgYXBwbGljYXRpb24gd2FzIG5vdCBjcmVhdGVkIGZyb20gYSBtYW5pZmVzdC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBnZXRNYW5pZmVzdCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0TWFuaWZlc3QoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRNYW5pZmVzdCgpLnRoZW4obWFuaWZlc3QgPT4gY29uc29sZS5sb2cobWFuaWZlc3QpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0TWFuaWZlc3QoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYXBwbGljYXRpb24tbWFuaWZlc3QnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIFVVSUQgb2YgdGhlIGFwcGxpY2F0aW9uIHRoYXQgbGF1bmNoZXMgdGhpcyBhcHBsaWNhdGlvbi4gSW52b2tlcyB0aGUgZXJyb3IgY2FsbGJhY2tcblx0ICAgICAqIGlmIHRoZSBhcHBsaWNhdGlvbiB3YXMgY3JlYXRlZCBmcm9tIGEgbWFuaWZlc3QuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0UGFyZW50VXVpZCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtQXBwbGljYXRpb24uZ2V0UGFyZW50VXVpZC5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmdldFBhcmVudFV1aWQoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRQYXJlbnRVdWlkKCkudGhlbihwYXJlbnRVdWlkID0+IGNvbnNvbGUubG9nKHBhcmVudFV1aWQpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0UGFyZW50VXVpZCgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1wYXJlbnQtYXBwbGljYXRpb24nLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIGN1cnJlbnQgYXBwbGljYXRpb24ncyBzaG9ydGN1dCBjb25maWd1cmF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGdldFNob3J0Y3V0cygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24ud3JhcCh7IHV1aWQ6ICd0ZXN0YXBwJyB9KTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmdldFNob3J0Y3V0cygpO1xuXHQgICAgICogfVxuXHQgICAgICogZ2V0U2hvcnRjdXRzKCkudGhlbihjb25maWcgPT4gY29uc29sZS5sb2coY29uZmlnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGdldFNob3J0Y3V0cygpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1zaG9ydGN1dHMnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIGN1cnJlbnQgYXBwbGljYXRpb24ncyB2aWV3cy5cblx0ICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBnZXRWaWV3cygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0Vmlld3MoKTtcblx0ICAgICAqIH1cblx0ICAgICAqIGdldFZpZXdzKCkudGhlbih2aWV3cyA9PiBjb25zb2xlLmxvZyh2aWV3cykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBnZXRWaWV3cygpIHtcblx0ICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1nZXQtdmlld3MnLCB0aGlzLmlkZW50aXR5KTtcblx0ICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhLm1hcCgoaWQpID0+IG5ldyB2aWV3XzEuVmlldyh0aGlzLndpcmUsIGlkKSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgYXBwbGljYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0Wm9vbUxldmVsKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5nZXRDdXJyZW50KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGFwcC5nZXRab29tTGV2ZWwoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRab29tTGV2ZWwoKS50aGVuKHpvb21MZXZlbCA9PiBjb25zb2xlLmxvZyh6b29tTGV2ZWwpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0Wm9vbUxldmVsKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFwcGxpY2F0aW9uLXpvb20tbGV2ZWwnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiB0aGUgbWFpbiBXaW5kb3cgb2YgdGhlIGFwcGxpY2F0aW9uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1BcHBsaWNhdGlvbi5nZXRXaW5kb3cuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRXaW5kb3coKS50aGVuKHdpbiA9PiB7XG5cdCAgICAgKiAgICAgd2luLnNob3dBdCgwLCA0MDApO1xuXHQgICAgICogICAgIHdpbi5mbGFzaCgpO1xuXHQgICAgICogfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGdldFdpbmRvdygpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignYXBwbGljYXRpb24tZ2V0LXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy53aW5kb3cpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBNYW51YWxseSByZWdpc3RlcnMgYSB1c2VyIHdpdGggdGhlIGxpY2Vuc2luZyBzZXJ2aWNlLiBUaGUgb25seSBkYXRhIHNlbnQgYnkgdGhpcyBjYWxsIGlzIHVzZXJOYW1lIGFuZCBhcHBOYW1lLlxuXHQgICAgICogQHBhcmFtIHVzZXJOYW1lIC0gdXNlcm5hbWUgdG8gYmUgcGFzc2VkIHRvIHRoZSBSVk0uXG5cdCAgICAgKiBAcGFyYW0gYXBwTmFtZSAtIGFwcCBuYW1lIHRvIGJlIHBhc3NlZCB0byB0aGUgUlZNLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyVXNlcigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAucmVnaXN0ZXJVc2VyKCd1c2VyJywgJ215QXBwJyk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogcmVnaXN0ZXJVc2VyKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQgdGhlIHVzZXInKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIHJlZ2lzdGVyVXNlcih1c2VyTmFtZSwgYXBwTmFtZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigncmVnaXN0ZXItdXNlcicsIHsgdXNlck5hbWUsIGFwcE5hbWUsIC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmVzIHRoZSBhcHBsaWNhdGlvbuKAmXMgaWNvbiBmcm9tIHRoZSB0cmF5LlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVRyYXlJY29uKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5nZXRDdXJyZW50KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGFwcC5yZW1vdmVUcmF5SWNvbigpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIHJlbW92ZVRyYXlJY29uKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnUmVtb3ZlZCB0aGUgdHJheSBpY29uLicpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgcmVtb3ZlVHJheUljb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZW1vdmUtdHJheS1pY29uJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXN0YXJ0cyB0aGUgYXBwbGljYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gcmVzdGFydEFwcCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAucmVzdGFydCgpO1xuXHQgICAgICogfVxuXHQgICAgICogcmVzdGFydEFwcCgpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0FwcGxpY2F0aW9uIHJlc3RhcnRlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgcmVzdGFydCgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Jlc3RhcnQtYXBwbGljYXRpb24nLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIERFUFJFQ0FURUQgbWV0aG9kIHRvIHJ1biB0aGUgYXBwbGljYXRpb24uXG5cdCAgICAgKiBOZWVkZWQgd2hlbiBzdGFydGluZyBhcHBsaWNhdGlvbiB2aWEge0BsaW5rIEFwcGxpY2F0aW9uLmNyZWF0ZX0sIGJ1dCBOT1QgbmVlZGVkIHdoZW4gc3RhcnRpbmcgdmlhIHtAbGluayBBcHBsaWNhdGlvbi5zdGFydH0uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gcnVuKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5jcmVhdGUoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtQXBwbGljYXRpb24ucnVuLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIGF3YWl0IGFwcC5ydW4oKTtcblx0ICAgICAqIH1cblx0ICAgICAqIHJ1bigpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0FwcGxpY2F0aW9uIGlzIHJ1bm5pbmcnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cdCAgICBydW4oKSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBcHBsaWNhdGlvbi5ydW4gaXMgZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGZpbi5BcHBsaWNhdGlvbi5zdGFydCcpO1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1ydW4nLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcnVuKCk7XG5cdCAgICB9XG5cdCAgICBfcnVuKG9wdHMgPSB7fSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmVcblx0ICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3J1bi1hcHBsaWNhdGlvbicsIHtcblx0ICAgICAgICAgICAgbWFuaWZlc3RVcmw6IHRoaXMuX21hbmlmZXN0VXJsLFxuXHQgICAgICAgICAgICBvcHRzLFxuXHQgICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG5cdCAgICAgICAgfSlcblx0ICAgICAgICAgICAgLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogSW5zdHJ1Y3RzIHRoZSBSVk0gdG8gc2NoZWR1bGUgb25lIHJlc3RhcnQgb2YgdGhlIGFwcGxpY2F0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNjaGVkdWxlUmVzdGFydCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuc2NoZWR1bGVSZXN0YXJ0KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogc2NoZWR1bGVSZXN0YXJ0KCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGljYXRpb24gaXMgc2NoZWR1bGVkIHRvIHJlc3RhcnQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIHNjaGVkdWxlUmVzdGFydCgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3JlbGF1bmNoLW9uLWNsb3NlJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIFJWTSB0byB1cGxvYWQgdGhlIGFwcGxpY2F0aW9uJ3MgbG9ncy4gT24gc3VjY2Vzcyxcblx0ICAgICAqIGFuIG9iamVjdCBjb250YWluaW5nIGxvZ0lkIGlzIHJldHVybmVkLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNlbmRMb2coKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLnNlbmRBcHBsaWNhdGlvbkxvZygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIHNlbmRMb2coKS50aGVuKGluZm8gPT4gY29uc29sZS5sb2coaW5mby5sb2dJZCkpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBzZW5kQXBwbGljYXRpb25Mb2coKSB7XG5cdCAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2VuZC1hcHBsaWNhdGlvbi1sb2cnLCB0aGlzLmlkZW50aXR5KTtcblx0ICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXRzIG9yIHJlbW92ZXMgYSBjdXN0b20gSnVtcExpc3QgZm9yIHRoZSBhcHBsaWNhdGlvbi4gT25seSBhcHBsaWNhYmxlIGluIFdpbmRvd3MgT1MuXG5cdCAgICAgKiBJZiBjYXRlZ29yaWVzIGlzIG51bGwgdGhlIHByZXZpb3VzbHkgc2V0IGN1c3RvbSBKdW1wTGlzdCAoaWYgYW55KSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBzdGFuZGFyZCBKdW1wTGlzdCBmb3IgdGhlIGFwcCAobWFuYWdlZCBieSBXaW5kb3dzKS5cblx0ICAgICAqXG5cdCAgICAgKiBOb3RlOiBJZiB0aGUgXCJuYW1lXCIgcHJvcGVydHkgaXMgb21pdHRlZCBpdCBkZWZhdWx0cyB0byBcInRhc2tzXCIuXG5cdCAgICAgKiBAcGFyYW0ganVtcExpc3RDYXRlZ29yaWVzIEFuIGFycmF5IG9mIEp1bXBMaXN0IENhdGVnb3JpZXMgdG8gcG9wdWxhdGUuIElmIG51bGwsIHJlbW92ZSBhbnkgZXhpc3RpbmcgSnVtcExpc3QgY29uZmlndXJhdGlvbiBhbmQgc2V0IHRvIFdpbmRvd3MgZGVmYXVsdC5cblx0ICAgICAqXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgSWYgY2F0ZWdvcmllcyBpcyBudWxsIHRoZSBwcmV2aW91c2x5IHNldCBjdXN0b20gSnVtcExpc3QgKGlmIGFueSkgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgc3RhbmRhcmQgSnVtcExpc3QgZm9yIHRoZSBhcHAgKG1hbmFnZWQgYnkgV2luZG93cykuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIGJvdHRvbW1vc3QgaXRlbSBpbiB0aGUganVtcGxpc3Qgd2lsbCBhbHdheXMgYmUgYW4gaXRlbSBwb2ludGluZyB0byB0aGUgY3VycmVudCBhcHAuIEl0cyBuYW1lIGlzIHRha2VuIGZyb20gdGhlIG1hbmlmZXN0J3Ncblx0ICAgICAqICoqYCBzaG9ydGN1dC5uYW1lIGAqKiBhbmQgdXNlcyAqKmAgc2hvcnRjdXQuY29tcGFueSBgKiogYXMgYSBmYWxsYmFjay4gQ2xpY2tpbmcgdGhhdCBpdGVtIHdpbGwgbGF1bmNoIHRoZSBhcHAgZnJvbSBpdHMgY3VycmVudCBtYW5pZmVzdC5cblx0ICAgICAqXG5cdCAgICAgKiBOb3RlOiBJZiB0aGUgXCJuYW1lXCIgcHJvcGVydHkgaXMgb21pdHRlZCBpdCBkZWZhdWx0cyB0byBcInRhc2tzXCIuXG5cdCAgICAgKlxuXHQgICAgICogTm90ZTogV2luZG93IE9TIGNhY2hlcyBqdW1wbGlzdHMgaWNvbnMsIHRoZXJlZm9yZSBhbiBpY29uIGNoYW5nZSBtaWdodCBvbmx5IGJlIHZpc2libGUgYWZ0ZXIgdGhlIGNhY2hlIGlzIHJlbW92ZWQgb3IgdGhlXG5cdCAgICAgKiB1dWlkIG9yIHNob3J0Y3V0Lm5hbWUgaXMgY2hhbmdlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnRTeW5jKCk7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwTmFtZSA9ICdNeSBBcHAnO1xuXHQgICAgICogICAgIGNvbnN0IGp1bXBMaXN0Q29uZmlnID0gWyAvLyBhcnJheSBvZiBKdW1wTGlzdCBjYXRlZ29yaWVzXG5cdCAgICAgKiAgICAgICAgIHtcblx0ICAgICAqICAgICAgICAgICAgIC8vIGhhcyBubyBuYW1lIGFuZCBubyB0eXBlIHNvIGB0eXBlYCBpcyBhc3N1bWVkIHRvIGJlIFwidGFza3NcIlxuXHQgICAgICogICAgICAgICAgICAgaXRlbXM6IFsgLy8gYXJyYXkgb2YgSnVtcExpc3QgaXRlbXNcblx0ICAgICAqICAgICAgICAgICAgIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICB0eXBlOiAndGFzaycsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgdGl0bGU6IGBMYXVuY2ggJHthcHBOYW1lfWAsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBSdW5zICR7YXBwTmFtZX0gd2l0aCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uYCxcblx0ICAgICAqICAgICAgICAgICAgICAgICBkZWVwTGluazogJ2ZpbnM6Ly9wYXRoLnRvL2FwcC9tYW5pZmVzdC5qc29uJyxcblx0ICAgICAqICAgICAgICAgICAgICAgICBpY29uUGF0aDogJ2h0dHBzOi8vcGF0aC50by9hcHAvaWNvbi5pY28nLFxuXHQgICAgICogICAgICAgICAgICAgICAgIGljb25JbmRleDogMFxuXHQgICAgICogICAgICAgICAgICAgfSxcblx0ICAgICAqICAgICAgICAgICAgIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcblx0ICAgICAqICAgICAgICAgICAgIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICB0eXBlOiAndGFzaycsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgdGl0bGU6IGBSZXN0b3JlICR7YXBwTmFtZX1gLFxuXHQgICAgICogICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUmVzdG9yZSB0byBsYXN0IGNvbmZpZ3VyYXRpb24nLFxuXHQgICAgICogICAgICAgICAgICAgICAgIGRlZXBMaW5rOiAnZmluczovL3BhdGgudG8vYXBwL21hbmlmZXN0Lmpzb24/JCR1c2UtbGFzdC1jb25maWd1cmF0aW9uPXRydWUnLFxuXHQgICAgICogICAgICAgICAgICAgICAgIGljb25QYXRoOiAnaHR0cHM6Ly9wYXRoLnRvL2FwcC9pY29uLmljbycsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgaWNvbkluZGV4OiAwXG5cdCAgICAgKiAgICAgICAgICAgICB9LFxuXHQgICAgICogICAgICAgICAgICAgXVxuXHQgICAgICogICAgICAgICB9LFxuXHQgICAgICogICAgICAgICB7XG5cdCAgICAgKiAgICAgICAgICAgICBuYW1lOiAnVG9vbHMnLFxuXHQgICAgICogICAgICAgICAgICAgaXRlbXM6IFsgLy8gYXJyYXkgb2YgSnVtcExpc3QgaXRlbXNcblx0ICAgICAqICAgICAgICAgICAgIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICB0eXBlOiAndGFzaycsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgdGl0bGU6ICdUb29sIEEnLFxuXHQgICAgICogICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUnVucyBUb29sIEEnLFxuXHQgICAgICogICAgICAgICAgICAgICAgIGRlZXBMaW5rOiAnZmluczovL3BhdGgudG8vdG9vbC1hL21hbmlmZXN0Lmpzb24nLFxuXHQgICAgICogICAgICAgICAgICAgICAgIGljb25QYXRoOiAnaHR0cHM6Ly9wYXRoLnRvL3Rvb2wtYS9pY29uLmljbycsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgaWNvbkluZGV4OiAwXG5cdCAgICAgKiAgICAgICAgICAgICB9LFxuXHQgICAgICogICAgICAgICAgICAge1xuXHQgICAgICogICAgICAgICAgICAgICAgIHR5cGU6ICd0YXNrJyxcblx0ICAgICAqICAgICAgICAgICAgICAgICB0aXRsZTogJ1Rvb2wgQicsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdSdW5zIFRvb2wgQicsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgZGVlcExpbms6ICdmaW5zOi8vcGF0aC50by90b29sLWIvbWFuaWZlc3QuanNvbicsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgaWNvblBhdGg6ICdodHRwczovL3BhdGgudG8vdG9vbC1iL2ljb24uaWNvJyxcblx0ICAgICAqICAgICAgICAgICAgICAgICBpY29uSW5kZXg6IDBcblx0ICAgICAqICAgICAgICAgICAgIH1dXG5cdCAgICAgKiAgICAgICAgIH1cblx0ICAgICAqICAgICBdO1xuXHQgICAgICpcblx0ICAgICAqICAgICBhcHAuc2V0SnVtcExpc3QoanVtcExpc3RDb25maWcpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0p1bXBMaXN0IGFwcGxpZWQnKSkuY2F0Y2goZSA9PiBjb25zb2xlLmxvZyhgSnVtcExpc3QgZmFpbGVkIHRvIGFwcGx5OiAke2UudG9TdHJpbmcoKX1gKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBUbyBoYW5kbGUgZGVlcGxpbmsgYXJnczpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiAgICAgZnVuY3Rpb24gaGFuZGxlVXNlTGFzdENvbmZpZ3VyYXRpb24oKSB7XG5cdCAgICAgKiAgICAgICAgIC8vIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgd2hlbiB0aGUgYXBwIGlzIGJlaW5nIGxhdW5jaGVkXG5cdCAgICAgKiAgICAgICAgIGFwcC5vbigncnVuLXJlcXVlc3RlZCcsIGV2ZW50ID0+IHtcblx0ICAgICAqICAgICAgICAgICAgIGlmKGV2ZW50LnVzZXJBcHBDb25maWdBcmdzWyd1c2UtbGFzdC1jb25maWd1cmF0aW9uJ10pIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAvLyB5b3VyIGxvZ2ljIGhlcmVcblx0ICAgICAqICAgICAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgfSk7XG5cdCAgICAgKiAgICAgICAgIC8vIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgd2hlbiB0aGUgYXBwIHdhcyBhbHJlYWR5IHJ1bm5pbmcgd2hlbiB0aGUgbGF1bmNoIHdhcyByZXF1ZXN0ZWRcblx0ICAgICAqICAgICAgICAgZmluLmRlc2t0b3AubWFpbihmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgKiAgICAgICAgICAgICBpZihhcmdzICYmIGFyZ3NbJ3VzZS1sYXN0LWNvbmZpZ3VyYXRpb24nXSkge1xuXHQgICAgICogICAgICAgICAgICAgICAgIC8vIHlvdXIgbG9naWMgaGVyZVxuXHQgICAgICogICAgICAgICAgICAgfVxuXHQgICAgICogICAgICAgICB9KTtcblx0ICAgICAqICAgICB9XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgYXN5bmMgc2V0SnVtcExpc3QoanVtcExpc3RDYXRlZ29yaWVzKSB7XG5cdCAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3NldC1qdW1wLWxpc3QnLCB7IGNvbmZpZzoganVtcExpc3RDYXRlZ29yaWVzLCAuLi50aGlzLmlkZW50aXR5IH0pO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBBZGRzIGEgY3VzdG9taXphYmxlIGljb24gaW4gdGhlIHN5c3RlbSB0cmF5LiAgVG8gbGlzdGVuIGZvciBhIGNsaWNrIG9uIHRoZSBpY29uIHVzZSB0aGUgYHRyYXktaWNvbi1jbGlja2VkYCBldmVudC5cblx0ICAgICAqIEBwYXJhbSBpY29uIEltYWdlIFVSTCBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYmUgdXNlZCBhcyB0aGUgaWNvblxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGNvbnN0IGltYWdlVXJsID0gXCJodHRwOi8vY2RuLm9wZW5maW4uY28vYXNzZXRzL3Rlc3RpbmcvaWNvbnMvY2lyY2xlZC1kaWdpdC1vbmUucG5nXCI7XG5cdCAgICAgKiBjb25zdCBiYXNlNjRFbmNvZGVkSW1hZ2UgPSBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBZ0FBQUFJQVFNQUFBRCt3U3pJQUFBQUJsQk1WRVhcXFxuXHQgICAgICogLy8vKy92NytqUTNZNUFBQUFEa2xFUVZRSTEyUDRBSVg4RUFnQUxnQUQvYU5wYnRFQUFBQUFTVVZPUks1Q1lJSVwiO1xuXHQgICAgICogY29uc3QgZGF0YVVSTCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQUhFbEVRVlFJMTJQNC8vOC93MzhHSUFYRElCS0UwREhcXFxuXHQgICAgICogeGdsak5CQUFPOVRYTDBZNE9Id0FBQUFCSlJVNUVya0pnZ2c9PVwiO1xuXHQgICAgICpcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNldFRyYXlJY29uKGljb24pIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuc2V0VHJheUljb24oaWNvbik7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNlIGltYWdlIHVybCB0byBzZXQgdHJheSBpY29uXG5cdCAgICAgKiBzZXRUcmF5SWNvbihpbWFnZVVybCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU2V0dGluZyB0cmF5IGljb24nKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gc2V0IHRyYXkgaWNvblxuXHQgICAgICogc2V0VHJheUljb24oYmFzZTY0RW5jb2RlZEltYWdlKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdTZXR0aW5nIHRyYXkgaWNvbicpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNlIGEgZGF0YVVSTCB0byBzZXQgdHJheSBpY29uXG5cdCAgICAgKiBzZXRUcmF5SWNvbihkYXRhVVJMKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdTZXR0aW5nIHRyYXkgaWNvbicpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgc2V0VHJheUljb24oaWNvbikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmVcblx0ICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3NldC10cmF5LWljb24nLCB7XG5cdCAgICAgICAgICAgIGVuYWJsZWRJY29uOiBpY29uLFxuXHQgICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG5cdCAgICAgICAgfSlcblx0ICAgICAgICAgICAgLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU2V0cyBuZXcgYXBwbGljYXRpb24ncyBzaG9ydGN1dCBjb25maWd1cmF0aW9uLiBXaW5kb3dzIG9ubHkuXG5cdCAgICAgKiBAcGFyYW0gY29uZmlnIE5ldyBhcHBsaWNhdGlvbidzIHNob3J0Y3V0IGNvbmZpZ3VyYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgQXBwbGljYXRpb24gaGFzIHRvIGJlIGxhdW5jaGVkIHdpdGggYSBtYW5pZmVzdCBhbmQgaGFzIHRvIGhhdmUgc2hvcnRjdXQgY29uZmlndXJhdGlvbiAoaWNvbiB1cmwsIG5hbWUsIGV0Yy4pIGluIGl0cyBtYW5pZmVzdFxuXHQgICAgICogdG8gYmUgYWJsZSB0byBjaGFuZ2Ugc2hvcnRjdXQgc3RhdGVzLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNldFNob3J0Y3V0cyhjb25maWcpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhcHAuc2V0U2hvcnRjdXRzKGNvbmZpZyk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogc2V0U2hvcnRjdXRzKHtcblx0ICAgICAqICAgICBkZXNrdG9wOiB0cnVlLFxuXHQgICAgICogICAgIHN0YXJ0TWVudTogZmFsc2UsXG5cdCAgICAgKiAgICAgc3lzdGVtU3RhcnR1cDogdHJ1ZVxuXHQgICAgICogfSkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU2hvcnRjdXRzIGFyZSBzZXQuJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBzZXRTaG9ydGN1dHMoY29uZmlnKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtc2hvcnRjdXRzJywgeyBkYXRhOiBjb25maWcsIC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXRzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYWxsIHNob3J0Y3V0cyBmb3IgdGhpcyBhcHAuIFJlcXVpcmVzIFJWTSA1LjUrLlxuXHQgICAgICogQHBhcmFtIHF1ZXJ5U3RyaW5nIFRoZSBuZXcgcXVlcnkgc3RyaW5nIGZvciB0aGlzIGFwcCdzIHNob3J0Y3V0cy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCBuZXdRdWVyeUFyZ3MgPSAnYXJnPXRydWUmYXJnMj1mYWxzZSc7XG5cdCAgICAgKiBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogdHJ5IHtcblx0ICAgICAqICAgICBhd2FpdCBhcHAuc2V0U2hvcnRjdXRRdWVyeVBhcmFtcyhuZXdRdWVyeUFyZ3MpO1xuXHQgICAgICogfSBjYXRjaChlcnIpIHtcblx0ICAgICAqICAgICBjb25zb2xlLmVycm9yKGVycilcblx0ICAgICAqIH1cblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBzZXRTaG9ydGN1dFF1ZXJ5UGFyYW1zKHF1ZXJ5U3RyaW5nKSB7XG5cdCAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3NldC1zaG9ydGN1dC1xdWVyeS1hcmdzJywgeyBkYXRhOiBxdWVyeVN0cmluZywgLi4udGhpcy5pZGVudGl0eSB9KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgYXBwbGljYXRpb24uIFRoZSBvcmlnaW5hbCBzaXplIGlzIDAgYW5kIGVhY2ggaW5jcmVtZW50IGFib3ZlIG9yIGJlbG93IHJlcHJlc2VudHMgem9vbWluZyAyMCVcblx0ICAgICAqIGxhcmdlciBvciBzbWFsbGVyIHRvIGRlZmF1bHQgbGltaXRzIG9mIDMwMCUgYW5kIDUwJSBvZiBvcmlnaW5hbCBzaXplLCByZXNwZWN0aXZlbHkuXG5cdCAgICAgKiBAcGFyYW0gbGV2ZWwgVGhlIHpvb20gbGV2ZWxcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBzZXRab29tTGV2ZWwobnVtYmVyKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLnNldFpvb21MZXZlbChudW1iZXIpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIHNldFpvb21MZXZlbCg1KS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdTZXR0aW5nIGEgIHpvb20gbGV2ZWwnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIHNldFpvb21MZXZlbChsZXZlbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LWFwcGxpY2F0aW9uLXpvb20tbGV2ZWwnLCB7IGxldmVsLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU2V0cyBhIHVzZXJuYW1lIHRvIGNvcnJlbGF0ZSB3aXRoIEFwcCBMb2cgTWFuYWdlbWVudC5cblx0ICAgICAqIEBwYXJhbSB1c2VybmFtZSBVc2VybmFtZSB0byBjb3JyZWxhdGUgd2l0aCBBcHAncyBMb2cuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gc2V0QXBwTG9nVXNlcigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuc2V0QXBwTG9nVXNlcm5hbWUoJ3VzZXJuYW1lJyk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogc2V0QXBwTG9nVXNlcigpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1N1Y2Nlc3MnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICpcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBzZXRBcHBMb2dVc2VybmFtZSh1c2VybmFtZSkge1xuXHQgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtYXBwLWxvZy11c2VybmFtZScsIHsgZGF0YTogdXNlcm5hbWUsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3lzdGVtIHRyYXkuIElmIHRoZSBzeXN0ZW0gdHJheSBpcyBub3Qgc2V0LCBpdCB3aWxsIHRocm93IGFuIGVycm9yIG1lc3NhZ2UuXG5cdCAgICAgKiBAcmVtYXJrcyBUaGUgb25seSBpbmZvcm1hdGlvbiBjdXJyZW50bHkgcmV0dXJuZWQgaXMgdGhlIHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGdldFRyYXlJY29uSW5mbygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24ud3JhcCh7IHV1aWQ6ICd0ZXN0YXBwJyB9KTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmdldFRyYXlJY29uSW5mbygpO1xuXHQgICAgICogfVxuXHQgICAgICogZ2V0VHJheUljb25JbmZvKCkudGhlbihpbmZvID0+IGNvbnNvbGUubG9nKGluZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0VHJheUljb25JbmZvKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXRyYXktaWNvbi1pbmZvJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiB0aGUgYXBwbGljYXRpb24gaGFzIGFuIGFzc29jaWF0ZWQgdHJheSBpY29uLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi53cmFwKHsgdXVpZDogJ3Rlc3RhcHAnIH0pO1xuXHQgICAgICogY29uc3QgaGFzVHJheUljb24gPSBhd2FpdCBhcHAuaGFzVHJheUljb24oKTtcblx0ICAgICAqIGNvbnNvbGUubG9nKGhhc1RyYXlJY29uKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBoYXNUcmF5SWNvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2hhcy10cmF5LWljb24nLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQ2xvc2VzIHRoZSBhcHBsaWNhdGlvbiBieSB0ZXJtaW5hdGluZyBpdHMgcHJvY2Vzcy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiB0ZXJtaW5hdGVBcHAoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLnRlcm1pbmF0ZSgpO1xuXHQgICAgICogfVxuXHQgICAgICogdGVybWluYXRlQXBwKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGljYXRpb24gdGVybWluYXRlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgdGVybWluYXRlKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigndGVybWluYXRlLWFwcGxpY2F0aW9uJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBXYWl0cyBmb3IgYSBoYW5naW5nIGFwcGxpY2F0aW9uLiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGFwcGxpY2F0aW9uXG5cdCAgICAgKiBcIm5vdC1yZXNwb25kaW5nXCIgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnRpbnVlIGFuZCB0byBnZW5lcmF0ZSBhbm90aGVyIFwibm90LXJlc3BvbmRpbmdcIlxuXHQgICAgICogbWVzc2FnZSBhZnRlciBhIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUuXG5cdCAgICAgKlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cdCAgICB3YWl0KCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignd2FpdC1mb3ItaHVuZy1hcHBsaWNhdGlvbicsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhcHBsaWNhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmVtYXJrcyBJZiB0aGUgYXBwbGljYXRpb24gd2FzIG5vdCBsYXVuY2hlZCBmcm9tIGEgbWFuaWZlc3QsIHRoZSBjYWxsIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHBhcmVudCBhcHBsaWNhdGlvbiBgbWFuaWZlc3RgXG5cdCAgICAgKiBhbmQgYG1hbmlmZXN0VXJsYC4gIGBpbml0aWFsT3B0aW9uc2Agc2hvd3MgdGhlIHBhcmFtZXRlcnMgdXNlZCB3aGVuIGxhdW5jaGVkIHByb2dyYW1tYXRpY2FsbHksIG9yIHRoZSBgc3RhcnR1cF9hcHBgIG9wdGlvbnNcblx0ICAgICAqIGlmIGxhdW5jaGVkIGZyb20gbWFuaWZlc3QuIFRoZSBgcGFyZW50VXVpZGAgd2lsbCBiZSB0aGUgdXVpZCBvZiB0aGUgaW1tZWRpYXRlIHBhcmVudCAoaWYgYXBwbGljYWJsZSkuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0SW5mbygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0SW5mbygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGdldEluZm8oKS50aGVuKGluZm8gPT4gY29uc29sZS5sb2coaW5mbykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBnZXRJbmZvKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWluZm8nLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIGFsbCBwcm9jZXNzIGluZm9ybWF0aW9uIGZvciBlbnRpdGllcyAod2luZG93cyBhbmQgdmlld3MpIGFzc29jaWF0ZWQgd2l0aCBhbiBhcHBsaWNhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogICAgIGNvbnN0IHByb2Nlc3NJbmZvID0gYXdhaXQgYXBwLmdldFByb2Nlc3NJbmZvKCk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAqL1xuXHQgICAgYXN5bmMgZ2V0UHJvY2Vzc0luZm8oKSB7XG5cdCAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGEgfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2FwcGxpY2F0aW9uLWdldC1wcm9jZXNzLWluZm8nLCB0aGlzLmlkZW50aXR5KTtcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU2V0cyBmaWxlIGF1dG8gZG93bmxvYWQgbG9jYXRpb24uIEl0J3Mgb25seSBhbGxvd2VkIGluIHRoZSBzYW1lIGFwcGxpY2F0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHJlc3RyaWN0ZWQgYnkgZGVmYXVsdCBhbmQgbXVzdCBiZSBlbmFibGVkIHZpYVxuXHQgICAgICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5XCI+QVBJIHNlY3VyaXR5IHNldHRpbmdzPC9hPi5cblx0ICAgICAqIEBwYXJhbSBkb3dubG9hZExvY2F0aW9uIGZpbGUgYXV0byBkb3dubG9hZCBsb2NhdGlvblxuXHQgICAgICpcblx0ICAgICAqIEB0aHJvd3MgaWYgc2V0dGluZyBmaWxlIGF1dG8gZG93bmxvYWQgbG9jYXRpb24gb24gZGlmZmVyZW50IGFwcGxpY2F0aW9ucy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGNvbnN0IGRvd25sb2FkTG9jYXRpb24gPSAnQzpcXFxcZGV2XFxcXHRlbXAnO1xuXHQgICAgICogY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnQoKTtcblx0ICAgICAqIHRyeSB7XG5cdCAgICAgKiAgICAgYXdhaXQgYXBwLnNldEZpbGVEb3dubG9hZExvY2F0aW9uKGRvd25sb2FkTG9jYXRpb24pO1xuXHQgICAgICogICAgIGNvbnNvbGUubG9nKCdGaWxlIGRvd25sb2FkIGxvY2F0aW9uIGlzIHNldCcpO1xuXHQgICAgICogfSBjYXRjaChlcnIpIHtcblx0ICAgICAqICAgICBjb25zb2xlLmVycm9yKGVycilcblx0ICAgICAqIH1cblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBzZXRGaWxlRG93bmxvYWRMb2NhdGlvbihkb3dubG9hZExvY2F0aW9uKSB7XG5cdCAgICAgICAgY29uc3QgeyBuYW1lIH0gPSB0aGlzLndpcmUubWU7XG5cdCAgICAgICAgY29uc3QgZW50aXR5SWRlbnRpdHkgPSB7IHV1aWQ6IHRoaXMuaWRlbnRpdHkudXVpZCwgbmFtZSB9O1xuXHQgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtZmlsZS1kb3dubG9hZC1sb2NhdGlvbicsIHsgLi4uZW50aXR5SWRlbnRpdHksIGRvd25sb2FkTG9jYXRpb24gfSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgZmlsZSBhdXRvIGRvd25sb2FkIGxvY2F0aW9uLiBJdCdzIG9ubHkgYWxsb3dlZCBpbiB0aGUgc2FtZSBhcHBsaWNhdGlvbi4gSWYgZmlsZSBhdXRvIGRvd25sb2FkIGxvY2F0aW9uIGlzIG5vdCBzZXQsIGl0IHdpbGwgcmV0dXJuIHRoZSBkZWZhdWx0IGxvY2F0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHJlc3RyaWN0ZWQgYnkgZGVmYXVsdCBhbmQgbXVzdCBiZSBlbmFibGVkIHZpYVxuXHQgICAgICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5XCI+QVBJIHNlY3VyaXR5IHNldHRpbmdzPC9hPi5cblx0ICAgICAqXG5cdCAgICAgKiBAdGhyb3dzIGlmIGdldHRpbmcgZmlsZSBhdXRvIGRvd25sb2FkIGxvY2F0aW9uIG9uIGRpZmZlcmVudCBhcHBsaWNhdGlvbnMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xuXHQgICAgICogY29uc3QgZmlsZURvd25sb2FkRGlyID0gIGF3YWl0IGFwcC5nZXRGaWxlRG93bmxvYWRMb2NhdGlvbigpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIGdldEZpbGVEb3dubG9hZExvY2F0aW9uKCkge1xuXHQgICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhIH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtZmlsZS1kb3dubG9hZC1sb2NhdGlvbicsIHRoaXMuaWRlbnRpdHkpO1xuXHQgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG93cyBhIG1lbnUgb24gdGhlIHRyYXkgaWNvbi4gVXNlIHdpdGggdHJheS1pY29uLWNsaWNrZWQgZXZlbnQuXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9uc1xuXHQgICAgICogQHR5cGVQYXJhbSBEYXRhIFVzZXItZGVmaW5lZCBzaGFwZSBmb3IgZGF0YSByZXR1cm5lZCB1cG9uIG1lbnUgaXRlbSBjbGljay4gU2hvdWxkIGJlIGFcblx0ICAgICAqIFt1bmlvbl0oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svMi9ldmVyeWRheS10eXBlcy5odG1sI3VuaW9uLXR5cGVzKVxuXHQgICAgICogb2YgYWxsIHBvc3NpYmxlIGRhdGEgc2hhcGVzIGZvciB0aGUgZW50aXJlIG1lbnUsIGFuZCB0aGUgY2xpY2sgaGFuZGxlciBzaG91bGQgcHJvY2Vzc1xuXHQgICAgICogdGhlc2Ugd2l0aCBhIFwicmVkdWNlclwiIHBhdHRlcm4uXG5cdCAgICAgKiBAdGhyb3dzIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgbm8gdHJheSBpY29uIHNldFxuXHQgICAgICogQHRocm93cyBpZiB0aGUgc3lzdGVtIHRyYXkgaXMgY3VycmVudGx5IGhpZGRlblxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogY29uc3QgaWNvblVybCA9ICdodHRwOi8vY2RuLm9wZW5maW4uY28vYXNzZXRzL3Rlc3RpbmcvaWNvbnMvY2lyY2xlZC1kaWdpdC1vbmUucG5nJztcblx0ICAgICAqIGNvbnN0IGFwcCA9IGZpbi5BcHBsaWNhdGlvbi5nZXRDdXJyZW50U3luYygpO1xuXHQgICAgICpcblx0ICAgICAqIGF3YWl0IGFwcC5zZXRUcmF5SWNvbihpY29uVXJsKTtcblx0ICAgICAqXG5cdCAgICAgKiBjb25zdCB0ZW1wbGF0ZSA9IFtcblx0ICAgICAqICB7XG5cdCAgICAgKiAgICBsYWJlbDogJ01lbnUgSXRlbSAxJyxcblx0ICAgICAqICAgIGRhdGE6ICdoZWxsbyBmcm9tIGl0ZW0gMSdcblx0ICAgICAqICB9LFxuXHQgICAgICogIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcblx0ICAgICAqICB7XG5cdCAgICAgKiAgICBsYWJlbDogJ01lbnUgSXRlbSAyJyxcblx0ICAgICAqICAgIHR5cGU6ICdjaGVja2JveCcsXG5cdCAgICAgKiAgICBjaGVja2VkOiB0cnVlLFxuXHQgICAgICogICAgZGF0YTogJ1RoZSB1c2VyIGNsaWNrZWQgdGhlIGNoZWNrYm94J1xuXHQgICAgICogIH0sXG5cdCAgICAgKiAge1xuXHQgICAgICogICAgbGFiZWw6ICdzZWUgbW9yZScsXG5cdCAgICAgKiAgICBlbmFibGVkOiBmYWxzZSxcblx0ICAgICAqICAgIHN1Ym1lbnU6IFtcblx0ICAgICAqICAgICAgeyBsYWJlbDogJ3N1Ym1lbnUgMScsIGRhdGE6ICdoZWxsbyBmcm9tIHN1Ym1lbnUnIH1cblx0ICAgICAqICAgIF1cblx0ICAgICAqICB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIGFwcC5hZGRMaXN0ZW5lcigndHJheS1pY29uLWNsaWNrZWQnLCAoZXZlbnQpID0+IHtcblx0ICAgICAqICAgLy8gcmlnaHQtY2xpY2tcblx0ICAgICAqICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMikge1xuXHQgICAgICogICAgIGFwcC5zaG93VHJheUljb25Qb3B1cE1lbnUoeyB0ZW1wbGF0ZSB9KS50aGVuKHIgPT4ge1xuXHQgICAgICogICAgICAgaWYgKHIucmVzdWx0ID09PSAnY2xvc2VkJykge1xuXHQgICAgICogICAgICAgICBjb25zb2xlLmxvZygnbm90aGluZyBoYXBwZW5lZCcpO1xuXHQgICAgICogICAgICAgfSBlbHNlIHtcblx0ICAgICAqICAgICAgICAgY29uc29sZS5sb2coci5kYXRhKTtcblx0ICAgICAqICAgICAgIH1cblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgfVxuXHQgICAgICogfSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgYXN5bmMgc2hvd1RyYXlJY29uUG9wdXBNZW51KG9wdGlvbnMpIHtcblx0ICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHRoaXMud2lyZS5tZTtcblx0ICAgICAgICBjb25zdCBlbnRpdHlJZGVudGl0eSA9IHsgdXVpZDogdGhpcy5pZGVudGl0eS51dWlkLCBuYW1lIH07XG5cdCAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2hvdy10cmF5LWljb24tcG9wdXAtbWVudScsIHsgLi4uZW50aXR5SWRlbnRpdHksIG9wdGlvbnMgfSk7XG5cdCAgICAgICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQ0xvc2VzIHRoZSB0cmF5IGljb24gbWVudS5cblx0ICAgICAqXG5cdCAgICAgKiBAdGhyb3dzIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgbm8gdHJheSBpY29uIHNldFxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogY29uc3QgYXBwID0gZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnRTeW5jKCk7XG5cdCAgICAgKlxuXHQgICAgICogYXdhaXQgYXBwLmNsb3NlVHJheUljb25Qb3B1cE1lbnUoKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBjbG9zZVRyYXlJY29uUG9wdXBNZW51KCkge1xuXHQgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gdGhpcy53aXJlLm1lO1xuXHQgICAgICAgIGNvbnN0IGVudGl0eUlkZW50aXR5ID0geyB1dWlkOiB0aGlzLmlkZW50aXR5LnV1aWQsIG5hbWUgfTtcblx0ICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xvc2UtdHJheS1pY29uLXBvcHVwLW1lbnUnLCB7IC4uLmVudGl0eUlkZW50aXR5IH0pO1xuXHQgICAgfVxuXHR9XG5cdEluc3RhbmNlJDYuQXBwbGljYXRpb24gPSBBcHBsaWNhdGlvbjtcblx0cmV0dXJuIEluc3RhbmNlJDY7XG59XG5cbnZhciBoYXNSZXF1aXJlZEZhY3RvcnkkMjtcblxuZnVuY3Rpb24gcmVxdWlyZUZhY3RvcnkkMiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEZhY3RvcnkkMikgcmV0dXJuIEZhY3RvcnkkNztcblx0aGFzUmVxdWlyZWRGYWN0b3J5JDIgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjdG9yeSQ3LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0RmFjdG9yeSQ3LkFwcGxpY2F0aW9uTW9kdWxlID0gdm9pZCAwO1xuXHRjb25zdCBiYXNlXzEgPSBiYXNlO1xuXHRjb25zdCB2YWxpZGF0ZV8xID0gdmFsaWRhdGU7XG5cdGNvbnN0IEluc3RhbmNlXzEgPSByZXF1aXJlSW5zdGFuY2UkMSgpO1xuXHQvKipcblx0ICogU3RhdGljIG5hbWVzcGFjZSBmb3IgT3BlbkZpbiBBUEkgbWV0aG9kcyB0aGF0IGludGVyYWN0IHdpdGggdGhlIHtAbGluayBBcHBsaWNhdGlvbn0gY2xhc3MsIGF2YWlsYWJsZSB1bmRlciBgZmluLkFwcGxpY2F0aW9uYC5cblx0ICovXG5cdGNsYXNzIEFwcGxpY2F0aW9uTW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuXHQgICAgLyoqXG5cdCAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGFuIEFwcGxpY2F0aW9uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gZXhpc3RpbmcgYXBwbGljYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogZmluLkFwcGxpY2F0aW9uLndyYXAoeyB1dWlkOiAndGVzdGFwcCcgfSlcblx0ICAgICAqIC50aGVuKGFwcCA9PiBhcHAuaXNSdW5uaW5nKCkpXG5cdCAgICAgKiAudGhlbihydW5uaW5nID0+IGNvbnNvbGUubG9nKCdBcHBsaWNhdGlvbiBpcyBydW5uaW5nOiAnICsgcnVubmluZykpXG5cdCAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBhc3luYyB3cmFwKGlkZW50aXR5KSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dyYXAtYXBwbGljYXRpb24nKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb25zdCBlcnJvck1zZyA9ICgwLCB2YWxpZGF0ZV8xLnZhbGlkYXRlSWRlbnRpdHkpKGlkZW50aXR5KTtcblx0ICAgICAgICBpZiAoZXJyb3JNc2cpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLkFwcGxpY2F0aW9uKHRoaXMud2lyZSwgaWRlbnRpdHkpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTeW5jaHJvbm91c2x5IHJldHVybnMgYW4gQXBwbGljYXRpb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleGlzdGluZyBhcHBsaWNhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCBhcHAgPSBmaW4uQXBwbGljYXRpb24ud3JhcFN5bmMoeyB1dWlkOiAndGVzdGFwcCcgfSk7XG5cdCAgICAgKiBhd2FpdCBhcHAuY2xvc2UoKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICpcblx0ICAgICAqL1xuXHQgICAgd3JhcFN5bmMoaWRlbnRpdHkpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd3JhcC1hcHBsaWNhdGlvbi1zeW5jJykuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29uc3QgZXJyb3JNc2cgPSAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUlkZW50aXR5KShpZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKGVycm9yTXNnKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMS5BcHBsaWNhdGlvbih0aGlzLndpcmUsIGlkZW50aXR5KTtcblx0ICAgIH1cblx0ICAgIGFzeW5jIF9jcmVhdGUoYXBwT3B0aW9ucykge1xuXHQgICAgICAgIC8vIHNldCBkZWZhdWx0czpcblx0ICAgICAgICBpZiAoYXBwT3B0aW9ucy53YWl0Rm9yUGFnZUxvYWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBhcHBPcHRpb25zLndhaXRGb3JQYWdlTG9hZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoYXBwT3B0aW9ucy5hdXRvU2hvdyA9PT0gdW5kZWZpbmVkICYmIGFwcE9wdGlvbnMuaXNQbGF0Zm9ybUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBhcHBPcHRpb25zLmF1dG9TaG93ID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NyZWF0ZS1hcHBsaWNhdGlvbicsIGFwcE9wdGlvbnMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLndyYXAoeyB1dWlkOiBhcHBPcHRpb25zLnV1aWQgfSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIERFUFJFQ0FURUQgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBBcHBsaWNhdGlvbi4gVXNlIHtAbGluayBBcHBsaWNhdGlvbi5BcHBsaWNhdGlvbk1vZHVsZS5zdGFydCBBcHBsaWNhdGlvbi5zdGFydH0gaW5zdGVhZC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVBcHAoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmNyZWF0ZSh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMycsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1BcHBsaWNhdGlvbi5jcmVhdGUuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgYXdhaXQgYXBwLnJ1bigpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGNyZWF0ZUFwcCgpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0FwcGxpY2F0aW9uIGlzIGNyZWF0ZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cdCAgICBjcmVhdGUoYXBwT3B0aW9ucykge1xuXHQgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogZmluLkFwcGxpY2F0aW9uLmNyZWF0ZSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGZpbi5BcHBsaWNhdGlvbi5zdGFydCcpO1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1jcmVhdGUnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlKGFwcE9wdGlvbnMpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuZCBzdGFydHMgYSBuZXcgQXBwbGljYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gc3RhcnQoKSB7XG5cdCAgICAgKiAgICAgcmV0dXJuIGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1BcHBsaWNhdGlvbi5zdGFydC5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqIH1cblx0ICAgICAqIHN0YXJ0KCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGljYXRpb24gaXMgcnVubmluZycpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIHN0YXJ0KGFwcE9wdGlvbnMpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc3RhcnQtYXBwbGljYXRpb24nKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb25zdCBhcHAgPSBhd2FpdCB0aGlzLl9jcmVhdGUoYXBwT3B0aW9ucyk7XG5cdCAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3J1bi1hcHBsaWNhdGlvbicsIHsgdXVpZDogYXBwT3B0aW9ucy51dWlkIH0pO1xuXHQgICAgICAgIHJldHVybiBhcHA7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEFzeW5jaHJvbm91c2x5IHN0YXJ0cyBhIGJhdGNoIG9mIGFwcGxpY2F0aW9ucyBnaXZlbiBhbiBhcnJheSBvZiBhcHBsaWNhdGlvbiBpZGVudGlmaWVycyBhbmQgbWFuaWZlc3RVcmxzLlxuXHQgICAgICogUmV0dXJucyBvbmNlIHRoZSBSVk0gaXMgZmluaXNoZWQgYXR0ZW1wdGluZyB0byBsYXVuY2ggdGhlIGFwcGxpY2F0aW9ucy5cblx0ICAgICAqIEBwYXJhbSBvcHRzIC0gUGFyYW1ldGVycyB0aGF0IHRoZSBSVk0gd2lsbCB1c2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICpcblx0ICAgICAqIGNvbnN0IGFwcGxpY2F0aW9uSW5mb0FycmF5ID0gW1xuXHQgICAgICogICAgIHtcblx0ICAgICAqICAgICAgICAgXCJ1dWlkXCI6ICdBcHAtMScsXG5cdCAgICAgKiAgICAgICAgIFwibWFuaWZlc3RVcmxcIjogJ2h0dHA6Ly9sb2NhbGhvc3Q6NTU1NS9hcHAxLmpzb24nLFxuXHQgICAgICogICAgIH0sXG5cdCAgICAgKiAgICAge1xuXHQgICAgICogICAgICAgICBcInV1aWRcIjogJ0FwcC0yJyxcblx0ICAgICAqICAgICAgICAgXCJtYW5pZmVzdFVybFwiOiAnaHR0cDovL2xvY2FsaG9zdDo1NTU1L2FwcDIuanNvbicsXG5cdCAgICAgKiAgICAgfSxcblx0ICAgICAqICAgICB7XG5cdCAgICAgKiAgICAgICAgIFwidXVpZFwiOiAnQXBwLTMnLFxuXHQgICAgICogICAgICAgICBcIm1hbmlmZXN0VXJsXCI6ICdodHRwOi8vbG9jYWxob3N0OjU1NTUvYXBwMy5qc29uJyxcblx0ICAgICAqICAgICB9XG5cdCAgICAgKiBdXG5cdCAgICAgKlxuXHQgICAgICogZmluLkFwcGxpY2F0aW9uLnN0YXJ0TWFueU1hbmlmZXN0cyhhcHBsaWNhdGlvbkluZm9BcnJheSlcblx0ICAgICAqICAgICAudGhlbigoKSA9PiB7XG5cdCAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdSVk0gaGFzIGZpbmlzaGVkIGxhdW5jaGluZyB0aGUgYXBwbGljYXRpb24gbGlzdC4nKTtcblx0ICAgICAqICAgICB9KVxuXHQgICAgICogICAgIC5jYXRjaCgoZXJyKSA9PiB7XG5cdCAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG5cdCAgICAgKiAgICAgfSlcblx0ICAgICAqIGBgYFxuXHQgICAgICpcblx0ICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAqL1xuXHQgICAgYXN5bmMgc3RhcnRNYW55TWFuaWZlc3RzKGFwcGxpY2F0aW9ucywgb3B0cykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigncnVuLWFwcGxpY2F0aW9ucycsIHsgYXBwbGljYXRpb25zLCBvcHRzIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhbiBBcHBsaWNhdGlvbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gaXNDdXJyZW50QXBwUnVubmluZyAoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXBwLmlzUnVubmluZygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGlzQ3VycmVudEFwcFJ1bm5pbmcoKS50aGVuKHJ1bm5pbmcgPT4ge1xuXHQgICAgICogICAgIGNvbnNvbGUubG9nKGBDdXJyZW50IGFwcCBpcyBydW5uaW5nOiAke3J1bm5pbmd9YCk7XG5cdCAgICAgKiB9KS5jYXRjaChlcnIgPT4ge1xuXHQgICAgICogICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBnZXRDdXJyZW50KCkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtY3VycmVudC1hcHBsaWNhdGlvbicpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLndyYXAoeyB1dWlkOiB0aGlzLndpcmUubWUudXVpZCB9KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGFuIEFwcGxpY2F0aW9uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgYXBwbGljYXRpb25cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBpc0N1cnJlbnRBcHBSdW5uaW5nICgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudFN5bmMoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXBwLmlzUnVubmluZygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGlzQ3VycmVudEFwcFJ1bm5pbmcoKS50aGVuKHJ1bm5pbmcgPT4ge1xuXHQgICAgICogICAgIGNvbnNvbGUubG9nKGBDdXJyZW50IGFwcCBpcyBydW5uaW5nOiAke3J1bm5pbmd9YCk7XG5cdCAgICAgKiB9KS5jYXRjaChlcnIgPT4ge1xuXHQgICAgICogICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBnZXRDdXJyZW50U3luYygpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWN1cnJlbnQtYXBwbGljYXRpb24tc3luYycpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLndyYXBTeW5jKHsgdXVpZDogdGhpcy53aXJlLm1lLnV1aWQgfSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJldHJpZXZlcyBhcHBsaWNhdGlvbidzIG1hbmlmZXN0IGFuZCByZXR1cm5zIGEgcnVubmluZyBpbnN0YW5jZSBvZiB0aGUgYXBwbGljYXRpb24uXG5cdCAgICAgKiBAcGFyYW0gbWFuaWZlc3RVcmwgLSBUaGUgVVJMIG9mIGFwcCdzIG1hbmlmZXN0LlxuXHQgICAgICogQHBhcmFtIG9wdHMgLSBQYXJhbWV0ZXJzIHRoYXQgdGhlIFJWTSB3aWxsIHVzZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBmaW4uQXBwbGljYXRpb24uc3RhcnRGcm9tTWFuaWZlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6NTU1NS9hcHAuanNvbicpLnRoZW4oYXBwID0+IGNvbnNvbGUubG9nKCdBcHAgaXMgcnVubmluZycpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gRm9yIGEgbG9jYWwgbWFuaWZlc3QgZmlsZTpcblx0ICAgICAqIGZpbi5BcHBsaWNhdGlvbi5zdGFydEZyb21NYW5pZmVzdCgnZmlsZTovLy9DOi9zb21lZm9sZGVyL2FwcC5qc29uJykudGhlbihhcHAgPT4gY29uc29sZS5sb2coJ0FwcCBpcyBydW5uaW5nJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBzdGFydEZyb21NYW5pZmVzdChtYW5pZmVzdFVybCwgb3B0cykge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1zdGFydC1mcm9tLW1hbmlmZXN0JykuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29uc3QgYXBwID0gYXdhaXQgdGhpcy5fY3JlYXRlRnJvbU1hbmlmZXN0KG1hbmlmZXN0VXJsKTtcblx0ICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVzaW5nIHByaXZhdGUgbWV0aG9kIHdpdGhvdXQgd2FybmluZy5cblx0ICAgICAgICBhd2FpdCBhcHAuX3J1bihvcHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuXHQgICAgICAgIHJldHVybiBhcHA7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQXBwbGljYXRpb24uQXBwbGljYXRpb25Nb2R1bGUuc3RhcnRGcm9tTWFuaWZlc3QgQXBwbGljYXRpb24uc3RhcnRGcm9tTWFuaWZlc3R9IGluc3RlYWQuXG5cdCAgICAgKiBSZXRyaWV2ZXMgYXBwbGljYXRpb24ncyBtYW5pZmVzdCBhbmQgcmV0dXJucyBhIHdyYXBwZWQgYXBwbGljYXRpb24uXG5cdCAgICAgKiBAcGFyYW0gbWFuaWZlc3RVcmwgLSBUaGUgVVJMIG9mIGFwcCdzIG1hbmlmZXN0LlxuXHQgICAgICogQHBhcmFtIGNhbGxiYWNrIC0gY2FsbGVkIGlmIHRoZSBtZXRob2Qgc3VjY2VlZHMuXG5cdCAgICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFjayAtIGNhbGxlZCBpZiB0aGUgbWV0aG9kIGZhaWxzLiBUaGUgcmVhc29uIGZvciBmYWlsdXJlIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBmaW4uQXBwbGljYXRpb24uY3JlYXRlRnJvbU1hbmlmZXN0KCdodHRwOi8vbG9jYWxob3N0OjU1NTUvYXBwLmpzb24nKS50aGVuKGFwcCA9PiBjb25zb2xlLmxvZyhhcHApKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXHQgICAgY3JlYXRlRnJvbU1hbmlmZXN0KG1hbmlmZXN0VXJsKSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBmaW4uQXBwbGljYXRpb24uY3JlYXRlRnJvbU1hbmlmZXN0IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZmluLkFwcGxpY2F0aW9uLnN0YXJ0RnJvbU1hbmlmZXN0Jyk7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2FwcGxpY2F0aW9uLWNyZWF0ZS1mcm9tLW1hbmlmZXN0JykuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUZyb21NYW5pZmVzdChtYW5pZmVzdFVybCk7XG5cdCAgICB9XG5cdCAgICBfY3JlYXRlRnJvbU1hbmlmZXN0KG1hbmlmZXN0VXJsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuXHQgICAgICAgICAgICAuc2VuZEFjdGlvbignZ2V0LWFwcGxpY2F0aW9uLW1hbmlmZXN0JywgeyBtYW5pZmVzdFVybCB9KVxuXHQgICAgICAgICAgICAudGhlbigoeyBwYXlsb2FkIH0pID0+IHtcblx0ICAgICAgICAgICAgY29uc3QgdXVpZCA9IHBheWxvYWQuZGF0YS5wbGF0Zm9ybSA/IHBheWxvYWQuZGF0YS5wbGF0Zm9ybS51dWlkIDogcGF5bG9hZC5kYXRhLnN0YXJ0dXBfYXBwLnV1aWQ7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXAoeyB1dWlkIH0pO1xuXHQgICAgICAgIH0pXG5cdCAgICAgICAgICAgIC50aGVuKChhcHApID0+IHtcblx0ICAgICAgICAgICAgYXBwLl9tYW5pZmVzdFVybCA9IG1hbmlmZXN0VXJsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG5cdCAgICAgICAgICAgIHJldHVybiBhcHA7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdH1cblx0RmFjdG9yeSQ3LkFwcGxpY2F0aW9uTW9kdWxlID0gQXBwbGljYXRpb25Nb2R1bGU7XG5cdHJldHVybiBGYWN0b3J5JDc7XG59XG5cbnZhciBoYXNSZXF1aXJlZEFwcGxpY2F0aW9uO1xuXG5mdW5jdGlvbiByZXF1aXJlQXBwbGljYXRpb24gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRBcHBsaWNhdGlvbikgcmV0dXJuIGFwcGxpY2F0aW9uO1xuXHRoYXNSZXF1aXJlZEFwcGxpY2F0aW9uID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdFx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdFx0ICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblx0XHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0XHQgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdFx0fSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0XHQgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcblx0XHQgICAgb1trMl0gPSBtW2tdO1xuXHRcdH0pKTtcblx0XHR2YXIgX19leHBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuXHRcdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdFx0fTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0LyoqXG5cdFx0ICogRW50cnkgcG9pbnRzIGZvciB0aGUgT3BlbkZpbiBgQXBwbGljYXRpb25gIEFQSSAoYGZpbi5BcHBsaWNhdGlvbmApLlxuXHRcdCAqXG5cdFx0ICogKiB7QGxpbmsgQXBwbGljYXRpb25Nb2R1bGV9IGNvbnRhaW5zIHN0YXRpYyBtZW1iZXJzIG9mIHRoZSBgQXBwbGljYXRpb25gIEFQSSwgYWNjZXNzaWJsZSB0aHJvdWdoIGBmaW4uQXBwbGljYXRpb25gLlxuXHRcdCAqICoge0BsaW5rIEFwcGxpY2F0aW9ufSBkZXNjcmliZXMgYW4gaW5zdGFuY2Ugb2YgYW4gT3BlbkZpbiBBcHBsaWNhdGlvbiwgZS5nLiBhcyByZXR1cm5lZCBieSBgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnRgLlxuXHRcdCAqXG5cdFx0ICogVGhlc2UgYXJlIHNlcGFyYXRlIGNvZGUgZW50aXRpZXMsIGFuZCBhcmUgZG9jdW1lbnRlZCBzZXBhcmF0ZWx5LiAgSW4gdGhlIFtwcmV2aW91cyB2ZXJzaW9uIG9mIHRoZSBBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvMzIuMTE0Ljc2LjEwL2luZGV4Lmh0bWwpLFxuXHRcdCAqIGJvdGggb2YgdGhlc2Ugd2VyZSBkb2N1bWVudGVkIG9uIHRoZSBzYW1lIHBhZ2UuXG5cdFx0ICpcblx0XHQgKiBAcGFja2FnZURvY3VtZW50YXRpb25cblx0XHQgKi9cblx0XHRfX2V4cG9ydFN0YXIocmVxdWlyZUZhY3RvcnkkMigpLCBleHBvcnRzKTtcblx0XHRfX2V4cG9ydFN0YXIocmVxdWlyZUluc3RhbmNlJDEoKSwgZXhwb3J0cyk7IFxuXHR9IChhcHBsaWNhdGlvbikpO1xuXHRyZXR1cm4gYXBwbGljYXRpb247XG59XG5cbnZhciBwcm9taXNpZnlTdWJzY3JpcHRpb24kMSA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzaWZ5U3Vic2NyaXB0aW9uJDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucHJvbWlzaWZ5U3Vic2NyaXB0aW9uJDEucHJvbWlzaWZ5U3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuY29uc3QgcHJvbWlzaWZ5U3Vic2NyaXB0aW9uID0gYXN5bmMgKGVtaXR0ZXIsIGV2ZW50TmFtZSwgcHJlZGljYXRlID0gKCkgPT4gdHJ1ZSwgdGltZW91dCkgPT4ge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgbGV0IHRpbWVyO1xuICAgIGNvbnN0IHZhbHVlUHJvbWlzZSA9IG5ldyBQcm9taXNlKCh5LCBuKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSB5O1xuICAgICAgICByZWplY3QgPSBuO1xuICAgIH0pO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShlKSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IGVtaXR0ZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ2V2ZW50IHRpbWVkIG91dCcpKSwgdGltZW91dCk7XG4gICAgfVxuICAgIHZhbHVlUHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRWYWx1ZTogKCkgPT4gdmFsdWVQcm9taXNlXG4gICAgfTtcbn07XG5wcm9taXNpZnlTdWJzY3JpcHRpb24kMS5wcm9taXNpZnlTdWJzY3JpcHRpb24gPSBwcm9taXNpZnlTdWJzY3JpcHRpb247XG5cbnZhciBoYXNSZXF1aXJlZEluc3RhbmNlO1xuXG5mdW5jdGlvbiByZXF1aXJlSW5zdGFuY2UgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbnN0YW5jZSkgcmV0dXJuIEluc3RhbmNlJDc7XG5cdGhhc1JlcXVpcmVkSW5zdGFuY2UgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFuY2UkNywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdEluc3RhbmNlJDcuX1dpbmRvdyA9IHZvaWQgMDtcblx0LyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cblx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG5cdGNvbnN0IGFwcGxpY2F0aW9uXzEgPSByZXF1aXJlQXBwbGljYXRpb24oKTtcblx0Y29uc3QgbWFpbl8xID0gbWFpbjtcblx0Y29uc3Qgdmlld18xID0gcmVxdWlyZVZpZXcoKTtcblx0Y29uc3Qgd2FybmluZ3NfMSA9IHdhcm5pbmdzO1xuXHRjb25zdCBwcm9taXNpZnlTdWJzY3JpcHRpb25fMSA9IHByb21pc2lmeVN1YnNjcmlwdGlvbiQxO1xuXHQvKipcblx0ICogQSBiYXNpYyB3aW5kb3cgdGhhdCB3cmFwcyBhIG5hdGl2ZSBIVE1MIHdpbmRvdy4gUHJvdmlkZXMgbW9yZSBmaW5lLWdyYWluZWRcblx0ICogY29udHJvbCBvdmVyIHRoZSB3aW5kb3cgc3RhdGUgc3VjaCBhcyB0aGUgYWJpbGl0eSB0byBtaW5pbWl6ZSwgbWF4aW1pemUsIHJlc3RvcmUsIGV0Yy5cblx0ICogQnkgZGVmYXVsdCBhIHdpbmRvdyBkb2VzIG5vdCBzaG93IHVwb24gaW5zdGFudGlhdGlvbjsgaW5zdGVhZCB0aGUgd2luZG93J3Mgc2hvdygpIG1ldGhvZFxuXHQgKiBtdXN0IGJlIGludm9rZWQgbWFudWFsbHkuIFRoZSBuZXcgd2luZG93IGFwcGVhcnMgaW4gdGhlIHNhbWUgcHJvY2VzcyBhcyB0aGUgcGFyZW50IHdpbmRvdy5cblx0ICogSXQgaGFzIHRoZSBhYmlsaXR5IHRvIGxpc3RlbiBmb3Ige0BsaW5rIE9wZW5GaW4uV2luZG93RXZlbnRzIHdpbmRvdyBzcGVjaWZpYyBldmVudHN9LlxuXHQgKi9cblx0Ly8gVGhlIHdpbmRvdy5XaW5kb3cgbmFtZSBpcyB0YWtlblxuXHRjbGFzcyBfV2luZG93IGV4dGVuZHMgbWFpbl8xLldlYkNvbnRlbnRzIHtcblx0ICAgIC8qKlxuXHQgICAgICogQGludGVybmFsXG5cdCAgICAgKi9cblx0ICAgIGNvbnN0cnVjdG9yKHdpcmUsIGlkZW50aXR5KSB7XG5cdCAgICAgICAgc3VwZXIod2lyZSwgaWRlbnRpdHksICd3aW5kb3cnKTtcblx0ICAgIH1cblx0ICAgIGFzeW5jIGNyZWF0ZVdpbmRvdyhvcHRpb25zKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dpbmRvdy1jcmVhdGUtd2luZG93JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29uc3QgQ09OU1RSVUNUT1JfQ0JfVE9QSUMgPSAnZmlyZS1jb25zdHJ1Y3Rvci1jYWxsYmFjayc7XG5cdCAgICAgICAgY29uc3QgcmVzcG9uc2VTdWJzY3JpcHRpb24gPSBhd2FpdCAoMCwgcHJvbWlzaWZ5U3Vic2NyaXB0aW9uXzEucHJvbWlzaWZ5U3Vic2NyaXB0aW9uKSh0aGlzLCBDT05TVFJVQ1RPUl9DQl9UT1BJQyk7XG5cdCAgICAgICAgLy8gc2V0IGRlZmF1bHRzOlxuXHQgICAgICAgIGlmIChvcHRpb25zLndhaXRGb3JQYWdlTG9hZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMud2FpdEZvclBhZ2VMb2FkID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcHRpb25zLmF1dG9TaG93ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5hdXRvU2hvdyA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICgwLCB3YXJuaW5nc18xLmhhbmRsZURlcHJlY2F0ZWRXYXJuaW5ncykob3B0aW9ucyk7XG5cdCAgICAgICAgY29uc3Qgd2luZG93Q3JlYXRpb24gPSB0aGlzLndpcmUuZW52aXJvbm1lbnQuY3JlYXRlQ2hpbGRDb250ZW50KHsgZW50aXR5VHlwZTogJ3dpbmRvdycsIG9wdGlvbnMgfSk7XG5cdCAgICAgICAgY29uc3QgW3Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtyZXNwb25zZVN1YnNjcmlwdGlvbi5nZXRWYWx1ZSgpLCB3aW5kb3dDcmVhdGlvbl0pO1xuXHQgICAgICAgIGxldCBjYlBheWxvYWQ7XG5cdCAgICAgICAgY29uc3QgeyBzdWNjZXNzIH0gPSByZXNwb25zZTtcblx0ICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSByZXNwb25zZS5kYXRhO1xuXHQgICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcmVzcG9uc2VEYXRhO1xuXHQgICAgICAgIGlmIChzdWNjZXNzKSB7XG5cdCAgICAgICAgICAgIGNiUGF5bG9hZCA9IHtcblx0ICAgICAgICAgICAgICAgIGh0dHBSZXNwb25zZUNvZGU6IHJlc3BvbnNlRGF0YS5odHRwUmVzcG9uc2VDb2RlLFxuXHQgICAgICAgICAgICAgICAgYXBpSW5qZWN0ZWQ6IHJlc3BvbnNlRGF0YS5hcGlJbmplY3RlZFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgY2JQYXlsb2FkID0ge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzcG9uc2VEYXRhLm1lc3NhZ2UsXG5cdCAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3JDb2RlOiByZXNwb25zZURhdGEubmV0d29ya0Vycm9yQ29kZSxcblx0ICAgICAgICAgICAgICAgIHN0YWNrOiByZXNwb25zZURhdGEuc3RhY2tcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc3QgcGFnZVJlc29sdmUgPSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UsXG5cdCAgICAgICAgICAgIGNiUGF5bG9hZCxcblx0ICAgICAgICAgICAgc3VjY2Vzc1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBlbmZvcmNlIGEgNS4wIGNvbnRyYWN0IHRoYXQgdGhlIGNoaWxkJ3MgbWFpbiBmdW5jdGlvblxuXHQgICAgICAgICAgICAvLyB3aWxsIG5vdCBmaXJlIGJlZm9yZSB0aGUgcGFyZW50J3Mgc3VjY2VzcyBjYWxsYmFjayBvbiBjcmVhdGlvbi5cblx0ICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIHdpbmRvdyBpcyBub3QgYWNjZXNzaWJsZSAoQ09SUykgdGhpcyBjb250cmFjdCBkb2VzXG5cdCAgICAgICAgICAgIC8vIG5vdCBob2xkLlxuXHQgICAgICAgICAgICBjb25zdCB3ZWJXaW5kb3cgPSB0aGlzLmdldFdlYldpbmRvdygpO1xuXHQgICAgICAgICAgICB3ZWJXaW5kb3cuZmluLl9faW50ZXJuYWxfLm9wZW5lclN1Y2Nlc3NDQkNhbGxlZCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAvLyBjb21tb24gZm9yIG1haW4gd2luZG93cywgd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IuIGhlcmUganVzdCB0byBoYXZlIGEgZGVidWcgdGFyZ2V0LlxuXHQgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocGFnZVJlc29sdmUuc3VjY2Vzcykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBhZ2VSZXNvbHZlKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIGFuIGFycmF5IG9mIGZyYW1lIGluZm8gb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIG1haW4gZnJhbWUgYW5kIGFueVxuXHQgICAgICogaWZyYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgb24gdGhlIHBhZ2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBnZXRBbGxGcmFtZXMoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5nZXRBbGxGcmFtZXMuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uZ2V0QWxsRnJhbWVzKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogZ2V0QWxsRnJhbWVzKCkudGhlbihmcmFtZXNJbmZvID0+IGNvbnNvbGUubG9nKGZyYW1lc0luZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0QWxsRnJhbWVzKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFsbC1mcmFtZXMnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgY3VycmVudCBib3VuZHMgKHRvcCwgYm90dG9tLCByaWdodCwgbGVmdCwgd2lkdGgsIGhlaWdodCkgb2YgdGhlIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGdldEJvdW5kcygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTMnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmdldEJvdW5kcy5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5nZXRCb3VuZHMoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRCb3VuZHMoKS50aGVuKGJvdW5kcyA9PiBjb25zb2xlLmxvZyhib3VuZHMpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0Qm91bmRzKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmVcblx0ICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2dldC13aW5kb3ctYm91bmRzJywgdGhpcy5pZGVudGl0eSlcblx0ICAgICAgICAgICAgLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBDZW50ZXJzIHRoZSB3aW5kb3cgb24gaXRzIGN1cnJlbnQgc2NyZWVuLlxuXHQgICAgICpcblx0ICAgICAqIEByZW1hcmtzIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IG9uIG1pbmltaXplZCBvciBtYXhpbWl6ZWQgd2luZG93cy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNlbnRlcldpbmRvdygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmNlbnRlci5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5jZW50ZXIoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBjZW50ZXJXaW5kb3coKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdXaW5kb3cgY2VudGVyZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBjZW50ZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjZW50ZXItd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGJsdXJXaW5kb3coKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5ibHVyLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLmJsdXIoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBibHVyV2luZG93KCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQmx1cmVkIFdpbmRvdycpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgYmx1cigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2JsdXItd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBCcmluZ3MgdGhlIHdpbmRvdyB0byB0aGUgZnJvbnQgb2YgdGhlIHdpbmRvdyBzdGFjay5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIEJyaW5nV2luZG93VG9Gcm9udCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmJyaW5nVG9Gcm9udC5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5icmluZ1RvRnJvbnQoKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBCcmluZ1dpbmRvd1RvRnJvbnQoKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdXaW5kb3cgaXMgaW4gdGhlIGZyb250JykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBicmluZ1RvRnJvbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdicmluZy13aW5kb3ctdG8tZnJvbnQnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFBlcmZvcm1zIHRoZSBzcGVjaWZpZWQgd2luZG93IHRyYW5zaXRpb25zLlxuXHQgICAgICogQHBhcmFtIHRyYW5zaXRpb25zIC0gRGVzY3JpYmVzIHRoZSBhbmltYXRpb25zIHRvIHBlcmZvcm0uIFNlZSB0aGUgdHV0b3JpYWwuXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24uIFNlZSB0aGUgdHV0b3JpYWwuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYFxuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gYW5pbWF0ZVdpbmRvdygpIHtcblx0ICAgICAqICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHtcblx0ICAgICAqICAgICAgICAgb3BhY2l0eToge1xuXHQgICAgICogICAgICAgICAgICAgb3BhY2l0eTogMC43LFxuXHQgICAgICogICAgICAgICAgICAgZHVyYXRpb246IDUwMFxuXHQgICAgICogICAgICAgICB9LFxuXHQgICAgICogICAgICAgICBwb3NpdGlvbjoge1xuXHQgICAgICogICAgICAgICAgICAgdG9wOiAxMDAsXG5cdCAgICAgKiAgICAgICAgICAgICBsZWZ0OiAxMDAsXG5cdCAgICAgKiAgICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuXHQgICAgICogICAgICAgICAgICAgcmVsYXRpdmU6IHRydWVcblx0ICAgICAqICAgICAgICAgfVxuXHQgICAgICogICAgIH07XG5cdCAgICAgKiAgICAgY29uc3Qgb3B0aW9ucyA9IHtcblx0ICAgICAqICAgICAgICAgaW50ZXJydXB0OiB0cnVlLFxuXHQgICAgICogICAgICAgICB0d2VlbjogJ2Vhc2UtaW4nXG5cdCAgICAgKiAgICAgfTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy5nZXRDdXJyZW50KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIHdpbi5hbmltYXRlKHRyYW5zaXRpb25zLCBvcHRpb25zKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBhbmltYXRlV2luZG93KClcblx0ICAgICAqICAgICAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUnKSlcblx0ICAgICAqICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgYW5pbWF0ZSh0cmFuc2l0aW9ucywgb3B0aW9ucykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmVcblx0ICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2FuaW1hdGUtd2luZG93Jywge1xuXHQgICAgICAgICAgICB0cmFuc2l0aW9ucyxcblx0ICAgICAgICAgICAgb3B0aW9ucyxcblx0ICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eVxuXHQgICAgICAgIH0pXG5cdCAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEhpZGVzIHRoZSB3aW5kb3cuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBoaWRlV2luZG93KCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuaGlkZS5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5oaWRlKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogaGlkZVdpbmRvdygpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1dpbmRvdyBpcyBoaWRkZW4nKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGhpZGUoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdoaWRlLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogY2xvc2VzIHRoZSB3aW5kb3cgYXBwbGljYXRpb25cblx0ICAgICAqIEBwYXJhbSBmb3JjZSBDbG9zZSB3aWxsIGJlIHByZXZlbnRlZCBmcm9tIGNsb3Npbmcgd2hlbiBmb3JjZSBpcyBmYWxzZSBhbmRcblx0ICAgICAqICDigJhjbG9zZS1yZXF1ZXN0ZWTigJkgaGFzIGJlZW4gc3Vic2NyaWJlZCB0byBmb3IgYXBwbGljYXRpb27igJlzIG1haW4gd2luZG93LlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gY2xvc2VXaW5kb3coKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0zJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5jbG9zZS5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5jbG9zZSgpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGNsb3NlV2luZG93KCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnV2luZG93IGNsb3NlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgY2xvc2UoZm9yY2UgPSBmYWxzZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xvc2Utd2luZG93JywgeyBmb3JjZSwgLi4udGhpcy5pZGVudGl0eSB9KS50aGVuKCgpID0+IHtcblx0ICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG51bGwpO1xuXHQgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZm9jdXNlZFdlYlZpZXdXYXNDaGFuZ2VkKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZm9jdXNlZC13ZWJ2aWV3LWNoYW5nZWQnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdGhlIG5hdGl2ZSBPUyBsZXZlbCBJZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmVtYXJrcyBJbiBXaW5kb3dzLCBpdCB3aWxsIHJldHVybiB0aGUgV2luZG93cyBbaGFuZGxlXShodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy93aW5kb3dzL2Rlc2t0b3AvV2luUHJvZy93aW5kb3dzLWRhdGEtdHlwZXMjSFdORCkuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBnZXRXaW5kb3dOYXRpdmVJZCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTMnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmdldE5hdGl2ZUlkLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLmdldE5hdGl2ZUlkKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogZ2V0V2luZG93TmF0aXZlSWQoKS50aGVuKG5hdGl2ZUlkID0+IGNvbnNvbGUubG9nKG5hdGl2ZUlkKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGdldE5hdGl2ZUlkKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXdpbmRvdy1uYXRpdmUtaWQnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIHdpbmRvdydzIGF0dGFjaGVkIHZpZXdzLlxuXHQgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogY29uc3Qgd2luID0gZmluLldpbmRvdy5nZXRDdXJyZW50U3luYygpO1xuXHQgICAgICpcblx0ICAgICAqIHdpbi5nZXRDdXJyZW50Vmlld3MoKVxuXHQgICAgICogICAudGhlbih2aWV3cyA9PiBjb25zb2xlLmxvZyh2aWV3cykpXG5cdCAgICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBnZXRDdXJyZW50Vmlld3MoKSB7XG5cdCAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LWdldC12aWV3cycsIHRoaXMuaWRlbnRpdHkpO1xuXHQgICAgICAgIHJldHVybiBwYXlsb2FkLmRhdGEubWFwKChpZCkgPT4gbmV3IHZpZXdfMS5WaWV3KHRoaXMud2lyZSwgaWQpKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBXaW5kb3cuX1dpbmRvdy5kaXNhYmxlVXNlck1vdmVtZW50fSBpbnN0ZWFkLlxuXHQgICAgICovXG5cdCAgICBkaXNhYmxlRnJhbWUoKSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdGdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgZGlzYWJsZVVzZXJNb3ZlbWVudCBpbnN0ZWFkLicpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZGlzYWJsZS13aW5kb3ctZnJhbWUnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFByZXZlbnRzIGEgdXNlciBmcm9tIGNoYW5naW5nIGEgd2luZG93J3Mgc2l6ZS9wb3NpdGlvbiB3aGVuIHVzaW5nIHRoZSB3aW5kb3cncyBmcmFtZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGRpc2FibGVVc2VyTW92ZW1lbnQoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0zJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5kaXNhYmxlRnJhbWUuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uZGlzYWJsZVVzZXJNb3ZlbWVudCgpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGRpc2FibGVVc2VyTW92ZW1lbnQoKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdXaW5kb3cgaXMgZGlzYWJsZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGRpc2FibGVVc2VyTW92ZW1lbnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdkaXNhYmxlLXdpbmRvdy1mcmFtZScsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBXaW5kb3cuX1dpbmRvdy5lbmFibGVVc2VyTW92ZW1lbnR9IGluc3RlYWQuXG5cdCAgICAgKi9cblx0ICAgIGVuYWJsZUZyYW1lKCkge1xuXHQgICAgICAgIGNvbnNvbGUud2FybignRnVuY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGVuYWJsZVVzZXJNb3ZlbWVudCBpbnN0ZWFkLicpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZW5hYmxlLXdpbmRvdy1mcmFtZScsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmUtZW5hYmxlcyB1c2VyIGNoYW5nZXMgdG8gYSB3aW5kb3cncyBzaXplL3Bvc2l0aW9uIHdoZW4gdXNpbmcgdGhlIHdpbmRvdydzIGZyYW1lLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gZW5hYmxlVXNlck1vdmVtZW50KCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMycsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuZW5hYmxlRnJhbWUuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uZW5hYmxlVXNlck1vdmVtZW50KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogZW5hYmxlVXNlck1vdmVtZW50KCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnV2luZG93IGlzIGVuYWJsZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGVuYWJsZVVzZXJNb3ZlbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2VuYWJsZS13aW5kb3ctZnJhbWUnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEZsYXNoZXMgdGhlIHdpbmRvd+KAmXMgZnJhbWUgYW5kIHRhc2tiYXIgaWNvbiB1bnRpbCBzdG9wRmxhc2hpbmcgaXMgY2FsbGVkIG9yIHVudGlsIGEgZm9jdXMgZXZlbnQgaXMgZmlyZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgT24gbWFjT1MgZmxhc2ggb25seSB3b3JrcyBvbiBpbmFjdGl2ZSB3aW5kb3dzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiB3aW5kb3dGbGFzaCgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmZsYXNoLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLmZsYXNoKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogd2luZG93Rmxhc2goKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdXaW5kb3cgZmxhc2hpbmcnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGZsYXNoKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZmxhc2gtd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTdG9wcyB0aGUgdGFza2JhciBpY29uIGZyb20gZmxhc2hpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBzdG9wV2luZG93Rmxhc2hpbmcoKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5zdG9wRmxhc2hpbmcuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uc3RvcEZsYXNoaW5nKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogc3RvcFdpbmRvd0ZsYXNoaW5nKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGljYXRpb24gd2luZG93IGZsYXNoaW5nJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBzdG9wRmxhc2hpbmcoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzdG9wLWZsYXNoLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyBhbiBpbmZvcm1hdGlvbiBvYmplY3QgZm9yIHRoZSB3aW5kb3cuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBnZXRJbmZvKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuZ2V0SW5mby5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5nZXRJbmZvKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogZ2V0SW5mbygpLnRoZW4oaW5mbyA9PiBjb25zb2xlLmxvZyhpbmZvKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGdldEluZm8oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtd2luZG93LWluZm8nLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIHRoZSB3aW5kb3cncyBMYXlvdXRcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqICAgICAvL2dldCB0aGUgY3VycmVudCB3aW5kb3dcblx0ICAgICAqICAgICBjb25zdCB3aW5kb3cgPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgLy9nZXQgdGhlIGxheW91dCBmb3IgdGhlIHdpbmRvd1xuXHQgICAgICogICAgIGNvbnN0IGxheW91dCA9IGF3YWl0IHdpbmRvdy5nZXRMYXlvdXQoKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICovXG5cdCAgICBhc3luYyBnZXRMYXlvdXQobGF5b3V0SWRlbnRpdHkpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LWdldC1sYXlvdXQnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5nZXRPcHRpb25zKCk7XG5cdCAgICAgICAgaWYgKCFvcHRzLmxheW91dCB8fCAhb3B0cy5sYXlvdXRTbmFwc2hvdCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbmRvdyBkb2VzIG5vdCBoYXZlIGEgTGF5b3V0Jyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbi5QbGF0Zm9ybS5MYXlvdXQud3JhcChsYXlvdXRJZGVudGl0eSA/PyB0aGlzLmlkZW50aXR5KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgY3VycmVudCBzZXR0aW5ncyBvZiB0aGUgd2luZG93LlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0V2luZG93T3B0aW9ucygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmdldE9wdGlvbnMuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uZ2V0T3B0aW9ucygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGdldFdpbmRvd09wdGlvbnMoKS50aGVuKG9wdHMgPT4gY29uc29sZS5sb2cob3B0cykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBnZXRPcHRpb25zKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXdpbmRvdy1vcHRpb25zJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIHBhcmVudCBhcHBsaWNhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGdldFBhcmVudEFwcGxpY2F0aW9uKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuZ2V0UGFyZW50QXBwbGljYXRpb24uaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uZ2V0UGFyZW50QXBwbGljYXRpb24oKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRQYXJlbnRBcHBsaWNhdGlvbigpLnRoZW4ocGFyZW50QXBwbGljYXRpb24gPT4gY29uc29sZS5sb2cocGFyZW50QXBwbGljYXRpb24pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0UGFyZW50QXBwbGljYXRpb24oKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dpbmRvdy1nZXQtcGFyZW50LWFwcGxpY2F0aW9uJywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgYXBwbGljYXRpb25fMS5BcHBsaWNhdGlvbih0aGlzLndpcmUsIHRoaXMuaWRlbnRpdHkpKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgcGFyZW50IHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGdldFBhcmVudFdpbmRvdygpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmdldFBhcmVudFdpbmRvdy5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5nZXRQYXJlbnRXaW5kb3coKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBnZXRQYXJlbnRXaW5kb3coKS50aGVuKHBhcmVudFdpbmRvdyA9PiBjb25zb2xlLmxvZyhwYXJlbnRXaW5kb3cpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0UGFyZW50V2luZG93KCkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd3aW5kb3ctZ2V0LXBhcmVudC13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBhcHBsaWNhdGlvbl8xLkFwcGxpY2F0aW9uKHRoaXMud2lyZSwgdGhpcy5pZGVudGl0eSkpLnRoZW4oKGFwcCkgPT4gYXBwLmdldFdpbmRvdygpKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogKioqREVQUkVDQVRFRCAtIHBsZWFzZSB1c2UgV2luZG93LmNhcHR1cmVQYWdlLioqKlxuXHQgICAgICogR2V0cyBhIGJhc2U2NCBlbmNvZGVkIFBORyBpbWFnZSBvZiB0aGUgd2luZG93IG9yIGp1c3QgcGFydCBhIG9mIGl0LlxuXHQgICAgICogQHBhcmFtIGFyZWEgVGhlIGFyZWEgb2YgdGhlIHdpbmRvdyB0byBiZSBjYXB0dXJlZC5cblx0ICAgICAqIE9taXR0aW5nIGl0IHdpbGwgY2FwdHVyZSB0aGUgd2hvbGUgdmlzaWJsZSB3aW5kb3cuXG5cdCAgICAgKlxuXHQgICAgICogQHR1dG9yaWFsIFdpbmRvdy5jYXB0dXJlUGFnZVxuXHQgICAgICovXG5cdCAgICBhc3luYyBnZXRTbmFwc2hvdChhcmVhKSB7XG5cdCAgICAgICAgY29uc3QgcmVxID0geyBhcmVhLCAuLi50aGlzLmlkZW50aXR5IH07XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdXaW5kb3cuZ2V0U25hcHNob3QgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBXaW5kb3cuY2FwdHVyZVBhZ2UnKTtcblx0ICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXdpbmRvdy1zbmFwc2hvdCcsIHJlcSk7XG5cdCAgICAgICAgcmV0dXJuIHJlcy5wYXlsb2FkLmRhdGE7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgKFwibWluaW1pemVkXCIsIFwibWF4aW1pemVkXCIsIG9yIFwibm9ybWFsXCIpIG9mIHRoZSB3aW5kb3cuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBnZXRXaW5kb3dTdGF0ZSgpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LmdldFN0YXRlLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLmdldFN0YXRlKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogZ2V0V2luZG93U3RhdGUoKS50aGVuKHdpblN0YXRlID0+IGNvbnNvbGUubG9nKHdpblN0YXRlKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGdldFN0YXRlKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXdpbmRvdy1zdGF0ZScsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBQcmV2aW91c2x5IGNhbGxlZCBnZXROYXRpdmVXaW5kb3cuXG5cdCAgICAgKiBSZXR1cm5zIHRoZSBbV2luZG93IE9iamVjdF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdylcblx0ICAgICAqIHRoYXQgcmVwcmVzZW50cyB0aGUgd2ViIGNvbnRleHQgb2YgdGhlIHRhcmdldCB3aW5kb3cuIFRoaXMgaXMgdGhlIHNhbWUgb2JqZWN0IHRoYXRcblx0ICAgICAqIHlvdSB3b3VsZCBnZXQgZnJvbSBjYWxsaW5nIFt3aW5kb3cub3BlbigpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L29wZW4pIGluIGEgc3RhbmRhcmQgd2ViIGNvbnRleHQuXG5cdCAgICAgKiBUaGUgdGFyZ2V0IHdpbmRvdyBuZWVkcyB0byBiZSBpbiB0aGUgc2FtZSBhcHBsaWNhdGlvbiBhcyB0aGUgcmVxdWVzdGluZyB3aW5kb3dcblx0ICAgICAqIGFzIHdlbGwgYXMgY29tcGx5IHdpdGggW3NhbWUtb3JpZ2luXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TZWN1cml0eS9TYW1lLW9yaWdpbl9wb2xpY3kpIHBvbGljeSByZXF1aXJlbWVudHMuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIEluamVjdGluZyBjb250ZW50IGludG8gYW4gZW1wdHkgd2luZG93OlxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiAoYXN5bmMgKCk9PiB7XG5cdCAgICAgKiAgICAgdHJ5IHtcblx0ICAgICAqICAgICAgICAgY29uc3Qgd2luTmFtZSA9IGBjaGlsZC13aW5kb3ctJHtEYXRlLm5vdygpfWA7XG5cdCAgICAgKiAgICAgICAgIGNvbnN0IHdpbiA9IGF3YWl0IGZpbi5XaW5kb3cuY3JlYXRlKHtcblx0ICAgICAqICAgICAgICAgICAgIG5hbWU6IHdpbk5hbWUsXG5cdCAgICAgKiAgICAgICAgICAgICB1cmw6ICdhYm91dDpibGFuaydcblx0ICAgICAqICAgICAgICAgfSk7XG5cdCAgICAgKiAgICAgICAgIHdpbi5nZXRXZWJXaW5kb3coKS5kb2N1bWVudC53cml0ZSgnPGgxPkhlbGxvIFdvcmxkPC9oMT4nKTtcblx0ICAgICAqICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pKCk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBDbG9uaW5nIERPTSBlbGVtZW50cyBmcm9tIHRoZSBwYXJlbnQgd2luZG93IChpbiB0aGlzIGV4YW1wbGUgd2UgY2xvbmUgYW4gYGgzYCBlbGVtZW50IGZyb20gdGhlIHBhcmVudCB3aW5kb3cpOlxuXHQgICAgICogYGBganNcblx0ICAgICAqIChhc3luYyAoKT0+IHtcblx0ICAgICAqICAgICB0cnkge1xuXHQgICAgICogICAgICAgICBjb25zdCBjdXJyZW50V2luZG93ID0gYXdhaXQgZmluLldpbmRvdy5nZXRDdXJyZW50KCk7XG5cdCAgICAgKiAgICAgICAgIGNvbnN0IHBhcmVudFdpbmRvdyA9IGF3YWl0IGN1cnJlbnRXaW5kb3cuZ2V0UGFyZW50V2luZG93KCk7XG5cdCAgICAgKiAgICAgICAgIGNvbnN0IGNsb25lZEgzID0gcGFyZW50V2luZG93LmdldFdlYldpbmRvdygpLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gzJykuY2xvbmVOb2RlKHRydWUpO1xuXHQgICAgICogICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjbG9uZWRIMyk7XG5cdCAgICAgKlxuXHQgICAgICogICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICogICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG5cdCAgICAgKiAgICAgfVxuXHQgICAgICogfSkoKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICpcblx0ICAgICAqIFJlbmRlcmluZyBvbiBhIGNoaWxkIHdpbmRvdyB2aWEgYSBsaWJyYXJ5IChpbiB0aGlzIGV4YW1wbGUgd2UgYXJlIHVzaW5nIHRoZSBbbGl0LWh0bWxdKGh0dHBzOi8vbGl0LWh0bWwucG9seW1lci1wcm9qZWN0Lm9yZy8pXG5cdCAgICAgKiB0ZW1wbGF0ZSBsaWJyYXJ5IHRvIHJlbmRlciBjb250ZW50IG9uIGEgYmxhbmsgY2hpbGQgd2luZG93LiBZb3UgYXJlIG5vdCBnb2luZyB0byBiZSBhYmxlIHRvIGNvcHkgcGFzdGUgdGhpcyBleGFtcGxlIHdpdGhvdXRcblx0ICAgICAqIGNvbmZpZ3VyaW5nIHRoZSBwcm9qZWN0IGNvcnJlY3RseSBidXQgdGhpcyB3b3VsZCBkZW1vbnN0cmF0ZSBzb21lIHRlbXBsYXRpbmcgb3B0aW9ucyBhdmFpbGFibGUpOlxuXHQgICAgICogYGBganNcblx0ICAgICAqIChhc3luYyAoKT0+IHtcblx0ICAgICAqICAgICB0cnkge1xuXHQgICAgICogICAgICAgICBjb25zdCB3aW4gPSBhd2FpdCBmaW4uV2luZG93LmNyZWF0ZSh7XG5cdCAgICAgKiAgICAgICAgICAgICBuYW1lOiBgY2hpbGQtd2luZG93LSR7RGF0ZS5ub3coKX1gLFxuXHQgICAgICogICAgICAgICAgICAgdXJsOiAnYWJvdXQ6YmxhbmsnXG5cdCAgICAgKiAgICAgICAgIH0pO1xuXHQgICAgICogICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGh0bWxgXG5cdCAgICAgKiAgICAgICAgICAgICA8ZGl2PlxuXHQgICAgICogICAgICAgICAgICAgICAgIDxzcGFuPkNsaWNrIGhlcmU6IDwvc3Bhbj5cblx0ICAgICAqICAgICAgICAgICAgICAgICA8YnV0dG9uIEBjbGljaz0keygpPT4gY29uc29sZS5sb2coJ0hlbGxvIFdvcmxkIScpfT5sb2cgdG8gdGhlIGNvbnNvbGU8L2J1dHRvbj5cblx0ICAgICAqICAgICAgICAgICAgIDwvZGl2PmA7XG5cdCAgICAgKiAgICAgICAgIHJlbmRlcih0ZW1wbGF0ZSwgd2luLmdldFdlYldpbmRvdygpLmRvY3VtZW50LmJvZHkpO1xuXHQgICAgICpcblx0ICAgICAqICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pKCk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgZ2V0V2ViV2luZG93KCkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd3aW5kb3ctZ2V0LXdlYi13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLmVudmlyb25tZW50LmdldFdlYldpbmRvdyh0aGlzLmlkZW50aXR5KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgd2luZG93IGlzIGEgbWFpbiB3aW5kb3cuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCB3bmQgPSBmaW4uV2luZG93LmdldEN1cnJlbnRTeW5jKCk7XG5cdCAgICAgKiBjb25zdCBpc01haW5XbmQgPSB3bmQuaXNNYWluV2luZG93KCk7XG5cdCAgICAgKiBjb25zb2xlLmxvZygnSXMgdGhpcyBhIG1haW4gd2luZG93PyAnICsgaXNNYWluV25kKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBpc01haW5XaW5kb3coKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dpbmRvdy1pcy1tYWluLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLm1lLnV1aWQgPT09IHRoaXMubWUubmFtZTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgd2luZG93IGlzIGN1cnJlbnRseSBzaG93aW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gaXNXaW5kb3dTaG93aW5nKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuaXNTaG93aW5nLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLmlzU2hvd2luZygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGlzV2luZG93U2hvd2luZygpLnRoZW4oYm9vbCA9PiBjb25zb2xlLmxvZyhib29sKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGlzU2hvd2luZygpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2lzLXdpbmRvdy1zaG93aW5nJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIE1heGltaXplcyB0aGUgd2luZG93XG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBtYXhXaW5kb3coKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5tYXhpbWl6ZS5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5tYXhpbWl6ZSgpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIG1heFdpbmRvdygpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ01heGltaXplZCB3aW5kb3cnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIG1heGltaXplKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignbWF4aW1pemUtd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBNaW5pbWl6ZXMgdGhlIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIG1pbldpbmRvdygpIHtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBmaW4uV2luZG93LmdldEN1cnJlbnQoKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLm1pbmltaXplKCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogbWluV2luZG93KCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnTWluaW1pemVkIHdpbmRvdycpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgbWluaW1pemUoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdtaW5pbWl6ZS13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIE1vdmVzIHRoZSB3aW5kb3cgYnkgYSBzcGVjaWZpZWQgYW1vdW50LlxuXHQgICAgICogQHBhcmFtIGRlbHRhTGVmdCBUaGUgY2hhbmdlIGluIHRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSB3aW5kb3dcblx0ICAgICAqIEBwYXJhbSBkZWx0YVRvcCBUaGUgY2hhbmdlIGluIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHdpbmRvd1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gY3JlYXRlV2luKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cubW92ZUJ5Lmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gbW92ZUJ5KGxlZnQsIHRvcCkge1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGNyZWF0ZVdpbigpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4ubW92ZUJ5KGxlZnQsIHRvcCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogbW92ZUJ5KDU4MCwgMzAwKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdNb3ZlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgbW92ZUJ5KGRlbHRhTGVmdCwgZGVsdGFUb3AsIHBvc2l0aW9uaW5nT3B0aW9ucykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmVcblx0ICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ21vdmUtd2luZG93LWJ5Jywge1xuXHQgICAgICAgICAgICBkZWx0YUxlZnQsXG5cdCAgICAgICAgICAgIGRlbHRhVG9wLFxuXHQgICAgICAgICAgICBwb3NpdGlvbmluZ09wdGlvbnMsXG5cdCAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHlcblx0ICAgICAgICB9KVxuXHQgICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBNb3ZlcyB0aGUgd2luZG93IHRvIGEgc3BlY2lmaWVkIGxvY2F0aW9uLlxuXHQgICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIHdpbmRvd1xuXHQgICAgICogQHBhcmFtIHRvcCBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSB3aW5kb3dcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93Lm1vdmVUby5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIG1vdmVUbyhsZWZ0LCB0b3ApIHtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBjcmVhdGVXaW4oKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLm1vdmVUbyhsZWZ0LCB0b3ApXG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogbW92ZVRvKDU4MCwgMzAwKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdNb3ZlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSlcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBtb3ZlVG8obGVmdCwgdG9wLCBwb3NpdGlvbmluZ09wdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlXG5cdCAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdtb3ZlLXdpbmRvdycsIHtcblx0ICAgICAgICAgICAgbGVmdCxcblx0ICAgICAgICAgICAgdG9wLFxuXHQgICAgICAgICAgICBwb3NpdGlvbmluZ09wdGlvbnMsXG5cdCAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHlcblx0ICAgICAgICB9KVxuXHQgICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNpemVzIHRoZSB3aW5kb3cgYnkgYSBzcGVjaWZpZWQgYW1vdW50LlxuXHQgICAgICogQHBhcmFtIGRlbHRhV2lkdGggVGhlIGNoYW5nZSBpbiB0aGUgd2lkdGggb2YgdGhlIHdpbmRvd1xuXHQgICAgICogQHBhcmFtIGRlbHRhSGVpZ2h0IFRoZSBjaGFuZ2UgaW4gdGhlIGhlaWdodCBvZiB0aGUgd2luZG93XG5cdCAgICAgKiBAcGFyYW0gYW5jaG9yIFNwZWNpZmllcyBhIGNvcm5lciB0byByZW1haW4gZml4ZWQgZHVyaW5nIHRoZSByZXNpemUuXG5cdCAgICAgKiBDYW4gdGFrZSB0aGUgdmFsdWVzOiBcInRvcC1sZWZ0XCIsIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgb3IgXCJib3R0b20tcmlnaHRcIi5cblx0ICAgICAqIElmIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHQgaXMgXCJ0b3AtbGVmdFwiXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVXaW4oKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5yZXNpemVCeS5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHJlc2l6ZUJ5KGxlZnQsIHRvcCwgYW5jaG9yKSB7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgY3JlYXRlV2luKCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5yZXNpemVCeShsZWZ0LCB0b3AsIGFuY2hvcilcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiByZXNpemVCeSg1ODAsIDMwMCwgJ3RvcC1yaWdodCcpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1Jlc2l6ZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIHJlc2l6ZUJ5KGRlbHRhV2lkdGgsIGRlbHRhSGVpZ2h0LCBhbmNob3IsIHBvc2l0aW9uaW5nT3B0aW9ucykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmVcblx0ICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3Jlc2l6ZS13aW5kb3ctYnknLCB7XG5cdCAgICAgICAgICAgIGRlbHRhV2lkdGg6IE1hdGguZmxvb3IoZGVsdGFXaWR0aCksXG5cdCAgICAgICAgICAgIGRlbHRhSGVpZ2h0OiBNYXRoLmZsb29yKGRlbHRhSGVpZ2h0KSxcblx0ICAgICAgICAgICAgYW5jaG9yLFxuXHQgICAgICAgICAgICBwb3NpdGlvbmluZ09wdGlvbnMsXG5cdCAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHlcblx0ICAgICAgICB9KVxuXHQgICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNpemVzIHRoZSB3aW5kb3cgdG8gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25zLlxuXHQgICAgICogQHBhcmFtIHdpZHRoIFRoZSBjaGFuZ2UgaW4gdGhlIHdpZHRoIG9mIHRoZSB3aW5kb3dcblx0ICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGNoYW5nZSBpbiB0aGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3dcblx0ICAgICAqIEBwYXJhbSBhbmNob3IgU3BlY2lmaWVzIGEgY29ybmVyIHRvIHJlbWFpbiBmaXhlZCBkdXJpbmcgdGhlIHJlc2l6ZS5cblx0ICAgICAqIENhbiB0YWtlIHRoZSB2YWx1ZXM6IFwidG9wLWxlZnRcIiwgXCJ0b3AtcmlnaHRcIiwgXCJib3R0b20tbGVmdFwiLCBvciBcImJvdHRvbS1yaWdodFwiLlxuXHQgICAgICogSWYgdW5kZWZpbmVkLCB0aGUgZGVmYXVsdCBpcyBcInRvcC1sZWZ0XCJcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LnJlc2l6ZVRvLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gcmVzaXplVG8obGVmdCwgdG9wLCBhbmNob3IpIHtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBjcmVhdGVXaW4oKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLnJlc2l6ZVRvKGxlZnQsIHRvcCwgYW5jaG9yKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiByZXNpemVUbyg1ODAsIDMwMCwgJ3RvcC1sZWZ0JykudGhlbigoKSA9PiBjb25zb2xlLmxvZygnUmVzaXplZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgcmVzaXplVG8od2lkdGgsIGhlaWdodCwgYW5jaG9yLCBwb3NpdGlvbmluZ09wdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlXG5cdCAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdyZXNpemUtd2luZG93Jywge1xuXHQgICAgICAgICAgICB3aWR0aDogTWF0aC5mbG9vcih3aWR0aCksXG5cdCAgICAgICAgICAgIGhlaWdodDogTWF0aC5mbG9vcihoZWlnaHQpLFxuXHQgICAgICAgICAgICBhbmNob3IsXG5cdCAgICAgICAgICAgIHBvc2l0aW9uaW5nT3B0aW9ucyxcblx0ICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eVxuXHQgICAgICAgIH0pXG5cdCAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJlc3RvcmVzIHRoZSB3aW5kb3cgdG8gaXRzIG5vcm1hbCBzdGF0ZSAoaS5lLiwgdW5taW5pbWl6ZWQsIHVubWF4aW1pemVkKS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LnJlc3RvcmUuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiByZXN0b3JlKCkge1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGNyZWF0ZVdpbigpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4ucmVzdG9yZSgpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIHJlc3RvcmUoKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdSZXN0b3JlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgcmVzdG9yZSgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Jlc3RvcmUtd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBXaWxsIGJyaW5nIHRoZSB3aW5kb3cgdG8gdGhlIGZyb250IG9mIHRoZSBlbnRpcmUgc3RhY2sgYW5kIGdpdmUgaXQgZm9jdXMuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVXaW4oKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5zZXRBc0ZvcmVncm91bmQuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiB0cnVlXG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGFwcC5nZXRXaW5kb3coKTtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBzZXRBc0ZvcmVncm91bmQoKSB7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgY3JlYXRlV2luKCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHdpbi5zZXRBc0ZvcmVncm91bmQoKVxuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIHNldEFzRm9yZWdyb3VuZCgpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0luIHRoZSBmb3JlZ3JvdW5kJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBzZXRBc0ZvcmVncm91bmQoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtZm9yZWdyb3VuZC13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFNldHMgdGhlIHdpbmRvdydzIHNpemUgYW5kIHBvc2l0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gY3JlYXRlV2luKCkge1xuXHQgICAgICogICAgIGNvbnN0IGFwcCA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5zdGFydCh7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6ICdteUFwcCcsXG5cdCAgICAgKiAgICAgICAgIHV1aWQ6ICdhcHAtMScsXG5cdCAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L3N0YWJsZS90dXRvcmlhbC1XaW5kb3cuc2V0Qm91bmRzLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gc2V0Qm91bmRzKGJvdW5kcykge1xuXHQgICAgICogICAgIGNvbnN0IHdpbiA9IGF3YWl0IGNyZWF0ZVdpbigpO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCB3aW4uc2V0Qm91bmRzKGJvdW5kcyk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogc2V0Qm91bmRzKHtcblx0ICAgICAqICAgICBoZWlnaHQ6IDEwMCxcblx0ICAgICAqICAgICB3aWR0aDogMjAwLFxuXHQgICAgICogICAgIHRvcDogNDAwLFxuXHQgICAgICogICAgIGxlZnQ6IDQwMFxuXHQgICAgICogfSkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQm91bmRzIHNldCB0byB3aW5kb3cnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIHNldEJvdW5kcyhib3VuZHMsIHBvc2l0aW9uaW5nT3B0aW9ucykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmVcblx0ICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3NldC13aW5kb3ctYm91bmRzJywgeyAuLi5ib3VuZHMsIC4uLnRoaXMuaWRlbnRpdHksIHBvc2l0aW9uaW5nT3B0aW9ucyB9KVxuXHQgICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG93cyB0aGUgd2luZG93IGlmIGl0IGlzIGhpZGRlbi5cblx0ICAgICAqIEBwYXJhbSBmb3JjZSBTaG93IHdpbGwgYmUgcHJldmVudGVkIGZyb20gc2hvd2luZyB3aGVuIGZvcmNlIGlzIGZhbHNlIGFuZFxuXHQgICAgICogIOKAmHNob3ctcmVxdWVzdGVk4oCZIGhhcyBiZWVuIHN1YnNjcmliZWQgdG8gZm9yIGFwcGxpY2F0aW9u4oCZcyBtYWluIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LnNob3cuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGF1dG9TaG93OiBmYWxzZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogYXN5bmMgZnVuY3Rpb24gc2hvdygpIHtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBjcmVhdGVXaW4oKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLnNob3coKVxuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIHNob3coKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdTaG93aW5nJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBzaG93KGZvcmNlID0gZmFsc2UpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Nob3ctd2luZG93JywgeyBmb3JjZSwgLi4udGhpcy5pZGVudGl0eSB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFNob3dzIHRoZSB3aW5kb3cgaWYgaXQgaXMgaGlkZGVuIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIHdpbmRvdyBpbiBwaXhlbHNcblx0ICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgd2luZG93IGluIHBpeGVsc1xuXHQgICAgICogQHBhcmFtIGZvcmNlIFNob3cgd2lsbCBiZSBwcmV2ZW50ZWQgZnJvbSBjbG9zaW5nIHdoZW4gZm9yY2UgaXMgZmFsc2UgYW5kXG5cdCAgICAgKiDigJhzaG93LXJlcXVlc3RlZOKAmSBoYXMgYmVlbiBzdWJzY3JpYmVkIHRvIGZvciBhcHBsaWNhdGlvbuKAmXMgbWFpbiB3aW5kb3dcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LnNob3dBdC5odG1sJyxcblx0ICAgICAqICAgICAgICAgYXV0b1Nob3c6IHRydWVcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgYXBwLmdldFdpbmRvdygpO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHNob3dBdChsZWZ0LCB0b3ApIHtcblx0ICAgICAqICAgICBjb25zdCB3aW4gPSBhd2FpdCBjcmVhdGVXaW4oKTtcblx0ICAgICAqICAgICByZXR1cm4gYXdhaXQgd2luLnNob3dBdChsZWZ0LCB0b3ApXG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogc2hvd0F0KDU4MCwgMzAwKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdTaG93aW5nIGF0JykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBzaG93QXQobGVmdCwgdG9wLCBmb3JjZSA9IGZhbHNlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuXHQgICAgICAgICAgICAuc2VuZEFjdGlvbignc2hvdy1hdC13aW5kb3cnLCB7XG5cdCAgICAgICAgICAgIGZvcmNlLFxuXHQgICAgICAgICAgICBsZWZ0OiBNYXRoLmZsb29yKGxlZnQpLFxuXHQgICAgICAgICAgICB0b3A6IE1hdGguZmxvb3IodG9wKSxcblx0ICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eVxuXHQgICAgICAgIH0pXG5cdCAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFNob3dzIHRoZSBDaHJvbWl1bSBEZXZlbG9wZXIgVG9vbHNcblx0ICAgICAqXG5cdCAgICAgKiBAdHV0b3JpYWwgV2luZG93LnNob3dEZXZlbG9wZXJUb29sc1xuXHQgICAgICovXG5cdCAgICAvKipcblx0ICAgICAqIFVwZGF0ZXMgdGhlIHdpbmRvdyB1c2luZyB0aGUgcGFzc2VkIG9wdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgVmFsdWVzIHRoYXQgYXJlIG9iamVjdHMgYXJlIGRlZXAtbWVyZ2VkLCBvdmVyd3JpdGluZyBvbmx5IHRoZSB2YWx1ZXMgdGhhdCBhcmUgcHJvdmlkZWQuXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyBDaGFuZ2VzIGEgd2luZG93J3Mgb3B0aW9ucyB0aGF0IHdlcmUgZGVmaW5lZCB1cG9uIGNyZWF0aW9uLiBTZWUgdHV0b3JpYWxcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoKSB7XG5cdCAgICAgKiAgICAgY29uc3Qgd2luID0gYXdhaXQgZmluLldpbmRvdy5nZXRDdXJyZW50KCk7XG5cdCAgICAgKiAgICAgcmV0dXJuIHdpbi51cGRhdGVPcHRpb25zKHttYXhXaWR0aDogMTAwfSk7XG5cdCAgICAgKiB9XG5cdCAgICAgKiB1cGRhdGVPcHRpb25zKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnb3B0aW9ucyBpcyB1cGRhdGVkJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigndXBkYXRlLXdpbmRvdy1vcHRpb25zJywgeyBvcHRpb25zLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUHJvdmlkZXMgY3JlZGVudGlhbHMgdG8gYXV0aGVudGljYXRpb24gcmVxdWVzdHNcblx0ICAgICAqIEBwYXJhbSB1c2VyTmFtZSB1c2VyTmFtZSB0byBwcm92aWRlIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBjaGFsbGVuZ2Vcblx0ICAgICAqIEBwYXJhbSBwYXNzd29yZCBwYXNzd29yZCB0byBwcm92aWRlIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBjaGFsbGVuZ2Vcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGZpbi5BcHBsaWNhdGlvbi53cmFwKHt1dWlkOiAnT3BlbmZpblBPQyd9KS50aGVuKGFwcCA9PiB7XG5cdCAgICAgKiAgICAgYXBwLm9uKCd3aW5kb3ctYXV0aC1yZXF1ZXN0ZWQnLCBldnQgPT4ge1xuXHQgICAgICogICAgICAgICBsZXQgd2luID0gZmluLldpbmRvdy53cmFwKHsgdXVpZDogZXZ0LnV1aWQsIG5hbWU6IGV2dC5uYW1lfSk7XG5cdCAgICAgKiAgICAgICAgIHdpbi5hdXRoZW50aWNhdGUoJ3VzZXJOYW1lJywgJ1BAYXNzdzByZCcpLnRoZW4oKCk9PiBjb25zb2xlLmxvZygnYXV0aGVudGljYXRlZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhdXRoZW50aWNhdGUodXNlck5hbWUsIHBhc3N3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuXHQgICAgICAgICAgICAuc2VuZEFjdGlvbignd2luZG93LWF1dGhlbnRpY2F0ZScsIHsgdXNlck5hbWUsIHBhc3N3b3JkLCAuLi50aGlzLmlkZW50aXR5IH0pXG5cdCAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFNob3dzIGEgbWVudSBvbiB0aGUgd2luZG93LlxuXHQgICAgICpcblx0ICAgICAqIEByZW1hcmtzIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdXNlciBoYXMgZWl0aGVyIHNlbGVjdGVkIGFuIGl0ZW0gb3IgY2xvc2VkIHRoZSBtZW51LiAoVGhpcyBtYXkgdGFrZSBsb25nZXIgdGhhbiBvdGhlciBhcGlzKS5cblx0ICAgICAqIFJlc29sdmVzIHRvIGFuIG9iamVjdCB3aXRoIGB7cmVzdWx0OiAnY2xpY2tlZCcsIGRhdGEgfWAgd2hlcmUgZGF0YSBpcyB0aGUgZGF0YSBmaWVsZCBvbiB0aGUgbWVudSBpdGVtIGNsaWNrZWQsIG9yIGB7cmVzdWx0ICdjbG9zZWQnfWAgd2hlbiB0aGUgdXNlciBkb2Vzbid0IHNlbGVjdCBhbnl0aGluZy5cblx0ICAgICAqIENhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBjbG9zZSBwcmV2aW91c2x5IG9wZW5lZCBtZW51cy5cblx0ICAgICAqIEBleHBlcmltZW50YWxcblx0ICAgICAqIEBwYXJhbSBvcHRpb25zXG5cdCAgICAgKiBAdHlwZVBhcmFtIERhdGEgVXNlci1kZWZpbmVkIHNoYXBlIGZvciBkYXRhIHJldHVybmVkIHVwb24gbWVudSBpdGVtIGNsaWNrLiAgU2hvdWxkIGJlIGFcblx0ICAgICAqIFt1bmlvbl0oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svMi9ldmVyeWRheS10eXBlcy5odG1sI3VuaW9uLXR5cGVzKVxuXHQgICAgICogb2YgYWxsIHBvc3NpYmxlIGRhdGEgc2hhcGVzIGZvciB0aGUgZW50aXJlIG1lbnUsIGFuZCB0aGUgY2xpY2sgaGFuZGxlciBzaG91bGQgcHJvY2Vzc1xuXHQgICAgICogdGhlc2Ugd2l0aCBhIFwicmVkdWNlclwiIHBhdHRlcm4uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogVGhpcyBjb3VsZCBiZSB1c2VkIHRvIHNob3cgYSBkcm9wIGRvd24gbWVudSBvdmVyIHZpZXdzIGluIGEgcGxhdGZvcm0gd2luZG93OlxuXHQgICAgICogYGBganNcblx0ICAgICAqIGNvbnN0IHRlbXBsYXRlID0gW1xuXHQgICAgICogICAgIHtcblx0ICAgICAqICAgICAgICAgbGFiZWw6ICdNZW51IEl0ZW0gMScsXG5cdCAgICAgKiAgICAgICAgIGRhdGE6ICdoZWxsbyBmcm9tIGl0ZW0gMSdcblx0ICAgICAqICAgICB9LFxuXHQgICAgICogICAgIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcblx0ICAgICAqICAgICB7XG5cdCAgICAgKiAgICAgICAgIGxhYmVsOiAnTWVudSBJdGVtIDInLFxuXHQgICAgICogICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuXHQgICAgICogICAgICAgICBjaGVja2VkOiB0cnVlLFxuXHQgICAgICogICAgICAgICBkYXRhOiAnVGhlIHVzZXIgY2xpY2tlZCB0aGUgY2hlY2tib3gnXG5cdCAgICAgKiAgICAgfSxcblx0ICAgICAqICAgICB7XG5cdCAgICAgKiAgICAgICAgIGxhYmVsOiAnc2VlIG1vcmUnLFxuXHQgICAgICogICAgICAgICBlbmFibGVkOiBmYWxzZSxcblx0ICAgICAqICAgICAgICAgc3VibWVudTogW1xuXHQgICAgICogICAgICAgICAgICAgeyBsYWJlbDogJ3N1Ym1lbnUgMScsIGRhdGE6ICdoZWxsbyBmcm9tIHN1Ym1lbnUnIH1cblx0ICAgICAqICAgICAgICAgXVxuXHQgICAgICogICAgIH1cblx0ICAgICAqIF1cblx0ICAgICAqIGZpbi5tZS5zaG93UG9wdXBNZW51KHsgdGVtcGxhdGUgfSkudGhlbihyID0+IHtcblx0ICAgICAqICAgICBpZiAoci5yZXN1bHQgPT09ICdjbG9zZWQnKSB7XG5cdCAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdub3RoaW5nIGhhcHBlbmVkJyk7XG5cdCAgICAgKiAgICAgfSBlbHNlIHtcblx0ICAgICAqICAgICAgICAgY29uc29sZS5sb2coci5kYXRhKVxuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pXG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBPdmVycmlkaW5nIHRoZSBidWlsdCBpbiBjb250ZXh0IG1lbnUgKG5vdGU6IHRoYXQgdGhpcyBjYW4gYmUgZG9uZSBwZXIgZWxlbWVudCBvciBkb2N1bWVudCB3aWRlKTpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGUgPT4ge1xuXHQgICAgICogICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAqICAgICBjb25zdCB0ZW1wbGF0ZSA9IFtcblx0ICAgICAqICAgICAgICAge1xuXHQgICAgICogICAgICAgICAgICAgbGFiZWw6ICdNZW51IEl0ZW0gMScsXG5cdCAgICAgKiAgICAgICAgICAgICBkYXRhOiAnaGVsbG8gZnJvbSBpdGVtIDEnXG5cdCAgICAgKiAgICAgICAgIH0sXG5cdCAgICAgKiAgICAgICAgIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcblx0ICAgICAqICAgICAgICAge1xuXHQgICAgICogICAgICAgICAgICAgbGFiZWw6ICdNZW51IEl0ZW0gMicsXG5cdCAgICAgKiAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuXHQgICAgICogICAgICAgICAgICAgY2hlY2tlZDogdHJ1ZSxcblx0ICAgICAqICAgICAgICAgICAgIGRhdGE6ICdUaGUgdXNlciBjbGlja2VkIHRoZSBjaGVja2JveCdcblx0ICAgICAqICAgICAgICAgfSxcblx0ICAgICAqICAgICAgICAge1xuXHQgICAgICogICAgICAgICAgICAgbGFiZWw6ICdzZWUgbW9yZScsXG5cdCAgICAgKiAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcblx0ICAgICAqICAgICAgICAgICAgIHN1Ym1lbnU6IFtcblx0ICAgICAqICAgICAgICAgICAgICAgICB7IGxhYmVsOiAnc3VibWVudSAxJywgZGF0YTogJ2hlbGxvIGZyb20gc3VibWVudScgfVxuXHQgICAgICogICAgICAgICAgICAgXVxuXHQgICAgICogICAgICAgICB9XG5cdCAgICAgKiAgICAgXVxuXHQgICAgICogICAgIGZpbi5tZS5zaG93UG9wdXBNZW51KHsgdGVtcGxhdGUsIHg6IGUueCwgeTogZS55IH0pLnRoZW4ociA9PiB7XG5cdCAgICAgKiAgICAgICAgIGlmIChyLnJlc3VsdCA9PT0gJ2Nsb3NlZCcpIHtcblx0ICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub3RoaW5nIGhhcHBlbmVkJyk7XG5cdCAgICAgKiAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhyLmRhdGEpXG5cdCAgICAgKiAgICAgICAgIH1cblx0ICAgICAqICAgICB9KVxuXHQgICAgICogfSlcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBzaG93UG9wdXBNZW51KG9wdGlvbnMpIHtcblx0ICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzaG93LXBvcHVwLW1lbnUnLCB7IG9wdGlvbnMsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG5cdCAgICAgICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQ2xvc2VzIHRoZSB3aW5kb3cncyBwb3B1cCBtZW51LCBpZiBvbmUgZXhpc3RzLlxuXHQgICAgICogQGV4cGVyaW1lbnRhbFxuXHQgICAgICpcblx0ICAgICAqIEByZW1hcmtzIE9ubHkgb25lIHBvcHVwIG1lbnUgd2lsbCBldmVyIGJlIHNob3dpbmcgYXQgYSB0aW1lLiBDYWxsaW5nIGBzaG93UG9wdXBNZW51YCB3aWxsIGF1dG9tYXRpY2FsbHkgY2xvc2Vcblx0ICAgICAqIGFueSBleGlzdGluZyBwb3B1cCBtZW51LlxuXHQgICAgICpcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogVGhpcyBjb3VsZCBiZSB1c2VkIHRvIGNsb3NlIGEgcG9wdXAgbWVudSBpZiB0aGUgdXNlcidzIG1vdXNlIGxlYXZlcyBhbiBlbGVtZW50IGZvciBleGFtcGxlLlxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhd2FpdCBmaW4ubWUuY2xvc2VQb3B1cE1lbnUoKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBjbG9zZVBvcHVwTWVudSgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Nsb3NlLXBvcHVwLW1lbnUnLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBEaXNwYXRjaCBhIHJlc3VsdCB0byB0aGUgY2FsbGVyIG9mIGBzaG93UG9wdXBXaW5kb3dgLlxuXHQgICAgICpcblx0ICAgICAqIEByZW1hcmtzIElmIHRoaXMgd2luZG93IGlzbid0IGN1cnJlbnRseSBiZWluZyBzaG93biBhcyBhIHBvcHVwLCB0aGlzIGNhbGwgd2lsbCBzaWxlbnRseSBmYWlsLlxuXHQgICAgICogQHBhcmFtIGRhdGEgU2VyaWFsaXphYmxlIGRhdGEgdG8gc2VuZCB0byB0aGUgY2FsbGVyIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGF3YWl0IGZpbi5tZS5kaXNwYXRjaFBvcHVwUmVzdWx0KHtcblx0ICAgICAqICAgICBmb286ICdiYXInXG5cdCAgICAgKiB9KTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBkaXNwYXRjaFBvcHVwUmVzdWx0KGRhdGEpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LWRpc3BhdGNoLXBvcHVwLXJlc3VsdCcsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdkaXNwYXRjaC1wb3B1cC1yZXN1bHQnLCB7IGRhdGEsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFByaW50cyB0aGUgY29udGVudHMgb2YgdGhlIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIGZvciB0aGUgcHJpbnQgdGFzay5cblx0ICAgICAqIEByZW1hcmtzIFdoZW4gYHNpbGVudGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIEFQSSB3aWxsIHBpY2sgdGhlIHN5c3RlbSdzIGRlZmF1bHQgcHJpbnRlciBpZiBkZXZpY2VOYW1lIGlzIGVtcHR5XG5cdCAgICAgKiBhbmQgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIHByaW50aW5nLlxuXHQgICAgICpcblx0ICAgICAqIFVzZSB0aGUgQ1NTIHN0eWxlIGBwYWdlLWJyZWFrLWJlZm9yZTogYWx3YXlzO2AgdG8gZm9yY2UgcHJpbnQgdG8gYSBuZXcgcGFnZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGNvbnN0IHdpbiA9IGZpbi5XaW5kb3cuZ2V0Q3VycmVudFN5bmMoKTtcblx0ICAgICAqXG5cdCAgICAgKiB3aW4ucHJpbnQoeyBzaWxlbnQ6IGZhbHNlLCBkZXZpY2VOYW1lOiAnc3lzdGVtLXByaW50ZXItbmFtZScgfSkudGhlbigoKSA9PiB7XG5cdCAgICAgKiAgICAgY29uc29sZS5sb2coJ3ByaW50IGNhbGwgaGFzIGJlZW4gc2VudCB0byB0aGUgc3lzdGVtJyk7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIGBgYFxuXHQgICAgICpcblx0ICAgICAqIElmIGEgd2luZG93IGhhcyBlbWJlZGRlZCB2aWV3cywgdGhvc2Ugdmlld3Mgd2lsbCBub3QgcHJpbnQgYnkgZGVmYXVsdC4gIFRvIHByaW50IGEgd2luZG93J3MgY29udGVudHMgaW5jbHVkaW5nIGVtYmVkZGVkIHZpZXdzLFxuXHQgICAgICogdXNlIHRoZSBgY29udGVudGAgb3B0aW9uOlxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCB3aW4gPSBmaW4uV2luZG93LmdldEN1cnJlbnRTeW5jKCk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gUHJpbnQgZW1iZWRkZWQgdmlld3Ncblx0ICAgICAqIHdpbi5wcmludCh7IGNvbnRlbnQ6ICd2aWV3cycgfSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gUHJpbnQgc2NyZWVuc2hvdCBvZiBjdXJyZW50IHdpbmRvd1xuXHQgICAgICogd2luLnByaW50KHsgY29udGVudDogJ3NjcmVlbnNob3QnIH0pXG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBXaGVuIGBjb250ZW50YCBpcyBzZXQgdG8gYHZpZXdzYCwgdGhlIGVtYmVkZGVkIHZpZXdzIGluIHRoZSBwbGF0Zm9ybSB3aW5kb3cgd2lsbCBiZSBjb25jYXRlbmF0ZWQgYW5kIHByaW50ZWQgYXNcblx0ICAgICAqIGluZGl2aWR1YWwgcGFnZXMuICBJZiBgaW5jbHVkZVNlbGZgIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBwbGF0Zm9ybSB3aW5kb3cgaXRzZWxmIHdpbGwgYmUgcHJpbnRlZCBhcyB0aGUgZmlyc3Rcblx0ICAgICAqIHBhZ2UgLSBiZSBhd2FyZSB0aGF0IHRoaXMgcGFnZSB3aWxsICpub3QqIGluY2x1ZGUgdGhlIGVtYmVkZGVkIHZpZXdzIC0gaXQgd2lsbCBvbmx5IGluY2x1ZGUgdGhlIGNvbnRlbnRzIG9mXG5cdCAgICAgKiB0aGUgcGxhdGZvcm0gd2luZG93IGl0c2VsZiAoZS5nLiB0YWIgc3RhY2tzKSwgd2l0aCBibGFuayBzcGFjZXMgd2hlcmUgdGhlIHZpZXcgY29udGVudHMgd291bGQgYmUgZW1iZWRkZWQuXG5cdCAgICAgKlxuXHQgICAgICogRHVlIHRvIGEga25vd24gaXNzdWUsIHZpZXcgY29udGVudHMgdGhhdCBhcmUgbm90IHZpc2libGUgYXQgdGhlIHRpbWUgYHByaW50YCBpcyBjYWxsZWQgd2lsbCBub3QgYXBwZWFyIHdoZW5cblx0ICAgICAqIHByaW50aW5nIGBjb250ZW50czogdmlld3NgLiAgVGhpcyBpbmNsdWRlcyB2aWV3cyB0aGF0IGFyZSBvYnNjdXJlZCBiZWhpbmQgb3RoZXIgYWN0aXZlIFVJIGVsZW1lbnRzLlxuXHQgICAgICpcblx0ICAgICAqIFRvIHByaW50IHRoZSB2aWV3cyBlbWJlZGRlZCBpbiB0aGVpciBwYWdlIGNvbnRleHQsIHNldCBgY29udGVudGAgdG8gYHNjcmVlbnNob3RgLlxuXHQgICAgICovXG5cdCAgICBhc3luYyBwcmludChvcHRpb25zID0geyBjb250ZW50OiAnc2VsZicgfSkge1xuXHQgICAgICAgIHN3aXRjaCAob3B0aW9ucy5jb250ZW50KSB7XG5cdCAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuXHQgICAgICAgICAgICBjYXNlICdzZWxmJzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5wcmludChvcHRpb25zKTtcblx0ICAgICAgICAgICAgY2FzZSAnc2NyZWVuc2hvdCc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ByaW50LXNjcmVlbnNob3QnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG5cdCAgICAgICAgICAgIGNhc2UgJ3ZpZXdzJzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigncHJpbnQtdmlld3MnLCB7IC4uLnRoaXMuaWRlbnRpdHksIG9wdGlvbnMgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblx0SW5zdGFuY2UkNy5fV2luZG93ID0gX1dpbmRvdztcblx0cmV0dXJuIEluc3RhbmNlJDc7XG59XG5cbnZhciBoYXNSZXF1aXJlZEZhY3RvcnkkMTtcblxuZnVuY3Rpb24gcmVxdWlyZUZhY3RvcnkkMSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEZhY3RvcnkkMSkgcmV0dXJuIEZhY3RvcnkkODtcblx0aGFzUmVxdWlyZWRGYWN0b3J5JDEgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjdG9yeSQ4LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0RmFjdG9yeSQ4Ll9XaW5kb3dNb2R1bGUgPSB2b2lkIDA7XG5cdGNvbnN0IGJhc2VfMSA9IGJhc2U7XG5cdGNvbnN0IHZhbGlkYXRlXzEgPSB2YWxpZGF0ZTtcblx0Y29uc3QgSW5zdGFuY2VfMSA9IHJlcXVpcmVJbnN0YW5jZSgpO1xuXHQvKipcblx0ICogU3RhdGljIG5hbWVzcGFjZSBmb3IgT3BlbkZpbiBBUEkgbWV0aG9kcyB0aGF0IGludGVyYWN0IHdpdGggdGhlIHtAbGluayBfV2luZG93fSBjbGFzcywgYXZhaWxhYmxlIHVuZGVyIGBmaW4uV2luZG93YC5cblx0ICovXG5cdGNsYXNzIF9XaW5kb3dNb2R1bGUgZXh0ZW5kcyBiYXNlXzEuQmFzZSB7XG5cdCAgICAvKipcblx0ICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYSBXaW5kb3cgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleGlzdGluZyB3aW5kb3cuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBhc3luYyBmdW5jdGlvbiBjcmVhdGVXaW4oKSB7XG5cdCAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLnN0YXJ0KHtcblx0ICAgICAqICAgICAgICAgbmFtZTogJ215QXBwJyxcblx0ICAgICAqICAgICAgICAgdXVpZDogJ2FwcC0xJyxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy53cmFwLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKiBjcmVhdGVXaW4oKS50aGVuKCgpID0+IGZpbi5XaW5kb3cud3JhcCh7IHV1aWQ6ICdhcHAtMScsIG5hbWU6ICdteUFwcCcgfSkpXG5cdCAgICAgKiAudGhlbih3aW4gPT4gY29uc29sZS5sb2coJ3dyYXBwZWQgd2luZG93JykpXG5cdCAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIHdyYXAoaWRlbnRpdHkpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LXdyYXAnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb25zdCBlcnJvck1zZyA9ICgwLCB2YWxpZGF0ZV8xLnZhbGlkYXRlSWRlbnRpdHkpKGlkZW50aXR5KTtcblx0ICAgICAgICBpZiAoZXJyb3JNc2cpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLl9XaW5kb3codGhpcy53aXJlLCBpZGVudGl0eSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFdpbmRvdyBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIGV4aXN0aW5nIHdpbmRvdy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbigpIHtcblx0ICAgICAqICAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uc3RhcnQoe1xuXHQgICAgICogICAgICAgICBuYW1lOiAnbXlBcHAnLFxuXHQgICAgICogICAgICAgICB1dWlkOiAnYXBwLTEnLFxuXHQgICAgICogICAgICAgICB1cmw6ICdodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9zdGFibGUvdHV0b3JpYWwtV2luZG93LndyYXBTeW5jLmh0bWwnLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogICAgIHJldHVybiBhd2FpdCBhcHAuZ2V0V2luZG93KCk7XG5cdCAgICAgKiB9XG5cdCAgICAgKiBhd2FpdCBjcmVhdGVXaW4oKTtcblx0ICAgICAqIGxldCB3aW4gPSBmaW4uV2luZG93LndyYXBTeW5jKHsgdXVpZDogJ2FwcC0xJywgbmFtZTogJ215QXBwJyB9KTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICB3cmFwU3luYyhpZGVudGl0eSkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd3aW5kb3ctd3JhcC1zeW5jJykuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29uc3QgZXJyb3JNc2cgPSAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUlkZW50aXR5KShpZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKGVycm9yTXNnKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMS5fV2luZG93KHRoaXMud2lyZSwgaWRlbnRpdHkpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgbmV3IFdpbmRvdy5cblx0ICAgICAqIEBwYXJhbSBvcHRpb25zIC0gV2luZG93IGNyZWF0aW9uIG9wdGlvbnNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdygpIHtcblx0ICAgICAqICAgICBjb25zdCB3aW5PcHRpb24gPSB7XG5cdCAgICAgKiAgICAgICAgIG5hbWU6J2NoaWxkJyxcblx0ICAgICAqICAgICAgICAgZGVmYXVsdFdpZHRoOiAzMDAsXG5cdCAgICAgKiAgICAgICAgIGRlZmF1bHRIZWlnaHQ6IDMwMCxcblx0ICAgICAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVdpbmRvdy5jcmVhdGUuaHRtbCcsXG5cdCAgICAgKiAgICAgICAgIGZyYW1lOiB0cnVlLFxuXHQgICAgICogICAgICAgICBhdXRvU2hvdzogdHJ1ZVxuXHQgICAgICogICAgIH07XG5cdCAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGZpbi5XaW5kb3cuY3JlYXRlKHdpbk9wdGlvbik7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogY3JlYXRlV2luZG93KCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnV2luZG93IGlzIGNyZWF0ZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGNyZWF0ZShvcHRpb25zKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NyZWF0ZS13aW5kb3cnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb25zdCB3aW4gPSBuZXcgSW5zdGFuY2VfMS5fV2luZG93KHRoaXMud2lyZSwgeyB1dWlkOiB0aGlzLm1lLnV1aWQsIG5hbWU6IG9wdGlvbnMubmFtZSB9KTtcblx0ICAgICAgICByZXR1cm4gd2luLmNyZWF0ZVdpbmRvdyhvcHRpb25zKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFdpbmRvdyBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHdpbmRvd1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogZmluLldpbmRvdy5nZXRDdXJyZW50KClcblx0ICAgICAqIC50aGVuKHduZCA9PiBjb25zb2xlLmxvZygnY3VycmVudCB3aW5kb3cnKSlcblx0ICAgICAqIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG5cdCAgICAgKlxuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGdldEN1cnJlbnQoKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1jdXJyZW50LXdpbmRvdycpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmICghdGhpcy53aXJlLm1lLmlzV2luZG93KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gYSBXaW5kb3cgY29udGV4dCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IHRoaXMud2lyZS5tZTtcblx0ICAgICAgICByZXR1cm4gdGhpcy53cmFwKHsgdXVpZCwgbmFtZSB9KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgV2luZG93IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgd2luZG93XG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCB3bmQgPSBmaW4uV2luZG93LmdldEN1cnJlbnRTeW5jKCk7XG5cdCAgICAgKiBjb25zdCBpbmZvID0gYXdhaXQgd25kLmdldEluZm8oKTtcblx0ICAgICAqIGNvbnNvbGUubG9nKGluZm8pO1xuXHQgICAgICpcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBnZXRDdXJyZW50U3luYygpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWN1cnJlbnQtd2luZG93LXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAoIXRoaXMud2lyZS5tZS5pc1dpbmRvdykge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IGluIGEgV2luZG93IGNvbnRleHQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSB0aGlzLndpcmUubWU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN5bmMoeyB1dWlkLCBuYW1lIH0pO1xuXHQgICAgfVxuXHR9XG5cdEZhY3RvcnkkOC5fV2luZG93TW9kdWxlID0gX1dpbmRvd01vZHVsZTtcblx0cmV0dXJuIEZhY3RvcnkkODtcbn1cblxudmFyIGhhc1JlcXVpcmVkV2luZG93O1xuXG5mdW5jdGlvbiByZXF1aXJlV2luZG93ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2luZG93KSByZXR1cm4gd2luZG93JDE7XG5cdGhhc1JlcXVpcmVkV2luZG93ID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdFx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdFx0ICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblx0XHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0XHQgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdFx0fSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcblx0XHQgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcblx0XHQgICAgb1trMl0gPSBtW2tdO1xuXHRcdH0pKTtcblx0XHR2YXIgX19leHBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuXHRcdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdFx0fTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0LyoqXG5cdFx0ICogRW50cnkgcG9pbnRzIGZvciB0aGUgT3BlbkZpbiBgV2luZG93YCBBUEkgKGBmaW4uV2luZG93YCkuXG5cdFx0ICpcblx0XHQgKiAqIHtAbGluayBfV2luZG93TW9kdWxlfSBjb250YWlucyBzdGF0aWMgbWVtYmVycyBvZiB0aGUgYFdpbmRvd2AgQVBJLCBhY2Nlc3NpYmxlIHRocm91Z2ggYGZpbi5XaW5kb3dgLlxuXHRcdCAqICoge0BsaW5rIF9XaW5kb3d9IGRlc2NyaWJlcyBhbiBpbnN0YW5jZSBvZiBhbiBPcGVuRmluIFdpbmRvdywgZS5nLiBhcyByZXR1cm5lZCBieSBgZmluLldpbmRvdy5nZXRDdXJyZW50YC5cblx0XHQgKlxuXHRcdCAqIFRoZXNlIGFyZSBzZXBhcmF0ZSBjb2RlIGVudGl0aWVzLCBhbmQgYXJlIGRvY3VtZW50ZWQgc2VwYXJhdGVseS4gIEluIHRoZSBbcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0LzMyLjExNC43Ni4xMC9pbmRleC5odG1sKSxcblx0XHQgKiBib3RoIG9mIHRoZXNlIHdlcmUgZG9jdW1lbnRlZCBvbiB0aGUgc2FtZSBwYWdlLlxuXHRcdCAqXG5cdFx0ICogVW5kZXJzY29yZSBwcmVmaXhpbmcgb2YgT3BlbkZpbiB0eXBlcyB0aGF0IGFsaWFzIERPTSBlbnRpdGllcyB3aWxsIGJlIGZpeGVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFja2FnZURvY3VtZW50YXRpb25cblx0XHQgKi9cblx0XHRfX2V4cG9ydFN0YXIocmVxdWlyZUZhY3RvcnkkMSgpLCBleHBvcnRzKTtcblx0XHRfX2V4cG9ydFN0YXIocmVxdWlyZUluc3RhbmNlKCksIGV4cG9ydHMpOyBcblx0fSAod2luZG93JDEpKTtcblx0cmV0dXJuIHdpbmRvdyQxO1xufVxuXG4vKipcbiAqIEVudHJ5IHBvaW50IGZvciB0aGUgT3BlbkZpbiBgU3lzdGVtYCBBUEkgKGBmaW4uU3lzdGVtYCkuXG4gKlxuICogKiB7QGxpbmsgU3lzdGVtfSBjb250YWlucyBzdGF0aWMgbWVtYmVycyBvZiB0aGUgYFN5c3RlbWAgQVBJIChhdmFpbGFibGUgdW5kZXIgYGZpbi5TeXN0ZW1gKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc3lzdGVtLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnN5c3RlbS5TeXN0ZW0gPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEkaiA9IGJhc2U7XG5jb25zdCB0cmFuc3BvcnRfZXJyb3JzXzEkMSA9IHRyYW5zcG9ydEVycm9ycztcbmNvbnN0IHdpbmRvd18xID0gcmVxdWlyZVdpbmRvdygpO1xuY29uc3QgZXZlbnRzXzEkNiA9IHJlcXVpcmUkJDA7XG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNvcmUgb2YgT3BlbkZpbiBSdW50aW1lLiBBbGxvd3MgdGhlIGRldmVsb3BlclxuICogdG8gcGVyZm9ybSBzeXN0ZW0tbGV2ZWwgYWN0aW9ucywgc3VjaCBhcyBhY2Nlc3NpbmcgbG9ncywgdmlld2luZyBwcm9jZXNzZXMsXG4gKiBjbGVhcmluZyB0aGUgY2FjaGUgYW5kIGV4aXRpbmcgdGhlIHJ1bnRpbWUgYXMgd2VsbCBhcyBsaXN0ZW4gdG8ge0BsaW5rIE9wZW5GaW4uU3lzdGVtRXZlbnRzIHN5c3RlbSBldmVudHN9LlxuICpcbiAqL1xuY2xhc3MgU3lzdGVtIGV4dGVuZHMgYmFzZV8xJGouRW1pdHRlckJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpcmUpIHtcbiAgICAgICAgc3VwZXIod2lyZSwgJ3N5c3RlbScpO1xuICAgIH1cbiAgICBzZW5kRXh0ZXJuYWxQcm9jZXNzUmVxdWVzdChhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXRFdmVudEtleSA9ICdleHRlcm5hbC1wcm9jZXNzLWV4aXRlZCc7XG4gICAgICAgICAgICBsZXQgcHJvY2Vzc1V1aWQ7XG4gICAgICAgICAgICBsZXQgZXhpdFBheWxvYWQ7XG4gICAgICAgICAgICBsZXQgZXh0ZXJuYWxQcm9jZXNzRXhpdEhhbmRsZXI7XG4gICAgICAgICAgICBsZXQgb2ZXaW5kb3c7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFByb2Nlc3NFeGl0SGFuZGxlciA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwYXlsb2FkIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBleGl0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiAnZXhpdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWQ6IGRhdGEucHJvY2Vzc1V1aWQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0Q29kZTogZGF0YS5leGl0Q29kZSB8fCAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzVXVpZCA9PT0gcGF5bG9hZC5wcm9jZXNzVXVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5saXN0ZW5lcihleGl0UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZldpbmRvdy5yZW1vdmVMaXN0ZW5lcihleGl0RXZlbnRLZXksIGV4dGVybmFsUHJvY2Vzc0V4aXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gd2luZG93IGNvbnN0cnVjdG9yIGV4cGVjdHMgdGhlIG5hbWUgaXMgbm90IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy53aXJlLm1lLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aXJlLm1lLm5hbWUgPSB0aGlzLndpcmUubWUudXVpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZXaW5kb3cgPSBuZXcgd2luZG93XzEuX1dpbmRvdyh0aGlzLndpcmUsIHRoaXMud2lyZS5tZSk7XG4gICAgICAgICAgICAgICAgb2ZXaW5kb3cub24oZXhpdEV2ZW50S2V5LCBleHRlcm5hbFByb2Nlc3NFeGl0SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpcmVcbiAgICAgICAgICAgICAgICAuc2VuZEFjdGlvbihhY3Rpb24sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1V1aWQgPSBwYXlsb2FkLmRhdGEudXVpZDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHBheWxvYWQuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXRQYXlsb2FkICYmIHByb2Nlc3NVdWlkID09PSBleGl0UGF5bG9hZC51dWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubGlzdGVuZXIoZXhpdFBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBvZldpbmRvdy5yZW1vdmVMaXN0ZW5lcihleGl0RXZlbnRLZXksIGV4dGVybmFsUHJvY2Vzc0V4aXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9mV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIG9mV2luZG93LnJlbW92ZUxpc3RlbmVyKGV4aXRFdmVudEtleSwgZXh0ZXJuYWxQcm9jZXNzRXhpdEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgcnVudGltZS4gVGhlIHZlcnNpb24gY29udGFpbnMgdGhlIG1ham9yLCBtaW5vcixcbiAgICAgKiBidWlsZCBhbmQgcmV2aXNpb24gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldFZlcnNpb24oKS50aGVuKHYgPT4gY29uc29sZS5sb2codikpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC12ZXJzaW9uJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBjYWNoZWQgZGF0YSBjb250YWluaW5nIGFwcGxpY2F0aW9uIHJlc291cmNlXG4gICAgICogZmlsZXMgKGltYWdlcywgSFRNTCwgSmF2YVNjcmlwdCBmaWxlcyksIGNvb2tpZXMsIGFuZCBpdGVtcyBzdG9yZWQgaW4gdGhlXG4gICAgICogTG9jYWwgU3RvcmFnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFNlZSBiZWxvdyBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBhY2NlcHRlZCBvcHRpb25zLCBzZWUgdGhlIGZvbGxvd2luZyBwYWdlczpcbiAgICAgKiAqIGNhY2hlOiBicm93c2luZyBkYXRhIGNhY2hlIGZvciBodG1sIGZpbGVzIGFuZCBpbWFnZXMgKFtjYWNoaW5nXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0NhY2hpbmcpKVxuICAgICAqICogY29va2llczogYnJvd3NlciBbY29va2llc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Db29raWVzKVxuICAgICAqICogbG9jYWxTdG9yYWdlOiBicm93c2VyIGRhdGEgdGhhdCBjYW4gYmUgdXNlZCBhY3Jvc3Mgc2Vzc2lvbnMgKFtsb2NhbCBzdG9yYWdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2xvY2FsU3RvcmFnZSkpXG4gICAgICogKiBhcHBjYWNoZTogaHRtbDUgW2FwcGxpY2F0aW9uIGNhY2hlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML1VzaW5nX3RoZV9hcHBsaWNhdGlvbl9jYWNoZSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgY2xlYXJDYWNoZU9wdGlvbnMgPSB7XG4gICAgICogICAgIGFwcGNhY2hlOiB0cnVlLFxuICAgICAqICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgKiAgICAgY29va2llczogdHJ1ZSxcbiAgICAgKiAgICAgbG9jYWxTdG9yYWdlOiB0cnVlXG4gICAgICogfTtcbiAgICAgKiBmaW4uU3lzdGVtLmNsZWFyQ2FjaGUoY2xlYXJDYWNoZU9wdGlvbnMpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0NhY2hlIGNsZWFyZWQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJDYWNoZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xlYXItY2FjaGUnLCBvcHRpb25zKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2FjaGVkIGRhdGEgd2hlbiBPcGVuRmluIFJ1bnRpbWUgZXhpdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5kZWxldGVDYWNoZU9uRXhpdCgpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0RlbGV0ZWQgQ2FjaGUnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRlbGV0ZUNhY2hlT25FeGl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2RlbGV0ZS1jYWNoZS1yZXF1ZXN0JykudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGl0cyB0aGUgUnVudGltZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmV4aXQoKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdleGl0JykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBleGl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2V4aXQtZGVza3RvcCcpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIEpTT04gbWFuaWZlc3QgdXNpbmcgdGhlIGJyb3dzZXIgcHJvY2VzcyBhbmQgcmV0dXJucyBhIEphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBtYW5pZmVzdFVybCBUaGUgVVJMIG9mIHRoZSBtYW5pZmVzdCB0byBmZXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGZpbi5TeXN0ZW0uZmV0Y2hNYW5pZmVzdCgnaHR0cHM6Ly93d3cucGF0aC10by1tYW5pZmVzdC5jb20nKTtcbiAgICAgKiBjb25zb2xlLmxvZyhtYW5pZmVzdCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hNYW5pZmVzdChtYW5pZmVzdFVybCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YSB9IH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZmV0Y2gtbWFuaWZlc3QnLCB7IG1hbmlmZXN0VXJsIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFueSB1bndyaXR0ZW4gY29va2llcyBkYXRhIHRvIGRpc2suXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5mbHVzaENvb2tpZVN0b3JlKClcbiAgICAgKiAgICAgLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ3N1Y2Nlc3MnKSlcbiAgICAgKiAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZsdXNoQ29va2llU3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZmx1c2gtY29va2llLXN0b3JlJykudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2YgZGF0YSAobmFtZSwgaWRzLCBib3VuZHMpIGZvciBhbGwgYXBwbGljYXRpb24gd2luZG93cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldEFsbFdpbmRvd3MoKS50aGVuKHdpbnMgPT4gY29uc29sZS5sb2cod2lucykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRBbGxXaW5kb3dzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1hbGwtd2luZG93cycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2YgZGF0YSBmb3IgYWxsIGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldEFsbEFwcGxpY2F0aW9ucygpLnRoZW4oYXBwcyA9PiBjb25zb2xlLmxvZyhhcHBzKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldEFsbEFwcGxpY2F0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYWxsLWFwcGxpY2F0aW9ucycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudCBzdHJpbmcgdGhhdCBzdGFydGVkIE9wZW5GaW4gUnVudGltZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldENvbW1hbmRMaW5lQXJndW1lbnRzKCkudGhlbihhcmdzID0+IGNvbnNvbGUubG9nKGFyZ3MpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0Q29tbWFuZExpbmVBcmd1bWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWNvbW1hbmQtbGluZS1hcmd1bWVudHMnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjcmFzaCByZXBvcnRlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldENyYXNoUmVwb3J0ZXJTdGF0ZSgpLnRoZW4oc3RhdGUgPT4gY29uc29sZS5sb2coc3RhdGUpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3Jhc2hSZXBvcnRlclN0YXRlKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YTogeyBkaWFnbm9zdGljTW9kZSwgaXNSdW5uaW5nIH0gfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1jcmFzaC1yZXBvcnRlci1zdGF0ZScpO1xuICAgICAgICBjb25zb2xlLndhcm4oJ2RpYWdub3N0aWNNb2RlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBkaWFnbm9zdGljTW9kZSB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvblxuICAgICAgICAgICAgZGlhZ25vc3RpY01vZGUsXG4gICAgICAgICAgICBkaWFnbm9zdGljc01vZGU6IGRpYWdub3N0aWNNb2RlLFxuICAgICAgICAgICAgaXNSdW5uaW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBjcmFzaCByZXBvcnRlciBpZiBub3QgYWxyZWFkeSBydW5uaW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gY29uZmlndXJlIGNyYXNoIHJlcG9ydGVyXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSBgZGlhZ25vc3RpY3NNb2RlYCB0byBoYXZlIHRoZSBsb2dzIHNlbnQgdG9cbiAgICAgKiBPcGVuRmluIG9uIHJ1bnRpbWUgY2xvc2UuIChOT1RFOiBgZGlhZ25vc3RpY3NNb2RlYCB3aWxsIHR1cm4gb24gdmVyYm9zZSBsb2dnaW5nIGFuZCBkaXNhYmxlIHRoZSBzYW5kYm94XG4gICAgICogZm9yIG5ld2x5IGxhdW5jaGVkIHJlbmRlcmVyIHByb2Nlc3Nlcy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL29mLWRvY3MvZG9jcy9kZWJ1Z2dpbmcjZGlhZ25vc3RpY3MtbW9kZSBmb3JcbiAgICAgKiBtb3JlIGRldGFpbHMuKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0uc3RhcnRDcmFzaFJlcG9ydGVyKHtkaWFnbm9zdGljc01vZGU6IHRydWV9KS50aGVuKHJlcG9ydGVyID0+IGNvbnNvbGUubG9nKHJlcG9ydGVyKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0Q3Jhc2hSZXBvcnRlcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBuZXdPcHRzID0geyAuLi5vcHRzLCBkaWFnbm9zdGljTW9kZTogb3B0cy5kaWFnbm9zdGljc01vZGUgfHwgb3B0cy5kaWFnbm9zdGljTW9kZSB9O1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YTogeyBkaWFnbm9zdGljTW9kZSwgaXNSdW5uaW5nIH0gfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3N0YXJ0LWNyYXNoLXJlcG9ydGVyJywgbmV3T3B0cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBkaWFnbm9zdGljTW9kZSB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvblxuICAgICAgICAgICAgZGlhZ25vc3RpY01vZGUsXG4gICAgICAgICAgICBkaWFnbm9zdGljc01vZGU6IGRpYWdub3N0aWNNb2RlLFxuICAgICAgICAgICAgaXNSdW5uaW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBoZXggZW5jb2RlZCBoYXNoIG9mIHRoZSBtYWNoaW5lIGlkIGFuZCB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIG5hbWUuXG4gICAgICogVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGEgdXNlciAvIG1hY2hpbmUgY29tYmluYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBGb3IgV2luZG93cyBzeXN0ZW1zIHRoaXMgaXMgYSBzaGEyNTYgaGFzaCBvZiB0aGUgbWFjaGluZSBJRCBzZXQgaW4gdGhlIHJlZ2lzdHJ5IGtleTpcbiAgICAgKiBgSEtFWV9MT0NBTF9NQUNISU5FXFxTT0ZUV0FSRVxcTWljcm9zb2Z0XFxDcnlwdG9ncmFwaHlcXE1hY2hpbmVHdWlkYCBhbmQgYFVTRVJOQU1FYC5cbiAgICAgKlxuICAgICAqIEZvciBPU1ggc3lzdGVtcywgYSBuYXRpdmUtbGV2ZWwgY2FsbCBpcyB1c2VkIHRvIGdldCB0aGUgbWFjaGluZSBJRC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldFVuaXF1ZVVzZXJJZCgpLnRoZW4oaWQgPT4gY29uc29sZS5sb2coaWQpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0VW5pcXVlVXNlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC11bmlxdWUtdXNlci1pZCcpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBmcmFtZSBpbmZvIG9iamVjdCBmb3IgdGhlIHV1aWQgYW5kIG5hbWUgcGFzc2VkIGluXG4gICAgICogQHBhcmFtIHV1aWQgLSBUaGUgVVVJRCBvZiB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoZSBwb3NzaWJsZSB0eXBlcyBhcmUgJ3dpbmRvdycsICdpZnJhbWUnLCAnZXh0ZXJuYWwgY29ubmVjdGlvbicgb3IgJ3Vua25vd24nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBlbnRpdHlVdWlkID0gJ09wZW5maW5QT0MnO1xuICAgICAqIGNvbnN0IGVudGl0eU5hbWUgPSAnNDBjNzRiNWQtZWQ5OC00MGY3LTg1M2YtZTNkM2MyNjk5MTc1JztcbiAgICAgKiBmaW4uU3lzdGVtLmdldEVudGl0eUluZm8oZW50aXR5VXVpZCwgZW50aXR5TmFtZSkudGhlbihpbmZvID0+IGNvbnNvbGUubG9nKGluZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICpcbiAgICAgKiAvLyBleGFtcGxlIGluZm8gc2hhcGVcbiAgICAgKiB7XG4gICAgICogICAgIFwidXVpZFwiOiBcIk9wZW5maW5QT0NcIixcbiAgICAgKiAgICAgXCJuYW1lXCI6IFwiNDBjNzRiNWQtZWQ5OC00MGY3LTg1M2YtZTNkM2MyNjk5MTc1XCIsXG4gICAgICogICAgIFwicGFyZW50XCI6IHtcbiAgICAgKiAgICAgICAgIFwidXVpZFwiOiBcIk9wZW5maW5QT0NcIixcbiAgICAgKiAgICAgICAgIFwibmFtZVwiOiBcIk9wZW5maW5QT0NcIlxuICAgICAqICAgICB9LFxuICAgICAqICAgICBcImVudGl0eVR5cGVcIjogXCJpZnJhbWVcIlxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRFbnRpdHlJbmZvKHV1aWQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtZW50aXR5LWluZm8nLCB7IHV1aWQsIG5hbWUgfSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGUgb24gdGhlIGNvbXB1dGVyIG9uIHdoaWNoIHRoZSBydW50aW1lIGlzIGluc3RhbGxlZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0uZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSgnSE9NRScpLnRoZW4oZW52ID0+IGNvbnNvbGUubG9nKGVudikpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2dldC1lbnZpcm9ubWVudC12YXJpYWJsZScsIHtcbiAgICAgICAgICAgIGVudmlyb25tZW50VmFyaWFibGVzOiBlbnZOYW1lXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGZvY3VzZWQgd2luZG93LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0uZ2V0Rm9jdXNlZFdpbmRvdygpLnRoZW4od2luSW5mbyA9PiBjb25zb2xlLmxvZyh3aW5JbmZvKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldEZvY3VzZWRXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWZvY3VzZWQtd2luZG93JykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGdpdmVuIGFwcCdzIGNlcnRpZmljYXRpb24gc3RhdHVzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgbWFuaWZlc3RVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6MTIzNC9hcHAuanNvblwiXG4gICAgICogdHJ5IHtcbiAgICAgKiAgICAgY29uc3QgY2VydGlmaWNhdGlvbkluZm8gPSBhd2FpdCBmaW4uU3lzdGVtLmlzQXBwQ2VydGlmaWVkKG1hbmlmZXN0VXJsKTtcbiAgICAgKiB9IGNhdGNoKGVycikge1xuICAgICAqICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgaXNBcHBDZXJ0aWZpZWQobWFuaWZlc3RVcmwpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGE6IHsgY2VydGlmaWVkSW5mbyB9IH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpcy1hcHAtY2VydGlmaWVkJywgeyBtYW5pZmVzdFVybCB9KTtcbiAgICAgICAgcmV0dXJuIGNlcnRpZmllZEluZm87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBpbnN0YWxsZWQgcnVudGltZSB2ZXJzaW9ucyBpbiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5nZXRJbnN0YWxsZWRSdW50aW1lcygpLnRoZW4ocnVudGltZXMgPT4gY29uc29sZS5sb2cocnVudGltZXMpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgLy8gaW5jb21wYXRpYmxlIHdpdGggc3RhbmRhbG9uZSBub2RlIHByb2Nlc3MuXG4gICAgZ2V0SW5zdGFsbGVkUnVudGltZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWluc3RhbGxlZC1ydW50aW1lcycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEucnVudGltZXMpO1xuICAgIH1cbiAgICAvLyBpbmNvbXBhdGlibGUgd2l0aCBzdGFuZGFsb25lIG5vZGUgcHJvY2Vzcy5cbiAgICBhc3luYyBnZXRJbnN0YWxsZWRBcHBzKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YTogeyBpbnN0YWxsZWRBcHBzIH0gfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1pbnN0YWxsZWQtYXBwcycpO1xuICAgICAgICByZXR1cm4gaW5zdGFsbGVkQXBwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjb250ZW50cyBvZiB0aGUgbG9nIHdpdGggdGhlIHNwZWNpZmllZCBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBIG9iamVjdCB0aGF0IGlkIGRlZmluZWQgYnkgdGhlIEdldExvZ1JlcXVlc3RUeXBlIGludGVyZmFjZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIGdldExvZygpIHtcbiAgICAgKiAgICAgY29uc3QgbG9ncyA9IGF3YWl0IGZpbi5TeXN0ZW0uZ2V0TG9nTGlzdCgpO1xuICAgICAqICAgICByZXR1cm4gYXdhaXQgZmluLlN5c3RlbS5nZXRMb2cobG9nc1swXSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZ2V0TG9nKCkudGhlbihsb2cgPT4gY29uc29sZS5sb2cobG9nKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldExvZyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigndmlldy1sb2cnLCBvcHRpb25zKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEKSBwcm92aWRlZCBieSB0aGUgbWFjaGluZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldE1hY2hpbmVJZCgpLnRoZW4oaWQgPT4gY29uc29sZS5sb2coaWQpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0TWFjaGluZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1tYWNoaW5lLWlkJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gKGluY2x1c2l2ZSkgbG9nZ2luZyBsZXZlbCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB3cml0dGVuIHRvIHRoZSBsb2cuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5nZXRNaW5Mb2dMZXZlbCgpLnRoZW4obGV2ZWwgPT4gY29uc29sZS5sb2cobGV2ZWwpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0TWluTG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LW1pbi1sb2ctbGV2ZWwnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFycmF5IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gZm9yIGVhY2ggbG9nIGZpbGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5nZXRMb2dMaXN0KCkudGhlbihsb2dMaXN0ID0+IGNvbnNvbGUubG9nKGxvZ0xpc3QpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0TG9nTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdsaXN0LWxvZ3MnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGRhdGEgYWJvdXQgdGhlIG1vbml0b3Igc2V0dXAgb2YgdGhlXG4gICAgICogY29tcHV0ZXIgdGhhdCB0aGUgcnVudGltZSBpcyBydW5uaW5nIG9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0uZ2V0TW9uaXRvckluZm8oKS50aGVuKG1vbml0b3JJbmZvID0+IGNvbnNvbGUubG9nKG1vbml0b3JJbmZvKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldE1vbml0b3JJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1tb25pdG9yLWluZm8nKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW91c2UgaW4gdmlydHVhbCBzY3JlZW4gY29vcmRpbmF0ZXMgKGxlZnQsIHRvcCkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5nZXRNb3VzZVBvc2l0aW9uKCkudGhlbihtb3VzZVBvc2l0aW9uID0+IGNvbnNvbGUubG9nKG1vdXNlUG9zaXRpb24pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0TW91c2VQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtbW91c2UtcG9zaXRpb24nKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgcnVudGltZSBwcm9jZXNzZXMgdGhhdCBhcmUgY3VycmVudGx5XG4gICAgICogcnVubmluZy4gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdXVpZFxuICAgICAqIGFuZCB0aGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24gdG8gd2hpY2ggdGhlIHByb2Nlc3MgYmVsb25ncy5cbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIG91ciBuZXcgc2V0IG9mIHByb2Nlc3MgQVBJczpcbiAgICAgKiB7QGxpbmsgV2luZG93Ll9XaW5kb3cjZ2V0UHJvY2Vzc0luZm8gV2luZG93LmdldFByb2Nlc3NJbmZvfVxuICAgICAqIHtAbGluayBWaWV3LlZpZXcjZ2V0UHJvY2Vzc0luZm8gVmlldy5nZXRQcm9jZXNzSW5mb31cbiAgICAgKiB7QGxpbmsgQXBwbGljYXRpb24uQXBwbGljYXRpb24jZ2V0UHJvY2Vzc0luZm8gQXBwbGljYXRpb24uZ2V0UHJvY2Vzc0luZm99XG4gICAgICoge0BsaW5rIFN5c3RlbSNnZXRBbGxQcm9jZXNzSW5mbyBTeXN0ZW0uZ2V0QWxsUHJvY2Vzc0luZm99XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5nZXRQcm9jZXNzTGlzdCgpLnRoZW4oUHJvY2Vzc0xpc3QgPT4gY29uc29sZS5sb2coUHJvY2Vzc0xpc3QpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0UHJvY2Vzc0xpc3QoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignU3lzdGVtLmdldFByb2Nlc3NMaXN0IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSBjb25zaWRlciB1c2luZyBvdXIgbmV3IHByb2Nlc3MgQVBJczogV2luZG93LmdldFByb2Nlc3NJbmZvLCBWaWV3LmdldFByb2Nlc3NJbmZvLCBBcHBsaWNhdGlvbi5nZXRQcm9jZXNzSW5mbywgU3lzdGVtLmdldEFsbFByb2Nlc3NJbmZvJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigncHJvY2Vzcy1zbmFwc2hvdCcpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIHByb2Nlc3MgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBUaGlzIGluY2x1ZGVzIHRoZSBicm93c2VyIHByb2Nlc3MgYW5kIGV2ZXJ5IHByb2Nlc3MgYXNzb2NpYXRlZCB0byBhbGwgZW50aXRpZXMgKHdpbmRvd3MgYW5kIHZpZXdzKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBhbGxQcm9jZXNzSW5mbyA9IGF3YWl0IGZpbi5TeXN0ZW0uZ2V0QWxsUHJvY2Vzc0luZm8oKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsUHJvY2Vzc0luZm8oKSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhIH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYWxsLXByb2Nlc3MtaW5mbycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBQcm94eSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldFByb3h5U2V0dGluZ3MoKS50aGVuKFByb3h5U2V0dGluZyA9PiBjb25zb2xlLmxvZyhQcm94eVNldHRpbmcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICpcbiAgICAgKiAvL1RoaXMgcmVzcG9uc2UgaGFzIHRoZSBmb2xsb3dpbmcgc2hhcGU6XG4gICAgICoge1xuICAgICAqICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgIHByb3h5QWRkcmVzczogXCJwcm94eUFkZHJlc3NcIiwgLy90aGUgY29uZmlndXJlZCBQcm94eSBBZGRyZXNzXG4gICAgICogICAgICAgICBwcm94eVBvcnQ6IDAsIC8vdGhlIGNvbmZpZ3VyZWQgUHJveHkgcG9ydFxuICAgICAqICAgICAgICAgdHlwZTogXCJzeXN0ZW1cIiAvL1Byb3h5IFR5cGVcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgc3lzdGVtOiB7XG4gICAgICogICAgICAgICBhdXRvQ29uZmlnVXJsOiBcIlwiLFxuICAgICAqICAgICAgICAgYnlwYXNzOiBcIlwiLFxuICAgICAqICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICogICAgICAgICBwcm94eTogXCJcIlxuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldFByb3h5U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXByb3h5LXNldHRpbmdzJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1bm5pbmcgUnVudGltZSBpbiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5nZXRSdW50aW1lSW5mbygpLnRoZW4oUnVudGltZUluZm8gPT4gY29uc29sZS5sb2coUnVudGltZUluZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0UnVudGltZUluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXJ1bnRpbWUtaW5mbycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW5uaW5nIFJWTSBpbiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5nZXRSdm1JbmZvKCkudGhlbihSdm1JbmZvID0+IGNvbnNvbGUubG9nKFJ2bUluZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgLy8gaW5jb21wYXRpYmxlIHdpdGggc3RhbmRhbG9uZSBub2RlIHByb2Nlc3MuXG4gICAgZ2V0UnZtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtcnZtLWluZm8nKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHN5c3RlbSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldEhvc3RTcGVjcygpLnRoZW4oc3BlY3MgPT4gY29uc29sZS5sb2coc3BlY3MpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0SG9zdFNwZWNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1ob3N0LXNwZWNzJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgYW4gZXhlY3V0YWJsZSBvciBiYXRjaCBmaWxlLiBBIHBhdGggdG8gdGhlIGZpbGUgbXVzdCBiZSBpbmNsdWRlZCBpbiBvcHRpb25zLlxuICAgICAqIDxicj4gQSB1dWlkIG1heSBiZSBvcHRpb25hbGx5IHByb3ZpZGVkLiBJZiBub3QgcHJvdmlkZWQsIE9wZW5GaW4gd2lsbCBjcmVhdGUgYSB1dWlkIGZvciB0aGUgbmV3IHByb2Nlc3MuXG4gICAgICogPGJyPiBOb3RlOiBUaGlzIG1ldGhvZCBpcyByZXN0cmljdGVkIGJ5IGRlZmF1bHQgYW5kIG11c3QgYmUgZW5hYmxlZCB2aWFcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXJzLm9wZW5maW4uY28vZG9jcy9hcGktc2VjdXJpdHlcIj5BUEkgc2VjdXJpdHkgc2V0dGluZ3M8L2E+LiBBbHNvLCB0aGlzIGFwaSBoYXMgYW4gZW5oYW5jZWQgcGVybWlzc2lvbiBzZXQgdG8gbWFrZSBpdCBsZXNzIGRhbmdlcm91cy4gU28gYXBwbGljYXRpb24gb3duZXJzIGNhbiBvbmx5IGFsbG93IHRvIGxhdW5jaCB0aGUgYXNzZXRzIG93bmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiwgdGhlIGVuYWJsZWQgZG93bmxvYWRlZCBmaWxlcyBvciB0aGUgcmVzdHJpY3RlZCBleGVjdXRhYmxlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBIG9iamVjdCB0aGF0IGlzIGRlZmluZWQgaW4gdGhlIEV4dGVybmFsUHJvY2Vzc1JlcXVlc3RUeXBlIGludGVyZmFjZVxuICAgICAqXG4gICAgICogQHJlbWFya3MgSWYgYW4gdW51c2VkIFVVSUQgaXMgcHJvdmlkZWQgaW4gb3B0aW9ucywgaXQgd2lsbCBiZSB1c2VkLiBJZiBubyBVVUlEIGlzIHByb3ZpZGVkLCBPcGVuRmluIHdpbGwgYXNzaWduIG9uZS5cbiAgICAgKiBUaGlzIGFwaSBoYXMgYW4gZW5oYW5jZWQgcGVybWlzc2lvbiBzZXQgdG8gbWFrZSBpdCBsZXNzIGRhbmdlcm91cy4gU28gYXBwbGljYXRpb24gb3duZXJzIGNhbiBvbmx5IGFsbG93IHRvIGxhdW5jaCB0aGVcbiAgICAgKiBhc3NldHMgb3duZWQgYnkgdGhlIGFwcGxpY2F0aW9uLCB0aGUgZW5hYmxlZCBkb3dubG9hZGVkIGZpbGVzIG9yIHRoZSByZXN0cmljdGVkIGV4ZWN1dGFibGVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFNpbmNlIF9hcHBBc3NldHNfIHJlbGllcyBvbiB0aGUgUlZNLCB3aGljaCBpcyBtaXNzaW5nIG9uIE1BQ19PUywgJ2FsaWFzJyBpcyBub3QgYXZhaWxhYmxlLiBJbnN0ZWFkIHByb3ZpZGVcbiAgICAgKiB0aGUgZnVsbCBwYXRoIGUuZy4gXy9BcHBsaWNhdGlvbnMvQ2FsY3VsYXRvci5hcHAvQ29udGVudHMvTWFjT1MvQ2FsY3VsYXRvcl8uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEJhc2ljIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmxhdW5jaEV4dGVybmFsUHJvY2Vzcyh7XG4gICAgICogICAgIHBhdGg6ICdub3RlcGFkJyxcbiAgICAgKiAgICAgYXJndW1lbnRzOiAnJyxcbiAgICAgKiAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCd0aGUgZXhpdCBjb2RlJywgcmVzdWx0LmV4aXRDb2RlKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pLnRoZW4ocHJvY2Vzc0lkZW50aXR5ID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocHJvY2Vzc0lkZW50aXR5KTtcbiAgICAgKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFByb21pc2UgcmVzb2x1dGlvbjpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogLy9UaGlzIHJlc3BvbnNlIGhhcyB0aGUgZm9sbG93aW5nIHNoYXBlOlxuICAgICAqIHtcbiAgICAgKiAgICAgdXVpZDogXCJGQjNFNkUzNi0wOTc2LTRDMkItOUEwOS1GQjJFNTREMkYxQkJcIiAvLyBUaGUgbWFwcGVkIFVVSUQgd2hpY2ggaWRlbnRpZmllcyB0aGUgbGF1bmNoZWQgcHJvY2Vzc1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIExpc3RlbmVyIGNhbGxiYWNrOlxuICAgICAqIGBgYGpzXG4gICAgICogLy9UaGlzIHJlc3BvbnNlIGhhcyB0aGUgZm9sbG93aW5nIHNoYXBlOlxuICAgICAqIHtcbiAgICAgKiAgICAgdG9waWM6IFwiZXhpdGVkXCIsIC8vIE9yIFwicmVsZWFzZWRcIiBvbiBhIGNhbGwgdG8gcmVsZWFzZUV4dGVybmFsUHJvY2Vzc1xuICAgICAqICAgICB1dWlkOiBcIkZCM0U2RTM2LTA5NzYtNEMyQi05QTA5LUZCMkU1NEQyRjFCQlwiLCAvLyBUaGUgbWFwcGVkIFVVSUQgd2hpY2ggaWRlbnRpZmllcyB0aGUgbGF1bmNoZWQgcHJvY2Vzc1xuICAgICAqICAgICBleGl0Q29kZTogMCAvLyBQcm9jZXNzIGV4aXQgY29kZVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJ5IHNwZWNpZnlpbmcgYSBsaWZldGltZSwgYW4gZXh0ZXJuYWwgcHJvY2VzcyBjYW4gbGl2ZSBhcyBsb25nIHRoZSB3aW5kb3cvYXBwbGljYXRpb24gdGhhdCBsYXVuY2hlZCBpdCBvclxuICAgICAqIHBlcnNpc3QgYWZ0ZXIgdGhlIGFwcGxpY2F0aW9uIGV4aXRzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvICdwZXJzaXN0JywgbWVhbmluZ1xuICAgICAqIHRoZSBwcm9jZXNzIGxpdmVzIG9uIGFmdGVyIHRoZSBhcHBsaWNhdGlvbiBleGl0czpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5sYXVuY2hFeHRlcm5hbFByb2Nlc3Moe1xuICAgICAqICAgICBwYXRoOiAnbm90ZXBhZCcsXG4gICAgICogICAgIGFyZ3VtZW50czogJycsXG4gICAgICogICAgIGxpc3RlbmVyOiAocmVzdWx0KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygndGhlIGV4aXQgY29kZScsIHJlc3VsdC5leGl0Q29kZSk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxpZmV0aW1lOiAnd2luZG93J1xuICAgICAqIH0pLnRoZW4ocHJvY2Vzc0lkZW50aXR5ID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocHJvY2Vzc0lkZW50aXR5KTtcbiAgICAgKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGU6IEEgcHJvY2VzcyB0aGF0IGV4aXRzIHdoZW4gdGhlIHdpbmRvdy9hcHBsaWNhdGlvbiBleGl0cyBjYW5ub3QgYmUgcmVsZWFzZWQgdmlhIGZpbi5kZXNrdG9wLlN5c3RlbS5yZWxlYXNlRXh0ZXJuYWxQcm9jZXNzLlxuICAgICAqXG4gICAgICogQnkgc3BlY2lmeWluZyBhIGN3ZCwgaXQgd2lsbCBzZXQgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSB3aGVuIGxhdW5jaGluZyBhbiBleHRlcm5hbCBwcm9jZXNzOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmxhdW5jaEV4dGVybmFsUHJvY2Vzcyh7XG4gICAgICogICAgIHBhdGg6ICdjbWQuZXhlJyxcbiAgICAgKiAgICAgY3dkOiAnYzpcXFxcdGVtcCcsXG4gICAgICogICAgIGFyZ3VtZW50czogJycsXG4gICAgICogICAgIGxpc3RlbmVyOiAocmVzdWx0KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygndGhlIGV4aXQgY29kZScsIHJlc3VsdC5leGl0Q29kZSk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KS50aGVuKHByb2Nlc3NJZGVudGl0eSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHByb2Nlc3NJZGVudGl0eSk7XG4gICAgICogfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHVzaW5nIGFuIGFsaWFzIGZyb20gYXBwLmpzb24gYXBwQXNzZXRzIHByb3BlcnR5OlxuICAgICAqXG4gICAgICogYGBganNvblxuICAgICAqIFwiYXBwQXNzZXRzXCI6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgICAgXCJzcmNcIjogXCJleGUuemlwXCIsXG4gICAgICogICAgICAgICBcImFsaWFzXCI6IFwibXlBcHBcIixcbiAgICAgKiAgICAgICAgIFwidmVyc2lvblwiOiBcIjQuMTIuOFwiLFxuICAgICAqICAgICAgICAgXCJ0YXJnZXRcIjogXCJteUFwcC5leGVcIixcbiAgICAgKiAgICAgICAgIFwiYXJnc1wiOiBcImEgYiBjIGRcIlxuICAgICAqICAgICB9LFxuICAgICAqIF1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogLy8gIFdoZW4gY2FsbGVkLCBpZiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aGVuIHRoZSBhcmd1bWVudHMgKGlmIGFueSlcbiAgICAgKiAvLyAgYXJlIHRha2VuIGZyb20gdGhlICdhcHAuanNvbicgZmlsZSwgZnJvbSB0aGUgICdhcmdzJyBwYXJhbWV0ZXJcbiAgICAgKiAvLyAgb2YgdGhlICdhcHBBc3NldHMnIE9iamVjdCB3aXRoIHRoZSByZWxldmFudCAnYWxpYXMnLlxuICAgICAqIGZpbi5TeXN0ZW0ubGF1bmNoRXh0ZXJuYWxQcm9jZXNzKHtcbiAgICAgKiAgICAgLy9BZGRpdGlvbmFsbHkgbm90ZSB0aGF0IHRoZSBleGVjdXRhYmxlIGZvdW5kIGluIHRoZSB6aXAgZmlsZSBzcGVjaWZpZWQgaW4gYXBwQXNzZXRzXG4gICAgICogICAgIC8vd2lsbCBkZWZhdWx0IHRvIHRoZSBvbmUgbWVudGlvbmVkIGJ5IGFwcEFzc2V0cy50YXJnZXRcbiAgICAgKiAgICAgLy9JZiB0aGUgdGhlIHBhdGggYmVsb3cgcmVmZXJzIHRvIGEgc3BlY2lmaWMgcGF0aCBpdCB3aWxsIG92ZXJyaWRlIHRoaXMgZGVmYXVsdFxuICAgICAqICAgICBhbGlhczogJ215QXBwJyxcbiAgICAgKiAgICAgbGlzdGVuZXI6IChyZXN1bHQpID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCd0aGUgZXhpdCBjb2RlJywgcmVzdWx0LmV4aXRDb2RlKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pLnRoZW4ocHJvY2Vzc0lkZW50aXR5ID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocHJvY2Vzc0lkZW50aXR5KTtcbiAgICAgKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgdXNpbmcgYW4gYWxpYXMgYnV0IG92ZXJyaWRpbmcgdGhlIGFyZ3VtZW50czpcbiAgICAgKlxuICAgICAqIGBgYGpzb25cbiAgICAgKiBcImFwcEFzc2V0c1wiOiBbXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICAgIFwic3JjXCI6IFwiZXhlLnppcFwiLFxuICAgICAqICAgICAgICAgXCJhbGlhc1wiOiBcIm15QXBwXCIsXG4gICAgICogICAgICAgICBcInZlcnNpb25cIjogXCI0LjEyLjhcIixcbiAgICAgKiAgICAgICAgIFwidGFyZ2V0XCI6IFwibXlBcHAuZXhlXCIsXG4gICAgICogICAgICAgICBcImFyZ3NcIjogXCJhIGIgYyBkXCJcbiAgICAgKiAgICAgfSxcbiAgICAgKiBdXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vICBJZiAnYXJndW1lbnRzJyBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXQgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAqIC8vICBvdmVyIGFueSAnYXJncycgc2V0IGluIHRoZSAnYXBwLmpzb24nLlxuICAgICAqIGZpbi5TeXN0ZW0ubGF1bmNoRXh0ZXJuYWxQcm9jZXNzKHtcbiAgICAgKiAgICAgYWxpYXM6ICdteUFwcCcsXG4gICAgICogICAgIGFyZ3VtZW50czogJ2UgZiBnJyxcbiAgICAgKiAgICAgbGlzdGVuZXI6IChyZXN1bHQpID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCd0aGUgZXhpdCBjb2RlJywgcmVzdWx0LmV4aXRDb2RlKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pLnRoZW4ocHJvY2Vzc0lkZW50aXR5ID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocHJvY2Vzc0lkZW50aXR5KTtcbiAgICAgKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEl0IGlzIG5vdyBwb3NzaWJsZSB0byBvcHRpb25hbGx5IHBlcmZvcm0gYW55IGNvbWJpbmF0aW9uIG9mIHRoZSBmb2xsb3dpbmcgY2VydGlmaWNhdGUgY2hlY2tzXG4gICAgICogYWdhaW5zdCBhbiBhYnNvbHV0ZSB0YXJnZXQgdmlhIGBmaW4uZGVza3RvcC5TeXN0ZW0ubGF1bmNoRXh0ZXJuYWxQcm9jZXNzKClgOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBcImNlcnRpZmljYXRlXCI6IHtcbiAgICAgKiAgICAgXCJzZXJpYWxcIjogXCIzYyBhNSAuLi5cIiwgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGhleCBzdHJpbmcgd2l0aCBvciB3aXRob3V0IHNwYWNlc1xuICAgICAqICAgICBcInN1YmplY3RcIjogXCJPPU9wZW5GaW4gSU5DLiwgTD1OZXcgWW9yaywgLi4uXCIsIC8vIEFuIGludGVybmFsbHkgdG9rZW5pemVkIGFuZCBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nIGFsbG93aW5nIHBhcnRpYWwgb3IgZnVsbCBjaGVja3Mgb2YgdGhlIHN1YmplY3QgZmllbGRzXG4gICAgICogICAgIFwicHVibGlja2V5XCI6IFwiM2MgYTUgLi4uXCIsICAgICAgICAgICAgICAgICAgICAgLy8gQSBoZXggc3RyaW5nIHdpdGggb3Igd2l0aG91dCBzcGFjZXNcbiAgICAgKiAgICAgXCJ0aHVtYnByaW50XCI6IFwiM2MgYTUgLi4uXCIsICAgICAgICAgICAgICAgICAgICAvLyBBIGhleCBzdHJpbmcgd2l0aCBvciB3aXRob3V0IHNwYWNlc1xuICAgICAqICAgICBcInRydXN0ZWRcIjogdHJ1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSBpcyB0cnVzdGVkIGFuZCBub3QgcmV2b2tlZFxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFByb3ZpZGluZyB0aGlzIGluZm9ybWF0aW9uIGFzIHBhcnQgb2YgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbnMgZm9yIGFzc2V0cyBpbiBhbiBhcHBsaWNhdGlvbidzIG1hbmlmZXN0XG4gICAgICogd2lsbCBiZSBhZGRlZCBpbiBhIGZ1dHVyZSBSVk0gdXBkYXRlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmxhdW5jaEV4dGVybmFsUHJvY2Vzcyh7XG4gICAgICogICAgIHBhdGg6ICdDOlxcXFxVc2Vyc1xcXFxFeGFtcGxlVXNlclxcXFxBcHBEYXRhXFxcXExvY2FsXFxcXE9wZW5GaW5cXFxcT3BlbkZpblJWTS5leGUnLFxuICAgICAqICAgICBhcmd1bWVudHM6ICctLXZlcnNpb24nLFxuICAgICAqICAgICBjZXJ0aWZpY2F0ZToge1xuICAgICAqICAgICAgICAgdHJ1c3RlZDogdHJ1ZSxcbiAgICAgKiAgICAgICAgIHN1YmplY3Q6ICdPPU9wZW5GaW4gSU5DLiwgTD1OZXcgWW9yaywgUz1OWSwgQz1VUycsXG4gICAgICogICAgICAgICB0aHVtYnByaW50OiAn4oCOM2MgYTUgMjggMTkgODMgMDUgZmUgNjkgODggZTYgOGYgNGIgM2EgYWYgYzUgYzUgMWIgMDcgODAgNWInXG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxpc3RlbmVyOiAocmVzdWx0KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygndGhlIGV4aXQgY29kZScsIHJlc3VsdC5leGl0Q29kZSk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KS50aGVuKHByb2Nlc3NJZGVudGl0eSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHByb2Nlc3NJZGVudGl0eSk7XG4gICAgICogfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJdCBpcyBwb3NzaWJsZSB0byBsYXVuY2ggZmlsZXMgdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZCBieSB0aGUgdXNlciBieSBsaXN0ZW5pbmcgdG8gdGhlIHdpbmRvd1xuICAgICAqIGBmaWxlLWRvd25sb2FkLWNvbXBsZXRlZGAgZXZlbnQgYW5kIHVzaW5nIHRoZSBgZmlsZVV1aWRgIHByb3ZpZGVkIGJ5IHRoZSBldmVudDpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgd2luID0gZmluLldpbmRvdy5nZXRDdXJyZW50U3luYygpO1xuICAgICAqIHdpbi5hZGRMaXN0ZW5lcignZmlsZS1kb3dubG9hZC1jb21wbGV0ZWQnLCAoZXZ0KSA9PiB7XG4gICAgICogICAgIGlmIChldnQuc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICogICAgICAgICBmaW4uU3lzdGVtLmxhdW5jaEV4dGVybmFsUHJvY2Vzcyh7XG4gICAgICogICAgICAgICAgICAgZmlsZVV1aWQ6IGV2dC5maWxlVXVpZCxcbiAgICAgKiAgICAgICAgICAgICBhcmd1bWVudHM6ICcnLFxuICAgICAqICAgICAgICAgICAgIGxpc3RlbmVyOiAocmVzdWx0KSA9PiB7XG4gICAgICogICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aGUgZXhpdCBjb2RlJywgcmVzdWx0LmV4aXRDb2RlKTtcbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICB9KS50aGVuKHByb2Nlc3NJZGVudGl0eSA9PiB7XG4gICAgICogICAgICAgICAgICAgY29uc29sZS5sb2cocHJvY2Vzc0lkZW50aXR5KTtcbiAgICAgKiAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICogICAgICAgICB9KTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTGF1bmNoaW5nIGFzc2V0cyBzcGVjaWZpZWQgaW4gdGhlIGFwcCBtYW5pZmVzdDpcbiAgICAgKlxuICAgICAqIFNhbXBsZSBhcHBBc3NldHMgc2VjdGlvbiBpbiBhcHAuanNvblxuICAgICAqIGBgYGpzXG4gICAgICogICAgIFwiYXBwQXNzZXRzXCI6IFtcbiAgICAgKiAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICBcInNyY1wiOiBcImh0dHA6Ly9maWxlc2FtcGxlcy5jb20vZXhlLnppcFwiLFxuICAgICAqICAgICAgICAgICAgIFwiYWxpYXNcIjogXCJteUFwcFwiLFxuICAgICAqICAgICAgICAgICAgIFwidmVyc2lvblwiOiBcIjQuMTIuOFwiLFxuICAgICAqICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwibXlBcHAuZXhlXCIsXG4gICAgICogICAgICAgICAgICAgXCJhcmdzXCI6IFwiYSBiIGMgZFwiXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgIFwic3JjXCI6IFwiaHR0cDovL2V4YW1wbGVzLmNvbS9leGUuemlwXCIsXG4gICAgICogICAgICAgICAgICAgXCJhbGlhc1wiOiBcIm15QXBwMlwiLFxuICAgICAqICAgICAgICAgICAgIFwidmVyc2lvblwiOiBcIjUuMTIuOFwiLFxuICAgICAqICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwibXlBcHAyLmV4ZVwiLFxuICAgICAqICAgICAgICAgICAgIFwiYXJnc1wiOiBcImEgYiBjXCJcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBwZXJtaXNzaW9uIGFsbG93cyBmb3IgbGF1bmNoaW5nIG9mIGFsbCBhc3NldHMgc3BlY2lmaWVkIGluIHRoZSBhYm92ZSBhcHBBc3NldHMgc2VjdGlvbi4gKFwibXlBcHBcIiBhbmQgXCJteUFwcDJcIik6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBcInBlcm1pc3Npb25zXCI6IHtcbiAgICAgKiAgICAgICAgXCJTeXN0ZW1cIjoge1xuICAgICAqICAgICAgICAgICAgXCJsYXVuY2hFeHRlcm5hbFByb2Nlc3NcIjoge1xuICAgICAqICAgICAgICAgICAgICAgICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgICAgKiAgICAgICAgICAgICAgICAgXCJhc3NldHNcIjoge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IHRydWVcbiAgICAgKiAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIHBlcm1pc3Npb24gYWxsb3dzIGZvciBsYXVuY2hpbmcgb2YgX29ubHlfIHRoZSBcIm15QXBwXCIgYXNzZXQgaW4gdGhlIGFib3ZlIGFwcEFzc2V0cyBzZWN0aW9uLCBhcyBkZWZpbmVkIGluIGBzcmNSdWxlc2A6XG4gICAgICogYGBganNcbiAgICAgKiAgICAgXCJwZXJtaXNzaW9uc1wiOiB7XG4gICAgICogICAgICAgIFwiU3lzdGVtXCI6IHtcbiAgICAgKiAgICAgICAgICAgIFwibGF1bmNoRXh0ZXJuYWxQcm9jZXNzXCI6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IHRydWUsXG4gICAgICogICAgICAgICAgICAgICAgIFwiYXNzZXRzXCI6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiB0cnVlXG4gICAgICogICAgICAgICAgICAgICAgICAgICBcInNyY1J1bGVzXCI6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF0Y2hcIjogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIqOi8vZmlsZXNhbXBsZXMuY29tLypcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJlaGF2aW9yXCI6IFwiYWxsb3dcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hdGNoXCI6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGFsbF91cmxzPlwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmVoYXZpb3JcIjogXCJibG9ja1wiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAqICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIExhdW5jaGluZyBkb3dubG9hZGVkIGZpbGVzOlxuICAgICAqIGBgYGpzXG4gICAgICogICAgIFwicGVybWlzc2lvbnNcIjoge1xuICAgICAqICAgICAgICBcIlN5c3RlbVwiOiB7XG4gICAgICogICAgICAgICAgICBcImxhdW5jaEV4dGVybmFsUHJvY2Vzc1wiOiB7XG4gICAgICogICAgICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiB0cnVlLFxuICAgICAqICAgICAgICAgICAgICAgICBcImRvd25sb2Fkc1wiOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICBcImVuYWJsZWRcIjogdHJ1ZVxuICAgICAqICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgcGVybWlzc2lvbiBhbGxvd3MgdG8gbGF1bmNoIGFsbCB0aGUgZXhlY3V0YWJsZXM6XG4gICAgICogYGBganNcbiAgICAgKiAgICAgXCJwZXJtaXNzaW9uc1wiOiB7XG4gICAgICogICAgICAgIFwiU3lzdGVtXCI6IHtcbiAgICAgKiAgICAgICAgICAgIFwibGF1bmNoRXh0ZXJuYWxQcm9jZXNzXCI6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IHRydWUsXG4gICAgICogICAgICAgICAgICAgICAgIFwiZXhlY3V0YWJsZXNcIjoge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IHRydWVcbiAgICAgKiAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqIFRoaXMgcGVybWlzc2lvbiBvbmx5IGFsbG93cyBsYXVuY2hpbmcgb2YgZXhlY3V0YWJsZXMgd2hvc2UgZmlsZSBwYXRocyBtYXRjaCB0aGUgY29ycmVzcG9uZGluZyBgcGF0aFJ1bGVzYDpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBcInBlcm1pc3Npb25zXCI6IHtcbiAgICAgKiAgICAgICAgXCJTeXN0ZW1cIjoge1xuICAgICAqICAgICAgICAgICAgXCJsYXVuY2hFeHRlcm5hbFByb2Nlc3NcIjoge1xuICAgICAqICAgICAgICAgICAgICAgICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgICAgKiAgICAgICAgICAgICAgICAgXCJleGVjdXRhYmxlc1wiOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICBcImVuYWJsZWRcIjogdHJ1ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgXCJwYXRoUnVsZXNcIjogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXRjaFwiOiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi9XaW5kb3dzL1N5c3RlbTMyLyouZXhlXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiZWhhdmlvclwiOiBcImFsbG93XCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXRjaFwiOiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiouZXhlXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiZWhhdmlvclwiOiBcImJsb2NrXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxhdW5jaEV4dGVybmFsUHJvY2VzcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRFeHRlcm5hbFByb2Nlc3NSZXF1ZXN0KCdsYXVuY2gtZXh0ZXJuYWwtcHJvY2VzcycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb25pdG9ycyBhIHJ1bm5pbmcgcHJvY2Vzcy4gQSBwaWQgZm9yIHRoZSBwcm9jZXNzIG11c3QgYmUgaW5jbHVkZWQgaW4gb3B0aW9ucy5cbiAgICAgKiA8YnI+IEEgdXVpZCBtYXkgYmUgb3B0aW9uYWxseSBwcm92aWRlZC4gSWYgbm90IHByb3ZpZGVkLCBPcGVuRmluIHdpbGwgY3JlYXRlIGEgdXVpZCBmb3IgdGhlIG5ldyBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgSWYgYW4gdW51c2VkIHV1aWQgaXMgcHJvdmlkZWQgaW4gb3B0aW9ucywgaXQgd2lsbCBiZSB1c2VkLiBJZiBubyB1dWlkIGlzIHByb3ZpZGVkLCBPcGVmaW5GaW4gd2lsbCBhc3NpZ24gYSB1dWlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLm1vbml0b3JFeHRlcm5hbFByb2Nlc3Moe1xuICAgICAqICAgICBwaWQ6IDEwMjA4LFxuICAgICAqICAgICB1dWlkOiAnbXktZXh0ZXJuYWwtcHJvY2VzcycsIC8vIG9wdGlvbmFsXG4gICAgICogICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygndGhlIGV4aXQgY29kZScsIHJlc3VsdC5leGl0Q29kZSk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KS50aGVuKHByb2Nlc3NJZGVudGl0eSA9PiBjb25zb2xlLmxvZyhwcm9jZXNzSWRlbnRpdHkpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbW9uaXRvckV4dGVybmFsUHJvY2VzcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRFeHRlcm5hbFByb2Nlc3NSZXF1ZXN0KCdtb25pdG9yLWV4dGVybmFsLXByb2Nlc3MnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBwYXNzZWQgbWVzc2FnZSBpbnRvIGJvdGggdGhlIGxvZyBmaWxlIGFuZCB0aGUgY29uc29sZS5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgVGhlIGxvZyBsZXZlbCBmb3IgdGhlIGVudHJ5LiBDYW4gYmUgZWl0aGVyIFwiaW5mb1wiLCBcIndhcm5pbmdcIiBvciBcImVycm9yXCJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbG9nIG1lc3NhZ2UgdGV4dFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0ubG9nKFwiaW5mb1wiLCBcIkFuIGV4YW1wbGUgbG9nIG1lc3NhZ2VcIikudGhlbigoKSA9PiBjb25zb2xlLmxvZygnTG9nIGluZm8gbWVzc2FnZScpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignd3JpdGUtdG8tbG9nJywgeyBsZXZlbCwgbWVzc2FnZSB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBwYXNzZWQgVVJMIGluIHRoZSBkZWZhdWx0IHdlYiBicm93c2VyLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgSXQgb25seSBzdXBwb3J0cyBodHRwKHMpIGFuZCBmaW4ocykgcHJvdG9jb2xzIGJ5IGRlZmF1bHQuXG4gICAgICogSW4gb3JkZXIgdG8gdXNlIG90aGVyIGN1c3RvbSBwcm90b2NvbHMsIHRoZXkgaGF2ZSB0byBiZSBlbmFibGVkIHZpYVxuICAgICAqIFtBUEkgc2VjdXJpdHkgc2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5KS5cbiAgICAgKiBGaWxlIHByb3RvY29sIGFuZCBmaWxlIHBhdGggYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIG9wZW5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLm9wZW5VcmxXaXRoQnJvd3NlcignaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvc3RhYmxlL3R1dG9yaWFsLVN5c3RlbS5vcGVuVXJsV2l0aEJyb3dzZXIuaHRtbCcpXG4gICAgICogLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ09wZW5lZCBVUkwnKSlcbiAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRXhhbXBsZSBvZiBwZXJtaXNzaW9uIGRlZmluaXRpb24gdG8gZW5hYmxlIG5vbi1kZWZhdWx0IHByb3RvY29sczpcbiAgICAgKlxuICAgICAqIE5vdGU6IHBlcm1pc3Npb24gZGVmaW5pdGlvbiBzaG91bGQgYmUgc3BlY2lmaWVkIGluIGFuIGFwcCBtYW5pZmVzdCBmaWxlIGlmIHRoZXJlIGlzIG5vIERPUyBzZXR0aW5ncy5cbiAgICAgKiBPdGhlcndpc2UgaXQgaGFzIHRvIGJlIHNwZWNpZmllZCBpbiBib3RoIERPUyBhbmQgYXBwIG1hbmlmZXN0IGZpbGVzLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAgICAgXCJwZXJtaXNzaW9uc1wiOiB7XG4gICAgICogICAgICAgIFwiU3lzdGVtXCI6IHtcbiAgICAgKiAgICAgICAgICAgIFwib3BlblVybFdpdGhCcm93c2VyXCI6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IHRydWUsXG4gICAgICogICAgICAgICAgICAgICAgIFwicHJvdG9jb2xzXCI6IFsgXCJtc3RlYW1zXCIsIFwic2xhY2tcIl1cbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9wZW5VcmxXaXRoQnJvd3Nlcih1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdvcGVuLXVybC13aXRoLWJyb3dzZXInLCB7IHVybCB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVnaXN0cnkgZW50cnkgdW5kZXIgdGhlIEhLQ1Ugcm9vdCBXaW5kb3dzIHJlZ2lzdHJ5IGtleSBpZiB0aGUgZ2l2ZW4gY3VzdG9tIHByb3RvY29sIG5hbWUgZG9lc24ndCBleGlzdCBvclxuICAgICAqIG92ZXJ3cml0ZXMgdGhlIGV4aXN0aW5nIHJlZ2lzdHJ5IGVudHJ5IGlmIHRoZSBnaXZlbiBjdXN0b20gcHJvdG9jb2wgbmFtZSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHJlc3RyaWN0ZWQgYnkgZGVmYXVsdCBhbmQgbXVzdCBiZSBlbmFibGVkIHZpYVxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL2FwaS1zZWN1cml0eSBBUEkgc2VjdXJpdHkgc2V0dGluZ3N9LiBJdCByZXF1aXJlcyBSVk0gMTIgb3IgaGlnaGVyIHZlcnNpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoZXNlIHByb3RvY29scyBhcmUgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSByZWdpc3RlcmVkOlxuICAgICAqIC0gZmluXG4gICAgICogLSBmaW5zXG4gICAgICogLSBvcGVuZmluXG4gICAgICogLSBVUkkgU2NoZW1lcyByZWdpc3RlcmVkIHdpdGgge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfVVJJX3NjaGVtZXMjT2ZmaWNpYWxfSUFOQS1yZWdpc3RlcmVkX3NjaGVtZXMgSUFOQX1cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgaWYgYSBnaXZlbiBjdXN0b20gcHJvdG9jb2wgZmFpbGVkIHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHRocm93cyBpZiBhIG1hbmlmZXN0IFVSTCBjb250YWlucyB0aGUgJyUxJyBzdHJpbmcuXG4gICAgICogQHRocm93cyBpZiBhIG1hbmlmZXN0IFVSTCBjb250YWlucyBhIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXIgd2hpY2ggbmFtZSBlcXVhbHMgdG8gdGhlIFByb3RvY29sIExhdW5jaCBSZXF1ZXN0IFBhcmFtZXRlciBOYW1lLlxuICAgICAqIEB0aHJvd3MgaWYgdGhlIGZ1bGwgbGVuZ3RoIG9mIHRoZSBjb21tYW5kIHN0cmluZyB0aGF0IGlzIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIHJlZ2lzdHJ5IGV4Y2VlZHMgMjA0OCBieXRlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLnJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2woe3Byb3RvY29sTmFtZToncHJvdG9jb2wxJ30pLnRoZW4oY29uc29sZS5sb2cpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiBvYmplY3Qgd2l0aCBhIGBwcm90b2NvbE5hbWVgIHByb3BlcnR5IGhhdmluZyBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbigncmVnaXN0ZXItY3VzdG9tLXByb3RvY29sJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHJlZ2lzdHJ5IGVudHJ5IGZvciBhIGdpdmVuIGN1c3RvbSBwcm90b2NvbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHJlc3RyaWN0ZWQgYnkgZGVmYXVsdCBhbmQgbXVzdCBiZSBlbmFibGVkIHZpYVxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL2FwaS1zZWN1cml0eSBBUEkgc2VjdXJpdHkgc2V0dGluZ3N9LiBJdCByZXF1aXJlcyBSVk0gMTIgb3IgaGlnaGVyIHZlcnNpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoZXNlIHByb3RvY29scyBhcmUgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSB1bnJlZ2lzdGVyZWQ6XG4gICAgICogLSBmaW5cbiAgICAgKiAtIGZpbnNcbiAgICAgKiAtIG9wZW5maW5cbiAgICAgKiAtIFVSSSBTY2hlbWVzIHJlZ2lzdGVyZWQgd2l0aCB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9VUklfc2NoZW1lcyNPZmZpY2lhbF9JQU5BLXJlZ2lzdGVyZWRfc2NoZW1lcyBJQU5BfVxuICAgICAqXG4gICAgICogQHRocm93cyBpZiBhIHByb3RvY29sIGVudHJ5IGZhaWxlZCB0byBiZSByZW1vdmVkIGluIHJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IGZpbi5TeXN0ZW0udW5yZWdpc3RlckN1c3RvbVByb3RvY29sKCdwcm90b2NvbDEnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1bnJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2xOYW1lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCd1bnJlZ2lzdGVyLWN1c3RvbS1wcm90b2NvbCcsIHsgcHJvdG9jb2xOYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlZ2lzdHJhdGlvbiBzdGF0ZSBmb3IgYSBnaXZlbiBjdXN0b20gcHJvdG9jb2wuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyByZXN0cmljdGVkIGJ5IGRlZmF1bHQgYW5kIG11c3QgYmUgZW5hYmxlZCB2aWFcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLm9wZW5maW4uY28vZG9jcy9hcGktc2VjdXJpdHkgQVBJIHNlY3VyaXR5IHNldHRpbmdzfS4gSXQgcmVxdWlyZXMgUlZNIDEyIG9yIGhpZ2hlciB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgVGhlc2UgcHJvdG9jb2xzIGFyZSByZXNlcnZlZCBhbmQgY2Fubm90IGdldCBzdGF0ZXMgZm9yIHRoZW06XG4gICAgICogLSBmaW5cbiAgICAgKiAtIGZpbnNcbiAgICAgKiAtIG9wZW5maW5cbiAgICAgKiAtIFVSSSBTY2hlbWVzIHJlZ2lzdGVyZWQgd2l0aCB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9VUklfc2NoZW1lcyNPZmZpY2lhbF9JQU5BLXJlZ2lzdGVyZWRfc2NoZW1lcyBJQU5BfVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcHJvdG9jb2xTdGF0ZSA9IGF3YWl0IGZpbi5TeXN0ZW0uZ2V0Q3VzdG9tUHJvdG9jb2xTdGF0ZSgncHJvdG9jb2wxJyk7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VzdG9tUHJvdG9jb2xTdGF0ZShwcm90b2NvbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtY3VzdG9tLXByb3RvY29sLXN0YXRlJywgeyBwcm90b2NvbE5hbWUgfSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb2Nlc3MgZW50cnkgZm9yIHRoZSBwYXNzZWQgVVVJRCBvYnRhaW5lZCBmcm9tIGEgcHJpb3IgY2FsbFxuICAgICAqIG9mIGZpbi5TeXN0ZW0ubGF1bmNoRXh0ZXJuYWxQcm9jZXNzKCkuXG4gICAgICogQHBhcmFtIHV1aWQgVGhlIFVVSUQgZm9yIGEgcHJvY2VzcyBvYnRhaW5lZCBmcm9tIGEgcHJpb3IgY2FsbCB0byBmaW4uZGVza3RvcC5TeXN0ZW0ubGF1bmNoRXh0ZXJuYWxQcm9jZXNzKClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmxhdW5jaEV4dGVybmFsUHJvY2Vzcyh7XG4gICAgICogICAgIHBhdGg6IFwibm90ZXBhZFwiLFxuICAgICAqICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coXCJUaGUgZXhpdCBjb2RlXCIsIHJlc3VsdC5leGl0Q29kZSk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KVxuICAgICAqIC50aGVuKGlkZW50aXR5ID0+IGZpbi5TeXN0ZW0ucmVsZWFzZUV4dGVybmFsUHJvY2VzcyhpZGVudGl0eS51dWlkKSlcbiAgICAgKiAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnUHJvY2VzcyBoYXMgYmVlbiB1bm1hcHBlZCEnKSlcbiAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlbGVhc2VFeHRlcm5hbFByb2Nlc3ModXVpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3JlbGVhc2UtZXh0ZXJuYWwtcHJvY2VzcycsIHsgdXVpZCB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBDaHJvbWl1bSBEZXZlbG9wZXIgVG9vbHMgZm9yIHRoZSBzcGVjaWZpZWQgd2luZG93XG4gICAgICogQHBhcmFtIGlkZW50aXR5IFRoaXMgaXMgYSBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IHRoZSBJZGVudGl0eSBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uc2hvd0RldmVsb3BlclRvb2xzXG4gICAgICovXG4gICAgc2hvd0RldmVsb3BlclRvb2xzKGlkZW50aXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc2hvdy1kZXZlbG9wZXItdG9vbHMnLCBpZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGNsb3NlIGFuIGV4dGVybmFsIHByb2Nlc3MuIFRoZSBwcm9jZXNzIHdpbGwgYmUgdGVybWluYXRlZCBpZiBpdFxuICAgICAqIGhhcyBub3QgY2xvc2VkIGFmdGVyIHRoZSBlbGFwc2VkIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgcmVzdHJpY3RlZCBieSBkZWZhdWx0IGFuZCBtdXN0IGJlIGVuYWJsZWQgdmlhXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5XCI+QVBJIHNlY3VyaXR5IHNldHRpbmdzPC9hPi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBIG9iamVjdCBkZWZpbmVkIGluIHRoZSBUZXJtaW5hdGVFeHRlcm5hbFJlcXVlc3RUeXBlIGludGVyZmFjZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0ubGF1bmNoRXh0ZXJuYWxQcm9jZXNzKHtcbiAgICAgKiAgICAgcGF0aDogXCJub3RlcGFkXCIsXG4gICAgICogICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSBleGl0IGNvZGVcIiwgcmVzdWx0LmV4aXRDb2RlKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pXG4gICAgICogLnRoZW4oaWRlbnRpdHkgPT4gZmluLlN5c3RlbS50ZXJtaW5hdGVFeHRlcm5hbFByb2Nlc3Moe3V1aWQ6IGlkZW50aXR5LnV1aWQsIHRpbWVvdXQ6MjAwMCwga2lsbFRyZWU6IGZhbHNlfSkpXG4gICAgICogLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1Rlcm1pbmF0ZSB0aGUgcHJvY2VzcycpKVxuICAgICAqIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGVybWluYXRlRXh0ZXJuYWxQcm9jZXNzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd0ZXJtaW5hdGUtZXh0ZXJuYWwtcHJvY2VzcycsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBPcGVuRmluIFJ1bnRpbWUgUHJveHkgc2V0dGluZ3MuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQSBjb25maWcgb2JqZWN0IGRlZmluZWQgaW4gdGhlIFByb3h5Q29uZmlnIGludGVyZmFjZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0udXBkYXRlUHJveHlTZXR0aW5ncyh7cHJveHlBZGRyZXNzOicxMjcuMC4wLjEnLCBwcm94eVBvcnQ6ODA4MCwgdHlwZTonaHR0cCd9KVxuICAgICAqIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgcHJveHkgc3VjY2Vzc2Z1bGx5JykpXG4gICAgICogLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHVwZGF0ZVByb3h5U2V0dGluZ3Mob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3VwZGF0ZS1wcm94eScsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBhc3NldC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHJlc3RyaWN0ZWQgYnkgZGVmYXVsdCBhbmQgbXVzdCBiZSBlbmFibGVkIHZpYVxuICAgICAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL2FwaS1zZWN1cml0eVwiPkFQSSBzZWN1cml0eSBzZXR0aW5nczwvYT4uXG4gICAgICogQHBhcmFtIGFwcEFzc2V0IEFwcCBhc3NldCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBhc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0KCkge1xuICAgICAqICAgICBjb25zdCBhcHBBc3NldCA9IHtcbiAgICAgKiAgICAgICAgIHNyYzogYCR7IGxvY2F0aW9uLm9yaWdpbiB9L2Fzc2V0cy56aXBgLFxuICAgICAqICAgICAgICAgYWxpYXM6ICdkaXJBcHAnLFxuICAgICAqICAgICAgICAgdmVyc2lvbjogJzEuMjMuMjQnLFxuICAgICAqICAgICAgICAgdGFyZ2V0OiAnYXNzZXRzL3J1bi5iYXQnXG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiAgICAgcmV0dXJuIGZpbi5TeXN0ZW0uZG93bmxvYWRBc3NldChhcHBBc3NldCwgKHByb2dyZXNzID0+IHtcbiAgICAgKiAgICAgLy9QcmludCBwcm9ncmVzcyBhcyB3ZSBkb3dubG9hZCB0aGUgYXNzZXQuXG4gICAgICogICAgICAgICBjb25zdCBkb3dubG9hZGVkUGVyY2VudCA9IE1hdGguZmxvb3IoKHByb2dyZXNzLmRvd25sb2FkZWRCeXRlcyAvIHByb2dyZXNzLnRvdGFsQnl0ZXMpICogMTAwKTtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGBEb3dubG9hZGVkICR7ZG93bmxvYWRlZFBlcmNlbnR9JWApO1xuICAgICAqICAgICB9KSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZG93bmxvYWRBc3NldCgpXG4gICAgICogLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1N1Y2Nlc3MnKSlcbiAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvLyBpbmNvbXBhdGlibGUgd2l0aCBzdGFuZGFsb25lIG5vZGUgcHJvY2Vzcy5cbiAgICBhc3luYyBkb3dubG9hZEFzc2V0KGFwcEFzc2V0LCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtZnVuY3Rpb24tcmV0dXJuLXR5cGUsIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICBjb25zdCBub29wID0gKCkgPT4geyB9O1xuICAgICAgICBsZXQgcmVzb2x2ZSA9IG5vb3A7XG4gICAgICAgIGxldCByZWplY3QgPSBub29wO1xuICAgICAgICBjb25zdCBkb3dubG9hZENvbXBsZXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKCh5LCBuKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlID0geTtcbiAgICAgICAgICAgIHJlamVjdCA9IG47XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub2RlLmpzIGVudmlyb25tZW50IG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKHRoaXMud2lyZS5lbnZpcm9ubWVudC50eXBlICE9PSAnb3BlbmZpbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEkMS5Ob3RTdXBwb3J0ZWRFcnJvcignZG93bmxvYWRBc3NldCBvbmx5IHN1cHBvcnRlZCBpbiBhbiBPcGVuRmluIFJlbmRlciBwcm9jZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbFNpdGUgPSB0cmFuc3BvcnRfZXJyb3JzXzEkMS5SdW50aW1lRXJyb3IuZ2V0Q2FsbFNpdGUoKTtcbiAgICAgICAgY29uc3QgZG93bmxvYWRJZCA9IHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXROZXh0TWVzc2FnZUlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZGxQcm9ncmVzc0tleSA9IGBhc3NldC1kb3dubG9hZC1wcm9ncmVzcy0ke2Rvd25sb2FkSWR9YDtcbiAgICAgICAgY29uc3QgZGxFcnJvcktleSA9IGBhc3NldC1kb3dubG9hZC1lcnJvci0ke2Rvd25sb2FkSWR9YDtcbiAgICAgICAgY29uc3QgZGxDb21wbGV0ZUtleSA9IGBhc3NldC1kb3dubG9hZC1jb21wbGV0ZS0ke2Rvd25sb2FkSWR9YDtcbiAgICAgICAgY29uc3QgZGxQcm9ncmVzcyA9IChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZGVkQnl0ZXM6IHByb2dyZXNzLmRvd25sb2FkZWRCeXRlcyxcbiAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzOiBwcm9ncmVzcy50b3RhbEJ5dGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcihwKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW5MaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggaW50ZXJuYWwgdHlwZXNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZGxQcm9ncmVzc0tleSwgZGxQcm9ncmVzcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRsRXJyb3IgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgY2xlYW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVhc29uLCBlcnI6IGVycm9yIH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEkMS5SdW50aW1lRXJyb3IoeyByZWFzb24sIGVycm9yIH0sIGNhbGxTaXRlKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRsQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggaW50ZXJuYWwgdHlwZXNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHRoaXMub24oZGxQcm9ncmVzc0tleSwgZGxQcm9ncmVzcyksXG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggaW50ZXJuYWwgdHlwZXNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHRoaXMub25jZShkbEVycm9yS2V5LCBkbEVycm9yKSxcbiAgICAgICAgICAgIC8vIFRPRE86IGZpeCBpbnRlcm5hbCB0eXBlc1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdGhpcy5vbmNlKGRsQ29tcGxldGVLZXksIGRsQ29tcGxldGUpXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGFwcEFzc2V0LCB7IGRvd25sb2FkSWQgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdkb3dubG9hZC1hc3NldCcsIGRvd25sb2FkT3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY2xlYW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkb3dubG9hZENvbXBsZXRlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgdmVyc2lvbiBvZiB0aGUgcnVudGltZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERvd25sb2FkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHByb2dyZXNzTGlzdGVuZXIgLSBjYWxsZWQgYXMgdGhlIHJ1bnRpbWUgaXMgZG93bmxvYWRlZCB3aXRoIHByb2dyZXNzIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgT25seSBzdXBwb3J0ZWQgaW4gYW4gT3BlbkZpbiBSZW5kZXIgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAqICAgICAvL1NwZWNpZmljIHZlcnNpb24gbnVtYmVyIHJlcXVpcmVkLCBpZiBnaXZlbiBhIHJlbGVhc2UgY2hhbm5lbCB0aGUgY2FsbCB3aWxsIHByb2R1Y2UgYW4gZXJyb3IuXG4gICAgICogICAgIHZlcnNpb246ICc5LjYxLjMwLjEnXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYCR7TWF0aC5mbG9vcigocHJvZ3Jlc3MuZG93bmxvYWRlZEJ5dGVzIC8gcHJvZ3Jlc3MudG90YWxCeXRlcykgKiAxMDApfSVgKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmaW4uU3lzdGVtLmRvd25sb2FkUnVudGltZShkb3dubG9hZE9wdGlvbnMsIG9uUHJvZ3Jlc3MpLnRoZW4oKCkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnRG93bmxvYWQgY29tcGxldGUnKTtcbiAgICAgKiB9KS5jYXRjaChlcnIgPT4gICAge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgRG93bmxvYWQgRmFpbGVkLCB3ZSBjb3VsZCByZXRyeTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkb3dubG9hZFJ1bnRpbWUob3B0aW9ucywgcHJvZ3Jlc3NMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBjYWxsc2l0ZXMgPSB0cmFuc3BvcnRfZXJyb3JzXzEkMS5SdW50aW1lRXJyb3IuZ2V0Q2FsbFNpdGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIG5vZGUuanMgZW52aXJvbm1lbnQgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgaWYgKHRoaXMud2lyZS5lbnZpcm9ubWVudC50eXBlICE9PSAnb3BlbmZpbicpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHRyYW5zcG9ydF9lcnJvcnNfMSQxLk5vdFN1cHBvcnRlZEVycm9yKCdkb3dubG9hZFJ1bnRpbWUgb25seSBzdXBwb3J0ZWQgaW4gYW4gT3BlbkZpbiBSZW5kZXIgcHJvY2VzcycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZElkID0gdGhpcy53aXJlLmVudmlyb25tZW50LmdldE5leHRNZXNzYWdlSWQoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgZGxQcm9ncmVzc0tleSA9IGBydW50aW1lLWRvd25sb2FkLXByb2dyZXNzLSR7ZG93bmxvYWRJZH1gO1xuICAgICAgICAgICAgY29uc3QgZGxFcnJvcktleSA9IGBydW50aW1lLWRvd25sb2FkLWVycm9yLSR7ZG93bmxvYWRJZH1gO1xuICAgICAgICAgICAgY29uc3QgZGxDb21wbGV0ZUtleSA9IGBydW50aW1lLWRvd25sb2FkLWNvbXBsZXRlLSR7ZG93bmxvYWRJZH1gO1xuICAgICAgICAgICAgY29uc3QgZGxQcm9ncmVzcyA9IChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkZWRCeXRlczogcHJvZ3Jlc3MuZG93bmxvYWRlZEJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzOiBwcm9ncmVzcy50b3RhbEJ5dGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpeCBpbnRlcm5hbCB0eXBlc1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGRsUHJvZ3Jlc3NLZXksIGRsUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRsRXJyb3IgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFuTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZWFzb24sIGVycjogZXJyb3IgfSA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEkMS5SdW50aW1lRXJyb3IoeyByZWFzb24sIGVycm9yIH0sIGNhbGxzaXRlcykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRsQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gVE9ETzogZml4IGludGVybmFsIHR5cGVzXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB0aGlzLm9uKGRsUHJvZ3Jlc3NLZXksIGRsUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVE9ETzogZml4IGludGVybmFsIHR5cGVzXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB0aGlzLm9uY2UoZGxFcnJvcktleSwgZGxFcnJvcik7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggaW50ZXJuYWwgdHlwZXNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHRoaXMub25jZShkbENvbXBsZXRlS2V5LCBkbENvbXBsZXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBkb3dubG9hZElkIH0pO1xuICAgICAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Rvd25sb2FkLXJ1bnRpbWUnLCBkb3dubG9hZE9wdGlvbnMpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBwcmVsb2FkIHNjcmlwdHMgZnJvbSBnaXZlbiBVUkxzXG4gICAgICogQHBhcmFtIHNjcmlwdHMgLSBVUkxzIG9mIHByZWxvYWQgc2NyaXB0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBzY3JpcHRzID0gW1xuICAgICAqICAgICB7IHVybDogJ2h0dHA6Ly8uLi4vcHJlbG9hZC5qcycgfSxcbiAgICAgKiAgICAgeyB1cmw6ICdodHRwOi8vLi4uL3ByZWxvYWQyLmpzJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIGZpbi5TeXN0ZW0uZG93bmxvYWRQcmVsb2FkU2NyaXB0cyhzY3JpcHRzKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAqICAgICByZXN1bHRzLmZvckVhY2goKHt1cmwsIHN1Y2Nlc3MsIGVycm9yfSkgPT4ge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coYFVSTDogJHt1cmx9YCk7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2VzczogJHtzdWNjZXNzfWApO1xuICAgICAqICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICogICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yOiAke2Vycm9yfWApO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkb3dubG9hZFByZWxvYWRTY3JpcHRzKHNjcmlwdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdkb3dubG9hZC1wcmVsb2FkLXNjcmlwdHMnLCB7IHNjcmlwdHMgfSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiBkYXRhIChuYW1lLCBpZHMsIGJvdW5kcykgZm9yIGFsbCBhcHBsaWNhdGlvbiB3aW5kb3dzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0uZ2V0QWxsRXh0ZXJuYWxBcHBsaWNhdGlvbnMoKVxuICAgICAqIC50aGVuKGV4dGVybmFsQXBwcyA9PiBjb25zb2xlLmxvZygnVG90YWwgZXh0ZXJuYWwgYXBwczogJyArIGV4dGVybmFsQXBwcy5sZW5ndGgpKVxuICAgICAqIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0QWxsRXh0ZXJuYWxBcHBsaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFsbC1leHRlcm5hbC1hcHBsaWNhdGlvbnMnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFwcCBhc3NldCBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0uZ2V0QXBwQXNzZXRJbmZvKHthbGlhczoncHJvY2V4cCd9KS50aGVuKGFzc2V0SW5mbyA9PiBjb25zb2xlLmxvZyhhc3NldEluZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0QXBwQXNzZXRJbmZvKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYXBwLWFzc2V0LWluZm8nLCBvcHRpb25zKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFkZGl0aW9uYWwgaW5mbyBvZiBjb29raWVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0uZ2V0Q29va2llcyh7bmFtZTogJ215Q29va2llJ30pLnRoZW4oY29va2llcyA9PiBjb25zb2xlLmxvZyhjb29raWVzKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldENvb2tpZXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLndpcmUuZW52aXJvbm1lbnQuZ2V0VXJsKCk7XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgdXJsIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1jb29raWVzJywgbmV3T3B0aW9ucykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWluaW11bSBsb2cgbGV2ZWwgYWJvdmUgd2hpY2ggbG9ncyB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIE9wZW5GaW4gbG9nXG4gICAgICogQHBhcmFtIFRoZSBtaW5pbXVtIGxldmVsIChpbmNsdXNpdmUpIGFib3ZlIHdoaWNoIGFsbCBjYWxscyB0byBsb2cgd2lsbCBiZSB3cml0dGVuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5zZXRNaW5Mb2dMZXZlbChcInZlcmJvc2VcIikudGhlbigoKSA9PiBjb25zb2xlLmxvZyhcImxvZyBsZXZlbCBpcyBzZXQgdG8gdmVyYm9zZVwiKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldE1pbkxvZ0xldmVsKGxldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LW1pbi1sb2ctbGV2ZWwnLCB7IGxldmVsIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBVVUlEIG9mIHRoZSBjb21wdXRlciBvbiB3aGljaCB0aGUgcnVudGltZSBpcyBpbnN0YWxsZWRcbiAgICAgKiBAcGFyYW0gdXVpZCBUaGUgdXVpZCBvZiB0aGUgcnVubmluZyBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0ucmVzb2x2ZVV1aWQoJ09wZW5maW5QT0MnKS50aGVuKGVudGl0eSA9PiBjb25zb2xlLmxvZyhlbnRpdHkpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVzb2x2ZVV1aWQodXVpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbigncmVzb2x2ZS11dWlkJywge1xuICAgICAgICAgICAgZW50aXR5S2V5OiB1dWlkXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiBkYXRhIGZvciBhbGwgZXh0ZXJuYWwgYXBwbGljYXRpb25zXG4gICAgICogQHBhcmFtIHJlcXVlc3RpbmdJZGVudGl0eSBUaGlzIG9iamVjdCBpcyBkZXNjcmliZWQgaW4gdGhlIElkZW50aXR5IHR5cGVkZWZcbiAgICAgKiBAcGFyYW0gZGF0YSBBbnkgZGF0YSB0eXBlIHRvIHBhc3MgdG8gdGhlIG1ldGhvZFxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGV4ZWN1dGVPblJlbW90ZShyZXF1ZXN0aW5nSWRlbnRpdHksIGRhdGEpIHtcbiAgICAgICAgZGF0YS5yZXF1ZXN0aW5nSWRlbnRpdHkgPSByZXF1ZXN0aW5nSWRlbnRpdHk7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuZmVycnlBY3Rpb24oZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBzcGVjaWZlZCB2YWx1ZSBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKiBAcmVtYXJrcyBUaGlzIG1ldGhvZCBpcyByZXN0cmljdGVkIGJ5IGRlZmF1bHQgYW5kIG11c3QgYmUgZW5hYmxlZCB2aWFcbiAgICAgKiBbQVBJIHNlY3VyaXR5IHNldHRpbmdzXShodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL2FwaS1zZWN1cml0eSkuXG4gICAgICogQHBhcmFtIHJvb3RLZXkgLSBUaGUgcmVnaXN0cnkgcm9vdCBrZXkuXG4gICAgICogQHBhcmFtIHN1YmtleSAtIFRoZSByZWdpc3RyeSBrZXkuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHJlZ2lzdHJ5IHZhbHVlIG5hbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5yZWFkUmVnaXN0cnlWYWx1ZShcIkhLRVlfTE9DQUxfTUFDSElORVwiLCBcIkhBUkRXQVJFXFxcXERFU0NSSVBUSU9OXFxcXFN5c3RlbVwiLCBcIkJvb3RBcmNoaXRlY3R1cmVcIikudGhlbih2YWwgPT4gY29uc29sZS5sb2codmFsKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9tczY4MTM4Mih2PXZzLjg1KS5hc3B4IGhlcmV9IGZvciBXaW5kb3cncyBlcnJvciBjb2RlIGRlZmluaXRpb25zLlxuICAgICAqXG4gICAgICogRXhhbXBsZSBwYXlsb2FkcyBvZiBkaWZmZXJlbnQgcmVnaXN0cnkgdHlwZXM6XG4gICAgICpcbiAgICAgKiBTZWUgbGlzdCBvZiB0eXBlcyB7QGxpbmsgaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvbXM3MjQ4ODQodj12cy44NSkuYXNweCBoZXJlfS5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogLy8gUkVHX0RXT1JEXG4gICAgICoge1xuICAgICAqICAgICBkYXRhOiAxLFxuICAgICAqICAgICByb290S2V5OiBcIkhLRVlfTE9DQUxfTUFDSElORVwiLFxuICAgICAqICAgICBzdWJrZXk6IFwiRm9vXFxCYXJcIixcbiAgICAgKiAgICAgdHlwZTogXCJSRUdfRFdPUkRcIixcbiAgICAgKiAgICAgdmFsdWU6IFwiQmF6XCJcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBSRUdfUVdPUkRcbiAgICAgKiB7XG4gICAgICogICAgIGRhdGE6IDEzMTA4MTQ2NjcxMzM0MTEyLFxuICAgICAqICAgICByb290S2V5OiBcIkhLRVlfTE9DQUxfTUFDSElORVwiLFxuICAgICAqICAgICBzdWJrZXk6IFwiRm9vXFxCYXJcIixcbiAgICAgKiAgICAgdHlwZTogXCJSRUdfUVdPUkRcIixcbiAgICAgKiAgICAgdmFsdWU6IFwiQmF6XCJcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBSRUdfU1pcbiAgICAgKiB7XG4gICAgICogICAgIGRhdGE6IFwiRm9vQmFyQmF6XCIsXG4gICAgICogICAgIHJvb3RLZXk6IFwiSEtFWV9MT0NBTF9NQUNISU5FXCIsXG4gICAgICogICAgIHN1YmtleTogXCJGb29cXEJhclwiLFxuICAgICAqICAgICB0eXBlOiBcIlJFR19TWlwiLFxuICAgICAqICAgICB2YWx1ZTogXCJCYXpcIlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIFJFR19FWFBBTkRfU1pcbiAgICAgKiB7XG4gICAgICogICAgIGRhdGE6IFwiQzpcXFVzZXJcXEpvaG5Eb2VcXEFwcERhdGFcXExvY2FsXCIsXG4gICAgICogICAgIHJvb3RLZXk6IFwiSEtFWV9DVVJSRU5UX1VTRVJcIixcbiAgICAgKiAgICAgc3Via2V5OiBcIkZvb1xcQmFyXCIsXG4gICAgICogICAgIHR5cGU6IFwiUkVHX0VYUEFORF9TWlwiLFxuICAgICAqICAgICB2YWx1ZTogXCJCYXpcIlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIFJFR19NVUxUSV9TWlxuICAgICAqIHtcbiAgICAgKiAgICAgZGF0YTogW1xuICAgICAqICAgICAgICAgXCJGb29cIixcbiAgICAgKiAgICAgICAgIFwiQmFyXCIsXG4gICAgICogICAgICAgICBcIkJhelwiXG4gICAgICogICAgIF0sXG4gICAgICogICAgIHJvb3RLZXk6IFwiSEtFWV9DVVJSRU5UX1VTRVJcIixcbiAgICAgKiAgICAgc3Via2V5OiBcIkZvb1xcQmFyXCIsXG4gICAgICogICAgIHR5cGU6IFwiUkVHX01VTFRJX1NaXCIsXG4gICAgICogICAgIHZhbHVlOiBcIkJhelwiXG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gUkVHX0JJTkFSWVxuICAgICAqIHtcbiAgICAgKiAgICAgZGF0YToge1xuICAgICAqICAgICAgICAgZGF0YTogW1xuICAgICAqICAgICAgICAgICAgIDI1NSxcbiAgICAgKiAgICAgICAgICAgICAyNTUsXG4gICAgICogICAgICAgICAgICAgMCxcbiAgICAgKiAgICAgICAgICAgICA0MyxcbiAgICAgKiAgICAgICAgICAgICA1NSxcbiAgICAgKiAgICAgICAgICAgICAwLFxuICAgICAqICAgICAgICAgICAgIDAsXG4gICAgICogICAgICAgICAgICAgMjU1LFxuICAgICAqICAgICAgICAgICAgIDI1NVxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIHR5cGU6IFwiQnVmZmVyXCJcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgcm9vdEtleTogXCJIS0VZX0NVUlJFTlRfVVNFUlwiLFxuICAgICAqICAgICBzdWJrZXk6IFwiRm9vXFxCYXJcIixcbiAgICAgKiAgICAgdHlwZTogXCJSRUdfQklOQVJZXCIsXG4gICAgICogICAgIHZhbHVlOiBcIkJhelwiXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlYWRSZWdpc3RyeVZhbHVlKHJvb3RLZXksIHN1YmtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3JlYWQtcmVnaXN0cnktdmFsdWUnLCB7XG4gICAgICAgICAgICByb290S2V5LFxuICAgICAgICAgICAgc3Via2V5LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxsIHdpbGwgcmVnaXN0ZXIgYSB1bmlxdWUgaWQgYW5kIHByb2R1Y2UgYSB0b2tlbi5cbiAgICAgKiBUaGUgdG9rZW4gY2FuIGJlIHVzZWQgdG8gYnJva2VyIGFuIGV4dGVybmFsIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHV1aWQgLSBBIFVVSUQgZm9yIHRoZSByZW1vdGUgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLnJlZ2lzdGVyRXh0ZXJuYWxDb25uZWN0aW9uKFwicmVtb3RlLWNvbm5lY3Rpb24tdXVpZFwiKS50aGVuKGNvbm4gPT4gY29uc29sZS5sb2coY29ubikpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogLy8gb2JqZWN0IGNvbWVzIGJhY2sgd2l0aFxuICAgICAqIC8vICAgICB0b2tlbjogXCIwNDg5RUFDNS02NDA0LTRGMEQtOTkzQi05MkJCOEVBQjQ0NURcIiwgLy8gdGhpcyB3aWxsIGJlIHVuaXF1ZSBlYWNoIHRpbWVcbiAgICAgKiAvLyAgICAgdXVpZDogXCJyZW1vdGUtY29ubmVjdGlvbi11dWlkXCJcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlZ2lzdGVyRXh0ZXJuYWxDb25uZWN0aW9uKHV1aWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZWdpc3Rlci1leHRlcm5hbC1jb25uZWN0aW9uJywgeyB1dWlkIH0pLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqc29uIGJsb2IgZm91bmQgaW4gdGhlIFtkZXNrdG9wIG93bmVyIHNldHRpbmdzXShodHRwczovL29wZW5maW4uY28vZG9jdW1lbnRhdGlvbi9kZXNrdG9wLW93bmVyLXNldHRpbmdzLylcbiAgICAgKiBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBzZXJ2aWNlSWRlbnRpZmllciBBbiBvYmplY3QgY29udGFpbmluZyBhIG5hbWUga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIE1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZGVza3RvcCBzZXJ2aWNlcyBjYW4gYmUgZm91bmQgW2hlcmVdKGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvZGVza3RvcC1zZXJ2aWNlcykuXG4gICAgICogVGhpcyBjYWxsIHdpbGwgcmVqZWN0IGlmIHRoZSBkZXNrdG9wIG93bmVyIHNldHRpbmdzIGZpbGUgaXMgbm90IHByZXNlbnQsIG5vdCBjb3JyZWN0bHkgZm9ybWF0dGVkLCBvciBpZiB0aGUgc2VydmljZSByZXF1ZXN0ZWQgaXMgbm90IGNvbmZpZ3VyZWQgb3IgY29uZmlndXJlZCBpbmNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiAvLyBIZXJlIHdlIGFyZSB1c2luZyB0aGUgW2xheW91dHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9IYWRvdWtlbklPL2xheW91dHMtc2VydmljZSkgc2VydmljZS5cbiAgICAgKiBmaW4uU3lzdGVtLmdldFNlcnZpY2VDb25maWd1cmF0aW9uKHtuYW1lOidsYXlvdXRzJ30pLnRoZW4oY29uc29sZS5sb2cpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlcnZpY2VDb25maWd1cmF0aW9uKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VydmljZUlkZW50aWZpZXIubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFuIG9iamVjdCB3aXRoIGEgYG5hbWVgIHByb3BlcnR5IGhhdmluZyBhIHN0cmluZyB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc2VydmljZUlkZW50aWZpZXI7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXNlcnZpY2UtY29uZmlndXJhdGlvbicsIHsgbmFtZSB9KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3lzdGVtQXBwQ29uZmlnKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBzdHJpbmcgdmFsdWUgZm9yIG5hbWUgb2Ygc3lzdGVtIGFwcCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXN5c3RlbS1hcHAtY29uZmlndXJhdGlvbicsIHsgbmFtZSB9KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgc3lzdGVtIHNodXRkb3duIGhhbmRsZXIgc28gdXNlciBjYW4gZG8gc29tZSBjbGVhbnVwIGJlZm9yZSBzeXN0ZW0gaXMgc2h1dHRpbmcgZG93bi5cbiAgICAgKiBAcmVtYXJrcyBPbmNlIHN5c3RlbSBzaHV0ZG93biBzdGFydHMsIHlvdSBhcmUgdW5hYmxlIHRvIGNhbmNlbCBpdC5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciBzeXN0ZW0gc2h1dGRvd24gaGFuZGxlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0ucmVnaXN0ZXJTaHV0ZG93bkhhbmRsZXIoKHNodXRkb3duRXZlbnQpID0+IHtcbiAgICAgKiAgICAgICAgIC8vIHNhdmUgc3RhdGUgb3IgY2xlYW51cFxuICAgICAqICAgICAgICAgY29uc29sZS5sb2coJ2RvIHNvbWUgY2xlYW51cCBiZWZvcmUgc2h1dGRvd24nKTtcbiAgICAgKiAgICAgICAgIC8vIE5vdGlmeSBhcHAgaXMgcmVhZHkgZm9yIHRlcm1pbmF0aW9uLlxuICAgICAqICAgICAgICAgc2h1dGRvd25FdmVudC5wcm9jZWVkKCk7XG4gICAgICogfSlcbiAgICAgKiAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU2h1dGRvd24gaGFuZGxlciByZWdpc3RlcmVkIScpKVxuICAgICAqIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVyU2h1dGRvd25IYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3N5c3RlbS1yZWdpc3Rlci1zaHV0ZG93bi1oYW5kbGVyJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgU3lzdGVtU2h1dGRvd25FdmVudE5hbWUgPSAnc3lzdGVtLXNodXRkb3duJztcbiAgICAgICAgY29uc3QgU3lzdGVtU2h1dGRvd25IYW5kbGVkRXZlbnROYW1lID0gJ3N5c3RlbS1zaHV0ZG93bi1oYW5kbGVkJztcbiAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSB0aGlzLndpcmUubWU7XG4gICAgICAgIGNvbnN0IHNodXRkb3duSGFuZGxlciA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZWVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBjb3JlIHRoYXQgdGhlIGFwcCBpcyByZWFkeSBmb3Igc2h1dGRvd25cbiAgICAgICAgICAgICAgICB0aGlzLndpcmUuZW52aXJvbm1lbnQucmFpc2VFdmVudChgYXBwbGljYXRpb24vJHtTeXN0ZW1TaHV0ZG93bkhhbmRsZWRFdmVudE5hbWV9YCwge1xuICAgICAgICAgICAgICAgICAgICB1dWlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB0b3BpYzogJ2FwcGxpY2F0aW9uJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhhbmRsZXIoeyBwcm9jZWVkIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKFN5c3RlbVNodXRkb3duRXZlbnROYW1lLCBzaHV0ZG93bkhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoZSBSVk0gdG8gcGVyZm9ybSBhIGhlYWx0aCBjaGVjayBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBqc29uLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgUmVxdWlyZXMgUlZNIDUuNStcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB0cnkge1xuICAgICAqICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZmluLlN5c3RlbS5ydW5Sdm1IZWFsdGhDaGVjaygpO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiB9IGNhdGNoKGUpIHtcbiAgICAgKiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJ1blJ2bUhlYWx0aENoZWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3J1bi1ydm0taGVhbHRoLWNoZWNrJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExhdW5jaCBhcHBsaWNhdGlvbiB1c2luZyBhIG1hbmlmZXN0IFVSTC9wYXRoLiBJdCBkaWZmZXJzIGZyb20gQXBwbGljYXRpb24uc3RhcnRGcm9tTWFuaWZlc3QgaW4gdGhhdCB0aGlzIEFQSSBjYW4gYWNjZXB0IGEgbWFuaWZlc3QgdXNpbmcgdGhlIGZpbiBwcm90b2NvbC5cbiAgICAgKiBAcGFyYW0gbWFuaWZlc3RVcmwgLSBUaGUgbWFuaWZlc3QncyBVUkwgb3IgcGF0aC5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIFBhcmFtZXRlcnMgdGhhdCB0aGUgUlZNIHdpbGwgdXNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEByZW1hcmtzIFN1cHBvcnRzIHByb3RvY29scyBodHRwL3MgYW5kIGZpbi9zLCBhbmQgYWxzbyBhIGxvY2FsIHBhdGguXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIEFQSSBpcyBXaW5kb3dzIG9ubHkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogVGhpcyBBUEkgY2FuIGhhbmRsZSBtb3N0IG1hbmlmZXN0IHR5cGVzLiBTb21lIGV4YW1wbGVzIGJlbG93LlxuICAgICAqXG4gICAgICogVHJhZGl0aW9uYWw6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGZpbi5TeXN0ZW0ubGF1bmNoTWFuaWZlc3QoXG4gICAgICogICAnaHR0cHM6Ly9kZW1vYXBwZGlyZWN0b3J5Lm9wZW5mLmluL2Rlc2t0b3AvY29uZmlnL2FwcHMvT3BlbkZpbi9IZWxsb09wZW5GaW4vYXBwLmpzb24nKTtcbiAgICAgKiBjb25zb2xlLmxvZyhtYW5pZmVzdCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBQbGF0Zm9ybTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IG1hbmlmZXN0ID0gYXdhaXQgZmluLlN5c3RlbS5sYXVuY2hNYW5pZmVzdCgnaHR0cHM6Ly9vcGVuZmluLmdpdGh1Yi5pby9wbGF0Zm9ybS1hcGktcHJvamVjdC1zZWVkL3B1YmxpYy5qc29uJyk7XG4gICAgICogY29uc29sZS5sb2cobWFuaWZlc3QpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTGF1bmNoaW5nIHRyYWRpdGlvbmFsIG1hbmlmZXN0IGludG8gYSBwbGF0Zm9ybTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IG1hbmlmZXN0ID0gYXdhaXQgZmluLlN5c3RlbS5sYXVuY2hNYW5pZmVzdChcbiAgICAgKiAgICdodHRwczovL29wZW5maW4uZ2l0aHViLmlvL3BsYXRmb3JtLWFwaS1wcm9qZWN0LXNlZWQvcHVibGljLmpzb24/XFxcbiAgICAgKiAgICQkYXBwTWFuaWZlc3RVcmw9aHR0cHM6Ly9kZW1vYXBwZGlyZWN0b3J5Lm9wZW5mLmluL2Rlc2t0b3AvY29uZmlnL1xcXG4gICAgICogICBhcHBzL09wZW5GaW4vSGVsbG9PcGVuRmluL2FwcC5qc29uJyk7XG4gICAgICogY29uc29sZS5sb2cobWFuaWZlc3QpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTGF1bmNoaW5nIHdpdGggUlZNIG9wdGlvbnM6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGZpbi5TeXN0ZW0ubGF1bmNoTWFuaWZlc3QoJ2h0dHBzOi8vb3BlbmZpbi5naXRodWIuaW8vcGxhdGZvcm0tYXBpLXByb2plY3Qtc2VlZC9wdWJsaWMuanNvbicsXG4gICAgICogICAgIHsgbm9VaTogdHJ1ZSwgdXNlckFwcENvbmZpZ0FyZ3M6IHsgYWJjOiAnMTIzJywgeHl6OiAnNzg5JyB9IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG1hbmlmZXN0KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIExvY2FsIFBhdGg6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBtYW5pZmVzdCA9ICBhd2FpdCBmaW4uU3lzdGVtLmxhdW5jaE1hbmlmZXN0KCdmaWxlOi8vYzpcXFxccGF0aFxcXFx0b1xcXFxtYW5pZmVzdFxcXFxmaWxlLmpzb24nKTtcbiAgICAgKiBjb25zb2xlLmxvZyhtYW5pZmVzdCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBMYXVuY2hpbmcgd2l0aCBSVk0gJ3N1YnNjcmliZScgb3B0aW9uOlxuICAgICAqXG4gICAgICogVGhpcyBvcHRpb24gYWxsb3dzIHVzZXJzIHRvIHN1YnNjcmliZSB0byBhcHAgdmVyc2lvbiByZXNvbHZlciBldmVudHMgd2hlblxuICAgICAqIGNhbGxpbmcgbGF1bmNoTWFuaWZlc3Qgd2l0aCBmYWxsYmFja01hbmlmZXN0cyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5TeXN0ZW0ubGF1bmNoTWFuaWZlc3QoJ2ZpbnM6Ly9zeXN0ZW0tYXBwcy9ub3RpZmljYXRpb25zL2FwcC5qc29uJywgeyBzdWJzY3JpYmU6IChsYXVuY2gpID0+IHtcbiAgICAgKiBcdFx0bGF1bmNoLm9uKCdhcHAtdmVyc2lvbi1wcm9ncmVzcycsIChwcm9ncmVzcykgPT4ge1xuICAgICAqIFx0XHRcdGNvbnNvbGUubG9nKFwiVHJ5aW5nIG1hbmlmZXN0IFwiICsgcHJvZ3Jlc3MubWFuaWZlc3QpXG4gICAgICogXHRcdH0pO1xuICAgICAqXG4gICAgICogXHRcdGxhdW5jaC5vbigncnVudGltZS1zdGF0dXMnLCAoc3RhdHVzKSA9PiB7XG4gICAgICogXHRcdFx0Y29uc29sZS5sb2coXCJSdW50aW1lIHN0YXR1czogXCIgKyBKU09OLnN0cmluZ2lmeShzdGF0dXMpKTtcbiAgICAgKiBcdFx0fSk7XG4gICAgICpcbiAgICAgKiBcdFx0Ly8gUlZNIGhhcyBzdWNjZXNzZnVsbHkgZm91bmQgdGhlIHRhcmdldCBydW50aW1lIHZlcnNpb25cbiAgICAgKiBcdFx0bGF1bmNoLm9uKCdhcHAtdmVyc2lvbi1jb21wbGV0ZScsIChjb21wbGV0ZSkgPT4ge1xuICAgICAqIFx0XHRcdGNvbnNvbGUubG9nKFwiUGFyZW50IGFwcCBcIiArIGNvbXBsZXRlLnNyY01hbmlmZXN0ICsgXCIgcmVzb2x2ZWQgdG8gXCIgKyBjb21wbGV0ZS5tYW5pZmVzdCk7XG4gICAgICogXHRcdFx0bGF1bmNoLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAqIFx0XHR9KTtcbiAgICAgKlxuICAgICAqIFx0XHQvLyBSVk0gZmFpbGVkIHRvIGZpbmQgYW4gYXZhaWxhYmxlIHJ1bnRpbWUgdmVyc2lvblxuICAgICAqIFx0XHRsYXVuY2gub24oJ2FwcC12ZXJzaW9uLWVycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICogXHRcdFx0Y29uc29sZS5sb2coXCJGYWlsZWQgdG8gcmVzb2x2ZSBcIiArIGVycm9yLnNyY01hbmlmZXN0ICsgXCIgZnJvbSB0aGUgZmFsbGJhY2tNYW5pZmVzdHNcIik7XG4gICAgICogXHRcdFx0bGF1bmNoLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAqIFx0XHR9KTtcbiAgICAgKiBcdH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBsYXVuY2hNYW5pZmVzdChtYW5pZmVzdFVybCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgc3Vic2NyaWJlLCAuLi5fc2VuZE9wdHMgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHNlbmRPcHRzID0gX3NlbmRPcHRzO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICBjb25zdCBsYXVuY2hFbWl0dGVyID0gbmV3IGV2ZW50c18xJDYuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICBzdWJzY3JpYmUobGF1bmNoRW1pdHRlcik7XG4gICAgICAgICAgICBjb25zdCBBcHBWZXJzaW9uUHJvZ3Jlc3NFdmVudE5hbWUgPSAnYXBwLXZlcnNpb24tcHJvZ3Jlc3MnO1xuICAgICAgICAgICAgY29uc3QgUnVudGltZVN0YXR1c0V2ZW50TmFtZSA9ICdydW50aW1lLXN0YXR1cyc7XG4gICAgICAgICAgICBjb25zdCBBcHBWZXJzaW9uQ29tcGxldGVFdmVudE5hbWUgPSAnYXBwLXZlcnNpb24tY29tcGxldGUnO1xuICAgICAgICAgICAgY29uc3QgQXBwVmVyc2lvbkVycm9yRXZlbnROYW1lID0gJ2FwcC12ZXJzaW9uLWVycm9yJztcbiAgICAgICAgICAgIC8vIGFkZCBpZCB0byBhdm9pZCBtdWx0aXBsZSBhcGkgY2FsbHMgZ2V0dGluZyBkdXBsaWNhdGVkIGV2ZW50c1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLndpcmUuZW52aXJvbm1lbnQuZ2V0TmV4dE1lc3NhZ2VJZCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBzZW5kT3B0cy5hcHBWZXJzaW9uSWQgPSBpZDtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZEV2ZW50cyA9IFtcbiAgICAgICAgICAgICAgICBBcHBWZXJzaW9uQ29tcGxldGVFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgQXBwVmVyc2lvblByb2dyZXNzRXZlbnROYW1lLFxuICAgICAgICAgICAgICAgIFJ1bnRpbWVTdGF0dXNFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgQXBwVmVyc2lvbkVycm9yRXZlbnROYW1lXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgY2xlYW5FdmVudFBheWxvYWQgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdHlwZSBjYXN0aW5ncyBiZWxvdyB0byBtYWtlIHN1cmUgdGhlIHJldHVybiB0eXBlIGlzIGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcHBWZXJzaW9uSWQsIHRvcGljLCB0eXBlOiB0eXBlV2l0aElkLCAuLi5yZXN0IH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzdXBwb3J0ZWRFdmVudHMuZmluZCgoeCkgPT4gdHlwZVdpdGhJZC5pbmNsdWRlcyh4KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYXBwVmVyc2lvbkxpc3RlbmVyID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhblBheWxvYWQgPSBjbGVhbkV2ZW50UGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBsYXVuY2hFbWl0dGVyLmVtaXQoY2xlYW5QYXlsb2FkLnR5cGUsIGNsZWFuUGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlQWxsTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoYCR7QXBwVmVyc2lvblByb2dyZXNzRXZlbnROYW1lfS4ke2lkfWAsIGFwcFZlcnNpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihgJHtSdW50aW1lU3RhdHVzRXZlbnROYW1lfS4ke2lkfWAsIGFwcFZlcnNpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihgJHtBcHBWZXJzaW9uQ29tcGxldGVFdmVudE5hbWV9LiR7aWR9YCwgYXBwVmVyc2lvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGAke0FwcFZlcnNpb25FcnJvckV2ZW50TmFtZX0uJHtpZH1gLCBhcHBWZXJzaW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoYCR7QXBwVmVyc2lvbkNvbXBsZXRlRXZlbnROYW1lfS4ke2lkfWAsIHJlbW92ZUFsbExpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihgJHtBcHBWZXJzaW9uRXJyb3JFdmVudE5hbWV9LiR7aWR9YCwgcmVtb3ZlQWxsTGlzdGVuZXJzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5vbihgJHtBcHBWZXJzaW9uUHJvZ3Jlc3NFdmVudE5hbWV9LiR7aWR9YCwgYXBwVmVyc2lvbkxpc3RlbmVyKSxcbiAgICAgICAgICAgICAgICB0aGlzLm9uKGAke1J1bnRpbWVTdGF0dXNFdmVudE5hbWV9LiR7aWR9YCwgYXBwVmVyc2lvbkxpc3RlbmVyKSxcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoYCR7QXBwVmVyc2lvbkNvbXBsZXRlRXZlbnROYW1lfS4ke2lkfWAsIGFwcFZlcnNpb25MaXN0ZW5lciksXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKGAke0FwcFZlcnNpb25FcnJvckV2ZW50TmFtZX0uJHtpZH1gLCBhcHBWZXJzaW9uTGlzdGVuZXIpLFxuICAgICAgICAgICAgICAgIHRoaXMub25jZShgJHtBcHBWZXJzaW9uQ29tcGxldGVFdmVudE5hbWV9LiR7aWR9YCwgcmVtb3ZlQWxsTGlzdGVuZXJzKSxcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoYCR7QXBwVmVyc2lvbkVycm9yRXZlbnROYW1lfS4ke2lkfWAsIHJlbW92ZUFsbExpc3RlbmVycylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xhdW5jaC1tYW5pZmVzdCcsIHtcbiAgICAgICAgICAgIG1hbmlmZXN0VXJsLFxuICAgICAgICAgICAgb3B0czogc2VuZE9wdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5wYXlsb2FkLmRhdGEubWFuaWZlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHBlcm1pc3Npb24gb2YgYSBzZWN1cmVkIGFwaSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICogQHBhcmFtIGFwaU5hbWUgLSBUaGUgZnVsbCBuYW1lIG9mIGEgc2VjdXJlZCBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLlN5c3RlbS5xdWVyeVBlcm1pc3Npb25Gb3JDdXJyZW50Q29udGV4dCgnU3lzdGVtLmxhdW5jaEV4dGVybmFsUHJvY2VzcycpLnRoZW4ocmVzdWx0ID0+IGNvbnNvbGUubG9nKHJlc3VsdCkpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKlxuICAgICAqIC8vVGhpcyByZXNwb25zZSBoYXMgdGhlIGZvbGxvd2luZyBzaGFwZTpcbiAgICAgKiB7XG4gICAgICogICAgcGVybWlzc2lvbjogJ1N5c3RlbS5sYXVuY2hFeHRlcm5hbFByb2Nlc3MnLCAvLyBhcGkgZnVsbCBuYW1lXG4gICAgICogICAgc3RhdGU6ICdncmFudGVkJywgLy8gc3RhdGUgb2YgcGVybWlzc2lvblxuICAgICAqICAgIGdyYW50ZWQ6IHRydWVcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlQZXJtaXNzaW9uRm9yQ3VycmVudENvbnRleHQoYXBpTmFtZSkge1xuICAgICAgICBjb25zdCBpZGVudGl0eSA9IHsgdXVpZDogdGhpcy53aXJlLm1lLnV1aWQsIG5hbWU6IHRoaXMud2lyZS5tZS5uYW1lIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3F1ZXJ5LXBlcm1pc3Npb24tZm9yLWN1cnJlbnQtY29udGV4dCcsIHtcbiAgICAgICAgICAgIGFwaU5hbWUsXG4gICAgICAgICAgICBpZGVudGl0eVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBheWxvYWQuZGF0YTtcbiAgICB9XG4gICAgLy8gTm90IGRvY3VtZW50aW5nLCBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICBhc3luYyBlbmFibGVOYXRpdmVXaW5kb3dJbnRlZ3JhdGlvblByb3ZpZGVyKHBlcm1pc3Npb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2VuYWJsZS1uYXRpdmUtd2luZG93LWludGVncmF0aW9uLXByb3ZpZGVyJywgeyBwZXJtaXNzaW9ucyB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogKEludGVybmFsKSBSZWdpc3RlciB0aGUgdXNhZ2Ugb2YgYSBjb21wb25lbnQgd2l0aCBhIHBsYXRmb3JtXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3Qgd2l0aCBkYXRhIGFuZCB0eXBlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJVc2FnZSgpIHtcbiAgICAgKiAgICAgY29uc3QgYXBwID0gYXdhaXQgZmluLlN5c3RlbS5nZXRDdXJyZW50KCk7XG4gICAgICogICAgIHJldHVybiBhd2FpdCBmaW4uU3lzdGVtLnJlZ2lzdGVyVXNhZ2Uoe1xuICAgICAqICAgICAgICAgdHlwZTogJ3dvcmtzcGFjZS1saWNlbnNpbmcnLFxuICAgICAqICAgICAgICAgLy8gZXhhbXBsZSB2YWx1ZXMgZm9yIHRoZSBmb2xsb3dpbmcgZGF0YSBvYmplY3RcbiAgICAgKiAgICAgICAgIGRhdGE6IHtcbiAgICAgKiAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnMS4wJyxcbiAgICAgKiAgICAgICAgICAgICBjb21wb25lbnROYW1lOiAnaG9tZScsXG4gICAgICogICAgICAgICAgICAgY29tcG9uZW50VmVyc2lvbjogJzEuMCcsXG4gICAgICogICAgICAgICAgICAgYWxsb3dlZDogdHJ1ZSxcbiAgICAgKiAgICAgICAgICAgICByZWplY3Rpb25Db2RlOiAnJ1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiByZWdpc3RlclVzYWdlKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQgY29tcG9uZW50IGFwcGxpY2F0aW9uJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWdpc3RlclVzYWdlKHsgZGF0YSwgdHlwZSB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZWdpc3Rlci11c2FnZScsIHsgZGF0YSwgdHlwZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIGFsbCBwcmludGVycyBvZiB0aGUgY2FsbGVyIGFuZCBub3QgYWxsIHRoZSBwcmludGVycyBvbiB0aGUgZGVza3RvcC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uU3lzdGVtLmdldFByaW50ZXJzKClcbiAgICAgKiAgICAgLnRoZW4oKHByaW50ZXJzKSA9PiB7XG4gICAgICogICAgICAgICBwcmludGVycy5mb3JFYWNoKChwcmludGVyKSA9PiB7XG4gICAgICogICAgICAgICAgICAgaWYgKHByaW50ZXIuaXNEZWZhdWx0KSB7XG4gICAgICogICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHByaW50ZXIpO1xuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqICAgICB9KVxuICAgICAqICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJpbnRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3N5c3RlbS1nZXQtcHJpbnRlcnMnKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBQcm9jZXNzIExvZ2dpbmcgdmFsdWVzOiBwZXJpb2RpYyBpbnRlcnZhbCBhbmQgb3V0bGllciBkZXRlY3Rpb24gZW50cmllcyBhbmQgaW50ZXJ2YWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgUHJvY2VzcyBMb2dnaW5nIHVwZGF0YWJsZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgV2hlbiBlbmFibGluZyB2ZXJib3NlIG1vZGUsIGFkZGl0aW9uYWwgcHJvY2VzcyBpbmZvcm1hdGlvbiBpcyBsb2dnZWQgdG8gdGhlIGRlYnVnLmxvZzpcbiAgICAgKlxuICAgICAqIDEuIFBlcmlvZGljYWxseSBwcm9jZXNzIHVzYWdlIChtZW1vcnksIGNwdSwgZXRjKSB3aWxsIGJlIGxvZ2dlZCBmb3IgZWFjaCBQSUQgYWxvbmcgd2l0aCB0aGUgd2luZG93cywgdmlld3MgYW5kXG4gICAgICogaWZyYW1lcyB0aGF0IGJlbG9uZyB0byB0aGVtLiBUaGUgZGVmYXVsdCBpcyBldmVyeSAzMCBzZWNvbmRzLiBVcGRhdGFibGUgYnkgcGFzc2luZyB0aGUgaW50ZXJ2YWwgb3B0aW9uLlxuICAgICAqIDIuIFdoZW4gV2luZG93cyBhbmQgVmlld3MgYXJlIGNyZWF0ZWQgb3IgbmF2aWdhdGVkIHRoZSBQSUQgdGhleSBiZWxvbmcgdG8gYW5kIHRoZWlyIG9wdGlvbnMgd2lsbCBiZSBsb2dnZWQuXG4gICAgICogMy4gV2hlbiBXaW5kb3dzIGFuZCBWaWV3cyBhcmUgZGVzdHJveWVkIHRoZWlyIGxhc3Qga25vd24gcHJvY2VzcyB1c2FnZSB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKiA0LiBXaGVuZXZlciBhbiBvdXRsaWVyIG1lbW9yeSB1c2FnZSBpcyBkZXRlY3RlZCBpdCB3aWxsIGJlIGxvZ2dlZC4gQnkgZGVmYXVsdCwgb24gYW4gaW50ZXJ2YWwgb2YgNSBzZWNvbmRzIHdlIHdpbGxcbiAgICAgKiBjb2xsZWN0IHByb2Nlc3MgdXNhZ2UgZm9yIGFsbCBQSURzIGFuZCB3aGVuIDE0NCBzdWNoIGVudHJpZXMgYXJlIGNvbGxlY3RlZCwgd2Ugd2lsbCBzdGFydCBhbmFseXppbmcgdGhlIGRhdGEgZm9yIGFueVxuICAgICAqIHBvc3NpYmxlIG91dGxpZXJzIGluIHRoZSBmb2xsb3dpbmcgZW50cmllcy4gVGhlIGludGVydmFsIGFuZCBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHN0b3JlZCBpbiB0aGUgcnVubmluZyBidWZmZXJcbiAgICAgKiBjYW4gYmUgdXBkYXRhYmxlIGJ5IHBhc3NpbmcgdGhlIG91dGxpZXJEZXRlY3Rpb24uaW50ZXJ2YWwgYW5kIG91dGxpZXJEZXRlY3Rpb24uZW50cmllcyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogYXdhaXQgZmluLlN5c3RlbS51cGRhdGVQcm9jZXNzTG9nZ2luZ09wdGlvbnMoe1xuICAgICAqICAgICBpbnRlcnZhbDogMTAsXG4gICAgICogICAgIG91dGxpZXJEZXRlY3Rpb246IHtcbiAgICAgKiAgICAgICAgIGludGVydmFsOiAxNSxcbiAgICAgKiAgICAgICAgIGVudHJpZXM6IDIwMFxuICAgICAqICAgICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUHJvY2Vzc0xvZ2dpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3N5c3RlbS11cGRhdGUtcHJvY2Vzcy1sb2dnaW5nLW9wdGlvbnMnLCB7IG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZG9tYWluIHNldHRpbmdzIGZvciB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi5cbiAgICAgKiBJbml0aWFsIHNldHRpbmdzIGFyZSBjb25maWd1cmVkIHdpdGggdGhlIGRlZmF1bHREb21haW5TZXR0aW5ncyBhcHBsaWNhdGlvbiBvcHRpb24gdmlhIG1hbmlmZXN0LlxuICAgICAqIERvbWFpbiBzZXR0aW5ncyBjYW4gYmUgb3ZlcndyaXR0ZW4gZHVyaW5nIHJ1bnRpbWUgd2l0aCBTeXN0ZW0uc2V0RG9tYWluU2V0dGluZ3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGRvbWFpblNldHRpbmdzID0gYXdhaXQgZmluLlN5c3RlbS5nZXREb21haW5TZXR0aW5ncygpO1xuICAgICAqIC8vIHtcbiAgICAgKiAvLyAgICAgXCJydWxlc1wiOiBbXG4gICAgICogLy8gICAgICAgICB7XG4gICAgICogLy8gICAgICAgICAgICAgXCJtYXRjaFwiOiBbXG4gICAgICogLy8gICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9vcGVuZmluLmNvXCJcbiAgICAgKiAvLyAgICAgICAgICAgICBdLFxuICAgICAqIC8vICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICogLy8gICAgICAgICAgICAgICAgIFwiZG93bmxvYWRTZXR0aW5nc1wiOiB7XG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF0Y2hcIjogW1xuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8YWxsX3VybHM+XCJcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiZWhhdmlvclwiOiBcInByb21wdFwiXG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAqIC8vICAgICAgICAgICAgICAgICB9XG4gICAgICogLy8gICAgICAgICAgICAgfVxuICAgICAqIC8vICAgICAgICAgfVxuICAgICAqIC8vICAgICBdXG4gICAgICogLy8gfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldERvbWFpblNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YSB9IH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWRvbWFpbi1zZXR0aW5ncycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZG9tYWluIHNldHRpbmdzIGZvciB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gZG9tYWluU2V0dGluZ3MgLSBkb21haW4gc2V0dGluZ3Mgb2JqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGRvbWFpblNldHRpbmdzID0gYXdhaXQgZmluLlN5c3RlbS5nZXREb21haW5TZXR0aW5ncygpO1xuICAgICAqIC8vIHtcbiAgICAgKiAvLyAgICAgXCJydWxlc1wiOiBbXG4gICAgICogLy8gICAgICAgICB7XG4gICAgICogLy8gICAgICAgICAgICAgXCJtYXRjaFwiOiBbXG4gICAgICogLy8gICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9vcGVuZmluLmNvXCJcbiAgICAgKiAvLyAgICAgICAgICAgICBdLFxuICAgICAqIC8vICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICogLy8gICAgICAgICAgICAgICAgIFwiZG93bmxvYWRTZXR0aW5nc1wiOiB7XG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICBcInJ1bGVzXCI6IFtcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF0Y2hcIjogW1xuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8YWxsX3VybHM+XCJcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiZWhhdmlvclwiOiBcInByb21wdFwiXG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAqIC8vICAgICAgICAgICAgICAgICB9XG4gICAgICogLy8gICAgICAgICAgICAgfVxuICAgICAqIC8vICAgICAgICAgfVxuICAgICAqIC8vICAgICBdXG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVmFsaWQgcnVsZSBiZWhhdmlvcnMgYXJlICdwcm9tcHQnIGFuZCAnbm8tcHJvbXB0J1xuICAgICAqIGRvbWFpblNldHRpbmdzLnJ1bGVzWzBdLm9wdGlvbnMuZG93bmxvYWRTZXR0aW5ncy5ydWxlc1swXS5iZWhhdmlvciA9ICduby1wcm9tcHQnO1xuICAgICAqXG4gICAgICogYXdhaXQgZmluLlN5c3RlbS5zZXREb21haW5TZXR0aW5ncyhkb21haW5TZXR0aW5ncyk7XG4gICAgICpcbiAgICAgKiBjb25zdCBuZXdEb21haW5TZXR0aW5ncyA9IGF3YWl0IGZpbi5TeXN0ZW0uZ2V0RG9tYWluU2V0dGluZ3MoKTtcbiAgICAgKiAvLyB7XG4gICAgICogLy8gICAgIFwicnVsZXNcIjogW1xuICAgICAqIC8vICAgICAgICAge1xuICAgICAqIC8vICAgICAgICAgICAgIFwibWF0Y2hcIjogW1xuICAgICAqIC8vICAgICAgICAgICAgICAgICBcImh0dHBzOi8vb3BlbmZpbi5jb1wiXG4gICAgICogLy8gICAgICAgICAgICAgXSxcbiAgICAgKiAvLyAgICAgICAgICAgICBcIm9wdGlvbnNcIjoge1xuICAgICAqIC8vICAgICAgICAgICAgICAgICBcImRvd25sb2FkU2V0dGluZ3NcIjoge1xuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgXCJydWxlc1wiOiBbXG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hdGNoXCI6IFtcbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGFsbF91cmxzPlwiXG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmVoYXZpb3JcIjogXCJuby1wcm9tcHRcIlxuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgfVxuICAgICAqIC8vICAgICAgICAgICAgIH1cbiAgICAgKiAvLyAgICAgICAgIH1cbiAgICAgKiAvLyAgICAgXVxuICAgICAqIC8vIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZXREb21haW5TZXR0aW5ncyhkb21haW5TZXR0aW5ncykge1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LWRvbWFpbi1zZXR0aW5ncycsIHsgZG9tYWluU2V0dGluZ3MsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG4gICAgfVxufVxuc3lzdGVtLlN5c3RlbSA9IFN5c3RlbTtcblxudmFyIGludGVyYXBwYnVzID0ge307XG5cbnZhciByZWZDb3VudGVyID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWZDb3VudGVyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnJlZkNvdW50ZXIuUmVmQ291bnRlciA9IHZvaWQgMDtcbmNsYXNzIFJlZkNvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRvcGljUmVmTWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSByZWYgY291bnQgYWZ0ZXIgaW5jcmVtZW50aW5nXG4gICAgaW5jUmVmQ291bnQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlZkNvdW50ID0gdGhpcy50b3BpY1JlZk1hcC5nZXQoa2V5KTtcbiAgICAgICAgbGV0IHJldHVybkNvdW50O1xuICAgICAgICBpZiAoIXJlZkNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRvcGljUmVmTWFwLnNldChrZXksIDEpO1xuICAgICAgICAgICAgcmV0dXJuQ291bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3UmVmQ291bnQgPSByZWZDb3VudCArIDE7XG4gICAgICAgICAgICByZXR1cm5Db3VudCA9IG5ld1JlZkNvdW50O1xuICAgICAgICAgICAgdGhpcy50b3BpY1JlZk1hcC5zZXQoa2V5LCBuZXdSZWZDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybkNvdW50O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSByZWYgY291bnQgYWZ0ZXIgZGVjcmVtZW50aW5nLCBvciAtMSBpZiB0aGUga2V5IGFscmVhZHkgaGFkIG5vIHJlZmVyZW5jZXNcbiAgICBkZWNSZWZDb3VudChrZXkpIHtcbiAgICAgICAgY29uc3QgcmVmQ291bnQgPSB0aGlzLnRvcGljUmVmTWFwLmdldChrZXkpO1xuICAgICAgICBsZXQgcmV0dXJuQ291bnQ7XG4gICAgICAgIGlmIChyZWZDb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UmVmQ291bnQgPSByZWZDb3VudCAtIDE7XG4gICAgICAgICAgICB0aGlzLnRvcGljUmVmTWFwLnNldChrZXksIG5ld1JlZkNvdW50KTtcbiAgICAgICAgICAgIHJldHVybkNvdW50ID0gbmV3UmVmQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5Db3VudCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5Db3VudDtcbiAgICB9XG4gICAgLy8gRXhlY3V0ZSBmaXJzdEFjdGlvbiBpZiBpdCBpcyB0aGUgZmlyc3Qgc3VjaCByZWYsIGVsc2UgZXhlY3V0ZSBub25GaXJzdEFjdGlvbi5cbiAgICAvLyBJbiBlaXRoZXIgY2FzZSB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoYXQgb2YgdGhlIGFjdGlvbiBleGVjdXRlZFxuICAgIGFjdE9uRmlyc3Qoa2V5LCBmaXJzdEFjdGlvbiwgbm9uRmlyc3RBY3Rpb24pIHtcbiAgICAgICAgY29uc3QgbnVtUmVmcyA9IHRoaXMuaW5jUmVmQ291bnQoa2V5KTtcbiAgICAgICAgY29uc3QgaXNGaXJzdFJlZiA9IG51bVJlZnMgPT09IDE7XG4gICAgICAgIHJldHVybiBpc0ZpcnN0UmVmID8gZmlyc3RBY3Rpb24oKSA6IG5vbkZpcnN0QWN0aW9uKCk7XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgbGFzdEFjdGlvbiBpZiBpdCBpcyB0aGUgZmlyc3Qgc3VjaCByZWYsIGVsc2UgZXhlY3V0ZSBub25MYXN0QWN0aW9uLlxuICAgIC8vIEluIGVpdGhlciBjYXNlIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhhdCBvZiB0aGUgYWN0aW9uIGV4ZWN1dGVkXG4gICAgYWN0T25MYXN0KGtleSwgbGFzdEFjdGlvbiwgbm9uTGFzdEFjdGlvbikge1xuICAgICAgICBjb25zdCBudW1SZWZzID0gdGhpcy5kZWNSZWZDb3VudChrZXkpO1xuICAgICAgICBjb25zdCBpc0xhc3RSZWYgPSBudW1SZWZzID09PSAwO1xuICAgICAgICByZXR1cm4gaXNMYXN0UmVmID8gbGFzdEFjdGlvbigpIDogbm9uTGFzdEFjdGlvbigpO1xuICAgIH1cbn1cbnJlZkNvdW50ZXIuUmVmQ291bnRlciA9IFJlZkNvdW50ZXI7XG5cbnZhciBjaGFubmVsJDEgPSB7fTtcblxudmFyIGNsaWVudCA9IHt9O1xuXG52YXIgY2hhbm5lbCA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhbm5lbCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jaGFubmVsLkNoYW5uZWxCYXNlID0gY2hhbm5lbC5Qcm90ZWN0ZWRJdGVtcyA9IHZvaWQgMDtcbmNvbnN0IHJlc3VsdE9yUGF5bG9hZCA9IChmdW5jKSA9PiBhc3luYyAodG9waWMsIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZnVuYyh0b3BpYywgcGF5bG9hZCwgc2VuZGVySWRlbnRpdHkpO1xuICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/IHBheWxvYWQgOiByZXM7XG59O1xuY2xhc3MgUHJvdGVjdGVkSXRlbXMge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWRlbnRpdHksIHdpcmUpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcklkZW50aXR5ID0gcHJvdmlkZXJJZGVudGl0eTtcbiAgICAgICAgdGhpcy53aXJlID0gd2lyZTtcbiAgICB9XG59XG5jaGFubmVsLlByb3RlY3RlZEl0ZW1zID0gUHJvdGVjdGVkSXRlbXM7XG5jbGFzcyBDaGFubmVsQmFzZSB7XG4gICAgc3RhdGljIGRlZmF1bHRBY3Rpb24odG9waWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBhY3Rpb24gcmVnaXN0ZXJlZCBhdCB0YXJnZXQgZm9yICR7dG9waWN9YCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NBY3Rpb24odG9waWMsIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtYWluQWN0aW9uID0gdGhpcy5zdWJzY3JpcHRpb25zLmhhcyh0b3BpYylcbiAgICAgICAgICAgICAgICA/IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQodG9waWMpXG4gICAgICAgICAgICAgICAgOiAoY3VycmVudFBheWxvYWQsIGlkKSA9PiAodGhpcy5kZWZhdWx0QWN0aW9uID8/IENoYW5uZWxCYXNlLmRlZmF1bHRBY3Rpb24pKHRvcGljLCBjdXJyZW50UGF5bG9hZCwgaWQpO1xuICAgICAgICAgICAgY29uc3QgcHJlQWN0aW9uUHJvY2Vzc2VkID0gdGhpcy5wcmVBY3Rpb24gPyBhd2FpdCB0aGlzLnByZUFjdGlvbih0b3BpYywgcGF5bG9hZCwgc2VuZGVySWRlbnRpdHkpIDogcGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvblByb2Nlc3NlZCA9IGF3YWl0IG1haW5BY3Rpb24ocHJlQWN0aW9uUHJvY2Vzc2VkLCBzZW5kZXJJZGVudGl0eSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0QWN0aW9uID8gYXdhaXQgdGhpcy5wb3N0QWN0aW9uKHRvcGljLCBhY3Rpb25Qcm9jZXNzZWQsIHNlbmRlcklkZW50aXR5KSA6IGFjdGlvblByb2Nlc3NlZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JNaWRkbGV3YXJlKHRvcGljLCBlLCBzZW5kZXJJZGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIG1pZGRsZXdhcmUgdGhhdCBmaXJlcyBiZWZvcmUgdGhlIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogQ2hhbm5lbCBQcm92aWRlcjpcbiAgICAgKiBgYGBqc1xuICAgICAqIChhc3luYyAoKT0+IHtcbiAgICAgKiAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNyZWF0ZSgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBwcm92aWRlci5yZWdpc3RlcigncHJvdmlkZXItYWN0aW9uJywgKHBheWxvYWQsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhwYXlsb2FkLCBpZGVudGl0eSk7XG4gICAgICogICAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgICAgIGVjaG86IHBheWxvYWRcbiAgICAgKiAgICAgICAgIH07XG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogICAgIHByb3ZpZGVyLmJlZm9yZUFjdGlvbigoYWN0aW9uLCBwYXlsb2FkLCBpZGVudGl0eSkgPT4ge1xuICAgICAqICAgICAgICAgLy9UaGUgcGF5bG9hZCBjYW4gYmUgYWx0ZXJlZCBoZXJlIGJlZm9yZSBoYW5kbGluZyB0aGUgYWN0aW9uLlxuICAgICAqICAgICAgICAgcGF5bG9hZC5yZWNlaXZlZCA9IERhdGUubm93KCk7XG4gICAgICogICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQ2hhbm5lbCBDbGllbnQ6XG4gICAgICogYGBganNcbiAgICAgKiAoYXN5bmMgKCk9PiB7XG4gICAgICogICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY29ubmVjdCgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBjbGllbnQucmVnaXN0ZXIoJ2NsaWVudC1hY3Rpb24nLCAocGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHBheWxvYWQsIGlkZW50aXR5KTtcbiAgICAgKiAgICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICAgZWNobzogcGF5bG9hZFxuICAgICAqICAgICAgICAgfTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgY2xpZW50LmJlZm9yZUFjdGlvbigoYWN0aW9uLCBwYXlsb2FkLCBpZGVudGl0eSkgPT4ge1xuICAgICAqICAgICAgICAgLy9UaGUgcGF5bG9hZCBjYW4gYmUgYWx0ZXJlZCBoZXJlIGJlZm9yZSBoYW5kbGluZyB0aGUgYWN0aW9uLlxuICAgICAqICAgICAgICAgcGF5bG9hZC5yZWNlaXZlZCA9IERhdGUubm93KCk7XG4gICAgICogICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgcHJvdmlkZXJSZXNwb25zZSA9IGF3YWl0IGNsaWVudC5kaXNwYXRjaCgncHJvdmlkZXItYWN0aW9uJywgeyBtZXNzYWdlOiAnSGVsbG8gRnJvbSB0aGUgY2xpZW50JyB9KTtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocHJvdmlkZXJSZXNwb25zZSk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBiZWZvcmVBY3Rpb24oZnVuYykge1xuICAgICAgICBpZiAodGhpcy5wcmVBY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxyZWFkeSByZWdpc3RlcmVkIGJlZm9yZUFjdGlvbiBtaWRkbGV3YXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVBY3Rpb24gPSByZXN1bHRPclBheWxvYWQoZnVuYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGVycm9yIGhhbmRsZXIuIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZXNwb25kaW5nIG9uIGFueSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICpcbiAgICAgKiBDaGFubmVsIFByb3ZpZGVyOlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKCdjaGFubmVsTmFtZScpO1xuICAgICAqXG4gICAgICogICAgIHByb3ZpZGVyLnJlZ2lzdGVyKCdwcm92aWRlci1hY3Rpb24nLCAocGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHBheWxvYWQpO1xuICAgICAqICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb24gZXJyb3InKTtcbiAgICAgKiAgICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICAgZWNobzogcGF5bG9hZFxuICAgICAqICAgICAgICAgfTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgcHJvdmlkZXIub25FcnJvcigoYWN0aW9uLCBlcnJvciwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCd1bmNhdWdodCBFeGNlcHRpb24gaW4gYWN0aW9uOicsIGFjdGlvbik7XG4gICAgICogICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQ2hhbm5lbCBDbGllbnQ6XG4gICAgICogYGBganNcbiAgICAgKiAoYXN5bmMgKCk9PiB7XG4gICAgICogICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY29ubmVjdCgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBjbGllbnQucmVnaXN0ZXIoJ2NsaWVudC1hY3Rpb24nLCAocGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHBheWxvYWQpO1xuICAgICAqICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb24gZXJyb3InKTtcbiAgICAgKiAgICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICAgZWNobzogcGF5bG9hZFxuICAgICAqICAgICAgICAgfTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgY2xpZW50Lm9uRXJyb3IoKGFjdGlvbiwgZXJyb3IsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygndW5jYXVnaHQgRXhjZXB0aW9uIGluIGFjdGlvbjonLCBhY3Rpb24pO1xuICAgICAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICogICAgIH0pO1xuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25FcnJvcihmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJlZ2lzdGVyZWQgZXJyb3IgbWlkZGxld2FyZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3JNaWRkbGV3YXJlID0gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbWlkZGxld2FyZSB0aGF0IGZpcmVzIGFmdGVyIHRoZSBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqXG4gICAgICogQHJlbWFya3MgSWYgdGhlIGFjdGlvbiBkb2VzIG5vdCByZXR1cm4gdGhlIHBheWxvYWQsIHRoZW4gdGhlIGFmdGVyQWN0aW9uIHdpbGwgbm90IGhhdmUgYWNjZXNzIHRvIHRoZSBwYXlsb2FkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBDaGFubmVsIFByb3ZpZGVyOlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKCdjaGFubmVsTmFtZScpO1xuICAgICAqXG4gICAgICogICAgIGF3YWl0IHByb3ZpZGVyLnJlZ2lzdGVyKCdwcm92aWRlci1hY3Rpb24nLCAocGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICAgZWNobzogcGF5bG9hZFxuICAgICAqICAgICAgICAgfTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgcHJvdmlkZXIuYWZ0ZXJBY3Rpb24oKGFjdGlvbiwgcGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgIC8vdGhlIHBheWxvYWQgY2FuIGJlIGFsdGVyZWQgaGVyZSBhZnRlciBoYW5kbGluZyB0aGUgYWN0aW9uIGJ1dCBiZWZvcmUgc2VuZGluZyBhbiBhY2tub3dsZWRnZW1lbnQuXG4gICAgICogICAgICAgICBwYXlsb2FkLnNlbnQgPSBkYXRlLm5vdygpO1xuICAgICAqICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIENoYW5uZWwgQ2xpZW50OlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNvbm5lY3QoJ2NoYW5uZWxOYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgY2xpZW50LnJlZ2lzdGVyKCdjbGllbnQtYWN0aW9uJywgKHBheWxvYWQsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgICAgIGVjaG86IHBheWxvYWRcbiAgICAgKiAgICAgICAgIH07XG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogICAgIGF3YWl0IGNsaWVudC5hZnRlckFjdGlvbigoYWN0aW9uLCBwYXlsb2FkLCBpZGVudGl0eSkgPT4ge1xuICAgICAqICAgICAgICAgLy90aGUgcGF5bG9hZCBjYW4gYmUgYWx0ZXJlZCBoZXJlIGFmdGVyIGhhbmRsaW5nIHRoZSBhY3Rpb24gYnV0IGJlZm9yZSBzZW5kaW5nIGFuIGFja25vd2xlZGdlbWVudC5cbiAgICAgKiAgICAgICAgIHBheWxvYWQuc2VudCA9IGRhdGUubm93KCk7XG4gICAgICogICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFmdGVyQWN0aW9uKGZ1bmMpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zdEFjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJlZ2lzdGVyZWQgYWZ0ZXJBY3Rpb24gbWlkZGxld2FyZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zdEFjdGlvbiA9IHJlc3VsdE9yUGF5bG9hZChmdW5jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGFjdGlvbiBieSBhY3Rpb24gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIChhc3luYyAoKT0+IHtcbiAgICAgKiAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNyZWF0ZSgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBhd2FpdCBwcm92aWRlci5yZWdpc3RlcigncHJvdmlkZXItYWN0aW9uJywgKHBheWxvYWQsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhwYXlsb2FkKTtcbiAgICAgKiAgICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICAgZWNobzogcGF5bG9hZFxuICAgICAqICAgICAgICAgfTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgcHJvdmlkZXIucmVtb3ZlKCdwcm92aWRlci1hY3Rpb24nKTtcbiAgICAgKlxuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVtb3ZlKGFjdGlvbikge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKGFjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGRlZmF1bHQgYWN0aW9uLiBUaGlzIGlzIHVzZWQgYW55IHRpbWUgYW4gYWN0aW9uIHRoYXQgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBDaGFubmVsIFByb3ZpZGVyOlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKCdjaGFubmVsTmFtZScpO1xuICAgICAqXG4gICAgICogICAgIGF3YWl0IHByb3ZpZGVyLnNldERlZmF1bHRBY3Rpb24oKGFjdGlvbiwgcGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGBDbGllbnQgd2l0aCBpZGVudGl0eSAke0pTT04uc3RyaW5naWZ5KGlkZW50aXR5KX0gaGFzIGF0dGVtcHRlZCB0byBkaXNwYXRjaCB1bnJlZ2lzdGVyZWQgYWN0aW9uOiAke2FjdGlvbn0uYCk7XG4gICAgICpcbiAgICAgKiAgICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICAgZWNobzogcGF5bG9hZFxuICAgICAqICAgICAgICAgfTtcbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQ2hhbm5lbCBDbGllbnQ6XG4gICAgICogYGBganNcbiAgICAgKiAoYXN5bmMgKCk9PiB7XG4gICAgICogICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY29ubmVjdCgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBhd2FpdCBjbGllbnQuc2V0RGVmYXVsdEFjdGlvbigoYWN0aW9uLCBwYXlsb2FkLCBpZGVudGl0eSkgPT4ge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coYFByb3ZpZGVyIHdpdGggaWRlbnRpdHkgJHtKU09OLnN0cmluZ2lmeShpZGVudGl0eSl9IGhhcyBhdHRlbXB0ZWQgdG8gZGlzcGF0Y2ggdW5yZWdpc3RlcmVkIGFjdGlvbjogJHthY3Rpb259LmApO1xuICAgICAqXG4gICAgICogICAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgICAgIGVjaG86IHBheWxvYWRcbiAgICAgKiAgICAgICAgIH07XG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqL1xuICAgIHNldERlZmF1bHRBY3Rpb24oZnVuYykge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHQgYWN0aW9uIGNhbiBvbmx5IGJlIHNldCBvbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBY3Rpb24gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGFjdGlvbiB0byBiZSBjYWxsZWQgYnkgZGlzcGF0Y2hpbmcgZnJvbSBhbnkgY2hhbm5lbENsaWVudCBvciBjaGFubmVsUHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9waWNcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBzZW50IGJhY2sgYXMgYW4gYWNrbm93bGVkZ2VtZW50IHRvIHRoZSBvcmlnaW5hbCBjYWxsZXIuIFlvdSBjYW4gdGhyb3cgYW5cbiAgICAgKiBlcnJvciB0byBzZW5kIGEgbmVnYXRpdmUtYWNrbm93bGVkZ2VtZW50IGFuZCB0aGUgZXJyb3Igd2lsbCByZWplY3QgdGhlIHByb21pc2UgcmV0dXJuZWQgdG8gdGhlIHNlbmRlciBieSB0aGVcbiAgICAgKiBkaXNwYXRjaCBjYWxsLiAgT25jZSBhIGxpc3RlbmVyIGlzIHJlZ2lzdGVyZWQgZm9yIGEgcGFydGljdWxhciBhY3Rpb24sIGl0IHN0YXlzIGluIHBsYWNlIHJlY2VpdmluZyBhbmQgcmVzcG9uZGluZ1xuICAgICAqIHRvIGluY29taW5nIG1lc3NhZ2VzIHVudGlsIGl0IGlzIHJlbW92ZWQuICBUaGlzIG1lc3NhZ2luZyBtZWNoYW5pc20gd29ya3MgZXhhY3RseSB0aGUgc2FtZSB3aGVuIG1lc3NhZ2VzIGFyZVxuICAgICAqIGRpc3BhdGNoZWQgZnJvbSB0aGUgcHJvdmlkZXIgdG8gYSBjbGllbnQuICBIb3dldmVyLCB0aGUgcHJvdmlkZXIgaGFzIGFuIGFkZGl0aW9uYWwgcHVibGlzaCBtZXRob2QgdGhhdCBzZW5kcyBtZXNzYWdlc1xuICAgICAqIHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEJlY2F1c2UgbXVsdGlwbGUgY2xpZW50cyBjYW4gc2hhcmUgdGhlIHNhbWUgYG5hbWVgIGFuZCBgdXVpZGAsIGluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW5kaXZpZHVhbCBjbGllbnRzLFxuICAgICAqIHRoZSBgaWRlbnRpdHlgIGFyZ3VtZW50IGluIGEgcHJvdmlkZXIncyByZWdpc3RlcmVkIGFjdGlvbiBjYWxsYmFjayBjb250YWlucyBhbiBgZW5kcG9pbnRJZGAgcHJvcGVydHkuIFdoZW4gZGlzcGF0Y2hpbmdcbiAgICAgKiBmcm9tIGEgcHJvdmlkZXIgdG8gYSBjbGllbnQsIHRoZSBgZW5kcG9pbnRJZGAgcHJvcGVydHkgbXVzdCBiZSBwcm92aWRlZCBpbiBvcmRlciB0byBzZW5kIGFuIGFjdGlvbiB0byBhIHNwZWNpZmljIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBDaGFubmVsIFByb3ZpZGVyOlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKCdjaGFubmVsTmFtZScpO1xuICAgICAqXG4gICAgICogICAgIGF3YWl0IHByb3ZpZGVyLnJlZ2lzdGVyKCdwcm92aWRlci1hY3Rpb24nLCAocGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coJ0FjdGlvbiBkaXNwYXRjaGVkIGJ5IGNsaWVudDogJywgaWRlbnRpdHkpO1xuICAgICAqICAgICAgICBjb25zb2xlLmxvZygnUGF5bG9hZCBzZW50IGluIGRpc3BhdGNoOiAnLCBwYXlsb2FkKTtcbiAgICAgKlxuICAgICAqICAgICAgICByZXR1cm4geyBlY2hvOiBwYXlsb2FkIH07XG4gICAgICogICAgfSk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIENoYW5uZWwgQ2xpZW50OlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNvbm5lY3QoJ2NoYW5uZWxOYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgY2xpZW50LnJlZ2lzdGVyKCdjbGllbnQtYWN0aW9uJywgKHBheWxvYWQsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKCdBY3Rpb24gZGlzcGF0Y2hlZCBieSBjbGllbnQ6ICcsIGlkZW50aXR5KTtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coJ1BheWxvYWQgc2VudCBpbiBkaXNwYXRjaDogJywgcGF5bG9hZCk7XG4gICAgICpcbiAgICAgKiAgICAgICAgcmV0dXJuIHsgZWNobzogcGF5bG9hZCB9O1xuICAgICAqICAgIH0pO1xuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVnaXN0ZXIodG9waWMsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMuaGFzKHRvcGljKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJzY3JpcHRpb24gYWxyZWFkeSByZWdpc3RlcmVkIGZvciBhY3Rpb246ICR7dG9waWN9LiBVbnN1YnNjcmliZSBiZWZvcmUgYWRkaW5nIG5ldyBzdWJzY3JpcHRpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQodG9waWMsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2hhbm5lbC5DaGFubmVsQmFzZSA9IENoYW5uZWxCYXNlO1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRkID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCRiID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfQ2hhbm5lbENsaWVudF9wcm90ZWN0ZWRPYmosIF9DaGFubmVsQ2xpZW50X3N0cmF0ZWd5LCBfQ2hhbm5lbENsaWVudF9jbG9zZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGllbnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xpZW50LkNoYW5uZWxDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsXzEkMSA9IGNoYW5uZWw7XG5jb25zdCBjaGFubmVsQ2xpZW50c0J5RW5kcG9pbnRJZCA9IG5ldyBNYXAoKTtcbi8qKlxuICogSW5zdGFuY2UgY3JlYXRlZCB0byBlbmFibGUgdXNlIG9mIGEgY2hhbm5lbCBhcyBhIGNsaWVudC4gIEFsbG93cyBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZVxuICoge0BsaW5rIENoYW5uZWxQcm92aWRlciBDaGFubmVsUHJvdmlkZXJ9IGJ5IGludm9raW5nIGFuIGFjdGlvbiBvbiB0aGVcbiAqIHByb3ZpZGVyIHZpYSB7QGxpbmsgQ2hhbm5lbENsaWVudCNkaXNwYXRjaCBkaXNwYXRjaH0gYW5kIHRvIGxpc3RlbiBmb3IgY29tbXVuaWNhdGlvblxuICogZnJvbSB0aGUgcHJvdmlkZXIgYnkgcmVnaXN0ZXJpbmcgYW4gYWN0aW9uIHZpYSB7QGxpbmsgQ2hhbm5lbENsaWVudCNyZWdpc3RlciByZWdpc3Rlcn0uXG4gKlxuICogIyMjIFN5bmNocm9ub3VzIE1ldGhvZHM6XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbENsaWVudCNvbkRpc2Nvbm5lY3Rpb24gb25EaXNjb25uZWN0aW9uKGxpc3RlbmVyKX1cbiAqICAqIHtAbGluayBDaGFubmVsQ2xpZW50I3JlZ2lzdGVyIHJlZ2lzdGVyKGFjdGlvbiwgbGlzdGVuZXIpfVxuICogICoge0BsaW5rIENoYW5uZWxDbGllbnQjcmVtb3ZlIHJlbW92ZShhY3Rpb24pfVxuICpcbiAqICMjIyBBc3luY2hyb25vdXMgTWV0aG9kczpcbiAqICAqIHtAbGluayBDaGFubmVsQ2xpZW50I2Rpc2Nvbm5lY3QgZGlzY29ubmVjdCgpfVxuICogICoge0BsaW5rIENoYW5uZWxDbGllbnQjZGlzcGF0Y2ggZGlzcGF0Y2goYWN0aW9uLCBwYXlsb2FkKX1cbiAqXG4gKiAjIyMgTWlkZGxld2FyZTpcbiAqIE1pZGRsZXdhcmUgZnVuY3Rpb25zIHJlY2VpdmUgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6IChhY3Rpb24sIHBheWxvYWQsIHNlbmRlcklkKS5cbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgb24gYXMgdGhlIHBheWxvYWQgZnJvbSBiZWZvcmVBY3Rpb24sIHRvIHRoZSBhY3Rpb24gbGlzdGVuZXIsIHRvIGFmdGVyQWN0aW9uXG4gKiB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIHRoZSBvcmlnaW5hbCBwYXlsb2FkIGlzIHVzZWQuICBNaWRkbGV3YXJlIGNhbiBiZSB1c2VkIGZvciBzaWRlIGVmZmVjdHMuXG4gKiAgKiB7QGxpbmsgQ2hhbm5lbENsaWVudCNzZXREZWZhdWx0QWN0aW9uIHNldERlZmF1bHRBY3Rpb24obWlkZGxld2FyZSl9XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbENsaWVudCNvbkVycm9yIG9uRXJyb3IobWlkZGxld2FyZSl9XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbENsaWVudCNiZWZvcmVBY3Rpb24gYmVmb3JlQWN0aW9uKG1pZGRsZXdhcmUpfVxuICogICoge0BsaW5rIENoYW5uZWxDbGllbnQjYWZ0ZXJBY3Rpb24gYWZ0ZXJBY3Rpb24obWlkZGxld2FyZSl9XG4gKi9cbmNsYXNzIENoYW5uZWxDbGllbnQgZXh0ZW5kcyBjaGFubmVsXzEkMS5DaGFubmVsQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGNsb3NlQ2hhbm5lbEJ5RW5kcG9pbnRJZChpZCkge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbENsaWVudHNCeUVuZHBvaW50SWQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZChjaGFubmVsLCBfQ2hhbm5lbENsaWVudF9jbG9zZSwgXCJmXCIpLmNhbGwoY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogY2xvc2VzIHRoZSBjb3JyZXNwb25kaW5nIGNoYW5uZWwgYW5kIGludm9rZXMgdGhlIGRpc2Nvbm5lY3QgbGlzdGVuZXIgaWYgYW4gZXZlbnQgcGF5bG9hZCBpcyBwYXNzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGhhbmRsZVByb3ZpZGVyRGlzY29ubmVjdChldmVudFBheWxvYWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsQ2xpZW50IG9mIGNoYW5uZWxDbGllbnRzQnlFbmRwb2ludElkLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbENsaWVudC5wcm92aWRlcklkZW50aXR5LmNoYW5uZWxJZCA9PT0gZXZlbnRQYXlsb2FkLmNoYW5uZWxJZCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxDbGllbnQuZGlzY29ubmVjdExpc3RlbmVyKGV2ZW50UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRkKGNoYW5uZWxDbGllbnQsIF9DaGFubmVsQ2xpZW50X2Nsb3NlLCBcImZcIikuY2FsbChjaGFubmVsQ2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb3V0aW5nSW5mbywgd2lyZSwgc3RyYXRlZ3kpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX0NoYW5uZWxDbGllbnRfcHJvdGVjdGVkT2JqLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ2hhbm5lbENsaWVudF9zdHJhdGVneS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgYm91bmQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc0FjdGlvbiA9IChhY3Rpb24sIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KSA9PiBzdXBlci5wcm9jZXNzQWN0aW9uKGFjdGlvbiwgcGF5bG9hZCwgc2VuZGVySWRlbnRpdHkpO1xuICAgICAgICBfQ2hhbm5lbENsaWVudF9jbG9zZS5zZXQodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgY2hhbm5lbENsaWVudHNCeUVuZHBvaW50SWQuZGVsZXRlKHRoaXMuZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGQodGhpcywgX0NoYW5uZWxDbGllbnRfc3RyYXRlZ3ksIFwiZlwiKS5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCRiKHRoaXMsIF9DaGFubmVsQ2xpZW50X3Byb3RlY3RlZE9iaiwgbmV3IGNoYW5uZWxfMSQxLlByb3RlY3RlZEl0ZW1zKHJvdXRpbmdJbmZvLCB3aXJlKSwgXCJmXCIpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lciA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbmRwb2ludElkID0gcm91dGluZ0luZm8uZW5kcG9pbnRJZDtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCRiKHRoaXMsIF9DaGFubmVsQ2xpZW50X3N0cmF0ZWd5LCBzdHJhdGVneSwgXCJmXCIpO1xuICAgICAgICBjaGFubmVsQ2xpZW50c0J5RW5kcG9pbnRJZC5zZXQodGhpcy5lbmRwb2ludElkLCB0aGlzKTtcbiAgICAgICAgc3RyYXRlZ3kucmVjZWl2ZSh0aGlzLnByb2Nlc3NBY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhIHJlYWQtb25seSBwcm92aWRlciBpZGVudGl0eVxuICAgICAqL1xuICAgIGdldCBwcm92aWRlcklkZW50aXR5KCkge1xuICAgICAgICBjb25zdCBwcm90ZWN0ZWRPYmogPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGQodGhpcywgX0NoYW5uZWxDbGllbnRfcHJvdGVjdGVkT2JqLCBcImZcIik7XG4gICAgICAgIHJldHVybiBwcm90ZWN0ZWRPYmoucHJvdmlkZXJJZGVudGl0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggdGhlIGdpdmVuIGFjdGlvbiB0byB0aGUgY2hhbm5lbCBwcm92aWRlci4gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBmcm9tXG4gICAgICogdGhlIHByb3ZpZGVyIGZvciB0aGF0IGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25cbiAgICAgKiBAcGFyYW0gcGF5bG9hZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNvbm5lY3QoJ2NoYW5uZWxOYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgY2xpZW50LnJlZ2lzdGVyKCdjbGllbnQtYWN0aW9uJywgKHBheWxvYWQsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhwYXlsb2FkLCBpZGVudGl0eSk7XG4gICAgICogICAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgICAgIGVjaG86IHBheWxvYWRcbiAgICAgKiAgICAgICAgIH07XG4gICAgICogICAgIH0pO1xuICAgICAqXG4gICAgICogICAgIGNvbnN0IHByb3ZpZGVyUmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ3Byb3ZpZGVyLWFjdGlvbicsIHsgbWVzc2FnZTogJ0hlbGxvIEZyb20gdGhlIGNsaWVudCd9KTtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocHJvdmlkZXJSZXNwb25zZSk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkaXNwYXRjaChhY3Rpb24sIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkZCh0aGlzLCBfQ2hhbm5lbENsaWVudF9zdHJhdGVneSwgXCJmXCIpLmlzRW5kcG9pbnRDb25uZWN0ZWQodGhpcy5wcm92aWRlcklkZW50aXR5LmNoYW5uZWxJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGQodGhpcywgX0NoYW5uZWxDbGllbnRfc3RyYXRlZ3ksIFwiZlwiKS5zZW5kKHRoaXMucHJvdmlkZXJJZGVudGl0eS5jaGFubmVsSWQsIGFjdGlvbiwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2xpZW50IHlvdSBhcmUgdHJ5aW5nIHRvIGRpc3BhdGNoIGZyb20gaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHRhcmdldCBwcm92aWRlci4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciB0aGF0IGlzIGNhbGxlZCBvbiBwcm92aWRlciBkaXNjb25uZWN0aW9uLiBJdCBpcyBwYXNzZWQgdGhlIGRpc2Nvbm5lY3Rpb24gZXZlbnQgb2YgdGhlXG4gICAgICogZGlzY29ubmVjdGluZyBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNvbm5lY3QoJ2NoYW5uZWxOYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgYXdhaXQgY2xpZW50Lm9uRGlzY29ubmVjdGlvbihldnQgPT4ge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coJ1Byb3ZpZGVyIGRpc2Nvbm5lY3RlZCcsIGB1dWlkOiAke2V2dC51dWlkfSwgbmFtZTogJHtldnQubmFtZX1gKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvbkRpc2Nvbm5lY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXIgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGNhbGxpbmcgdGhlIG9uRGlzY29ubmVjdGlvbiBjYWxsYmFjazogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgY2xpZW50IGZyb20gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAoYXN5bmMgKCk9PiB7XG4gICAgICogICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY29ubmVjdCgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBhd2FpdCBjbGllbnQuZGlzY29ubmVjdCgpO1xuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRGlzY29ubmVjdEFjdGlvbigpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGQodGhpcywgX0NoYW5uZWxDbGllbnRfY2xvc2UsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGlzY29ubmVjdEFjdGlvbigpIHtcbiAgICAgICAgY29uc3QgcHJvdGVjdGVkT2JqID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCRkKHRoaXMsIF9DaGFubmVsQ2xpZW50X3Byb3RlY3RlZE9iaiwgXCJmXCIpO1xuICAgICAgICBjb25zdCB7IGNoYW5uZWxOYW1lLCB1dWlkLCBuYW1lIH0gPSBwcm90ZWN0ZWRPYmoucHJvdmlkZXJJZGVudGl0eTtcbiAgICAgICAgYXdhaXQgcHJvdGVjdGVkT2JqLndpcmUuc2VuZEFjdGlvbignZGlzY29ubmVjdC1mcm9tLWNoYW5uZWwnLCB7XG4gICAgICAgICAgICBjaGFubmVsTmFtZSxcbiAgICAgICAgICAgIHV1aWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZW5kcG9pbnRJZDogdGhpcy5lbmRwb2ludElkXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsaWVudC5DaGFubmVsQ2xpZW50ID0gQ2hhbm5lbENsaWVudDtcbl9DaGFubmVsQ2xpZW50X3Byb3RlY3RlZE9iaiA9IG5ldyBXZWFrTWFwKCksIF9DaGFubmVsQ2xpZW50X3N0cmF0ZWd5ID0gbmV3IFdlYWtNYXAoKSwgX0NoYW5uZWxDbGllbnRfY2xvc2UgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB7fTtcblxudmFyIGV4aGF1c3RpdmUgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4aGF1c3RpdmUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhoYXVzdGl2ZS5leGhhdXN0aXZlQ2hlY2sgPSB2b2lkIDA7XG5mdW5jdGlvbiBleGhhdXN0aXZlQ2hlY2sodmFsdWUsIGFsbG93ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlOiAke3ZhbHVlfSR7YWxsb3dlZCA/IGBcXG4gU3VwcG9ydGVkIHZhbHVlcyBhcmU6ICR7YWxsb3dlZC5qb2luKCcnKX1gIDogJyd9YCk7XG59XG5leGhhdXN0aXZlLmV4aGF1c3RpdmVDaGVjayA9IGV4aGF1c3RpdmVDaGVjaztcblxudmFyIHN0cmF0ZWd5JDIgPSB7fTtcblxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkYSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRjID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NsYXNzaWNTdHJhdGVneV93aXJlLCBfQ2xhc3NpY1N0cmF0ZWd5X2VuZHBvaW50SWRlbnRpdHlNYXAsIF9DbGFzc2ljU3RyYXRlZ3lfcGVuZGluZ01lc3NhZ2VzQnlFbmRwb2ludElkO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0cmF0ZWd5JDIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuc3RyYXRlZ3kkMi5DbGFzc2ljSW5mbyA9IHN0cmF0ZWd5JDIuQ2xhc3NpY1N0cmF0ZWd5ID0gdm9pZCAwO1xuLypcblRoaXMgaXMgdXNlZCB0byBhYnN0cmFjdCBvdXQgaXBjIG1lc3NhZ2luZyBmcm9tIHRoZSBjaGFubmVscyBpbXBsZW1lbnRhdGlvbi4gSXQgaXMgb25seSBjb25jZXJuZWQgd2l0aCBzZW5kaW5nIG1lc3NhZ2VzIGFuZCByZWdpc3RyYXRpb24gd2l0aCB0aGUgTWVzc2FnZVJlY2VpdmVyXG4qL1xuY2xhc3MgQ2xhc3NpY1N0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlLCBtZXNzYWdlUmVjZWl2ZXIsIGVuZHBvaW50SWQsIC8vIFByb3ZpZGVyIGVuZHBvaW50SWQgaXMgY2hhbm5lbElkXG4gICAgcHJvdmlkZXJJZGVudGl0eSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VSZWNlaXZlciA9IG1lc3NhZ2VSZWNlaXZlcjtcbiAgICAgICAgdGhpcy5lbmRwb2ludElkID0gZW5kcG9pbnRJZDtcbiAgICAgICAgdGhpcy5wcm92aWRlcklkZW50aXR5ID0gcHJvdmlkZXJJZGVudGl0eTtcbiAgICAgICAgX0NsYXNzaWNTdHJhdGVneV93aXJlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvLyBTdG9yZSBmdWxsIGVuZHBvaW50SWRlbnRpdHkgYnkgZW5kcG9pbnRJZCBvZiBhbGwga25vd24gZW5kcG9pbnRzIGZvciB0aGlzIHN0cmF0ZWd5IGluc3RhbmNlLlxuICAgICAgICAvLyAoY2xpZW50cyB3aWxsIG9ubHkgaGF2ZSAxOiB0aGUgcHJvdmlkZXIsIHRoZSBwcm92aWRlciB3aWxsIGhhdmUgYWxsIGNsaWVudHMpXG4gICAgICAgIF9DbGFzc2ljU3RyYXRlZ3lfZW5kcG9pbnRJZGVudGl0eU1hcC5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgLy8gU3RvcmUgYSBzZXQgb2YgY2FuY2VsbGFibGUgcHJvbWlzZXMgdG8gYmUgYWJsZSB0byByZWplY3QgdGhlbSB3aGVuIGNsaWVudFxuICAgICAgICAvLyBjb25uZWN0aW9uIHByb2JsZW1zIG9jY3VyXG4gICAgICAgIF9DbGFzc2ljU3RyYXRlZ3lfcGVuZGluZ01lc3NhZ2VzQnlFbmRwb2ludElkLnNldCh0aGlzLCBuZXcgTWFwKTtcbiAgICAgICAgdGhpcy5zZW5kID0gYXN5bmMgKGVuZHBvaW50SWQsIGFjdGlvbiwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG8gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGModGhpcywgX0NsYXNzaWNTdHJhdGVneV9lbmRwb2ludElkZW50aXR5TWFwLCBcImZcIikuZ2V0KGVuZHBvaW50SWQpO1xuICAgICAgICAgICAgaWYgKCF0bykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGxvY2F0ZSByb3V0aW5nIGluZm8gZm9yIGVuZHBvaW50ICR7ZW5kcG9pbnRJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzIGNhc3RpbmcgdG8gYW55IGJlY2F1c2UgdHlwZXNjcmlwdCBjb21wbGFpbnMuIFRoZSBmb2xsb3dpbmcgaXMgb25seSByZWxldmFudCBpZiB0aGlzIGlzIGEgbG9jYWxseSBzZXQgZW5kcG9pbnRJZCBvbiBhIENsaWVudElkZW50aXR5LlxuICAgICAgICAgICAgLy8gV2UgZGVsZXRlIHRoZXNlIHByb3BlcnRpZXMgdG8gbm90IGNoYW5nZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgIGNvbnN0IGNsZWFuSWQgPSB7IC4uLnRvIH07XG4gICAgICAgICAgICBpZiAoY2xlYW5JZC5pc0xvY2FsRW5kcG9pbnRJZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjbGVhbklkLmVuZHBvaW50SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgY2xlYW5JZC5pc0xvY2FsRW5kcG9pbnRJZDtcbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIHByb21pc2UgYmVmb3JlIGF3YWl0aW5nIGl0IHRvIHNhdmUgaW4gb3VyIHBlbmRpbmcgbWVzc2FnZXMgbWFwXG4gICAgICAgICAgICBjb25zdCBwID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCRjKHRoaXMsIF9DbGFzc2ljU3RyYXRlZ3lfd2lyZSwgXCJmXCIpXG4gICAgICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3NlbmQtY2hhbm5lbC1tZXNzYWdlJywge1xuICAgICAgICAgICAgICAgIC4uLmNsZWFuSWQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJJZGVudGl0eTogdGhpcy5wcm92aWRlcklkZW50aXR5LFxuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYyh0aGlzLCBfQ2xhc3NpY1N0cmF0ZWd5X3BlbmRpbmdNZXNzYWdlc0J5RW5kcG9pbnRJZCwgXCJmXCIpLmdldChlbmRwb2ludElkKT8uYWRkKHApO1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gYXdhaXQgcC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCB0aGUgcGVuZGluZyBwcm9taXNlXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRjKHRoaXMsIF9DbGFzc2ljU3RyYXRlZ3lfcGVuZGluZ01lc3NhZ2VzQnlFbmRwb2ludElkLCBcImZcIikuZ2V0KGVuZHBvaW50SWQpPy5kZWxldGUocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByYXcucGF5bG9hZC5kYXRhLnJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVJlY2VpdmVyLnJlbW92ZUVuZHBvaW50KHRoaXMucHJvdmlkZXJJZGVudGl0eS5jaGFubmVsSWQsIHRoaXMuZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICBbLi4uX19jbGFzc1ByaXZhdGVGaWVsZEdldCRjKHRoaXMsIF9DbGFzc2ljU3RyYXRlZ3lfZW5kcG9pbnRJZGVudGl0eU1hcCwgXCJmXCIpLmtleXMoKV0uZm9yRWFjaCgoaWQpID0+IHRoaXMuY2xvc2VFbmRwb2ludChpZCkpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCRhKHRoaXMsIF9DbGFzc2ljU3RyYXRlZ3lfZW5kcG9pbnRJZGVudGl0eU1hcCwgbmV3IE1hcCgpLCBcImZcIik7XG4gICAgICAgIH07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkYSh0aGlzLCBfQ2xhc3NpY1N0cmF0ZWd5X3dpcmUsIHdpcmUsIFwiZlwiKTtcbiAgICB9XG4gICAgb25FbmRwb2ludERpc2Nvbm5lY3QoZW5kcG9pbnRJZCwgbGlzdGVuZXIpIHtcbiAgICAgICAgLy8gTmV2ZXIgZmlyZXMgZm9yICdjbGFzc2ljJy5cbiAgICB9XG4gICAgcmVjZWl2ZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2VSZWNlaXZlci5hZGRFbmRwb2ludChsaXN0ZW5lciwgdGhpcy5wcm92aWRlcklkZW50aXR5LmNoYW5uZWxJZCwgdGhpcy5lbmRwb2ludElkKTtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2VFbmRwb2ludChlbmRwb2ludElkKSB7XG4gICAgICAgIGNvbnN0IGlkID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCRjKHRoaXMsIF9DbGFzc2ljU3RyYXRlZ3lfZW5kcG9pbnRJZGVudGl0eU1hcCwgXCJmXCIpLmdldChlbmRwb2ludElkKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRjKHRoaXMsIF9DbGFzc2ljU3RyYXRlZ3lfZW5kcG9pbnRJZGVudGl0eU1hcCwgXCJmXCIpLmRlbGV0ZShlbmRwb2ludElkKTtcbiAgICAgICAgY29uc3QgcGVuZGluZ1NldCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYyh0aGlzLCBfQ2xhc3NpY1N0cmF0ZWd5X3BlbmRpbmdNZXNzYWdlc0J5RW5kcG9pbnRJZCwgXCJmXCIpLmdldChlbmRwb2ludElkKTtcbiAgICAgICAgcGVuZGluZ1NldD8uZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBgQ2hhbm5lbCBjb25uZWN0aW9uIHdpdGggaWRlbnRpdHkgdXVpZDogJHtpZD8udXVpZH0gLyBuYW1lOiAke2lkPy5uYW1lfSAvIGVuZHBvaW50SWQ6ICR7ZW5kcG9pbnRJZH0gbm8gbG9uZ2VyIGNvbm5lY3RlZC5gO1xuICAgICAgICAgICAgcC5jYW5jZWwobmV3IEVycm9yKGVycm9yTXNnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0VuZHBvaW50Q29ubmVjdGVkKGVuZHBvaW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYyh0aGlzLCBfQ2xhc3NpY1N0cmF0ZWd5X2VuZHBvaW50SWRlbnRpdHlNYXAsIFwiZlwiKS5oYXMoZW5kcG9pbnRJZCk7XG4gICAgfVxuICAgIGFkZEVuZHBvaW50KGVuZHBvaW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRjKHRoaXMsIF9DbGFzc2ljU3RyYXRlZ3lfZW5kcG9pbnRJZGVudGl0eU1hcCwgXCJmXCIpLnNldChlbmRwb2ludElkLCBwYXlsb2FkLmVuZHBvaW50SWRlbnRpdHkpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGModGhpcywgX0NsYXNzaWNTdHJhdGVneV9wZW5kaW5nTWVzc2FnZXNCeUVuZHBvaW50SWQsIFwiZlwiKS5zZXQoZW5kcG9pbnRJZCwgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgaXNWYWxpZEVuZHBvaW50UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHBheWxvYWQ/LmVuZHBvaW50SWRlbnRpdHk/LmVuZHBvaW50SWQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgcGF5bG9hZD8uZW5kcG9pbnRJZGVudGl0eT8uY2hhbm5lbElkID09PSAnc3RyaW5nJyk7XG4gICAgfVxufVxuc3RyYXRlZ3kkMi5DbGFzc2ljU3RyYXRlZ3kgPSBDbGFzc2ljU3RyYXRlZ3k7XG5fQ2xhc3NpY1N0cmF0ZWd5X3dpcmUgPSBuZXcgV2Vha01hcCgpLCBfQ2xhc3NpY1N0cmF0ZWd5X2VuZHBvaW50SWRlbnRpdHlNYXAgPSBuZXcgV2Vha01hcCgpLCBfQ2xhc3NpY1N0cmF0ZWd5X3BlbmRpbmdNZXNzYWdlc0J5RW5kcG9pbnRJZCA9IG5ldyBXZWFrTWFwKCk7XG4vLyBBcmJpdHJhcmlseSBzdGFydGluZyBhdCA1IHRvIGxlYXZlIHRoZSBkb29yIG9wZW4gdG8gYmFja2ZpbGxpbmcgcHJlIGVuZHBvaW50SWQgZXRjLlxuc3RyYXRlZ3kkMi5DbGFzc2ljSW5mbyA9IHsgdmVyc2lvbjogNSwgbWluaW11bVZlcnNpb246IDAsIHR5cGU6ICdjbGFzc2ljJyB9O1xuXG52YXIgc3RyYXRlZ3kkMSA9IHt9O1xuXG52YXIgZW5kcG9pbnQgPSB7fTtcblxudmFyIGVycm9ycyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmVycm9ycy5lcnJvclRvUE9KTyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVycm9yVG9QT0pPKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAvLyBzdXBwb3J0IHRoZSBjYXNlIHdoZXJlIHN0YWNrIGlzIGVtcHR5IG9yIG1pc3NpbmdcbiAgICAgICAgdG9TdHJpbmc6ICgpID0+IGVycm9yLnN0YWNrIHx8IGVycm9yLnRvU3RyaW5nKClcbiAgICB9O1xufVxuZXJyb3JzLmVycm9yVG9QT0pPID0gZXJyb3JUb1BPSk87XG5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDkgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9SVENFbmRwb2ludF9wcm9jZXNzQWN0aW9uLCBfUlRDRW5kcG9pbnRfZGlzY29ubmVjdExpc3RlbmVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGVuZHBvaW50LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmVuZHBvaW50LlJUQ0VuZHBvaW50ID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5jb25zdCBlcnJvcnNfMSQxID0gZXJyb3JzO1xuLypcblRoaXMgaGFuZGxlcyBzZW5kaW5nIFJUQyBtZXNzYWdlcyBiZXR3ZWVuIFJUQyBjb25uZWN0aW9ucyBvdmVyIHRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBkYXRhIGNoYW5uZWxzLlxuKi9cbmNsYXNzIFJUQ0VuZHBvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihydGMsIGVuZHBvaW50SWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy5ydGMgPSBydGM7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRJZGVudGl0eSA9IGVuZHBvaW50SWRlbnRpdHk7XG4gICAgICAgIHRoaXMucmVzcG9uc2VNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIF9SVENFbmRwb2ludF9wcm9jZXNzQWN0aW9uLnNldCh0aGlzLCBudWxsKTtcbiAgICAgICAgX1JUQ0VuZHBvaW50X2Rpc2Nvbm5lY3RMaXN0ZW5lci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGVDaGFuZ2VIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5ydGMucnRjQ2xpZW50LmNvbm5lY3Rpb25TdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ0Yy5ydGNDbGllbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5jb25uZWN0aW9uU3RhdGVDaGFuZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYih0aGlzLCBfUlRDRW5kcG9pbnRfZGlzY29ubmVjdExpc3RlbmVyLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRiKHRoaXMsIF9SVENFbmRwb2ludF9kaXNjb25uZWN0TGlzdGVuZXIsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kID0gYXN5bmMgKGFjdGlvbiwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gYG1lc3NhZ2UtJHtNYXRoLnJhbmRvbSgpfWA7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VNYXAuc2V0KG1lc3NhZ2VJZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucnRjLmNoYW5uZWxzLnJlcXVlc3Quc2VuZChKU09OLnN0cmluZ2lmeSh7IGFjdGlvbiwgcGF5bG9hZCwgbWVzc2FnZUlkIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZU1hcC5mb3JFYWNoKChyZXNwb25zZSkgPT4gcmVzcG9uc2UucmVqZWN0KCdDb25uZWN0aW9uIGhhcyBjbG9zZWQuJykpO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMucnRjLmNoYW5uZWxzLnJlcXVlc3QuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucnRjLmNoYW5uZWxzLnJlc3BvbnNlLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnJ0Yy5ydGNDbGllbnQuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydGMuY2hhbm5lbHMucmVzcG9uc2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkYXRhIH0gPSBlO1xuICAgICAgICAgICAgaWYgKGUuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBtZXNzYWdlSWQsIHBheWxvYWQsIHN1Y2Nlc3MsIGVycm9yIH0gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMucmVzcG9uc2VNYXAuZ2V0KG1lc3NhZ2VJZCkgPz8ge307XG4gICAgICAgICAgICBpZiAocmVzb2x2ZSAmJiByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlTWFwLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZmluZCBpZCBpbiByZXNwb25zZU1hcC4nKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnRjLmNoYW5uZWxzLnJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkYXRhIH0gPSBlO1xuICAgICAgICAgICAgaWYgKGUuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBtZXNzYWdlSWQsIGFjdGlvbiwgcGF5bG9hZCB9ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGIodGhpcywgX1JUQ0VuZHBvaW50X3Byb2Nlc3NBY3Rpb24sIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYih0aGlzLCBfUlRDRW5kcG9pbnRfcHJvY2Vzc0FjdGlvbiwgXCJmXCIpLmNhbGwodGhpcywgYWN0aW9uLCBwYXlsb2FkLCBlbmRwb2ludElkZW50aXR5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydGMuY2hhbm5lbHMucmVzcG9uc2Uuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiByZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIFJUQ0RhdGFDaGFubmVsIGlzIG9wZW4gYmVmb3JlIHNlbmRpbmcsIGVycm9yIGdldHMgc3dhbGxvd2VkIGhlcmUgaW4gdGhlIGNhc2Ugd2hlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50IGRpc3BhdGNoZWQgdGhlbiBjbG9zZWQgb3IgZGlzY29ubmVjdGVkIGJlZm9yZSB0aGUgZGlzcGF0Y2ggcmVzb2x2ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJ0Yy5jaGFubmVscy5yZXNwb25zZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnRjLmNoYW5uZWxzLnJlc3BvbnNlLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yc18xJDEuZXJyb3JUb1BPSk8pKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIFJUQ0RhdGFDaGFubmVsIGlzIG9wZW4gZm9yIHNhbWUgcmVhc29uIGFzIGNhdGNoIGJsb2NrIGFib3ZlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5ydGMuY2hhbm5lbHMucmVzcG9uc2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydGMuY2hhbm5lbHMucmVzcG9uc2Uuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAnQ29ubmVjdGlvbiBub3QgcmVhZHkuJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnRjLnJ0Y0NsaWVudC5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLmNvbm5lY3Rpb25TdGF0ZUNoYW5nZUhhbmRsZXIpO1xuICAgICAgICAvLyBEaXNjb25uZWN0IGlmIGRhdGEgY2hhbm5lbHMgY2xvc2UgdW5leHBlY3RlZGx5LCBlLmcuIGNhbiBoYXBwZW4gZHVlIHRvIG1lc3NhZ2Ugc2l6ZSA+IH4yNTVrQiAoUlRDUGVlckNvbm5lY3Rpb24uc2N0cC5tYXhNZXNzYWdlU2l6ZUxpbWl0OiAyNjIxNDQpXG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5ydGMuY2hhbm5lbHMpLmZvckVhY2goKGRhdGFjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICBkYXRhY2hhbm5lbC5vbmNsb3NlID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBbLi4udGhpcy5yZXNwb25zZU1hcC52YWx1ZXMoKV0uZm9yRWFjaCgocHJvbWlzZSkgPT4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdSVENEYXRhQ2hhbm5lbCBjbG9zZWQgdW5leHBlY3RlZGx5LCB0aGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5IG1lc3NhZ2Ugc2l6ZS4gTm90ZTogUlRDIENoYW5uZWxzIGhhdmUgYSBtZXNzYWdlIHNpemUgbGltaXQgb2YgfjI1NWtCLicpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGIodGhpcywgX1JUQ0VuZHBvaW50X2Rpc2Nvbm5lY3RMaXN0ZW5lciwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYih0aGlzLCBfUlRDRW5kcG9pbnRfZGlzY29ubmVjdExpc3RlbmVyLCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25EaXNjb25uZWN0KGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCRiKHRoaXMsIF9SVENFbmRwb2ludF9kaXNjb25uZWN0TGlzdGVuZXIsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ5KHRoaXMsIF9SVENFbmRwb2ludF9kaXNjb25uZWN0TGlzdGVuZXIsIGxpc3RlbmVyLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ0VuZHBvaW50IGRpc2Nvbm5lY3RMaXN0ZW5lciBjYW5ub3QgYmUgc2V0IHR3aWNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY2VpdmUobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYih0aGlzLCBfUlRDRW5kcG9pbnRfcHJvY2Vzc0FjdGlvbiwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgc2V0IGEgbGlzdGVuZXIgZm9yIHRoaXMgUlRDIEVuZHBvaW50LicpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkOSh0aGlzLCBfUlRDRW5kcG9pbnRfcHJvY2Vzc0FjdGlvbiwgbGlzdGVuZXIsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnRjLnJ0Y0NsaWVudC5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuICAgIH1cbn1cbmVuZHBvaW50LlJUQ0VuZHBvaW50ID0gUlRDRW5kcG9pbnQ7XG5fUlRDRW5kcG9pbnRfcHJvY2Vzc0FjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9SVENFbmRwb2ludF9kaXNjb25uZWN0TGlzdGVuZXIgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRhID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ4ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfUlRDU3RyYXRlZ3lfcHJvY2Vzc0FjdGlvbiwgX1JUQ1N0cmF0ZWd5X3J0Y0VuZHBvaW50TWFwLCBfUlRDU3RyYXRlZ3lfY29ubmVjdGVkO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0cmF0ZWd5JDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuc3RyYXRlZ3kkMS5SVENJbmZvID0gc3RyYXRlZ3kkMS5SVENTdHJhdGVneSA9IHZvaWQgMDtcbmNvbnN0IGVuZHBvaW50XzEgPSBlbmRwb2ludDtcbi8qXG5UaGlzIGlzIHVzZWQgdG8gYWJzdHJhY3Qgb3V0IHJ0YyBtZXNzYWdpbmcgZnJvbSB0aGUgY2hhbm5lbHMgaW1wbGVtZW50YXRpb24gdXNpbmcgUlRDRW5kcG9pbnRzLlxuKi9cbmNsYXNzIFJUQ1N0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgX1JUQ1N0cmF0ZWd5X3Byb2Nlc3NBY3Rpb24uc2V0KHRoaXMsIG51bGwpO1xuICAgICAgICBfUlRDU3RyYXRlZ3lfcnRjRW5kcG9pbnRNYXAuc2V0KHRoaXMsIG5ldyBNYXAoKSk7XG4gICAgICAgIF9SVENTdHJhdGVneV9jb25uZWN0ZWQuc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICB0aGlzLnNlbmQgPSBhc3luYyAoZW5kcG9pbnRJZCwgYWN0aW9uLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmRwb2ludEJ5SWQoZW5kcG9pbnRJZCkuc2VuZChhY3Rpb24sIHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsb3NlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYSh0aGlzLCBfUlRDU3RyYXRlZ3lfY29ubmVjdGVkLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGEodGhpcywgX1JUQ1N0cmF0ZWd5X3J0Y0VuZHBvaW50TWFwLCBcImZcIikuZm9yRWFjaCgocnRjRW5kcG9pbnQpID0+IHJ0Y0VuZHBvaW50LmNsb3NlKCkpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkOCh0aGlzLCBfUlRDU3RyYXRlZ3lfcnRjRW5kcG9pbnRNYXAsIG5ldyBNYXAoKSwgXCJmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ4KHRoaXMsIF9SVENTdHJhdGVneV9jb25uZWN0ZWQsIGZhbHNlLCBcImZcIik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uRW5kcG9pbnREaXNjb25uZWN0KGVuZHBvaW50SWQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZ2V0RW5kcG9pbnRCeUlkKGVuZHBvaW50SWQpLm9uRGlzY29ubmVjdChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlY2VpdmUobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYSh0aGlzLCBfUlRDU3RyYXRlZ3lfcHJvY2Vzc0FjdGlvbiwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgc2V0IGEgbGlzdGVuZXIgZm9yIHRoaXMgUlRDIFN0cmF0ZWd5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ4KHRoaXMsIF9SVENTdHJhdGVneV9wcm9jZXNzQWN0aW9uLCBsaXN0ZW5lciwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGEodGhpcywgX1JUQ1N0cmF0ZWd5X3J0Y0VuZHBvaW50TWFwLCBcImZcIikuZm9yRWFjaCgocnRjRW5kcG9pbnQpID0+IHJ0Y0VuZHBvaW50LnJlY2VpdmUoX19jbGFzc1ByaXZhdGVGaWVsZEdldCRhKHRoaXMsIF9SVENTdHJhdGVneV9wcm9jZXNzQWN0aW9uLCBcImZcIikpKTtcbiAgICB9XG4gICAgZ2V0RW5kcG9pbnRCeUlkKGVuZHBvaW50SWQpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JGEodGhpcywgX1JUQ1N0cmF0ZWd5X3J0Y0VuZHBvaW50TWFwLCBcImZcIikuZ2V0KGVuZHBvaW50SWQpO1xuICAgICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCB3aXRoIGVuZHBvaW50IGlkICR7ZW5kcG9pbnRJZH0gaXMgbm90IGNvbm5lY3RlZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmRwb2ludDtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYSh0aGlzLCBfUlRDU3RyYXRlZ3lfY29ubmVjdGVkLCBcImZcIik7XG4gICAgfVxuICAgIGlzRW5kcG9pbnRDb25uZWN0ZWQoZW5kcG9pbnRJZCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCRhKHRoaXMsIF9SVENTdHJhdGVneV9ydGNFbmRwb2ludE1hcCwgXCJmXCIpLmhhcyhlbmRwb2ludElkKTtcbiAgICB9XG4gICAgYWRkRW5kcG9pbnQoZW5kcG9pbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQkYSh0aGlzLCBfUlRDU3RyYXRlZ3lfY29ubmVjdGVkLCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQWRkaW5nIGVuZHBvaW50IHRvIGRpc2Nvbm5lY3RlZCBSVEMgU3RyYXRlZ3knKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRTdHJhdCA9IG5ldyBlbmRwb2ludF8xLlJUQ0VuZHBvaW50KHBheWxvYWQucnRjLCBwYXlsb2FkLmVuZHBvaW50SWRlbnRpdHkpO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCRhKHRoaXMsIF9SVENTdHJhdGVneV9wcm9jZXNzQWN0aW9uLCBcImZcIikpIHtcbiAgICAgICAgICAgIGNsaWVudFN0cmF0LnJlY2VpdmUoX19jbGFzc1ByaXZhdGVGaWVsZEdldCRhKHRoaXMsIF9SVENTdHJhdGVneV9wcm9jZXNzQWN0aW9uLCBcImZcIikpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkYSh0aGlzLCBfUlRDU3RyYXRlZ3lfcnRjRW5kcG9pbnRNYXAsIFwiZlwiKS5zZXQoZW5kcG9pbnRJZCwgY2xpZW50U3RyYXQpO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZUVuZHBvaW50KGVuZHBvaW50SWQpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCRhKHRoaXMsIF9SVENTdHJhdGVneV9ydGNFbmRwb2ludE1hcCwgXCJmXCIpLmRlbGV0ZShlbmRwb2ludElkKTtcbiAgICB9XG4gICAgaXNWYWxpZEVuZHBvaW50UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gKHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChpc09iamVjdChwYXlsb2FkKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QocGF5bG9hZC5lbmRwb2ludElkZW50aXR5KSAmJlxuICAgICAgICAgICAgaXNPYmplY3QocGF5bG9hZC5ydGMpICYmXG4gICAgICAgICAgICB0eXBlb2YgcGF5bG9hZC5lbmRwb2ludElkZW50aXR5LmVuZHBvaW50SWQgPT09ICdzdHJpbmcnKTtcbiAgICB9XG59XG5zdHJhdGVneSQxLlJUQ1N0cmF0ZWd5ID0gUlRDU3RyYXRlZ3k7XG5fUlRDU3RyYXRlZ3lfcHJvY2Vzc0FjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9SVENTdHJhdGVneV9ydGNFbmRwb2ludE1hcCA9IG5ldyBXZWFrTWFwKCksIF9SVENTdHJhdGVneV9jb25uZWN0ZWQgPSBuZXcgV2Vha01hcCgpO1xuc3RyYXRlZ3kkMS5SVENJbmZvID0geyB2ZXJzaW9uOiAyLCBtaW5pbXVtVmVyc2lvbjogMCwgdHlwZTogJ3J0YycgfTtcblxudmFyIGljZU1hbmFnZXIgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGljZU1hbmFnZXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuaWNlTWFuYWdlci5SVENJQ0VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xJGkgPSBiYXNlO1xuLypcblNpbmdsZXRvbiB0aGF0IGZhY2lsaXRhdGVzIE9mZmVyIGFuZCBBbnN3ZXIgZXhjaGFuZ2UgcmVxdWlyZWQgZm9yIGVzdGFibGlzaGluZyBSVEMgY29ubmVjdGlvbnMuXG4qL1xuY2xhc3MgUlRDSUNFTWFuYWdlciBleHRlbmRzIGJhc2VfMSRpLkVtaXR0ZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlKSB7XG4gICAgICAgIHN1cGVyKHdpcmUsICdjaGFubmVsJyk7XG4gICAgICAgIHRoaXMuZW5zdXJlQ2hhbm5lbE9wZW5lZCA9IChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGlzIENoYW5uZWwgaGFzIGFscmVhZHkgY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRGF0YUNoYW5uZWxQcm9taXNlKGxhYmVsLCBydGNDbGllbnQpIHtcbiAgICAgICAgbGV0IHJlc29sdmVyO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5MaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBlLmNoYW5uZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIG9wZW5MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIoZS5jaGFubmVsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZS5jaGFubmVsLmxhYmVsID09PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIGUuY2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgb3Blbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBydGNDbGllbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGF0YWNoYW5uZWwnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJ0Y0NsaWVudC5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbkZvclByb3ZpZGVySWNlKHJ0Y0Nvbm5lY3Rpb25JZCwgbGlzdGVuZXIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5vbih0aGlzLmNyZWF0ZVByb3ZpZGVyRXZlbnROYW1lKHJ0Y0Nvbm5lY3Rpb25JZCksIGxpc3RlbmVyLCB7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmFpc2VQcm92aWRlckljZShydGNDb25uZWN0aW9uSWQsIHBheWxvYWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLmVudmlyb25tZW50LnJhaXNlRXZlbnQodGhpcy5jcmVhdGVSb3V0ZVN0cmluZyh0aGlzLmNyZWF0ZVByb3ZpZGVyRXZlbnROYW1lKHJ0Y0Nvbm5lY3Rpb25JZCkpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuRm9yQ2xpZW50SWNlKHJ0Y0Nvbm5lY3Rpb25JZCwgbGlzdGVuZXIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5vbih0aGlzLmNyZWF0ZUNsaWVudEV2ZW50TmFtZShydGNDb25uZWN0aW9uSWQpLCBsaXN0ZW5lciwgeyB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJhaXNlQ2xpZW50SWNlKHJ0Y0Nvbm5lY3Rpb25JZCwgcGF5bG9hZCkge1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuZW52aXJvbm1lbnQucmFpc2VFdmVudCh0aGlzLmNyZWF0ZVJvdXRlU3RyaW5nKHRoaXMuY3JlYXRlQ2xpZW50RXZlbnROYW1lKHJ0Y0Nvbm5lY3Rpb25JZCkpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY2xlYW51cEljZUxpc3RlbmVycyhydGNDb25uZWN0aW9uSWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnModGhpcy5jcmVhdGVDbGllbnRFdmVudE5hbWUocnRjQ29ubmVjdGlvbklkKSk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKHRoaXMuY3JlYXRlUHJvdmlkZXJFdmVudE5hbWUocnRjQ29ubmVjdGlvbklkKSk7XG4gICAgfVxuICAgIGNyZWF0ZUNsaWVudEV2ZW50TmFtZShydGNDb25uZWN0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIGBpY2UtY2xpZW50LSR7cnRjQ29ubmVjdGlvbklkfWA7XG4gICAgfVxuICAgIGNyZWF0ZVByb3ZpZGVyRXZlbnROYW1lKHJ0Y0Nvbm5lY3Rpb25JZCkge1xuICAgICAgICByZXR1cm4gYGljZS1wcm92aWRlci0ke3J0Y0Nvbm5lY3Rpb25JZH1gO1xuICAgIH1cbiAgICBjcmVhdGVSb3V0ZVN0cmluZyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBgY2hhbm5lbC8ke25hbWV9YDtcbiAgICB9XG4gICAgY3JlYXRlUnRjUGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXRSdGNQZWVyKCk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0Q2xpZW50T2ZmZXIoKSB7XG4gICAgICAgIC8vIFRPRE8gcmVwbGFjZSB3aXRoIHJlYWwgZ3VpZC5cbiAgICAgICAgY29uc3QgcnRjQ29ubmVjdGlvbklkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBydGNDbGllbnQgPSB0aGlzLmNyZWF0ZVJ0Y1BlZXIoKTtcbiAgICAgICAgcnRjQ2xpZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJhaXNlQ2xpZW50SWNlKHJ0Y0Nvbm5lY3Rpb25JZCwgeyBjYW5kaWRhdGU6IGUuY2FuZGlkYXRlPy50b0pTT04oKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMubGlzdGVuRm9yUHJvdmlkZXJJY2UocnRjQ29ubmVjdGlvbklkLCBhc3luYyAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgcnRjQ2xpZW50LmFkZEljZUNhbmRpZGF0ZShwYXlsb2FkLmNhbmRpZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHJ0Y0NsaWVudC5jcmVhdGVEYXRhQ2hhbm5lbCgncmVxdWVzdCcpLFxuICAgICAgICAgICAgcmVzcG9uc2U6IHJ0Y0NsaWVudC5jcmVhdGVEYXRhQ2hhbm5lbCgncmVzcG9uc2UnKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHJ0Y0NsaWVudC5jcmVhdGVPZmZlcigpO1xuICAgICAgICBhd2FpdCBydGNDbGllbnQuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzT3BlbmVkID0gUHJvbWlzZS5hbGwoW2NoYW5uZWxzLnJlcXVlc3QsIGNoYW5uZWxzLnJlc3BvbnNlXS5tYXAodGhpcy5lbnN1cmVDaGFubmVsT3BlbmVkKSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4geyBydGNDbGllbnQsIGNoYW5uZWxzLCBvZmZlciwgcnRjQ29ubmVjdGlvbklkLCBjaGFubmVsc09wZW5lZCB9O1xuICAgIH1cbiAgICBhc3luYyBmaW5pc2hDbGllbnRPZmZlcihydGNDbGllbnQsIGFuc3dlciwgcHJvdmlkZXJSZWFkeSkge1xuICAgICAgICBhd2FpdCBydGNDbGllbnQuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgcHJvdmlkZXJSZWFkeTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb3ZpZGVyQW5zd2VyKHJ0Y0Nvbm5lY3Rpb25JZCwgb2ZmZXIpIHtcbiAgICAgICAgY29uc3QgcnRjQ2xpZW50ID0gdGhpcy5jcmVhdGVSdGNQZWVyKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDaGFubmVsUHJvbWlzZSA9IFJUQ0lDRU1hbmFnZXIuY3JlYXRlRGF0YUNoYW5uZWxQcm9taXNlKCdyZXF1ZXN0JywgcnRjQ2xpZW50KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VDaGFubmVsUHJvbWlzZSA9IFJUQ0lDRU1hbmFnZXIuY3JlYXRlRGF0YUNoYW5uZWxQcm9taXNlKCdyZXNwb25zZScsIHJ0Y0NsaWVudCk7XG4gICAgICAgIHJ0Y0NsaWVudC5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yYWlzZVByb3ZpZGVySWNlKHJ0Y0Nvbm5lY3Rpb25JZCwgeyBjYW5kaWRhdGU6IGUuY2FuZGlkYXRlPy50b0pTT04oKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMubGlzdGVuRm9yQ2xpZW50SWNlKHJ0Y0Nvbm5lY3Rpb25JZCwgYXN5bmMgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHJ0Y0NsaWVudC5hZGRJY2VDYW5kaWRhdGUocGF5bG9hZC5jYW5kaWRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRjQ2xpZW50LnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcnRjQ2xpZW50LmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBhd2FpdCBydGNDbGllbnQuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IFByb21pc2UuYWxsKFtyZXF1ZXN0Q2hhbm5lbFByb21pc2UsIHJlc3BvbnNlQ2hhbm5lbFByb21pc2VdKS50aGVuKChbcmVxdWVzdCwgcmVzcG9uc2VdKSA9PiB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBpY2UgZXZlbnRzLlxuICAgICAgICAgICAgdGhpcy5jbGVhbnVwSWNlTGlzdGVuZXJzKHJ0Y0Nvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICByZXR1cm4geyByZXF1ZXN0LCByZXNwb25zZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJ0Y0NsaWVudCxcbiAgICAgICAgICAgIGFuc3dlcixcbiAgICAgICAgICAgIGNoYW5uZWxzXG4gICAgICAgIH07XG4gICAgfVxufVxuaWNlTWFuYWdlci5SVENJQ0VNYW5hZ2VyID0gUlRDSUNFTWFuYWdlcjtcblxudmFyIHByb3ZpZGVyID0ge307XG5cbnZhciBydW50aW1lVmVyc2lvbmluZyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocnVudGltZVZlcnNpb25pbmcsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucnVudGltZVZlcnNpb25pbmcucnVudGltZVV1aWRNZWV0c01pbmltdW1SdW50aW1lVmVyc2lvbiA9IHJ1bnRpbWVWZXJzaW9uaW5nLnBhcnNlUnVudGltZVV1aWQgPSBydW50aW1lVmVyc2lvbmluZy5tZWV0c01pbmltdW1SdW50aW1lVmVyc2lvbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIHZOdW0oeCkge1xuICAgIHJldHVybiBbLi4ueC5zcGxpdCgnLicpLnJldmVyc2UoKS5lbnRyaWVzKCldLnJlZHVjZSgocCwgW2ksIHZdKSA9PiBwICsgK3YgKiAxMDAwMCAqKiBpLCAwKTtcbn1cbi8qXG4gIENvbXBhcmVzIHJ1bnRpbWUgdmVyc2lvbnMgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHJ1bnRpbWUgbWVldHMgeW91ciBkZXNpcmVkIG1pbmltdW0uXG4qL1xuZnVuY3Rpb24gbWVldHNNaW5pbXVtUnVudGltZVZlcnNpb24oY3VycmVudFZlcnNpb24sIG1pblZlcnNpb24pIHtcbiAgICBjb25zdCBjdXJyZW50VmVyc2lvblBhcnNlZCA9IHZOdW0oY3VycmVudFZlcnNpb24pO1xuICAgIGNvbnN0IG1pblZlcnNpb25QYXJzZWQgPSB2TnVtKG1pblZlcnNpb24pO1xuICAgIHJldHVybiBjdXJyZW50VmVyc2lvblBhcnNlZCA+PSBtaW5WZXJzaW9uUGFyc2VkO1xufVxucnVudGltZVZlcnNpb25pbmcubWVldHNNaW5pbXVtUnVudGltZVZlcnNpb24gPSBtZWV0c01pbmltdW1SdW50aW1lVmVyc2lvbjtcbi8vIFN0cmlwcyB0aGUgcG9ydCBpbmZvIGZyb20gdGhlIHJ1bnRpbWVVdWlkLCBsZWF2aW5nIGp1c3QgdGhlIHJ1bnRpbWUgdmVyc2lvbi5cbmZ1bmN0aW9uIHBhcnNlUnVudGltZVV1aWQocnVudGltZVV1aWQpIHtcbiAgICByZXR1cm4gcnVudGltZVV1aWQuc3BsaXQoJy8nKVswXTtcbn1cbnJ1bnRpbWVWZXJzaW9uaW5nLnBhcnNlUnVudGltZVV1aWQgPSBwYXJzZVJ1bnRpbWVVdWlkO1xuZnVuY3Rpb24gcnVudGltZVV1aWRNZWV0c01pbmltdW1SdW50aW1lVmVyc2lvbihydW50aW1lVXVpZCwgbWluVmVyc2lvbikge1xuICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9uID0gcGFyc2VSdW50aW1lVXVpZChydW50aW1lVXVpZCk7XG4gICAgcmV0dXJuIG1lZXRzTWluaW11bVJ1bnRpbWVWZXJzaW9uKHJ1bnRpbWVWZXJzaW9uLCBtaW5WZXJzaW9uKTtcbn1cbnJ1bnRpbWVWZXJzaW9uaW5nLnJ1bnRpbWVVdWlkTWVldHNNaW5pbXVtUnVudGltZVZlcnNpb24gPSBydW50aW1lVXVpZE1lZXRzTWluaW11bVJ1bnRpbWVWZXJzaW9uO1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ5ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ3ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfQ2hhbm5lbFByb3ZpZGVyX2Nvbm5lY3Rpb25zLCBfQ2hhbm5lbFByb3ZpZGVyX3Byb3RlY3RlZE9iaiwgX0NoYW5uZWxQcm92aWRlcl9zdHJhdGVneSwgX0NoYW5uZWxQcm92aWRlcl9yZW1vdmVFbmRwb2ludCwgX0NoYW5uZWxQcm92aWRlcl9jbG9zZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm92aWRlciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5wcm92aWRlci5DaGFubmVsUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsXzEgPSBjaGFubmVsO1xuY29uc3QgcnVudGltZVZlcnNpb25pbmdfMSA9IHJ1bnRpbWVWZXJzaW9uaW5nO1xuLyoqXG4gKiBJbnN0YW5jZSBjcmVhdGVkIHRvIGVuYWJsZSB1c2Ugb2YgYSBjaGFubmVsIGFzIGEgcHJvdmlkZXIuIEFsbG93cyBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSB7QGxpbmsgQ2hhbm5lbENsaWVudCBDaGFubmVsQ2xpZW50c30gYnkgaW52b2tpbmcgYW4gYWN0aW9uIG9uXG4gKiBhIHNpbmdsZSBjbGllbnQgdmlhIHtAbGluayBDaGFubmVsUHJvdmlkZXIjZGlzcGF0Y2ggZGlzcGF0Y2h9IG9yIGFsbCBjbGllbnRzIHZpYSB7QGxpbmsgQ2hhbm5lbFByb3ZpZGVyI3B1Ymxpc2ggcHVibGlzaH1cbiAqIGFuZCB0byBsaXN0ZW4gZm9yIGNvbW11bmljYXRpb24gZnJvbSBjbGllbnRzIGJ5IHJlZ2lzdGVyaW5nIGFuIGFjdGlvbiB2aWEge0BsaW5rIENoYW5uZWxQcm92aWRlciNyZWdpc3RlciByZWdpc3Rlcn0uXG4gKlxuICogIyMjIFN5bmNocm9ub3VzIE1ldGhvZHM6XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbFByb3ZpZGVyI29uQ29ubmVjdGlvbiBvbkNvbm5lY3Rpb24obGlzdGVuZXIpfVxuICogICoge0BsaW5rIENoYW5uZWxQcm92aWRlciNvbkRpc2Nvbm5lY3Rpb24gb25EaXNjb25uZWN0aW9uKGxpc3RlbmVyKX1cbiAqICAqIHtAbGluayBDaGFubmVsUHJvdmlkZXIjcHVibGlzaCBwdWJsaXNoKGFjdGlvbiwgcGF5bG9hZCl9XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbFByb3ZpZGVyI3JlZ2lzdGVyIHJlZ2lzdGVyKGFjdGlvbiwgbGlzdGVuZXIpfVxuICogICoge0BsaW5rIENoYW5uZWxQcm92aWRlciNyZW1vdmUgcmVtb3ZlKGFjdGlvbil9XG4gKlxuICogIyMjIEFzeW5jaHJvbm91cyBNZXRob2RzOlxuICogICoge0BsaW5rIENoYW5uZWxQcm92aWRlciNkZXN0cm95IGRlc3Ryb3koKX1cbiAqICAqIHtAbGluayBDaGFubmVsUHJvdmlkZXIjZGlzcGF0Y2ggZGlzcGF0Y2godG8sIGFjdGlvbiwgcGF5bG9hZCl9XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbFByb3ZpZGVyI2dldEFsbENsaWVudEluZm8gZ2V0QWxsQ2xpZW50SW5mbygpfVxuICpcbiAqICMjIyBNaWRkbGV3YXJlOlxuICogTWlkZGxld2FyZSBmdW5jdGlvbnMgcmVjZWl2ZSB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czogKGFjdGlvbiwgcGF5bG9hZCwgc2VuZGVySWQpLlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbWlkZGxld2FyZSBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBvbiBhcyB0aGUgcGF5bG9hZCBmcm9tIGJlZm9yZUFjdGlvbiwgdG8gdGhlIGFjdGlvbiBsaXN0ZW5lciwgdG8gYWZ0ZXJBY3Rpb25cbiAqIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2UgdGhlIG1vc3QgcmVjZW50bHkgZGVmaW5lZCBwYXlsb2FkIGlzIHVzZWQuICBNaWRkbGV3YXJlIGNhbiBiZSB1c2VkIGZvciBzaWRlIGVmZmVjdHMuXG4gKiAgKiB7QGxpbmsgQ2hhbm5lbFByb3ZpZGVyI3NldERlZmF1bHRBY3Rpb24gc2V0RGVmYXVsdEFjdGlvbihtaWRkbGV3YXJlKX1cbiAqICAqIHtAbGluayBDaGFubmVsUHJvdmlkZXIjb25FcnJvciBvbkVycm9yKG1pZGRsZXdhcmUpfVxuICogICoge0BsaW5rIENoYW5uZWxQcm92aWRlciNiZWZvcmVBY3Rpb24gYmVmb3JlQWN0aW9uKG1pZGRsZXdhcmUpfVxuICogICoge0BsaW5rIENoYW5uZWxQcm92aWRlciNhZnRlckFjdGlvbiBhZnRlckFjdGlvbihtaWRkbGV3YXJlKX1cbiAqL1xuY2xhc3MgQ2hhbm5lbFByb3ZpZGVyIGV4dGVuZHMgY2hhbm5lbF8xLkNoYW5uZWxCYXNlIHtcbiAgICAvKipcbiAgICAgKiBhIHJlYWQtb25seSBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgaWRlbnRpdGllcyBvZiBjb25uZWN0aW5nIGNsaWVudHMuXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gWy4uLl9fY2xhc3NQcml2YXRlRmllbGRHZXQkOSh0aGlzLCBfQ2hhbm5lbFByb3ZpZGVyX2Nvbm5lY3Rpb25zLCBcImZcIildO1xuICAgIH1cbiAgICBzdGF0aWMgaGFuZGxlQ2xpZW50RGlzY29ubmVjdGlvbihjaGFubmVsLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUJ5SWQgPSBjaGFubmVsLmNvbm5lY3Rpb25zLmZpbmQoKGlkZW50aXR5KSA9PiBpZGVudGl0eS5lbmRwb2ludElkID09PSBwYXlsb2FkLmVuZHBvaW50SWQpO1xuICAgICAgICBpZiAocmVtb3ZlQnlJZCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ5KGNoYW5uZWwsIF9DaGFubmVsUHJvdmlkZXJfcmVtb3ZlRW5kcG9pbnQsIFwiZlwiKS5jYWxsKGNoYW5uZWwsIHJlbW92ZUJ5SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbXVsdGlwbGVSZW1vdmVzID0gY2hhbm5lbC5jb25uZWN0aW9ucy5maWx0ZXIoKGlkZW50aXR5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5LnV1aWQgPT09IHBheWxvYWQudXVpZCAmJiBpZGVudGl0eS5uYW1lID09PSBwYXlsb2FkLm5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG11bHRpcGxlUmVtb3Zlcy5mb3JFYWNoKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkOShjaGFubmVsLCBfQ2hhbm5lbFByb3ZpZGVyX3JlbW92ZUVuZHBvaW50LCBcImZcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdExpc3RlbmVyKHBheWxvYWQpO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0UHJvdmlkZXJSZW1vdmFsKHByb3ZpZGVyLCByZW1vdmUpIHtcbiAgICAgICAgQ2hhbm5lbFByb3ZpZGVyLnJlbW92YWxNYXAuc2V0KHByb3ZpZGVyLCByZW1vdmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkZW50aXR5LCB3aXJlLCBzdHJhdGVneSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfQ2hhbm5lbFByb3ZpZGVyX2Nvbm5lY3Rpb25zLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ2hhbm5lbFByb3ZpZGVyX3Byb3RlY3RlZE9iai5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NoYW5uZWxQcm92aWRlcl9zdHJhdGVneS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NoYW5uZWxQcm92aWRlcl9yZW1vdmVFbmRwb2ludC5zZXQodGhpcywgKGlkZW50aXR5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdDb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnMuZmlsdGVyKChjbGllbnRJZGVudGl0eSkgPT4gY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCAhPT0gaWRlbnRpdHkuZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDkodGhpcywgX0NoYW5uZWxQcm92aWRlcl9zdHJhdGVneSwgXCJmXCIpLmNsb3NlRW5kcG9pbnQoaWRlbnRpdHkuZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDcodGhpcywgX0NoYW5uZWxQcm92aWRlcl9jb25uZWN0aW9ucywgcmVtYWluaW5nQ29ubmVjdGlvbnMsIFwiZlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE11c3QgYmUgYm91bmQuXG4gICAgICAgIHRoaXMucHJvY2Vzc0FjdGlvbiA9IGFzeW5jIChhY3Rpb24sIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KSA9PiB7XG4gICAgICAgICAgICBpZiAoQ2hhbm5lbFByb3ZpZGVyLmNsaWVudElzTXVsdGlSdW50aW1lKHNlbmRlcklkZW50aXR5KSAmJlxuICAgICAgICAgICAgICAgICEoMCwgcnVudGltZVZlcnNpb25pbmdfMS5ydW50aW1lVXVpZE1lZXRzTWluaW11bVJ1bnRpbWVWZXJzaW9uKShzZW5kZXJJZGVudGl0eS5ydW50aW1lVXVpZCwgJzE4Ljg3LjU2LjAnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTXVsdGlSdW50aW1lTGVnYWN5Q2xpZW50KHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JDbGllbnRDb25uZWN0aW9uKHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdXBlci5wcm9jZXNzQWN0aW9uKGFjdGlvbiwgcGF5bG9hZCwgc2VuZGVySWRlbnRpdHkpO1xuICAgICAgICB9O1xuICAgICAgICBfQ2hhbm5lbFByb3ZpZGVyX2Nsb3NlLnNldCh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDkodGhpcywgX0NoYW5uZWxQcm92aWRlcl9zdHJhdGVneSwgXCJmXCIpLmNsb3NlKCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmUgPSBDaGFubmVsUHJvdmlkZXIucmVtb3ZhbE1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDcodGhpcywgX0NoYW5uZWxQcm92aWRlcl9wcm90ZWN0ZWRPYmosIG5ldyBjaGFubmVsXzEuUHJvdGVjdGVkSXRlbXMocHJvdmlkZXJJZGVudGl0eSwgd2lyZSksIFwiZlwiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0TGlzdGVuZXIgPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDcodGhpcywgX0NoYW5uZWxQcm92aWRlcl9jb25uZWN0aW9ucywgW10sIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ3KHRoaXMsIF9DaGFubmVsUHJvdmlkZXJfc3RyYXRlZ3ksIHN0cmF0ZWd5LCBcImZcIik7XG4gICAgICAgIHN0cmF0ZWd5LnJlY2VpdmUodGhpcy5wcm9jZXNzQWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYW4gYWN0aW9uIHRvIGEgc3BlY2lmaWVkIGNsaWVudC4gUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoYXQgYWN0aW9uIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0byAtIElkZW50aXR5IG9mIHRoZSB0YXJnZXQgY2xpZW50LlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBOYW1lIG9mIHRoZSBhY3Rpb24gdG8gYmUgaW52b2tlZCBieSB0aGUgY2xpZW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gUGF5bG9hZCB0byBiZSBzZW50IGFsb25nIHdpdGggdGhlIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIG11bHRpcGxlIGNsaWVudHMgY2FuIHNoYXJlIHRoZSBzYW1lIGBuYW1lYCBhbmQgYHV1aWRgLCB3aGVuIGRpc3BhdGNoaW5nIGZyb20gYSBwcm92aWRlciB0byBhIGNsaWVudCxcbiAgICAgKiB0aGUgYGlkZW50aXR5YCB5b3UgcHJvdmlkZSBtdXN0IGluY2x1ZGUgdGhlIGNsaWVudCdzIHVuaXF1ZSBgZW5kcG9pbnRJZGAgcHJvcGVydHkuIFRoaXMgYGVuZHBvaW50SWRgIGlzXG4gICAgICogcGFzc2VkIHRvIHRoZSBwcm92aWRlciBpbiBib3RoIHRoZSBgUHJvdmlkZXIub25Db25uZWN0aW9uYCBjYWxsYmFjayBhbmQgaW4gYW55IHJlZ2lzdGVyZWQgYWN0aW9uIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIChhc3luYyAoKT0+IHtcbiAgICAgKiAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNyZWF0ZSgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBhd2FpdCBwcm92aWRlci5yZWdpc3RlcigncHJvdmlkZXItYWN0aW9uJywgYXN5bmMgKHBheWxvYWQsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhwYXlsb2FkLCBpZGVudGl0eSk7XG4gICAgICogICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZGlzcGF0Y2goaWRlbnRpdHksICdjbGllbnQtYWN0aW9uJywgJ0hlbGxvLCBXb3JsZCEnKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkaXNwYXRjaCh0bywgYWN0aW9uLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50SWQgPSB0by5lbmRwb2ludElkID8/IHRoaXMuZ2V0RW5kcG9pbnRJZEZvck9wZW5GaW5JZCh0bywgYWN0aW9uKTtcbiAgICAgICAgaWYgKGVuZHBvaW50SWQgJiYgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ5KHRoaXMsIF9DaGFubmVsUHJvdmlkZXJfc3RyYXRlZ3ksIFwiZlwiKS5pc0VuZHBvaW50Q29ubmVjdGVkKGVuZHBvaW50SWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ5KHRoaXMsIF9DaGFubmVsUHJvdmlkZXJfc3RyYXRlZ3ksIFwiZlwiKS5zZW5kKGVuZHBvaW50SWQsIGFjdGlvbiwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ2xpZW50IGNvbm5lY3Rpb24gd2l0aCBpZGVudGl0eSB1dWlkOiAke3RvLnV1aWR9IC8gbmFtZTogJHt0by5uYW1lfSAvIGVuZHBvaW50SWQ6ICR7ZW5kcG9pbnRJZH0gbm8gbG9uZ2VyIGNvbm5lY3RlZC5gKSk7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NDb25uZWN0aW9uKHNlbmRlcklkLCBwYXlsb2FkKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkOSh0aGlzLCBfQ2hhbm5lbFByb3ZpZGVyX2Nvbm5lY3Rpb25zLCBcImZcIikucHVzaChzZW5kZXJJZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RMaXN0ZW5lcihzZW5kZXJJZCwgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYW4gYWN0aW9uIGFuZCBwYXlsb2FkIHRvIGV2ZXJ5IGNvbm5lY3RlZCBjbGllbnQuXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGZvciBlYWNoIGFjdGlvbiAoc2VlIGRpc3BhdGNoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25cbiAgICAgKiBAcGFyYW0gcGF5bG9hZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIChhc3luYyAoKT0+IHtcbiAgICAgKiAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNyZWF0ZSgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBhd2FpdCBwcm92aWRlci5yZWdpc3RlcigncHJvdmlkZXItYWN0aW9uJywgYXN5bmMgKHBheWxvYWQsIGlkZW50aXR5KSA9PiB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhwYXlsb2FkLCBpZGVudGl0eSk7XG4gICAgICogICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvdmlkZXIucHVibGlzaCgnY2xpZW50LWFjdGlvbicsIHsgbWVzc2FnZTogJ0Jyb2FkY2FzdCBmcm9tIHByb3ZpZGVyJ30pKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaXNoKGFjdGlvbiwgcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9ucy5tYXAoKHRvKSA9PiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDkodGhpcywgX0NoYW5uZWxQcm92aWRlcl9zdHJhdGVneSwgXCJmXCIpLnNlbmQodG8uZW5kcG9pbnRJZCwgYWN0aW9uLCBwYXlsb2FkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgbmV3IGNsaWVudCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgSXQgaXMgcGFzc2VkIHRoZSBpZGVudGl0eSBvZiB0aGUgY29ubmVjdGluZyBjbGllbnQgYW5kIGEgcGF5bG9hZCBpZiBpdCB3YXMgcHJvdmlkZWQgdG8gQ2hhbm5lbC5jb25uZWN0LlxuICAgICAqIElmIHlvdSB3aXNoIHRvIHJlamVjdCB0aGUgY29ubmVjdGlvbiwgdGhyb3cgYW4gZXJyb3IuIEJlIHN1cmUgdG8gc3luY2hyb25vdXNseSBwcm92aWRlIGFuIG9uQ29ubmVjdGlvbiB1cG9uIHJlY2VpcHQgb2ZcbiAgICAgKiB0aGUgY2hhbm5lbFByb3ZpZGVyIHRvIGVuc3VyZSBhbGwgcG90ZW50aWFsIGNsaWVudCBjb25uZWN0aW9ucyBhcmUgY2F1Z2h0IGJ5IHRoZSBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIEJlY2F1c2UgbXVsdGlwbGUgY2xpZW50cyBjYW4gZXhpc3QgYXQgdGhlIHNhbWUgYG5hbWVgIGFuZCBgdXVpZGAsIGluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW5kaXZpZHVhbCBjbGllbnRzLFxuICAgICAqIHRoZSBgaWRlbnRpdHlgIGFyZ3VtZW50IGluIGEgcHJvdmlkZXIncyBgb25Db25uZWN0aW9uYCBjYWxsYmFjayBjb250YWlucyBhbiBgZW5kcG9pbnRJZGAgcHJvcGVydHkuIFdoZW4gZGlzcGF0Y2hpbmcgZnJvbSBhXG4gICAgICogcHJvdmlkZXIgdG8gYSBjbGllbnQsIHRoZSBgZW5kcG9pbnRJZGAgcHJvcGVydHkgbXVzdCBiZSBwcm92aWRlZCBpbiBvcmRlciB0byBzZW5kIGFuIGFjdGlvbiB0byBhIHNwZWNpZmljIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiAoYXN5bmMgKCk9PiB7XG4gICAgICogICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jcmVhdGUoJ2NoYW5uZWxOYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgcHJvdmlkZXIub25Db25uZWN0aW9uKGlkZW50aXR5ID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdDbGllbnQgY29ubmVjdGVkJywgaWRlbnRpdHkpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUmVqZWN0IGNvbm5lY3Rpb246XG4gICAgICogYGBganNcbiAgICAgKiAoYXN5bmMgKCk9PiB7XG4gICAgICogICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jcmVhdGUoJ2NoYW5uZWxOYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgcHJvdmlkZXIub25Db25uZWN0aW9uKGlkZW50aXR5ID0+IHtcbiAgICAgKiAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29ubmVjdGlvbiBSZWplY3RlZCcpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uQ29ubmVjdGlvbihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNvbm5lY3RMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIHRoYXQgaXMgY2FsbGVkIG9uIGNsaWVudCBkaXNjb25uZWN0aW9uLiBJdCBpcyBwYXNzZWQgdGhlIGRpc2Nvbm5lY3Rpb24gZXZlbnQgb2YgdGhlIGRpc2Nvbm5lY3RpbmdcbiAgICAgKiBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIChhc3luYyAoKT0+IHtcbiAgICAgKiAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNyZWF0ZSgnY2hhbm5lbE5hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBhd2FpdCBwcm92aWRlci5vbkRpc2Nvbm5lY3Rpb24oZXZ0ID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdDbGllbnQgZGlzY29ubmVjdGVkJywgYHV1aWQ6ICR7ZXZ0LnV1aWR9LCBuYW1lOiAke2V2dC5uYW1lfWApO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uRGlzY29ubmVjdGlvbihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBjaGFubmVsLCByYWlzZXMgYGRpc2Nvbm5lY3RlZGAgZXZlbnRzIG9uIGFsbCBjb25uZWN0ZWQgY2hhbm5lbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpPT4ge1xuICAgICAqICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKCdjaGFubmVsTmFtZScpO1xuICAgICAqXG4gICAgICogICAgIGF3YWl0IHByb3ZpZGVyLmRlc3Ryb3koKTtcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHByb3RlY3RlZE9iaiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkOSh0aGlzLCBfQ2hhbm5lbFByb3ZpZGVyX3Byb3RlY3RlZE9iaiwgXCJmXCIpO1xuICAgICAgICBjb25zdCB7IGNoYW5uZWxOYW1lIH0gPSBwcm90ZWN0ZWRPYmoucHJvdmlkZXJJZGVudGl0eTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ3KHRoaXMsIF9DaGFubmVsUHJvdmlkZXJfY29ubmVjdGlvbnMsIFtdLCBcImZcIik7XG4gICAgICAgIGF3YWl0IHByb3RlY3RlZE9iai53aXJlLnNlbmRBY3Rpb24oJ2Rlc3Ryb3ktY2hhbm5lbCcsIHsgY2hhbm5lbE5hbWUgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkOSh0aGlzLCBfQ2hhbm5lbFByb3ZpZGVyX2Nsb3NlLCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIGluZm8gb24gZXZlcnkgQ2xpZW50IGNvbm5lY3RlZCB0byB0aGUgUHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jcmVhdGUoJ29wZW5maW4nKTtcbiAgICAgKiBjb25zdCBjbGllbnQgPSBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNvbm5lY3QoJ29wZW5maW4nKTtcbiAgICAgKiBjb25zdCBjbGllbnRJbmZvID0gYXdhaXQgcHJvdmlkZXIuZ2V0QWxsQ2xpZW50SW5mbygpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY2xpZW50SW5mbyk7XG4gICAgICpcbiAgICAgKiAvLyBbXG4gICAgICogLy8gICAge1xuICAgICAqIC8vICAgICAgICBcInV1aWRcIjogXCJvcGVuZmluXCIsXG4gICAgICogLy8gICAgICAgIFwibmFtZVwiOiBcIm9wZW5maW4tdmlld1wiLFxuICAgICAqIC8vICAgICAgICBcImVuZHBvaW50SWRcIjogXCI2ZDRjN2NhOC00YTc0LTQ2MzQtODdmOC03NjA1NTgyMjk2MTNcIixcbiAgICAgKiAvLyAgICAgICAgXCJlbnRpdHlUeXBlXCI6IFwidmlld1wiLFxuICAgICAqIC8vICAgICAgICBcInVybFwiOiBcImh0dHBzOi8vb3BlbmZpbi5jb1wiXG4gICAgICogLy8gICAgfSxcbiAgICAgKiAvLyAgICB7XG4gICAgICogLy8gICAgICAgIFwidXVpZFwiOiBcIm9wZW5maW4yXCIsXG4gICAgICogLy8gICAgICAgIFwibmFtZVwiOiBcIm9wZW5maW4tdmlldzJcIixcbiAgICAgKiAvLyAgICAgICAgXCJlbmRwb2ludElkXCI6IFwiNHo1ZDhhYjktMmI4MS0zNjkxLTkxZXgtMTQyMTc5MzgyNTExXCIsXG4gICAgICogLy8gICAgICAgIFwiZW50aXR5VHlwZVwiOiBcInZpZXdcIixcbiAgICAgKiAvLyAgICAgICAgXCJ1cmxcIjogXCJodHRwczovL2V4YW1wbGUuY29tXCJcbiAgICAgKiAvLyAgICB9XG4gICAgICogLy9dXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsQ2xpZW50SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnMubWFwKChjbGllbnRJbmZvKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUsIGVuZHBvaW50SWQsIGVudGl0eVR5cGUsIGNvbm5lY3Rpb25VcmwgfSA9IGNsaWVudEluZm87XG4gICAgICAgICAgICByZXR1cm4geyB1dWlkLCBuYW1lLCBlbmRwb2ludElkLCBlbnRpdHlUeXBlLCBjb25uZWN0aW9uVXJsIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVja0ZvckNsaWVudENvbm5lY3Rpb24oY2xpZW50SWRlbnRpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xpZW50Q29ubmVjdGVkKGNsaWVudElkZW50aXR5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGFjdGlvbiB3YXMgc2VudCBmcm9tIGEgY2xpZW50IHRoYXQgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgcHJvdmlkZXIuXG4gICAgICAgICAgICAgICAgICAgIENsaWVudCBJZGVudGl0eToge3V1aWQ6ICR7Y2xpZW50SWRlbnRpdHkudXVpZH0sIG5hbWU6ICR7Y2xpZW50SWRlbnRpdHkubmFtZX0sIGVuZHBvaW50SWQ6ICR7Y2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZH19YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNDbGllbnRDb25uZWN0ZWQoY2xpZW50SWRlbnRpdHkpIHtcbiAgICAgICAgaWYgKENoYW5uZWxQcm92aWRlci5jbGllbnRJZGVudGl0eUluY2x1ZGVzRW5kcG9pbnRJZChjbGllbnRJZGVudGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zLnNvbWUoKGlkZW50aXR5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAvLyBNaWdodCBiZSByZWR1bmRhbnQgdG8gY2hlY2sgZm9yIHV1aWQgYW5kIG5hbWUgaGVyZSBhZnRlciB3ZSBnZXQgYW4gZW5kcG9pbnRJZCBtYXRjaCwgYnV0IGp1c3QgaW4gY2FzZVxuICAgICAgICAgICAgICAgIGlkZW50aXR5LmVuZHBvaW50SWQgPT09IGNsaWVudElkZW50aXR5LmVuZHBvaW50SWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHkudXVpZCA9PT0gY2xpZW50SWRlbnRpdHkudXVpZCAmJlxuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eS5uYW1lID09PSBjbGllbnRJZGVudGl0eS5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGVnYWN5Q2xpZW50Q29ubmVjdGVkKGNsaWVudElkZW50aXR5KTtcbiAgICB9XG4gICAgaXNMZWdhY3lDbGllbnRDb25uZWN0ZWQoY2xpZW50SWRlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnMuc29tZSgoaWRlbnRpdHkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGl0eS51dWlkID09PSBjbGllbnRJZGVudGl0eS51dWlkICYmIGlkZW50aXR5Lm5hbWUgPT09IGNsaWVudElkZW50aXR5Lm5hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVNdWx0aVJ1bnRpbWVMZWdhY3lDbGllbnQoc2VuZGVySWRlbnRpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGVnYWN5Q2xpZW50Q29ubmVjdGVkKHNlbmRlcklkZW50aXR5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGFjdGlvbiB3YXMgc2VudCBmcm9tIGEgY2xpZW50IHRoYXQgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgcHJvdmlkZXIuIENsaWVudCBJZGVudGl0eTpcbiAgICAgICAgICAgICAgICAgICAge3V1aWQ6ICR7c2VuZGVySWRlbnRpdHkudXVpZH0sIG5hbWU6ICR7c2VuZGVySWRlbnRpdHkubmFtZX0sIGVuZHBvaW50SWQ6ICR7c2VuZGVySWRlbnRpdHkuZW5kcG9pbnRJZH19YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW5kcG9pbnRJZEZvck9wZW5GaW5JZChjbGllbnRJZGVudGl0eSwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQ29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25zLmZpbHRlcigoYykgPT4gYy5uYW1lID09PSBjbGllbnRJZGVudGl0eS5uYW1lICYmIGMudXVpZCA9PT0gY2xpZW50SWRlbnRpdHkudXVpZCk7XG4gICAgICAgIGlmIChtYXRjaGluZ0Nvbm5lY3Rpb25zLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90ZWN0ZWRPYmogPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDkodGhpcywgX0NoYW5uZWxQcm92aWRlcl9wcm90ZWN0ZWRPYmosIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXVpZCwgbmFtZSB9ID0gY2xpZW50SWRlbnRpdHk7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlclV1aWQgPSBwcm90ZWN0ZWRPYmo/LnByb3ZpZGVySWRlbnRpdHkudXVpZDtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyTmFtZSA9IHByb3RlY3RlZE9iaj8ucHJvdmlkZXJJZGVudGl0eS5uYW1lO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogRGlzcGF0Y2ggY2FsbCBtYXkgaGF2ZSB1bmludGVuZGVkIHJlc3VsdHMuIFRoZSBcInRvXCIgYXJndW1lbnQgb2YgeW91ciBkaXNwYXRjaCBjYWxsIGlzIG1pc3NpbmcgdGhlXG4gICAgICAgICAgICAgICAgXCJlbmRwb2ludElkXCIgcGFyYW1ldGVyLiBUaGUgaWRlbnRpdHkgeW91IGFyZSBkaXNwYXRjaGluZyB0byAoe3V1aWQ6ICR7dXVpZH0sIG5hbWU6ICR7bmFtZX19KVxuICAgICAgICAgICAgICAgIGhhcyBtdWx0aXBsZSBjaGFubmVsQ2xpZW50cyBmb3IgdGhpcyBjaGFubmVsLiBZb3VyIGRpc3BhdGNoZWQgYWN0aW9uOiAoJHthY3Rpb259KSBmcm9tIHRoZSBwcm92aWRlcjpcbiAgICAgICAgICAgICAgICAoe3V1aWQ6ICR7cHJvdmlkZXJVdWlkfSwgbmFtZTogJHtwcm92aWRlck5hbWV9fSkgd2lsbCBvbmx5IGJlIHByb2Nlc3NlZCBieSB0aGUgbW9zdCByZWNlbnRseS1jcmVhdGVkIGNsaWVudC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3AgdG8gcmV0dXJuIHRoZSBtb3N0IHJlY2VudGx5IGNyZWF0ZWQgZW5kcG9pbnRJZC5cbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nQ29ubmVjdGlvbnMucG9wKCk/LmVuZHBvaW50SWQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgc3RhdGljIGNsaWVudElkZW50aXR5SW5jbHVkZXNFbmRwb2ludElkKHN1YnNjcmlwdGlvbklkZW50aXR5KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25JZGVudGl0eS5lbmRwb2ludElkICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgc3RhdGljIGNsaWVudElzTXVsdGlSdW50aW1lKHN1YnNjcmlwdGlvbklkZW50aXR5KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25JZGVudGl0eS5ydW50aW1lVXVpZCAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbnByb3ZpZGVyLkNoYW5uZWxQcm92aWRlciA9IENoYW5uZWxQcm92aWRlcjtcbl9DaGFubmVsUHJvdmlkZXJfY29ubmVjdGlvbnMgPSBuZXcgV2Vha01hcCgpLCBfQ2hhbm5lbFByb3ZpZGVyX3Byb3RlY3RlZE9iaiA9IG5ldyBXZWFrTWFwKCksIF9DaGFubmVsUHJvdmlkZXJfc3RyYXRlZ3kgPSBuZXcgV2Vha01hcCgpLCBfQ2hhbm5lbFByb3ZpZGVyX3JlbW92ZUVuZHBvaW50ID0gbmV3IFdlYWtNYXAoKSwgX0NoYW5uZWxQcm92aWRlcl9jbG9zZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBUaGUgZm9sbG93aW5nIGxpbmUgc2hvdWxkIGJlIGNoYW5nZWQgZm9sbG93aW5nIGEgdHlwZXNjcmlwdCB1cGRhdGUuXG4vLyBzdGF0aWMgI3JlbW92YWxNYXAgPSBuZXcgV2Vha01hcDxDaGFubmVsUHJvdmlkZXIsIEZ1bmN0aW9uPigpO1xuQ2hhbm5lbFByb3ZpZGVyLnJlbW92YWxNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgbWVzc2FnZVJlY2VpdmVyID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXNzYWdlUmVjZWl2ZXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xubWVzc2FnZVJlY2VpdmVyLk1lc3NhZ2VSZWNlaXZlciA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF8xJDEgPSBjbGllbnQ7XG5jb25zdCBiYXNlXzEkaCA9IGJhc2U7XG4vKlxuVGhpcyBpcyBhIHNpbmdsZXRvbiAocGVyIGZpbiBvYmplY3QpIHRhc2tlZCB3aXRoIHJvdXRpbmcgbWVzc2FnZXMgY29taW5nIG9mZiB0aGUgaXBjIHRvIHRoZSBjb3JyZWN0IGVuZHBvaW50LlxuSXQgbmVlZHMgdG8gYmUgYSBzaW5nbGV0b24gYmVjYXVzZSB0aGVyZSBjYW4gb25seSBiZSBvbmUgcGVyIHdpcmUuIEl0IHRyYWNrcyBib3RoIGNsaWVudHMgYW5kIHByb3ZpZGVycycgcHJvY2Vzc0FjdGlvbiBwYXNzZWQgaW4gdmlhIHRoZSBzdHJhdGVneS5cbklmIGZ1bmN0aW9uYWxpdHkgaXMgbm90IGFib3V0IHJlY2VpdmluZyBtZXNzYWdlcywgaXQgZG9lcyBub3QgYmVsb25nIGhlcmUuXG4qL1xuY2xhc3MgTWVzc2FnZVJlY2VpdmVyIGV4dGVuZHMgYmFzZV8xJGguQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSkge1xuICAgICAgICBzdXBlcih3aXJlKTtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICBpZiAobXNnLmFjdGlvbiA9PT0gJ3Byb2Nlc3MtY2hhbm5lbC1tZXNzYWdlJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kcG9pbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0RW5kcG9pbnRJZEJ5Q2hhbm5lbElkID0gbmV3IE1hcCgpO1xuICAgICAgICB3aXJlLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIodGhpcy5vbm1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NDaGFubmVsTWVzc2FnZShtc2cpIHtcbiAgICAgICAgY29uc3QgeyBzZW5kZXJJZGVudGl0eSwgcHJvdmlkZXJJZGVudGl0eSwgYWN0aW9uLCBhY2tUb1NlbmRlciwgcGF5bG9hZCwgaW50ZW5kZWRUYXJnZXRJZGVudGl0eSB9ID0gbXNnLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGtleSA9IGludGVuZGVkVGFyZ2V0SWRlbnRpdHkuY2hhbm5lbElkID8/IC8vIFRoZSByZWNpcGllbnQgaXMgYSBwcm92aWRlclxuICAgICAgICAgICAgaW50ZW5kZWRUYXJnZXRJZGVudGl0eS5lbmRwb2ludElkID8/IC8vIFRoZSByZWNpcGllbnQgaXMgYSBjbGllbnRcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0RW5kcG9pbnRJZEJ5Q2hhbm5lbElkLmdldChwcm92aWRlcklkZW50aXR5LmNoYW5uZWxJZCk7IC8vIE5vIGVuZHBvaW50SWQgd2FzIHBhc3NlZCwgbWFrZSBiZXN0IGF0dGVtcHRcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuZW5kcG9pbnRNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgYWNrVG9TZW5kZXIucGF5bG9hZC5zdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnJlYXNvbiA9IGBDbGllbnQgY29ubmVjdGlvbiB3aXRoIGlkZW50aXR5IHV1aWQ6ICR7dGhpcy53aXJlLm1lLnV1aWR9IC8gbmFtZTogJHt0aGlzLndpcmUubWUubmFtZX0gLyBlbmRwb2ludElkOiAke2tleX0gbm8gbG9uZ2VyIGNvbm5lY3RlZC5gO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kUmF3KGFja1RvU2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgaGFuZGxlcihhY3Rpb24sIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCA9IGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCB8fCB7fTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZC5yZXN1bHQgPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRSYXcoYWNrVG9TZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucmVhc29uID0gZS5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kUmF3KGFja1RvU2VuZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFbmRwb2ludChoYW5kbGVyLCBjaGFubmVsSWQsIGVuZHBvaW50SWQpIHtcbiAgICAgICAgdGhpcy5lbmRwb2ludE1hcC5zZXQoZW5kcG9pbnRJZCwgaGFuZGxlcik7XG4gICAgICAgIC8vIFByb3ZpZGVycyBoYXZlIHRoZSBzYW1lIGVuZHBvaW50SWQgYW5kIGNoYW5uZWxJZC5cbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiBjbGllbnRzIGFyZSByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSBwcm92aWRlcnMsIHNvIHdlIHNob3VsZG4ndCBzYXZlIHByb3ZpZGVyIGVuZHBvaW50SWQgaGVyZS5cbiAgICAgICAgaWYgKGNoYW5uZWxJZCAhPT0gZW5kcG9pbnRJZCkge1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RFbmRwb2ludElkQnlDaGFubmVsSWQuc2V0KGNoYW5uZWxJZCwgZW5kcG9pbnRJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRW5kcG9pbnQoY2hhbm5lbElkLCBlbmRwb2ludElkKSB7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRNYXAuZGVsZXRlKGVuZHBvaW50SWQpO1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RFbmRwb2ludElkQnlDaGFubmVsSWQuZ2V0KGNoYW5uZWxJZCkgPT09IGVuZHBvaW50SWQpIHtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0RW5kcG9pbnRJZEJ5Q2hhbm5lbElkLmRlbGV0ZShjaGFubmVsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrRm9yUHJldmlvdXNDbGllbnRDb25uZWN0aW9uKGNoYW5uZWxJZCkge1xuICAgICAgICBjb25zdCBlbmRwb2ludElkRnJvbVByZXZpb3VzQ29ubmVjdGlvbiA9IHRoaXMubGF0ZXN0RW5kcG9pbnRJZEJ5Q2hhbm5lbElkLmdldChjaGFubmVsSWQpO1xuICAgICAgICBpZiAoZW5kcG9pbnRJZEZyb21QcmV2aW91c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIE5vdCBjb252aW5jZWQgYnkgdGhpcyB3YXkgb2YgZG9pbmcgdGhpbmdzLCBidXQgcHVzaGluZyB1cCBmb3Igbm93LlxuICAgICAgICAgICAgY2xpZW50XzEkMS5DaGFubmVsQ2xpZW50LmNsb3NlQ2hhbm5lbEJ5RW5kcG9pbnRJZChlbmRwb2ludElkRnJvbVByZXZpb3VzQ29ubmVjdGlvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdZb3UgaGF2ZSBjcmVhdGVkIGEgc2Vjb25kIGNvbm5lY3Rpb24gdG8gYW4gb2xkZXIgcHJvdmlkZXIuIEZpcnN0IGNvbm5lY3Rpb24gaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBjbGllbnRNYXAnKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0lmIHRoZSBwcm92aWRlciBjYWxscyBwdWJsaXNoKCksIHlvdSBtYXkgcmVjZWl2ZSBtdWx0aXBsZSBtZXNzYWdlcy4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm1lc3NhZ2VSZWNlaXZlci5NZXNzYWdlUmVjZWl2ZXIgPSBNZXNzYWdlUmVjZWl2ZXI7XG5cbnZhciBwcm90b2NvbE1hbmFnZXIgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvY29sTWFuYWdlciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5wcm90b2NvbE1hbmFnZXIuUHJvdG9jb2xNYW5hZ2VyID0gdm9pZCAwO1xuLypcblRoaXMgc2hvdWxkIGJlIGFnbm9zdGljIG9mIGFueSBhY3R1YWwgb3BlbmZpbiBjb2RlIHRvIGJlIHVuaXQgdGVzdGFibGUuXG5EZXBlbmRlbmNpZXMgb24gdGhlIGFjdHVhbCBzcmF0ZWdpZXMgc2hvdWxkIGJlIGhhbmRsZWQgaW4gQ29ubmVjdGlvbk1hbmFnZXJcbiovXG5jbGFzcyBQcm90b2NvbE1hbmFnZXIge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3IoUHJvdG9jb2xzSW5QcmVmZXJlbmNlT3JkZXIpIHtcbiAgICAgICAgdGhpcy5Qcm90b2NvbHNJblByZWZlcmVuY2VPcmRlciA9IFByb3RvY29sc0luUHJlZmVyZW5jZU9yZGVyO1xuICAgICAgICB0aGlzLkRlZmF1bHRDbGllbnRQcm90b2NvbHMgPSBbJ2NsYXNzaWMnXTtcbiAgICAgICAgdGhpcy5EZWZhdWx0UHJvdmlkZXJQcm90b2NvbHMgPSBbJ2NsYXNzaWMnXTtcbiAgICAgICAgdGhpcy5nZXRDbGllbnRQcm90b2NvbHMgPSAocHJvdG9jb2xzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWQgPSBwcm90b2NvbHNcbiAgICAgICAgICAgICAgICA/IHRoaXMuUHJvdG9jb2xzSW5QcmVmZXJlbmNlT3JkZXIuZmlsdGVyKCh4KSA9PiBwcm90b2NvbHMuaW5jbHVkZXMoeCkpXG4gICAgICAgICAgICAgICAgOiB0aGlzLkRlZmF1bHRDbGllbnRQcm90b2NvbHM7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHZhbGlkIHByb3RvY29scyB3ZXJlIHBhc3NlZCBpbi4gQWNjZXB0ZWQgdmFsdWVzIGFyZTogJHt0aGlzLlByb3RvY29sc0luUHJlZmVyZW5jZU9yZGVyLmpvaW4oJywgJyl9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRQcm92aWRlclByb3RvY29scyA9IChwcm90b2NvbHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZCA9IHByb3RvY29sc1xuICAgICAgICAgICAgICAgID8gdGhpcy5Qcm90b2NvbHNJblByZWZlcmVuY2VPcmRlci5maWx0ZXIoKHgpID0+IHByb3RvY29scy5pbmNsdWRlcyh4KSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuRGVmYXVsdFByb3ZpZGVyUHJvdG9jb2xzO1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB2YWxpZCBwcm90b2NvbHMgd2VyZSBwYXNzZWQgaW4uIEFjY2VwdGVkIHZhbHVlcyBhcmU6ICR7dGhpcy5Qcm90b2NvbHNJblByZWZlcmVuY2VPcmRlci5qb2luKCcsICcpfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29tcGF0aWJsZVByb3RvY29scyA9IChwcm92aWRlclByb3RvY29scywgY2xpZW50T2ZmZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZCA9IGNsaWVudE9mZmVyLnN1cHBvcnRlZFByb3RvY29scy5maWx0ZXIoKGNsaWVudFByb3RvY29sKSA9PiBwcm92aWRlclByb3RvY29scy5zb21lKChwcm92aWRlclByb3RvY29sKSA9PiBwcm92aWRlclByb3RvY29sLnR5cGUgPT09IGNsaWVudFByb3RvY29sLnR5cGUgJiZcbiAgICAgICAgICAgICAgICBjbGllbnRQcm90b2NvbC52ZXJzaW9uID49IHByb3ZpZGVyUHJvdG9jb2wubWluaW11bVZlcnNpb24gJiZcbiAgICAgICAgICAgICAgICBwcm92aWRlclByb3RvY29sLnZlcnNpb24gPj0gKGNsaWVudFByb3RvY29sLm1pbmltdW1WZXJzaW9uID8/IDApKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkLnNsaWNlKDAsIGNsaWVudE9mZmVyLm1heFByb3RvY29scyk7XG4gICAgICAgIH07XG4gICAgfVxufVxucHJvdG9jb2xNYW5hZ2VyLlByb3RvY29sTWFuYWdlciA9IFByb3RvY29sTWFuYWdlcjtcblxudmFyIHN0cmF0ZWd5ID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHJhdGVneSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBDb21iaW5lZFN0cmF0ZWd5IHtcbiAgICAvLyBNYWtpbmcgdGhpcyBhIHN0YXRpYyBtZXRob2QgYmVjYXVzZSB0aGUgY29uc3RydWN0b3IgY2FuJ3QgYmUgdHlwZWQuXG4gICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgZXJyb3Igd2hlbiBjYWxsaW5nIGFkZEVuZHBvaW50IGJ1dCBJJ2QgcmF0aGVyIHRoZSB3aG9sZSBpbnN0YW5jZSBiZSB0eXBlZCBhcyBuZXZlci5cbiAgICBzdGF0aWMgY29tYmluZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tYmluZWRTdHJhdGVneShhLCBiKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcihwcmltYXJ5LCBzZWNvbmRhcnkpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeTtcbiAgICAgICAgdGhpcy5zZWNvbmRhcnkgPSBzZWNvbmRhcnk7XG4gICAgfVxuICAgIG9uRW5kcG9pbnREaXNjb25uZWN0KGVuZHBvaW50SWQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeS5vbkVuZHBvaW50RGlzY29ubmVjdChlbmRwb2ludElkLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Vjb25kYXJ5LmlzRW5kcG9pbnRDb25uZWN0ZWQoZW5kcG9pbnRJZCkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWNvbmRhcnkub25FbmRwb2ludERpc2Nvbm5lY3QoZW5kcG9pbnRJZCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByaW1hcnkuaXNFbmRwb2ludENvbm5lY3RlZChlbmRwb2ludElkKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc1ZhbGlkRW5kcG9pbnRQYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeS5pc1ZhbGlkRW5kcG9pbnRQYXlsb2FkKHBheWxvYWQpIHx8IHRoaXMuc2Vjb25kYXJ5LmlzVmFsaWRFbmRwb2ludFBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlRW5kcG9pbnQoZW5kcG9pbnRJZCkge1xuICAgICAgICBhd2FpdCB0aGlzLnByaW1hcnkuY2xvc2VFbmRwb2ludChlbmRwb2ludElkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZWNvbmRhcnkuY2xvc2VFbmRwb2ludChlbmRwb2ludElkKTtcbiAgICB9XG4gICAgaXNFbmRwb2ludENvbm5lY3RlZChlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5LmlzRW5kcG9pbnRDb25uZWN0ZWQoZW5kcG9pbnQpIHx8IHRoaXMuc2Vjb25kYXJ5LmlzRW5kcG9pbnRDb25uZWN0ZWQoZW5kcG9pbnQpO1xuICAgIH1cbiAgICBhc3luYyBhZGRFbmRwb2ludChlbmRwb2ludCwgcGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5wcmltYXJ5LmlzVmFsaWRFbmRwb2ludFBheWxvYWQocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJpbWFyeS5hZGRFbmRwb2ludChlbmRwb2ludCwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5LmlzVmFsaWRFbmRwb2ludFBheWxvYWQocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Vjb25kYXJ5LmFkZEVuZHBvaW50KGVuZHBvaW50LCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWNlaXZlKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeS5yZWNlaXZlKGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zZWNvbmRhcnkucmVjZWl2ZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIHNlbmQoZW5kcG9pbnRJZCwgYWN0aW9uLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLnByaW1hcnkuaXNFbmRwb2ludENvbm5lY3RlZChlbmRwb2ludElkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeS5zZW5kKGVuZHBvaW50SWQsIGFjdGlvbiwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kYXJ5LnNlbmQoZW5kcG9pbnRJZCwgYWN0aW9uLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnByaW1hcnkuY2xvc2UoKSwgdGhpcy5zZWNvbmRhcnkuY2xvc2UoKV0pO1xuICAgIH1cbn1cbnN0cmF0ZWd5LmRlZmF1bHQgPSBDb21iaW5lZFN0cmF0ZWd5O1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ2ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDggPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ29ubmVjdGlvbk1hbmFnZXJfbWVzc2FnZVJlY2VpdmVyLCBfQ29ubmVjdGlvbk1hbmFnZXJfcnRjQ29ubmVjdGlvbk1hbmFnZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY29ubmVjdGlvbk1hbmFnZXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29ubmVjdGlvbk1hbmFnZXIuQ29ubmVjdGlvbk1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBleGhhdXN0aXZlXzEgPSBleGhhdXN0aXZlO1xuY29uc3QgYmFzZV8xJGcgPSBiYXNlO1xuY29uc3Qgc3RyYXRlZ3lfMSA9IHN0cmF0ZWd5JDI7XG5jb25zdCBzdHJhdGVneV8yID0gc3RyYXRlZ3kkMTtcbmNvbnN0IGljZV9tYW5hZ2VyXzEgPSBpY2VNYW5hZ2VyO1xuY29uc3QgcHJvdmlkZXJfMSQxID0gcHJvdmlkZXI7XG5jb25zdCBtZXNzYWdlX3JlY2VpdmVyXzEgPSBtZXNzYWdlUmVjZWl2ZXI7XG5jb25zdCBwcm90b2NvbF9tYW5hZ2VyXzEgPSBwcm90b2NvbE1hbmFnZXI7XG5jb25zdCBzdHJhdGVneV8zID0gc3RyYXRlZ3k7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIGJhc2VfMSRnLkJhc2Uge1xuICAgIHN0YXRpYyBnZXRQcm90b2NvbE9wdGlvbnNGcm9tU3RyaW5ncyhwcm90b2NvbHMpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvY29scy5tYXAoKHByb3RvY29sKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncnRjJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWd5XzIuUlRDSW5mbztcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzc2ljJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWd5XzEuQ2xhc3NpY0luZm87XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBleGhhdXN0aXZlXzEuZXhoYXVzdGl2ZUNoZWNrKShwcm90b2NvbCwgWydydGMnLCAnY2xhc3NpYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHdpcmUpIHtcbiAgICAgICAgc3VwZXIod2lyZSk7XG4gICAgICAgIF9Db25uZWN0aW9uTWFuYWdlcl9tZXNzYWdlUmVjZWl2ZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25uZWN0aW9uTWFuYWdlcl9ydGNDb25uZWN0aW9uTWFuYWdlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGFubmVsRnJvbVByb3ZpZGVyTWFwID0gKGNoYW5uZWxJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlck1hcC5kZWxldGUoY2hhbm5lbElkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICBpZiAobXNnLmFjdGlvbiA9PT0gJ3Byb2Nlc3MtY2hhbm5lbC1jb25uZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NoYW5uZWxDb25uZWN0aW9uKG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvdmlkZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucHJvdG9jb2xNYW5hZ2VyID0gbmV3IHByb3RvY29sX21hbmFnZXJfMS5Qcm90b2NvbE1hbmFnZXIodGhpcy53aXJlLmVudmlyb25tZW50LnR5cGUgPT09ICdub2RlJyA/IFsnY2xhc3NpYyddIDogWydydGMnLCAnY2xhc3NpYyddKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ2KHRoaXMsIF9Db25uZWN0aW9uTWFuYWdlcl9tZXNzYWdlUmVjZWl2ZXIsIG5ldyBtZXNzYWdlX3JlY2VpdmVyXzEuTWVzc2FnZVJlY2VpdmVyKHdpcmUpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkNih0aGlzLCBfQ29ubmVjdGlvbk1hbmFnZXJfcnRjQ29ubmVjdGlvbk1hbmFnZXIsIG5ldyBpY2VfbWFuYWdlcl8xLlJUQ0lDRU1hbmFnZXIod2lyZSksIFwiZlwiKTtcbiAgICAgICAgd2lyZS5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKHRoaXMub25tZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBjcmVhdGVQcm92aWRlcihvcHRpb25zLCBwcm92aWRlcklkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXREZWZhdWx0Q2hhbm5lbE9wdGlvbnMoKS5jcmVhdGUsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBjb25zdCBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29sTWFuYWdlci5nZXRQcm92aWRlclByb3RvY29scyhvcHRzPy5wcm90b2NvbHMpO1xuICAgICAgICBjb25zdCBjcmVhdGVTaW5nbGVTdHJhdGVneSA9IChzdHJhdFR5cGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RyYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncnRjJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJhdGVneV8yLlJUQ1N0cmF0ZWd5KCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhc3NpYyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RyYXRlZ3lfMS5DbGFzc2ljU3RyYXRlZ3kodGhpcy53aXJlLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDgodGhpcywgX0Nvbm5lY3Rpb25NYW5hZ2VyX21lc3NhZ2VSZWNlaXZlciwgXCJmXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlkZXJzIGRvIG5vdCBoYXZlIGFuIGVuZHBvaW50SWQsIHVzZSBjaGFubmVsSWQgYXMgZW5kcG9pbnRJZCBpbiB0aGUgc3RyYXRlZ3kuXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVySWRlbnRpdHkuY2hhbm5lbElkLCBwcm92aWRlcklkZW50aXR5KTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGV4aGF1c3RpdmVfMS5leGhhdXN0aXZlQ2hlY2spKHN0cmF0VHlwZSwgWydydGMnLCAnY2xhc3NpYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ2llcyA9IHByb3RvY29scy5tYXAoY3JlYXRlU2luZ2xlU3RyYXRlZ3kpO1xuICAgICAgICBsZXQgc3RyYXRlZ3k7XG4gICAgICAgIGlmIChzdHJhdGVnaWVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgW2EsIGJdID0gc3RyYXRlZ2llcztcbiAgICAgICAgICAgIHN0cmF0ZWd5ID0gc3RyYXRlZ3lfMy5kZWZhdWx0LmNvbWJpbmUoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyYXRlZ2llcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIFtzdHJhdGVneV0gPSBzdHJhdGVnaWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBjb21iaW5lIHN0cmF0ZWdpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFubmVsID0gbmV3IHByb3ZpZGVyXzEkMS5DaGFubmVsUHJvdmlkZXIocHJvdmlkZXJJZGVudGl0eSwgdGhpcy53aXJlLCBzdHJhdGVneSk7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3ZpZGVySWRlbnRpdHkuY2hhbm5lbElkO1xuICAgICAgICB0aGlzLnByb3ZpZGVyTWFwLnNldChrZXksIHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiBjaGFubmVsLFxuICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICBzdXBwb3J0ZWRQcm90b2NvbHM6IENvbm5lY3Rpb25NYW5hZ2VyLmdldFByb3RvY29sT3B0aW9uc0Zyb21TdHJpbmdzKHByb3RvY29scylcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3ZpZGVyXzEkMS5DaGFubmVsUHJvdmlkZXIuc2V0UHJvdmlkZXJSZW1vdmFsKGNoYW5uZWwsIHRoaXMucmVtb3ZlQ2hhbm5lbEZyb21Qcm92aWRlck1hcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNsaWVudE9mZmVyKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2xzID0gdGhpcy5wcm90b2NvbE1hbmFnZXIuZ2V0Q2xpZW50UHJvdG9jb2xzKG9wdGlvbnM/LnByb3RvY29scyk7XG4gICAgICAgIGxldCBydGNQYWNrZXQ7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZFByb3RvY29scyA9IGF3YWl0IFByb21pc2UuYWxsKHByb3RvY29scy5tYXAoYXN5bmMgKHR5cGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3J0Yyc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBydGNDbGllbnQsIGNoYW5uZWxzLCBvZmZlciwgcnRjQ29ubmVjdGlvbklkLCBjaGFubmVsc09wZW5lZCB9ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ4KHRoaXMsIF9Db25uZWN0aW9uTWFuYWdlcl9ydGNDb25uZWN0aW9uTWFuYWdlciwgXCJmXCIpLnN0YXJ0Q2xpZW50T2ZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcnRjUGFja2V0ID0geyBydGNDbGllbnQsIGNoYW5uZWxzLCBjaGFubmVsc09wZW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J0YycsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBzdHJhdGVneV8yLlJUQ0luZm8udmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgb2ZmZXIsIHJ0Y0Nvbm5lY3Rpb25JZCB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzaWMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY2xhc3NpYycsIHZlcnNpb246IHN0cmF0ZWd5XzEuQ2xhc3NpY0luZm8udmVyc2lvbiB9O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZXhoYXVzdGl2ZV8xLmV4aGF1c3RpdmVDaGVjaykodHlwZSwgWydydGMnLCAnY2xhc3NpYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2ZmZXI6IHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRQcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgbWF4UHJvdG9jb2xzOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnRjOiBydGNQYWNrZXRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ2xpZW50U3RyYXRlZ3kocnRjUGFja2V0LCByb3V0aW5nSW5mbykge1xuICAgICAgICBpZiAoIXJvdXRpbmdJbmZvLmVuZHBvaW50SWQpIHtcbiAgICAgICAgICAgIHJvdXRpbmdJbmZvLmVuZHBvaW50SWQgPSB0aGlzLndpcmUuZW52aXJvbm1lbnQuZ2V0TmV4dE1lc3NhZ2VJZCgpO1xuICAgICAgICAgICAgLy8gRm9yIE5ldyBDbGllbnRzIGNvbm5lY3RpbmcgdG8gT2xkIFByb3ZpZGVycy4gVG8gcHJldmVudCBtdWx0aS1kaXNwYXRjaGluZyBhbmQgcHVibGlzaGluZywgd2UgZGVsZXRlIHByZXZpb3VzbHktY29ubmVjdGVkXG4gICAgICAgICAgICAvLyBjbGllbnRzIHRoYXQgYXJlIGluIHRoZSBzYW1lIGNvbnRleHQgYXMgdGhlIG5ld2x5LWNvbm5lY3RlZCBjbGllbnQuXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDgodGhpcywgX0Nvbm5lY3Rpb25NYW5hZ2VyX21lc3NhZ2VSZWNlaXZlciwgXCJmXCIpLmNoZWNrRm9yUHJldmlvdXNDbGllbnRDb25uZWN0aW9uKHJvdXRpbmdJbmZvLmNoYW5uZWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5zd2VyID0gcm91dGluZ0luZm8uYW5zd2VyID8/IHtcbiAgICAgICAgICAgIHN1cHBvcnRlZFByb3RvY29sczogW3sgdHlwZTogJ2NsYXNzaWMnLCB2ZXJzaW9uOiAxIH1dXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNyZWF0ZVN0cmF0ZWd5RnJvbUFuc3dlciA9IGFzeW5jIChwcm90b2NvbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3RvY29sLnR5cGUgPT09ICdydGMnICYmIHJ0Y1BhY2tldCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkOCh0aGlzLCBfQ29ubmVjdGlvbk1hbmFnZXJfcnRjQ29ubmVjdGlvbk1hbmFnZXIsIFwiZlwiKS5maW5pc2hDbGllbnRPZmZlcihydGNQYWNrZXQucnRjQ2xpZW50LCBwcm90b2NvbC5wYXlsb2FkLmFuc3dlciwgcnRjUGFja2V0LmNoYW5uZWxzT3BlbmVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0cmF0ZWd5XzIuUlRDU3RyYXRlZ3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm90b2NvbC50eXBlID09PSAnY2xhc3NpYycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0cmF0ZWd5XzEuQ2xhc3NpY1N0cmF0ZWd5KHRoaXMud2lyZSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ4KHRoaXMsIF9Db25uZWN0aW9uTWFuYWdlcl9tZXNzYWdlUmVjZWl2ZXIsIFwiZlwiKSwgcm91dGluZ0luZm8uZW5kcG9pbnRJZCwgcm91dGluZ0luZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFsbFByb3RvY29scyA9IChhd2FpdCBQcm9taXNlLmFsbChhbnN3ZXIuc3VwcG9ydGVkUHJvdG9jb2xzLm1hcChjcmVhdGVTdHJhdGVneUZyb21BbnN3ZXIpKSkuZmlsdGVyKCh4KSA9PiB4ICE9PSBudWxsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgbG9naWMgaWYgcHJvdmlkZXIgZGlkbid0IHN1cHBvcnQgcnRjLlxuICAgICAgICBpZiAocnRjUGFja2V0ICYmICFhbGxQcm90b2NvbHMuc29tZSgoeCkgPT4geCBpbnN0YW5jZW9mIHN0cmF0ZWd5XzIuUlRDU3RyYXRlZ3kpKSB7XG4gICAgICAgICAgICBpZiAocnRjUGFja2V0KSB7XG4gICAgICAgICAgICAgICAgcnRjUGFja2V0LnJ0Y0NsaWVudC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJhdGVneTtcbiAgICAgICAgaWYgKGFsbFByb3RvY29scy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgc3RyYXRlZ3kgPSBzdHJhdGVneV8zLmRlZmF1bHQuY29tYmluZShhbGxQcm90b2NvbHNbMF0sIGFsbFByb3RvY29sc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsUHJvdG9jb2xzLmxlbmd0aCkge1xuICAgICAgICAgICAgW3N0cmF0ZWd5XSA9IGFsbFByb3RvY29scztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb21wYXRpYmxlIHByb3RvY29scycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzIGNhc3RpbmcgcnRjUGFja2V0IGJlY2F1c2Ugd2Ugd29uJ3QgaGF2ZSBhbiBydGNTdHJhdGVneSBpZiBydGNQYWNrZXQgaXMgdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBlbmRwb2ludFBheWxvYWQgPSB7IGVuZHBvaW50SWRlbnRpdHk6IHJvdXRpbmdJbmZvLCBydGM6IHJ0Y1BhY2tldCB9O1xuICAgICAgICBzdHJhdGVneS5hZGRFbmRwb2ludChyb3V0aW5nSW5mby5jaGFubmVsSWQsIGVuZHBvaW50UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxDb25uZWN0aW9uKG1zZykge1xuICAgICAgICBjb25zdCB7IGNsaWVudElkZW50aXR5LCBwcm92aWRlcklkZW50aXR5LCBhY2tUb1NlbmRlciwgcGF5bG9hZCwgb2ZmZXI6IGNsaWVudE9mZmVyIH0gPSBtc2cucGF5bG9hZDtcbiAgICAgICAgaWYgKCFjbGllbnRJZGVudGl0eS5lbmRwb2ludElkKSB7XG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgcG9seWZpbGxlZCBieSBjb3JlIGJ1dCBub3QgaW4gY2FzZXMgb2Ygbm9kZSBjb25uZWN0aW5nIHRvIGFuIG9sZCBydW50aW1lLlxuICAgICAgICAgICAgY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCA9IHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXROZXh0TWVzc2FnZUlkKCk7XG4gICAgICAgICAgICBjbGllbnRJZGVudGl0eS5pc0xvY2FsRW5kcG9pbnRJZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRJZGVudGl0eS5pc0xvY2FsRW5kcG9pbnRJZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3ZpZGVySWRlbnRpdHkuY2hhbm5lbElkO1xuICAgICAgICBjb25zdCBidXMgPSB0aGlzLnByb3ZpZGVyTWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWJ1cykge1xuICAgICAgICAgICAgYWNrVG9TZW5kZXIucGF5bG9hZC5zdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnJlYXNvbiA9IGBDaGFubmVsIFwiJHtwcm92aWRlcklkZW50aXR5LmNoYW5uZWxOYW1lfVwiIGhhcyBiZWVuIGRlc3Ryb3llZC5gO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kUmF3KGFja1RvU2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBzdHJhdGVneSwgc3VwcG9ydGVkUHJvdG9jb2xzIH0gPSBidXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIShwcm92aWRlciBpbnN0YW5jZW9mIHByb3ZpZGVyXzEkMS5DaGFubmVsUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb25uZWN0IHRvIGEgY2hhbm5lbCBjbGllbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gY2xpZW50T2ZmZXIgPz8ge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZFByb3RvY29sczogW3sgdHlwZTogJ2NsYXNzaWMnLCB2ZXJzaW9uOiAxIH1dLFxuICAgICAgICAgICAgICAgIG1heFByb3RvY29sczogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nUHJvdG9jb2xzID0gdGhpcy5wcm90b2NvbE1hbmFnZXIuZ2V0Q29tcGF0aWJsZVByb3RvY29scyhzdXBwb3J0ZWRQcm90b2NvbHMsIG9mZmVyKTtcbiAgICAgICAgICAgIGlmICghb3ZlcmxhcHBpbmdQcm90b2NvbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYW55IG9mIHRoZSBvZmZlcmVkIHByb3RvY29scy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHByb3ZpZGVyLnByb2Nlc3NDb25uZWN0aW9uKGNsaWVudElkZW50aXR5LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCA9IGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCB8fCB7fTtcbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc3VwcG9ydGVkIHByb3RvY29scyBhbmQgYWNjdW11bGF0ZSB0aGVtIGludG8gdGhlIGFuc3dlclxuICAgICAgICAgICAgLy8gYWRkRW5kcG9pbnQgaXMgdHJpY2t5IGJ1dCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGNoYW5uZWwgcmVzb2x1dGlvbiBiZWZvcmUgYWRkaW5nIHRoZSBlbmRwb2ludC5cbiAgICAgICAgICAgIGxldCBjbGllbnRBbnN3ZXIgPSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkUHJvdG9jb2xzOiBbXSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludFBheWxvYWRQcm9taXNlOiBQcm9taXNlLnJlc29sdmUoeyBlbmRwb2ludElkZW50aXR5OiBjbGllbnRJZGVudGl0eSB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsaWVudEFuc3dlciA9IGF3YWl0IG92ZXJsYXBwaW5nUHJvdG9jb2xzLnJlZHVjZShhc3luYyAoYWNjdW1QLCBwcm90b2NvbFRvVXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgYWNjdW1QO1xuICAgICAgICAgICAgICAgIGlmIChwcm90b2NvbFRvVXNlLnR5cGUgPT09ICdydGMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYW5zd2VyOiBydGNBbnN3ZXIsIHJ0Y0NsaWVudCwgY2hhbm5lbHMgfSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkOCh0aGlzLCBfQ29ubmVjdGlvbk1hbmFnZXJfcnRjQ29ubmVjdGlvbk1hbmFnZXIsIFwiZlwiKS5jcmVhdGVQcm92aWRlckFuc3dlcihwcm90b2NvbFRvVXNlLnBheWxvYWQucnRjQ29ubmVjdGlvbklkLCBwcm90b2NvbFRvVXNlLnBheWxvYWQub2ZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBhbnN3ZXIuc3VwcG9ydGVkUHJvdG9jb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J0YycsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBzdHJhdGVneV8yLlJUQ0luZm8udmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnN3ZXI6IHJ0Y0Fuc3dlclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyLmVuZHBvaW50UGF5bG9hZFByb21pc2UgPSBhbnN3ZXIuZW5kcG9pbnRQYXlsb2FkUHJvbWlzZS50aGVuKChlbmRwb2ludFBheWxvYWQpID0+IGNoYW5uZWxzLnRoZW4oKHJlc29sdmVkQ2hhbm5lbHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZW5kcG9pbnRQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ0Yzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydGNDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzOiByZXNvbHZlZENoYW5uZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyLnN1cHBvcnRlZFByb3RvY29scy5wdXNoKHsgdHlwZTogJ2NsYXNzaWMnLCB2ZXJzaW9uOiBzdHJhdGVneV8xLkNsYXNzaWNJbmZvLnZlcnNpb24gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoY2xpZW50QW5zd2VyKSk7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGFzIGNhc3QgaGVyZS5cbiAgICAgICAgICAgIGNsaWVudEFuc3dlci5lbmRwb2ludFBheWxvYWRQcm9taXNlLnRoZW4oKGVuZHBvaW50UGF5bG9hZCkgPT4gc3RyYXRlZ3kuYWRkRW5kcG9pbnQoY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCwgZW5kcG9pbnRQYXlsb2FkKSk7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnBheWxvYWQucmVzdWx0ID0gcmVzO1xuICAgICAgICAgICAgYWNrVG9TZW5kZXIucGF5bG9hZC5wYXlsb2FkLmFuc3dlciA9IGNsaWVudEFuc3dlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZFJhdyhhY2tUb1NlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQuc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgYWNrVG9TZW5kZXIucGF5bG9hZC5yZWFzb24gPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRSYXcoYWNrVG9TZW5kZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29ubmVjdGlvbk1hbmFnZXIuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbl9Db25uZWN0aW9uTWFuYWdlcl9tZXNzYWdlUmVjZWl2ZXIgPSBuZXcgV2Vha01hcCgpLCBfQ29ubmVjdGlvbk1hbmFnZXJfcnRjQ29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEVudHJ5IHBvaW50cyBmb3IgdGhlIGBDaGFubmVsYCBzdWJzZXQgb2YgdGhlIGBJbnRlckFwcGxpY2F0aW9uQnVzYCBBUEkgKGBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsYCkuXG4gKlxuICogKiB7QGxpbmsgQ2hhbm5lbH0gY29udGFpbnMgc3RhdGljIG1lbWJlcnMgb2YgdGhlIGBDaGFubmVsYCBBUEksIGFjY2Vzc2libGUgdGhyb3VnaCBgZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbGAuXG4gKiAqIHtAbGluayBPcGVuRmluLkNoYW5uZWxDbGllbnR9IGRlc2NyaWJlcyBhIGNsaWVudCBvZiBhIGNoYW5uZWwsIGUuZy4gYXMgcmV0dXJuZWQgYnkgYGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY29ubmVjdGAuXG4gKiAqIHtAbGluayBPcGVuRmluLkNoYW5uZWxQcm92aWRlcn0gZGVzY3JpYmVzIGEgcHJvdmlkZXIgb2YgYSBjaGFubmVsLCBlLmcuIGFzIHJldHVybmVkIGJ5IGBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNyZWF0ZWAuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDUgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkNyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9DaGFubmVsX2Nvbm5lY3Rpb25NYW5hZ2VyLCBfQ2hhbm5lbF9pbnRlcm5hbEVtaXR0ZXIsIF9DaGFubmVsX3JlYWR5VG9Db25uZWN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoYW5uZWwkMSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jaGFubmVsJDEuQ2hhbm5lbCA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmNvbnN0IGV2ZW50c18xJDUgPSByZXF1aXJlJCQwO1xuY29uc3QgbGF6eV8xJDEgPSBsYXp5O1xuY29uc3QgYmFzZV8xJGYgPSBiYXNlO1xuY29uc3QgY2xpZW50XzEgPSBjbGllbnQ7XG5jb25zdCBjb25uZWN0aW9uX21hbmFnZXJfMSA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xuY29uc3QgcHJvdmlkZXJfMSA9IHByb3ZpZGVyO1xuZnVuY3Rpb24gcmV0cnlEZWxheShjb3VudCkge1xuICAgIGNvbnN0IGludGVydmFsID0gNTAwOyAvLyBiYXNlIGRlbGF5XG4gICAgY29uc3Qgc3RlcHMgPSAxMDsgLy8gSG93IG1hbnkgcmV0cmllcyB0byBkbyBiZWZvcmUgaW5jcmVtZW50aW5nIHRoZSBkZWxheVxuICAgIGNvbnN0IGJhc2UgPSAyOyAvLyBIb3cgbXVjaCB0byBtdWx0aXBseSB0aGUgcHJldmlvdXMgZGVsYXkgYnlcbiAgICBjb25zdCBtYXggPSAzMDAwMDsgLy8gbWF4IGRlbGF5XG4gICAgY29uc3Qgc3RlcCA9IE1hdGguZmxvb3IoY291bnQgLyBzdGVwcyk7XG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihtYXgsIGludGVydmFsICogYmFzZSAqKiBzdGVwKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgQ2hhbm5lbCBBUEkgYWxsb3dzIGFuIE9wZW5GaW4gYXBwbGljYXRpb24gdG8gY3JlYXRlIGEgY2hhbm5lbCBhcyBhIHtAbGluayBDaGFubmVsUHJvdmlkZXIgQ2hhbm5lbFByb3ZpZGVyfSxcbiAqIG9yIGNvbm5lY3QgdG8gYSBjaGFubmVsIGFzIGEge0BsaW5rIENoYW5uZWxDbGllbnQgQ2hhbm5lbENsaWVudH0uXG4gKiBAcmVtYXJrcyBUaGUgXCJoYW5kc2hha2VcIiBiZXR3ZWVuIHRoZSBjb21tdW5pY2F0aW9uIHBhcnRuZXJzIGlzXG4gKiBzaW1wbGlmaWVkIHdoZW4gdXNpbmcgYSBjaGFubmVsLiAgQSByZXF1ZXN0IHRvIGNvbm5lY3QgdG8gYSBjaGFubmVsIGFzIGEgY2xpZW50IHdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmL3doZW4gdGhlIGNoYW5uZWwgaGFzIGJlZW4gY3JlYXRlZC4gQm90aCB0aGVcbiAqIHByb3ZpZGVyIGFuZCBjbGllbnQgY2FuIGRpc3BhdGNoIGFjdGlvbnMgdGhhdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBvbiB0aGVpciBvcHBvc2l0ZXMsIGFuZCBkaXNwYXRjaCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBwYXlsb2FkIGZyb20gdGhlIG90aGVyXG4gKiBjb21tdW5pY2F0aW9uIHBhcnRpY2lwYW50LiBUaGVyZSBjYW4gYmUgb25seSBvbmUgcHJvdmlkZXIgcGVyIGNoYW5uZWwsIGJ1dCBtYW55IGNsaWVudHMuICBWZXJzaW9uIGA5LjYxLjM1LipgIG9yIGxhdGVyIGlzIHJlcXVpcmVkIGZvciBib3RoIGNvbW11bmljYXRpb24gcGFydG5lcnMuXG4gKlxuICogQXN5bmNocm9ub3VzIE1ldGhvZHM6XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbC5jcmVhdGUgY3JlYXRlKGNoYW5uZWxOYW1lLCBvcHRpb25zKX1cbiAqICAqIHtAbGluayBDaGFubmVsLmNvbm5lY3QgY29ubmVjdChjaGFubmVsTmFtZSwgb3B0aW9ucyl9XG4gKiAgKiB7QGxpbmsgQ2hhbm5lbC5vbkNoYW5uZWxDb25uZWN0IG9uQ2hhbm5lbENvbm5lY3QobGlzdGVuZXIpfVxuICogICoge0BsaW5rIENoYW5uZWwub25DaGFubmVsRGlzY29ubmVjdCBvbkNoYW5uZWxEaXNjb25uZWN0KGxpc3RlbmVyKX1cbiAqL1xuY2xhc3MgQ2hhbm5lbCBleHRlbmRzIGJhc2VfMSRmLkVtaXR0ZXJCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aXJlKSB7XG4gICAgICAgIHN1cGVyKHdpcmUsICdjaGFubmVsJyk7XG4gICAgICAgIF9DaGFubmVsX2Nvbm5lY3Rpb25NYW5hZ2VyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ2hhbm5lbF9pbnRlcm5hbEVtaXR0ZXIuc2V0KHRoaXMsIG5ldyBldmVudHNfMSQ1LkV2ZW50RW1pdHRlcigpKTtcbiAgICAgICAgLy8gT3BlbkZpbiBBUEkgaGFzIG5vdCBiZWVuIGluamVjdGVkIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCAqbXVzdCogd2FpdCBmb3IgQVBJIHRvIGJlIHJlYWR5LlxuICAgICAgICBfQ2hhbm5lbF9yZWFkeVRvQ29ubmVjdC5zZXQodGhpcywgbmV3IGxhenlfMSQxLkFzeW5jUmV0cnlhYmxlTGF6eShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5vbignZGlzY29ubmVjdGVkJywgKGV2ZW50UGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRfMS5DaGFubmVsQ2xpZW50LmhhbmRsZVByb3ZpZGVyRGlzY29ubmVjdChldmVudFBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Nvbm5lY3RlZCcsICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkNyh0aGlzLCBfQ2hhbm5lbF9pbnRlcm5hbEVtaXR0ZXIsIFwiZlwiKS5lbWl0KCdjb25uZWN0ZWQnLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSkuY2F0Y2goKCkgPT4gbmV3IEVycm9yKCdlcnJvciBzZXR0aW5nIHVwIGNoYW5uZWwgY29ubmVjdGlvbiBsaXN0ZW5lcnMnKSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQ1KHRoaXMsIF9DaGFubmVsX2Nvbm5lY3Rpb25NYW5hZ2VyLCBuZXcgY29ubmVjdGlvbl9tYW5hZ2VyXzEuQ29ubmVjdGlvbk1hbmFnZXIod2lyZSksIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBbGxDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYWxsLWNoYW5uZWxzJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbnMgZm9yIGNoYW5uZWwgY29ubmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgbGlzdGVuZXIgPSAoY2hhbm5lbFBheWxvYWQpID0+IGNvbnNvbGUubG9nKGNoYW5uZWxQYXlsb2FkKTsgLy8gc2VlIHJldHVybiB2YWx1ZSBiZWxvd1xuICAgICAqXG4gICAgICogZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5vbkNoYW5uZWxDb25uZWN0KGxpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqIC8vIGV4YW1wbGUgc2hhcGVcbiAgICAgKiB7XG4gICAgICogICAgIFwidG9waWNcIjogXCJjaGFubmVsXCIsXG4gICAgICogICAgIFwidHlwZVwiOiBcImNvbm5lY3RlZFwiLFxuICAgICAqICAgICBcInV1aWRcIjogXCJPcGVuZmluUE9DXCIsXG4gICAgICogICAgIFwibmFtZVwiOiBcIk9wZW5maW5QT0NcIixcbiAgICAgKiAgICAgXCJjaGFubmVsTmFtZVwiOiBcImNvdW50ZXJcIixcbiAgICAgKiAgICAgXCJjaGFubmVsSWRcIjogXCJPcGVuZmluUE9DL09wZW5maW5QT0MvY291bnRlclwiXG4gICAgICogfVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgb25DaGFubmVsQ29ubmVjdChsaXN0ZW5lcikge1xuICAgICAgICBhd2FpdCB0aGlzLm9uKCdjb25uZWN0ZWQnLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgY2hhbm5lbCBkaXNjb25uZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIGNhbGxiYWNrIHRvIGV4ZWN1dGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsaXN0ZW5lciA9IChjaGFubmVsUGF5bG9hZCkgPT4gY29uc29sZS5sb2coY2hhbm5lbFBheWxvYWQpOyAvLyBzZWUgcmV0dXJuIHZhbHVlIGJlbG93XG4gICAgICpcbiAgICAgKiBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLm9uQ2hhbm5lbERpc2Nvbm5lY3QobGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogLy8gZXhhbXBsZSBzaGFwZVxuICAgICAqIHtcbiAgICAgKiAgICAgXCJ0b3BpY1wiOiBcImNoYW5uZWxcIixcbiAgICAgKiAgICAgXCJ0eXBlXCI6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgICogICAgIFwidXVpZFwiOiBcIk9wZW5maW5QT0NcIixcbiAgICAgKiAgICAgXCJuYW1lXCI6IFwiT3BlbmZpblBPQ1wiLFxuICAgICAqICAgICBcImNoYW5uZWxOYW1lXCI6IFwiY291bnRlclwiLFxuICAgICAqICAgICBcImNoYW5uZWxJZFwiOiBcIk9wZW5maW5QT0MvT3BlbmZpblBPQy9jb3VudGVyXCJcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBvbkNoYW5uZWxEaXNjb25uZWN0KGxpc3RlbmVyKSB7XG4gICAgICAgIGF3YWl0IHRoaXMub24oJ2Rpc2Nvbm5lY3RlZCcsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgYXN5bmMgc2FmZUNvbm5lY3QoY2hhbm5lbE5hbWUsIHNob3VsZFdhaXQsIGNvbm5lY3RQYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHJldHJ5SW5mbyA9IHsgY291bnQ6IDAgfTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tYXdhaXQtaW4tbG9vcCwgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIHNldHVwIGEgbGlzdGVuZXIgYW5kIGEgY29ubmVjdGVkIHByb21pc2UgdG8gYXdhaXQgaW4gY2FzZSB3ZSBjb25uZWN0IGJlZm9yZSB0aGUgY2hhbm5lbCBpcyByZWFkeVxuICAgICAgICAgICAgbGV0IGNvbm5lY3RlZExpc3RlbmVyID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkTGlzdGVuZXIgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbE5hbWUgPT09IHBheWxvYWQuY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkNyh0aGlzLCBfQ2hhbm5lbF9pbnRlcm5hbEVtaXR0ZXIsIFwiZlwiKS5vbignY29ubmVjdGVkJywgY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRyeUluZm8uY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGF5IHJldHVybnMgZmFsc2UgY29ubmVjdGVkUHJvbWlzZSByZXR1cm5zIHRydWUgc28gd2UgY2FuIGtub3cgaWYgYSByZXRyeSBpcyBkdWUgdG8gY29ubmVjdGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5SW5mby5nb3RDb25uZWN0ZWRFdmVudCA9IGF3YWl0IFByb21pc2UucmFjZShbcmV0cnlEZWxheShyZXRyeUluZm8uY291bnQpLCBjb25uZWN0ZWRQcm9taXNlXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjb25uZWN0LXRvLWNoYW5uZWwnLCB7IC4uLmNvbm5lY3RQYXlsb2FkLCByZXRyeUluZm8gfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZyBvbmx5IGlmIHRoZXJlIHdhcyBhIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvIGNoYW5uZWxOYW1lOiAke2NoYW5uZWxOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VuZCByZXRyeUluZm8gdG8gdGhlIGNvcmUgZm9yIGRlYnVnIGxvZyBpbmNsdXNpb25cbiAgICAgICAgICAgICAgICBjb25zdCBzZW50TWVzc2FnZVByb21pc2UgPSB0aGlzLndpcmUuc2VuZEFjdGlvbignY29ubmVjdC10by1jaGFubmVsJywgY29ubmVjdFBheWxvYWQpO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgbWVzc2FnZUlkIGZyb20gdGhlIGZpcnN0IGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgICAgICAgICAgICAgIHJldHJ5SW5mby5vcmlnaW5hbE1lc3NhZ2VJZCA9IHNlbnRNZXNzYWdlUHJvbWlzZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VudE1lc3NhZ2VQcm9taXNlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucGF5bG9hZC5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdpbnRlcm5hbC1uYWNrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFuIGludGVybmFsIG5hY2ssIGJyZWFrIHRoZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkV2FpdCAmJiByZXRyeUluZm8uY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgd2FpdGluZyBvbiB0aGUgbmV4dCBpdGVyYXRpb24sIHdhcm4gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBObyBjaGFubmVsIGZvdW5kIGZvciBjaGFubmVsTmFtZTogJHtjaGFubmVsTmFtZX0uIFdhaXRpbmcgZm9yIGNvbm5lY3Rpb24uLi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZXRyeUluZm8uY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIG90aGVyIGVycm9ycywgcmVtb3ZlIG91ciBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkNyh0aGlzLCBfQ2hhbm5lbF9pbnRlcm5hbEVtaXR0ZXIsIFwiZlwiKS5yZW1vdmVMaXN0ZW5lcignY29ubmVjdGVkJywgY29ubmVjdGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChzaG91bGRXYWl0KTsgLy8gSWYgd2UncmUgd2FpdGluZyB3ZSByZXRyeSB0aGUgYWJvdmUgbG9vcFxuICAgICAgICAvLyBTaG91bGQgd2FpdCB3YXMgZmFsc2UsIG5vIGNoYW5uZWwgd2FzIGZvdW5kLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoYW5uZWwgZm91bmQgZm9yIGNoYW5uZWxOYW1lOiAke2NoYW5uZWxOYW1lfS5gKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1hd2FpdC1pbi1sb29wLCBuby1jb25zdGFudC1jb25kaXRpb24gKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byBhIGNoYW5uZWwuIElmIHlvdSB3aXNoIHRvIHNlbmQgYSBwYXlsb2FkIHRvIHRoZSBwcm92aWRlciwgYWRkIGEgcGF5bG9hZCBwcm9wZXJ0eSB0byB0aGUgb3B0aW9ucyBhcmd1bWVudC5cbiAgICAgKiBFWFBFUklNRU5UQUw6IHBhc3MgeyBwcm90b2NvbHM6IFsncnRjJ10gfSBhcyBvcHRpb25zIHRvIG9wdC1pbiB0byBIaWdoIFRocm91Z2hwdXQgQ2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbE5hbWUgLSBOYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIENoYW5uZWxDbGllbnQgQ2hhbm5lbENsaWVudH0uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBUaGUgY29ubmVjdGlvbiByZXF1ZXN0IHdpbGwgYmUgcm91dGVkIHRvIHRoZSBjaGFubmVsUHJvdmlkZXIgaWYvd2hlbiB0aGUgY2hhbm5lbCBpcyBjcmVhdGVkLiAgSWYgdGhlIGNvbm5lY3RcbiAgICAgKiByZXF1ZXN0IGlzIHNlbnQgcHJpb3IgdG8gY3JlYXRpb24sIHRoZSBwcm9taXNlIHdpbGwgbm90IHJlc29sdmUgb3IgcmVqZWN0IHVudGlsIHRoZSBjaGFubmVsIGlzIGNyZWF0ZWQgYnkgYSBjaGFubmVsUHJvdmlkZXJcbiAgICAgKiAod2hldGhlciBvciBub3QgdG8gd2FpdCBmb3IgY3JlYXRpb24gaXMgY29uZmlndXJhYmxlIGluIHRoZSBjb25uZWN0T3B0aW9ucykuXG4gICAgICpcbiAgICAgKiBUaGUgY29ubmVjdCBjYWxsIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdpdGggYSBjaGFubmVsQ2xpZW50IGJ1cyBpZiBhY2NlcHRlZCBieSB0aGUgY2hhbm5lbFByb3ZpZGVyLCBvciByZWplY3QgaWZcbiAgICAgKiB0aGUgY2hhbm5lbFByb3ZpZGVyIHRocm93cyBhbiBlcnJvciB0byByZWplY3QgdGhlIGNvbm5lY3Rpb24uIFRoaXMgYnVzIGNhbiBjb21tdW5pY2F0ZSB3aXRoIHRoZSBQcm92aWRlciwgYnV0IG5vdCB0byBvdGhlclxuICAgICAqIGNsaWVudHMgb24gdGhlIGNoYW5uZWwuIFVzaW5nIHRoZSBidXMsIHRoZSBjaGFubmVsQ2xpZW50IGNhbiByZWdpc3RlciBhY3Rpb25zIGFuZCBtaWRkbGV3YXJlLiBDaGFubmVsIGxpZmVjeWNsZSBjYW4gYWxzbyBiZVxuICAgICAqIGhhbmRsZWQgd2l0aCBhbiBvbkRpc2Nvbm5lY3Rpb24gbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBhc3luYyBmdW5jdGlvbiBtYWtlQ2xpZW50KGNoYW5uZWxOYW1lKSB7XG4gICAgICogICAgLy8gQSBwYXlsb2FkIGNhbiBiZSBzZW50IGFsb25nIHdpdGggY2hhbm5lbCBjb25uZWN0aW9uIHJlcXVlc3RzIHRvIGhlbHAgd2l0aCBhdXRoZW50aWNhdGlvblxuICAgICAqICAgIGNvbnN0IGNvbm5lY3RQYXlsb2FkID0geyBwYXlsb2FkOiAndG9rZW4nIH07XG4gICAgICpcbiAgICAgKiAgICAvLyBJZiB0aGUgY2hhbm5lbCBoYXMgYmVlbiBjcmVhdGVkIHRoaXMgcmVxdWVzdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHByb3ZpZGVyLiAgSWYgbm90LCB0aGVcbiAgICAgKiAgICAvLyBwcm9taXNlIHdpbGwgbm90IGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIHVudGlsIHRoZSBjaGFubmVsIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogICAgY29uc3QgY2xpZW50QnVzID0gYXdhaXQgZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jb25uZWN0KGNoYW5uZWxOYW1lLCBjb25uZWN0UGF5bG9hZCk7XG4gICAgICpcbiAgICAgKiAgICBjbGllbnRCdXMub25EaXNjb25uZWN0aW9uKGNoYW5uZWxJbmZvID0+IHtcbiAgICAgKiAgICAgICAgLy8gaGFuZGxlIHRoZSBjaGFubmVsIGxpZmVjeWNsZSBoZXJlIC0gd2UgY2FuIGNvbm5lY3QgYWdhaW4gd2hpY2ggd2lsbCByZXR1cm4gYSBwcm9taXNlXG4gICAgICogICAgICAgIC8vIHRoYXQgd2lsbCByZXNvbHZlIGlmL3doZW4gdGhlIGNoYW5uZWwgaXMgcmUtY3JlYXRlZC5cbiAgICAgKiAgICAgICAgbWFrZUNsaWVudChjaGFubmVsSW5mby5jaGFubmVsTmFtZSk7XG4gICAgICogICAgfSlcbiAgICAgKlxuICAgICAqICAgIGNsaWVudEJ1cy5yZWdpc3RlcigndG9waWMnLCAocGF5bG9hZCwgaWRlbnRpdHkpID0+IHtcbiAgICAgKiAgICAgICAgLy8gcmVnaXN0ZXIgYSBjYWxsYmFjayBmb3IgYSB0b3BpYyB0byB3aGljaCB0aGUgY2hhbm5lbCBwcm92aWRlciBjYW4gZGlzcGF0Y2ggYW4gYWN0aW9uXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKCdBY3Rpb24gZGlzcGF0Y2hlZCBieSBwcm92aWRlcjogJywgSlNPTi5zdHJpbmdpZnkoaWRlbnRpdHkpKTtcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coJ1BheWxvYWQgc2VudCBpbiBkaXNwYXRjaDogJywgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAqICAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgICAgZWNobzogcGF5bG9hZFxuICAgICAqICAgICAgICB9O1xuICAgICAqICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIG1ha2VDbGllbnQoJ2NoYW5uZWxOYW1lJylcbiAgICAgKiAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQ29ubmVjdGVkJykpXG4gICAgICogLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QoY2hhbm5lbE5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgY29ubmVjdCBiZWZvcmUgbGlzdGVuZXJzIGFyZSBzZXQgdXBcbiAgICAgICAgLy8gVGhpcyBhbHNvIGVycm9ycyBpZiB3ZSdyZSBub3QgaW4gT3BlbkZpbiwgZW5zdXJpbmcgd2UgZG9uJ3QgcnVuIHVubmVjZXNzYXJ5IGNvZGVcbiAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ3KHRoaXMsIF9DaGFubmVsX3JlYWR5VG9Db25uZWN0LCBcImZcIikuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKCFjaGFubmVsTmFtZSB8fCB0eXBlb2YgY2hhbm5lbE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgY2hhbm5lbE5hbWUgc3RyaW5nIHRvIGNvbm5lY3QgdG8gYSBjaGFubmVsLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7IHdhaXQ6IHRydWUsIC4uLnRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXREZWZhdWx0Q2hhbm5lbE9wdGlvbnMoKS5jb25uZWN0LCAuLi5vcHRpb25zIH07XG4gICAgICAgIGNvbnN0IHsgb2ZmZXIsIHJ0YzogcnRjUGFja2V0IH0gPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDcodGhpcywgX0NoYW5uZWxfY29ubmVjdGlvbk1hbmFnZXIsIFwiZlwiKS5jcmVhdGVDbGllbnRPZmZlcihvcHRzKTtcbiAgICAgICAgbGV0IGNvbm5lY3Rpb25Vcmw7XG4gICAgICAgIGlmICh0aGlzLmZpbi5tZS5pc0ZyYW1lIHx8IHRoaXMuZmluLm1lLmlzVmlldyB8fCB0aGlzLmZpbi5tZS5pc1dpbmRvdykge1xuICAgICAgICAgICAgY29ubmVjdGlvblVybCA9IChhd2FpdCB0aGlzLmZpbi5tZS5nZXRJbmZvKCkpLnVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGNoYW5uZWxOYW1lLFxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIG9mZmVyLFxuICAgICAgICAgICAgY29ubmVjdGlvblVybFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3V0aW5nSW5mbyA9IGF3YWl0IHRoaXMuc2FmZUNvbm5lY3QoY2hhbm5lbE5hbWUsIG9wdHMud2FpdCwgY29ubmVjdFBheWxvYWQpO1xuICAgICAgICBjb25zdCBzdHJhdGVneSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkNyh0aGlzLCBfQ2hhbm5lbF9jb25uZWN0aW9uTWFuYWdlciwgXCJmXCIpLmNyZWF0ZUNsaWVudFN0cmF0ZWd5KHJ0Y1BhY2tldCwgcm91dGluZ0luZm8pO1xuICAgICAgICBjb25zdCBjaGFubmVsID0gbmV3IGNsaWVudF8xLkNoYW5uZWxDbGllbnQocm91dGluZ0luZm8sIHRoaXMud2lyZSwgc3RyYXRlZ3kpO1xuICAgICAgICAvLyBJdCBpcyB0aGUgY2xpZW50J3MgcmVzcG9uc2liaWxpdHkgdG8gaGFuZGxlIGVuZHBvaW50IGRpc2Nvbm5lY3Rpb24gdG8gdGhlIHByb3ZpZGVyLlxuICAgICAgICAvLyBJZiB0aGUgZW5kcG9pbnQgZGllcywgdGhlIGNsaWVudCB3aWxsIGZvcmNlIGEgZGlzY29ubmVjdGlvbiB0aHJvdWdoIHRoZSBjb3JlLlxuICAgICAgICAvLyBUaGUgcHJvdmlkZXIgZG9lcyBub3QgY2FyZSBhYm91dCBlbmRwb2ludCBkaXNjb25uZWN0aW9uLlxuICAgICAgICBzdHJhdGVneS5vbkVuZHBvaW50RGlzY29ubmVjdChyb3V0aW5nSW5mby5jaGFubmVsSWQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2hhbm5lbC5zZW5kRGlzY29ubmVjdEFjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgZGlzY29ubmVjdCBmb3IgY2xpZW50IHdpdGggdXVpZDogJHtyb3V0aW5nSW5mby51dWlkfSAvIG5hbWU6ICR7cm91dGluZ0luZm8ubmFtZX0gLyBlbmRwb2ludElkOiAke3JvdXRpbmdJbmZvLmVuZHBvaW50SWR9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY2xpZW50XzEuQ2hhbm5lbENsaWVudC5oYW5kbGVQcm92aWRlckRpc2Nvbm5lY3Qocm91dGluZ0luZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjaGFubmVsLlxuICAgICAqIFlvdSBtdXN0IHByb3ZpZGUgYSB1bmlxdWUgY2hhbm5lbE5hbWUuIElmIGEgY2hhbm5lbE5hbWUgaXMgbm90IHByb3ZpZGVkLCBvciBpdCBpcyBub3QgdW5pcXVlLCB0aGUgY3JlYXRpb24gd2lsbCBmYWlsLlxuICAgICAqIEVYUEVSSU1FTlRBTDogcGFzcyB7IHByb3RvY29sczogWydydGMnXSB9IGFzIG9wdGlvbnMgdG8gb3B0LWluIHRvIEhpZ2ggVGhyb3VnaHB1dCBDaGFubmVscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsTmFtZSAtIE5hbWUgb2YgdGhlIGNoYW5uZWwgdG8gYmUgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENyZWF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGluc3RhbmNlIG9mIHtAbGluayBDaGFubmVsUHJvdmlkZXIgQ2hhbm5lbFByb3ZpZGVyfS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIElmIHN1Y2Nlc3NmdWwsIHRoZSBjcmVhdGUgbWV0aG9kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gaW5zdGFuY2Ugb2YgdGhlIGNoYW5uZWxQcm92aWRlciBidXMuIFRoZSBjYWxsZXJcbiAgICAgKiB0aGVuIGJlY29tZXMgdGhlIOKAnGNoYW5uZWwgcHJvdmlkZXLigJ0gYW5kIGNhbiB1c2UgdGhlIGNoYW5uZWxQcm92aWRlciBidXMgdG8gcmVnaXN0ZXIgYWN0aW9ucyBhbmQgbWlkZGxld2FyZS5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsZXIgY2FuIGFsc28gc2V0IGFuIG9uQ29ubmVjdGlvbiBhbmQvb3Igb25EaXNjb25uZWN0aW9uIGxpc3RlbmVyIHRoYXQgd2lsbCBleGVjdXRlIG9uIGFueSBuZXcgY2hhbm5lbFxuICAgICAqIGNvbm5lY3Rpb24vZGlzY29ubmVjdGlvbiBhdHRlbXB0IGZyb20gYSBjaGFubmVsIGNsaWVudC4gVG8gcmVqZWN0IGEgY29ubmVjdGlvbiwgc2ltcGx5IHRocm93IGFuIGVycm9yIGluIHRoZVxuICAgICAqIG9uQ29ubmVjdGlvbiBsaXN0ZW5lci4gIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGFjY2VwdCBhbGwgbmV3IGNvbm5lY3Rpb25zLlxuICAgICAqXG4gICAgICogQSBtYXAgb2YgY2xpZW50IGNvbm5lY3Rpb25zIGlzIHVwZGF0ZWQgYXV0b21hdGljYWxseSBvbiBjbGllbnQgY29ubmVjdGlvbiBhbmQgZGlzY29ubmVjdGlvbiBhbmQgc2F2ZWQgaW4gdGhlXG4gICAgICogW3JlYWQtb25seV0gYGNvbm5lY3Rpb25zYCBwcm9wZXJ0eSBvbiB0aGUgY2hhbm5lbFByb3ZpZGVyIGJ1cy4gIFRoZSBjaGFubmVsIHdpbGwgZXhpc3QgdW50aWwgdGhlIHByb3ZpZGVyXG4gICAgICogZGVzdHJveXMgaXQgb3IgZGlzY29ubmVjdHMgYnkgY2xvc2luZyBvciBkZXN0cm95aW5nIHRoZSBjb250ZXh0IChuYXZpZ2F0aW5nIG9yIHJlbG9hZGluZykuIFRvIHNldHVwIGEgY2hhbm5lbFxuICAgICAqIGFzIGEgY2hhbm5lbFByb3ZpZGVyLCBjYWxsIGBDaGFubmVsLmNyZWF0ZWAgd2l0aCBhIHVuaXF1ZSBjaGFubmVsIG5hbWUuIEEgbWFwIG9mIGNsaWVudCBjb25uZWN0aW9ucyBpcyB1cGRhdGVkXG4gICAgICogYXV0b21hdGljYWxseSBvbiBjbGllbnQgY29ubmVjdGlvbiBhbmQgZGlzY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIChhc3luYyAoKT0+IHtcbiAgICAgKiAgICAvLyBlbnRpdHkgY3JlYXRlcyBhIGNoYW5uZWwgYW5kIGJlY29tZXMgdGhlIGNoYW5uZWxQcm92aWRlclxuICAgICAqICAgIGNvbnN0IHByb3ZpZGVyQnVzID0gYXdhaXQgZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jcmVhdGUoJ2NoYW5uZWxOYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICBwcm92aWRlckJ1cy5vbkNvbm5lY3Rpb24oKGlkZW50aXR5LCBwYXlsb2FkKSA9PiB7XG4gICAgICogICAgICAgIC8vIGNhbiByZWplY3QgYSBjb25uZWN0aW9uIGhlcmUgYnkgdGhyb3dpbmcgYW4gZXJyb3JcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coJ0NsaWVudCBjb25uZWN0aW9uIHJlcXVlc3QgaWRlbnRpdHk6ICcsIEpTT04uc3RyaW5naWZ5KGlkZW50aXR5KSk7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKCdDbGllbnQgY29ubmVjdGlvbiByZXF1ZXN0IHBheWxvYWQ6ICcsIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgKiAgICB9KTtcbiAgICAgKlxuICAgICAqICAgIHByb3ZpZGVyQnVzLnJlZ2lzdGVyKCd0b3BpYycsIChwYXlsb2FkLCBpZGVudGl0eSkgPT4ge1xuICAgICAqICAgICAgICAvLyByZWdpc3RlciBhIGNhbGxiYWNrIGZvciBhICd0b3BpYycgdG8gd2hpY2ggY2xpZW50cyBjYW4gZGlzcGF0Y2ggYW4gYWN0aW9uXG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKCdBY3Rpb24gZGlzcGF0Y2hlZCBieSBjbGllbnQ6ICcsIEpTT04uc3RyaW5naWZ5KGlkZW50aXR5KSk7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKCdQYXlsb2FkIHNlbnQgaW4gZGlzcGF0Y2g6ICcsIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgKiAgICAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICAgICAgIGVjaG86IHBheWxvYWRcbiAgICAgKiAgICAgICAgfTtcbiAgICAgKiAgICB9KTtcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgY2hhbm5lbE5hbWUgdG8gY3JlYXRlIGEgY2hhbm5lbCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhOiBwcm92aWRlcklkZW50aXR5IH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjcmVhdGUtY2hhbm5lbCcsIHsgY2hhbm5lbE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDcodGhpcywgX0NoYW5uZWxfY29ubmVjdGlvbk1hbmFnZXIsIFwiZlwiKS5jcmVhdGVQcm92aWRlcihvcHRpb25zLCBwcm92aWRlcklkZW50aXR5KTtcbiAgICAgICAgLy8gVE9ETzogZml4IHR5cGluZyAoaW50ZXJuYWwpXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgdGhpcy5vbignY2xpZW50LWRpc2Nvbm5lY3RlZCcsIChldmVudFBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudFBheWxvYWQuY2hhbm5lbE5hbWUgPT09IGNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfMS5DaGFubmVsUHJvdmlkZXIuaGFuZGxlQ2xpZW50RGlzY29ubmVjdGlvbihjaGFubmVsLCBldmVudFBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxufVxuY2hhbm5lbCQxLkNoYW5uZWwgPSBDaGFubmVsO1xuX0NoYW5uZWxfY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgV2Vha01hcCgpLCBfQ2hhbm5lbF9pbnRlcm5hbEVtaXR0ZXIgPSBuZXcgV2Vha01hcCgpLCBfQ2hhbm5lbF9yZWFkeVRvQ29ubmVjdCA9IG5ldyBXZWFrTWFwKCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlcmFwcGJ1cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5pbnRlcmFwcGJ1cy5JbnRlckFwcFBheWxvYWQgPSBpbnRlcmFwcGJ1cy5JbnRlckFwcGxpY2F0aW9uQnVzID0gdm9pZCAwO1xuLyoqXG4gKiBFbnRyeSBwb2ludCBmb3IgdGhlIE9wZW5GaW4gYEludGVyQXBwbGljYXRpb25CdXNgIEFQSSAoYGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzYCkuXG4gKlxuICogKiB7QGxpbmsgSW50ZXJBcHBsaWNhdGlvbkJ1c30gY29udGFpbnMgc3RhdGljIG1lbWJlcnMgb2YgdGhlIGBJbnRlckFwcGxpY2F0aW9uQnVzYCBBUEksIGFjY2Vzc2libGUgdGhyb3VnaCBgZmluLkludGVyQXBwbGljYXRpb25CdXNgLlxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5jb25zdCBldmVudHNfMSQ0ID0gcmVxdWlyZSQkMDtcbmNvbnN0IGJhc2VfMSRlID0gYmFzZTtcbmNvbnN0IHJlZl9jb3VudGVyXzEgPSByZWZDb3VudGVyO1xuY29uc3QgaW5kZXhfMSQyID0gY2hhbm5lbCQxO1xuY29uc3QgdmFsaWRhdGVfMSQzID0gdmFsaWRhdGU7XG4vKipcbiAqIEEgbWVzc2FnaW5nIGJ1cyB0aGF0IGFsbG93cyBmb3IgcHViL3N1YiBtZXNzYWdpbmcgYmV0d2VlbiBkaWZmZXJlbnQgYXBwbGljYXRpb25zLlxuICpcbiAqL1xuY2xhc3MgSW50ZXJBcHBsaWNhdGlvbkJ1cyBleHRlbmRzIGJhc2VfMSRlLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpcmUpIHtcbiAgICAgICAgc3VwZXIod2lyZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgc3Vic2NyaWJlckFkZGVkOiAnc3Vic2NyaWJlci1hZGRlZCcsXG4gICAgICAgICAgICBzdWJzY3JpYmVyUmVtb3ZlZDogJ3N1YnNjcmliZXItcmVtb3ZlZCdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWZDb3VudGVyID0gbmV3IHJlZl9jb3VudGVyXzEuUmVmQ291bnRlcigpO1xuICAgICAgICB0aGlzLkNoYW5uZWwgPSBuZXcgaW5kZXhfMSQyLkNoYW5uZWwod2lyZSk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBldmVudHNfMSQ0LkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB3aXJlLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIodGhpcy5vbm1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub24gPSB0aGlzLmVtaXR0ZXIub24uYmluZCh0aGlzLmVtaXR0ZXIpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyA9IHRoaXMuZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMuYmluZCh0aGlzLmVtaXR0ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgYSBtZXNzYWdlIHRvIGFsbCBhcHBsaWNhdGlvbnMgcnVubmluZyBvbiBPcGVuRmluIFJ1bnRpbWUgdGhhdFxuICAgICAqIGFyZSBzdWJzY3JpYmVkIHRvIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAgICogQHBhcmFtIHRvcGljIFRoZSB0b3BpYyBvbiB3aGljaCB0aGUgbWVzc2FnZSBpcyBzZW50XG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgcHVibGlzaGVkLiBDYW4gYmUgZWl0aGVyIGEgcHJpbWl0aXZlXG4gICAgICogZGF0YSB0eXBlIChzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbikgb3IgY29tcG9zaXRlIGRhdGEgdHlwZSAob2JqZWN0LCBhcnJheSlcbiAgICAgKiB0aGF0IGlzIGNvbXBvc2VkIG9mIG90aGVyIHByaW1pdGl2ZSBvciBjb21wb3NpdGUgZGF0YSB0eXBlc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLnB1Ymxpc2goJ3RvcGljJywgJ2hlbGxvJykudGhlbigoKSA9PiBjb25zb2xlLmxvZygnUHVibGlzaGVkJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBwdWJsaXNoKHRvcGljLCBtZXNzYWdlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwdWJsaXNoLW1lc3NhZ2UnLCB7XG4gICAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBzb3VyY2VXaW5kb3dOYW1lOiB0aGlzLm1lLm5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byBhIHNwZWNpZmljIGFwcGxpY2F0aW9uIG9uIGEgc3BlY2lmaWMgdG9waWMuXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uIFRoZSBpZGVudGl0eSBvZiB0aGUgYXBwbGljYXRpb24gdG8gd2hpY2ggdGhlIG1lc3NhZ2UgaXMgc2VudFxuICAgICAqIEBwYXJhbSB0b3BpYyBUaGUgdG9waWMgb24gd2hpY2ggdGhlIG1lc3NhZ2UgaXMgc2VudFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHNlbnQuIENhbiBiZSBlaXRoZXIgYSBwcmltaXRpdmUgZGF0YVxuICAgICAqIHR5cGUgKHN0cmluZywgbnVtYmVyLCBvciBib29sZWFuKSBvciBjb21wb3NpdGUgZGF0YSB0eXBlIChvYmplY3QsIGFycmF5KSB0aGF0XG4gICAgICogaXMgY29tcG9zZWQgb2Ygb3RoZXIgcHJpbWl0aXZlIG9yIGNvbXBvc2l0ZSBkYXRhIHR5cGVzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLkludGVyQXBwbGljYXRpb25CdXMuc2VuZChmaW4ubWUsICd0b3BpYycsICdIZWxsbyB0aGVyZSEnKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdNZXNzYWdlIHNlbnQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmQoZGVzdGluYXRpb24sIHRvcGljLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gKDAsIHZhbGlkYXRlXzEkMy52YWxpZGF0ZUlkZW50aXR5KShkZXN0aW5hdGlvbik7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2VuZC1tZXNzYWdlJywge1xuICAgICAgICAgICAgZGVzdGluYXRpb25VdWlkOiBkZXN0aW5hdGlvbi51dWlkLFxuICAgICAgICAgICAgZGVzdGluYXRpb25XaW5kb3dOYW1lOiBkZXN0aW5hdGlvbi5uYW1lLFxuICAgICAgICAgICAgdG9waWMsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgc291cmNlV2luZG93TmFtZTogdGhpcy5tZS5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG1lc3NhZ2VzIGZyb20gdGhlIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBvbiB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgVGhpcyBvYmplY3QgaXMgZGVzY3JpYmVkIGluIHRoZSBJZGVudGl0eSBpbiB0aGUgdHlwZWRlZlxuICAgICAqIEBwYXJhbSB0b3BpYyBUaGUgdG9waWMgb24gd2hpY2ggdGhlIG1lc3NhZ2UgaXMgc2VudFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBtZXNzYWdlIGhhc1xuICAgICAqIGJlZW4gcmVjZWl2ZWQuIEl0IGlzIHBhc3NlZCB0aGUgbWVzc2FnZSwgdXVpZCBhbmQgbmFtZSBvZiB0aGUgc2VuZGluZyBhcHBsaWNhdGlvbi5cbiAgICAgKiBUaGUgbWVzc2FnZSBjYW4gYmUgZWl0aGVyIGEgcHJpbWl0aXZlIGRhdGEgdHlwZSAoc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4pIG9yXG4gICAgICogY29tcG9zaXRlIGRhdGEgdHlwZSAob2JqZWN0LCBhcnJheSkgdGhhdCBpcyBjb21wb3NlZCBvZiBvdGhlciBwcmltaXRpdmUgb3IgY29tcG9zaXRlXG4gICAgICogZGF0YSB0eXBlc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIHN1YnNjcmliZSB0byBhIHNwZWNpZmllZCBhcHBsaWNhdGlvblxuICAgICAqIGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLnN1YnNjcmliZShmaW4ubWUsICd0b3BpYycsIHN1Yl9tc2cgPT4gY29uc29sZS5sb2coc3ViX21zZykpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1N1YnNjcmliZWQgdG8gdGhlIHNwZWNpZmllZCBhcHBsaWNhdGlvbicpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICpcbiAgICAgKiAvLyBzdWJzY3JpYmUgdG8gd2lsZGNhcmRcbiAgICAgKiBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5zdWJzY3JpYmUoeyB1dWlkOiAnKicgfSwgJ3RvcGljJywgc3ViX21zZyA9PiBjb25zb2xlLmxvZyhzdWJfbXNnKSkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnU3Vic2NyaWJlZCB0byAqJykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoc291cmNlLCB0b3BpYywgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViS2V5ID0gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb25LZXkoc291cmNlLnV1aWQsIHNvdXJjZS5uYW1lIHx8ICcqJywgdG9waWMpO1xuICAgICAgICBjb25zdCBzZW5kU3Vic2NyaXB0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3N1YnNjcmliZScsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VVdWlkOiBzb3VyY2UudXVpZCxcbiAgICAgICAgICAgICAgICBzb3VyY2VXaW5kb3dOYW1lOiBzb3VyY2UubmFtZSB8fCAnKicsXG4gICAgICAgICAgICAgICAgdG9waWMsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25XaW5kb3dOYW1lOiB0aGlzLm1lLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhbHJlYWR5U3Vic2NyaWJlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9uKHN1YktleSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZDb3VudGVyLmFjdE9uRmlyc3Qoc3ViS2V5LCBzZW5kU3Vic2NyaXB0aW9uLCBhbHJlYWR5U3Vic2NyaWJlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyB0byBtZXNzYWdlcyBmcm9tIHRoZSBzcGVjaWZpZWQgYXBwbGljYXRpb24gb24gdGhlIHNwZWNpZmllZCB0b3BpYy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIElmIHlvdSBhcmUgbGlzdGVuaW5nIHRvIGFsbCBhcHBzIG9uIGEgdG9waWMsIChpLmUgeW91IHBhc3NlZCBgeyB1dWlkOicqJyB9YCB0byB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uKVxuICAgICAqIHRoZW4geW91IG5lZWQgdG8gcGFzcyBgeyB1dWlkOicqJyB9YCB0byB1bnN1YnNjcmliZSBhcyB3ZWxsLiBJZiB5b3UgYXJlIGxpc3RlbmluZyB0byBhIHNwZWNpZmljIGFwcGxpY2F0aW9uLFxuICAgICAqIChpLmUgeW91IHBhc3NlZCBgeyB1dWlkOidzb21lX2FwcCcgfWAgdG8gdGhlIHN1YnNjcmliZSBmdW5jdGlvbikgdGhlbiB5b3UgbmVlZCB0byBwcm92aWRlIHRoZSBzYW1lIGlkZW50aWZpZXIgdG9cbiAgICAgKiB1bnN1YnNjcmliZSwgdW5zdWJzY3JpYmluZyB0byBgKmAgb24gdGhhdCBzYW1lIHRvcGljIHdpbGwgbm90IHVuaG9vayB5b3VyIGluaXRpYWwgbGlzdGVuZXIgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSBUaGlzIG9iamVjdCBpcyBkZXNjcmliZWQgaW4gdGhlIElkZW50aXR5IGluIHRoZSB0eXBlZGVmXG4gICAgICogQHBhcmFtIHRvcGljIFRoZSB0b3BpYyBvbiB3aGljaCB0aGUgbWVzc2FnZSBpcyBzZW50XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIEEgY2FsbGJhY2sgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggc3Vic2NyaWJlKClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsaXN0ZW5lciA9IGNvbnNvbGUubG9nO1xuICAgICAqXG4gICAgICogLy8gSWYgYW55IGFwcGxpY2F0aW9uIHB1Ymxpc2hlcyBhIG1lc3NhZ2Ugb24gdG9waWMgYGZvb2AsIG91ciBsaXN0ZW5lciB3aWxsIGJlIGNhbGxlZC5cbiAgICAgKiBhd2FpdCBmaW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5zdWJzY3JpYmUoeyB1dWlkOicqJyB9LCAnZm9vJywgbGlzdGVuZXIpXG4gICAgICpcbiAgICAgKiAvLyBXaGVuIHlvdSB3YW50IHRvIHVuc3Vic2NyaWJlLCB5b3UgbmVlZCB0byBzcGVjaWZ5IHRoZSB1dWlkIG9mIHRoZSBhcHAgeW91J2QgbGlrZSB0b1xuICAgICAqIC8vIHVuc3Vic2NyaWJlIGZyb20gKG9yIGAqYCkgYW5kIHByb3ZpZGUgdGhlIHNhbWUgZnVuY3Rpb24geW91IGdhdmUgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgICAqIGF3YWl0IGZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLnVuc3Vic2NyaWJlKHsgdXVpZDonKicgfSwgJ2ZvbycsIGxpc3RlbmVyKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKHNvdXJjZSwgdG9waWMsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVdpbmRvd05hbWUgPSBzb3VyY2UubmFtZSB8fCAnKic7XG4gICAgICAgIGNvbnN0IHN1YktleSA9IHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uS2V5KHNvdXJjZS51dWlkLCBzb3VyY2VXaW5kb3dOYW1lLCB0b3BpYyk7XG4gICAgICAgIGNvbnN0IHNlbmRVbnN1YnNjcmlwdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCd1bnN1YnNjcmliZScsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VVdWlkOiBzb3VyY2UudXVpZCxcbiAgICAgICAgICAgICAgICBzb3VyY2VXaW5kb3dOYW1lLFxuICAgICAgICAgICAgICAgIHRvcGljLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uV2luZG93TmFtZTogdGhpcy5tZS5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG9udFNlbmRVbnN1YnNjcmlwdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4gcikudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoc3ViS2V5LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZkNvdW50ZXIuYWN0T25MYXN0KHN1YktleSwgc2VuZFVuc3Vic2NyaXB0aW9uLCBkb250U2VuZFVuc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcHJvY2Vzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgbWVzc2FnZTogcGF5bG9hZE1lc3NhZ2UsIHNvdXJjZVdpbmRvd05hbWUsIHNvdXJjZVV1aWQsIHRvcGljIH0gfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbktleShzb3VyY2VVdWlkLCBzb3VyY2VXaW5kb3dOYW1lLCB0b3BpYyksXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbktleShzb3VyY2VVdWlkLCAnKicsIHRvcGljKSxcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uS2V5KCcqJywgJyonLCB0b3BpYylcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaWRPZlNlbmRlciA9IHsgdXVpZDogc291cmNlVXVpZCwgbmFtZTogc291cmNlV2luZG93TmFtZSB9O1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoa2V5LCBwYXlsb2FkTWVzc2FnZSwgaWRPZlNlbmRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWl0U3Vic2NyaXZlckV2ZW50KHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IHRhcmdldE5hbWU6IG5hbWUsIHV1aWQsIHRvcGljIH0gfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG5hbWUsIHV1aWQsIHRvcGljIH07XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KHR5cGUsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGNyZWF0ZVN1YnNjcmlwdGlvbktleSh1dWlkLCBuYW1lLCB0b3BpYykge1xuICAgICAgICBjb25zdCBuID0gbmFtZSB8fCAnKic7XG4gICAgICAgIGlmICghKHV1aWQgJiYgbiAmJiB0b3BpYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB1dWlkLCBuYW1lLCBvciB0b3BpYyBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlS2V5KHV1aWQsIG4sIHRvcGljKTtcbiAgICB9XG4gICAgb25tZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBhY3Rpb24gfSA9IG1lc3NhZ2U7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdwcm9jZXNzLW1lc3NhZ2UnOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuZXZlbnRzLnN1YnNjcmliZXJBZGRlZDpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRTdWJzY3JpdmVyRXZlbnQodGhpcy5ldmVudHMuc3Vic2NyaWJlckFkZGVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5ldmVudHMuc3Vic2NyaWJlclJlbW92ZWQ6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0U3Vic2NyaXZlckV2ZW50KHRoaXMuZXZlbnRzLnN1YnNjcmliZXJSZW1vdmVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5pbnRlcmFwcGJ1cy5JbnRlckFwcGxpY2F0aW9uQnVzID0gSW50ZXJBcHBsaWNhdGlvbkJ1cztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEludGVyQXBwUGF5bG9hZCB7XG59XG5pbnRlcmFwcGJ1cy5JbnRlckFwcFBheWxvYWQgPSBJbnRlckFwcFBheWxvYWQ7XG5mdW5jdGlvbiBjcmVhdGVLZXkoLi4udG9IYXNoKSB7XG4gICAgcmV0dXJuIHRvSGFzaFxuICAgICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShgJHtpdGVtfWApLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9KVxuICAgICAgICAuam9pbignLycpO1xufVxuXG52YXIgY2xpcGJvYXJkID0ge307XG5cbi8qKlxuICogRW50cnkgcG9pbnQgZm9yIHRoZSBPcGVuRmluIGBDbGlwYm9hcmRgIEFQSSAoYGZpbi5DbGlwYm9hcmRgKS5cbiAqXG4gKiAqIHtAbGluayBDbGlwYm9hcmR9IGNvbnRhaW5zIHN0YXRpYyBtZW1iZXJzIG9mIHRoZSBgQ2xpcGJvYXJkYCBBUEksIGFjY2Vzc2libGUgdGhyb3VnaCBgZmluLkNsaXBib2FyZGAuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGlwYm9hcmQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xpcGJvYXJkLkNsaXBib2FyZCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSRkID0gYmFzZTtcbi8qKlxuICogVGhlIENsaXBib2FyZCBBUEkgYWxsb3dzIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIGNsaXBib2FyZCBpbiBtdWx0aXBsZSBmb3JtYXRzLlxuICpcbiAqL1xuY2xhc3MgQ2xpcGJvYXJkIGV4dGVuZHMgYmFzZV8xJGQuQmFzZSB7XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGRhdGEgaW50byB0aGUgY2xpcGJvYXJkIGFzIHBsYWluIHRleHRcbiAgICAgKiBAcGFyYW0gd3JpdGVPYmogVGhlIG9iamVjdCBmb3Igd3JpdGluZyBkYXRhIGludG8gdGhlIGNsaXBib2FyZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5DbGlwYm9hcmQud3JpdGVUZXh0KHtcbiAgICAgKiAgICAgZGF0YTogJ2hlbGxvLCB3b3JsZCdcbiAgICAgKiB9KS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdUZXh0IE9uIGNsaXBib2FyZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVUZXh0KHdyaXRlT2JqKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUtdGV4dCcsIHdyaXRlT2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY29udGVudCBvZiB0aGUgY2xpcGJvYXJkIGFzIHBsYWluIHRleHRcbiAgICAgKiBAcGFyYW0gdHlwZSBDbGlwYm9hcmQgVHlwZSBkZWZhdWx0cyB0byAnY2xpcGJvYXJkJywgdXNlICdzZWxlY3Rpb24nIGZvciBsaW51eFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5DbGlwYm9hcmQucmVhZFRleHQoKS50aGVuKHRleHQgPT4gY29uc29sZS5sb2codGV4dCkpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWFkVGV4dCh0eXBlKSB7XG4gICAgICAgIC8vIE5PVEU6IFdoZW4gd2Ugc3RhcnQgc3VwcG9ydGluZyBsaW51eCwgd2UgY291bGQgZGV0ZWN0IHRoZSBPUyBhbmQgY2hvb3NlICdzZWxlY3Rpb24nIGF1dG9tYXRpY2FsbHkgZm9yIHRoZSB1c2VyXG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NsaXBib2FyZC1yZWFkLXRleHQnLCB7IHR5cGUgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGludG8gdGhlIGNsaXBib2FyZCBhcyBhbiBJbWFnZVxuICAgICAqIEBwYXJhbSB3cml0ZVJlcXVlc3QgVGhlIG9iamVjdCB0byB3cml0ZSBhbiBpbWFnZSB0byB0aGUgY2xpcGJvYXJkXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLkNsaXBib2FyZC53cml0ZUltYWdlKHtcbiAgICAgKiAgIC8vIHJhdyBiYXNlNjQgc3RyaW5nLCBvciBkYXRhVVJMIG9mIGVpdGhlciBkYXRhOmltYWdlL3BuZyBvciBkYXRhOmltYWdlL2pwZWcgdHlwZVxuICAgICAqICAgaW1hZ2U6ICcuLi4nXG4gICAgICogfSkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnSW1hZ2Ugd3JpdHRlbiB0byBjbGlwYm9hcmQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHdyaXRlSW1hZ2Uod3JpdGVSZXF1ZXN0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUtaW1hZ2UnLCB3cml0ZVJlcXVlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjb250ZW50IG9mIHRoZSBjbGlwYm9hcmQgYXMgYSBiYXNlNjQgc3RyaW5nIG9yIGEgZGF0YVVSTCBiYXNlZCBvbiB0aGUgaW5wdXQgcGFyYW1ldGVyICdmb3JtYXQnLCBkZWZhdWx0cyB0byAnZGF0YVVSTCdcbiAgICAgKiBAcGFyYW0gcmVhZFJlcXVlc3QgQ2xpcGJvYXJkIFJlYWQgSW1hZ2UgcmVxdWVzdCB3aXRoIGZvcm1hdHRpbmcgb3B0aW9uc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIHNlZSBUUyB0eXBlOiBPcGVuRmluLkltYWdlRm9ybWF0T3B0aW9uc1xuICAgICAqXG4gICAgICogY29uc3QgcG5nT3JEYXRhVVJMT3JCbXBPcHRpb25zID0ge1xuICAgICAqICAgICBmb3JtYXQ6ICdwbmcnLCAvLyBjYW4gYmU6ICdwbmcnIHwgJ2RhdGFVUkwnIHwgJ2JtcCdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogY29uc3QganBnT3B0aW9ucyA9IHtcbiAgICAgKiAgICAgZm9ybWF0OiAnanBnJyxcbiAgICAgKiAgICAgcXVhbGl0eTogODAgLy8gb3B0aW9uYWwsIGlmIG9taXR0ZWQgZGVmYXVsdHMgdG8gMTAwXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZpbi5DbGlwYm9hcmQucmVhZEltYWdlKHBuZ09yRGF0YVVSTE9yQm1wT3B0aW9ucylcbiAgICAgKiAgICAgLnRoZW4oaW1hZ2UgPT4gY29uc29sZS5sb2coJ0ltYWdlIHJlYWQgZnJvbSBjbGlwYm9hcmQgYXMgUE5HLCBEYXRhVVJMIG9yIEJNUCcsIGltYWdlKSlcbiAgICAgKiAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKlxuICAgICAqIGZpbi5DbGlwYm9hcmQucmVhZEltYWdlKGpwZ09wdGlvbnMpXG4gICAgICogICAgIC50aGVuKGltYWdlID0+IGNvbnNvbGUubG9nKCdJbWFnZSByZWFkIGZyb20gY2xpcGJvYXJkIGFzIEpQRycsIGltYWdlKSlcbiAgICAgKiAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKlxuICAgICAqIC8vIGRlZmF1bHRzIHRvIHtmb3JtYXQ6ICdkYXRhVVJMJ31cbiAgICAgKiBmaW4uQ2xpcGJvYXJkLnJlYWRJbWFnZSgpXG4gICAgICogICAgIC50aGVuKGltYWdlID0+IGNvbnNvbGUubG9nKCdJbWFnZSByZWFkIGZyb20gY2xpcGJvYXJkIGFzIERhdGFVUkwnLCBpbWFnZSkpXG4gICAgICogICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWFkSW1hZ2UocmVhZFJlcXVlc3QgPSB7IGZvcm1hdDogJ2RhdGFVUkwnIH0pIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xpcGJvYXJkLXJlYWQtaW1hZ2UnLCByZWFkUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGludG8gdGhlIGNsaXBib2FyZCBhcyBIdG1sXG4gICAgICogQHBhcmFtIHdyaXRlT2JqIFRoZSBvYmplY3QgZm9yIHdyaXRpbmcgZGF0YSBpbnRvIHRoZSBjbGlwYm9hcmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uQ2xpcGJvYXJkLndyaXRlSHRtbCh7XG4gICAgICogICAgICAgICBkYXRhOiAnPGgxPkhlbGxvLCBXb3JsZCE8L2gxPidcbiAgICAgKiB9KS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdIVE1MIE9uIGNsaXBib2FyZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVIdG1sKHdyaXRlT2JqKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUtaHRtbCcsIHdyaXRlT2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY29udGVudCBvZiB0aGUgY2xpcGJvYXJkIGFzIEh0bWxcbiAgICAgKiBAcGFyYW0gdHlwZSBDbGlwYm9hcmQgVHlwZSBkZWZhdWx0cyB0byAnY2xpcGJvYXJkJywgdXNlICdzZWxlY3Rpb24nIGZvciBsaW51eFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5DbGlwYm9hcmQucmVhZEh0bWwoKS50aGVuKGh0bWwgPT4gY29uc29sZS5sb2coaHRtbCkpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWFkSHRtbCh0eXBlKSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NsaXBib2FyZC1yZWFkLWh0bWwnLCB7IHR5cGUgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGludG8gdGhlIGNsaXBib2FyZCBhcyBSdGZcbiAgICAgKiBAcGFyYW0gd3JpdGVPYmogVGhlIG9iamVjdCBmb3Igd3JpdGluZyBkYXRhIGludG8gdGhlIGNsaXBib2FyZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5DbGlwYm9hcmQud3JpdGVSdGYoe1xuICAgICAqICAgICAgICAgZGF0YTogJ3NvbWUgdGV4dCBnb2VzIGhlcmUnXG4gICAgICogfSkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnUlRGIE9uIGNsaXBib2FyZCcpKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVSdGYod3JpdGVPYmopIHtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NsaXBib2FyZC13cml0ZS1ydGYnLCB3cml0ZU9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNvbnRlbnQgb2YgdGhlIGNsaXBib2FyZCBhcyBSdGZcbiAgICAgKiBAcGFyYW0gdHlwZSBDbGlwYm9hcmQgVHlwZSBkZWZhdWx0cyB0byAnY2xpcGJvYXJkJywgdXNlICdzZWxlY3Rpb24nIGZvciBsaW51eFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgd3JpdGVPYmogPSB7XG4gICAgICogICAgIGRhdGE6ICdzb21lIHRleHQgZ29lcyBoZXJlJ1xuICAgICAqIH07XG4gICAgICogYXN5bmMgZnVuY3Rpb24gcmVhZFJ0ZigpIHtcbiAgICAgKiAgICAgYXdhaXQgZmluLkNsaXBib2FyZC53cml0ZVJ0Zih3cml0ZU9iaik7XG4gICAgICogICAgIHJldHVybiBhd2FpdCBmaW4uQ2xpcGJvYXJkLnJlYWRSdGYoKTtcbiAgICAgKiB9XG4gICAgICogcmVhZFJ0ZigpLnRoZW4ocnRmID0+IGNvbnNvbGUubG9nKHJ0ZikpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWFkUnRmKHR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xpcGJvYXJkLXJlYWQtcnRmJywgeyB0eXBlIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZGF0YSBpbnRvIHRoZSBjbGlwYm9hcmRcbiAgICAgKiBAcGFyYW0gd3JpdGVPYmogVGhlIG9iamVjdCBmb3Igd3JpdGluZyBkYXRhIGludG8gdGhlIGNsaXBib2FyZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5DbGlwYm9hcmQud3JpdGUoe1xuICAgICAqICAgZGF0YToge1xuICAgICAqICAgICB0ZXh0OiAnYScsXG4gICAgICogICAgIGh0bWw6ICdiJyxcbiAgICAgKiAgICAgcnRmOiAnYycsXG4gICAgICogICAgIC8vIENhbiBiZSBlaXRoZXIgYSBiYXNlNjQgc3RyaW5nLCBvciBhIERhdGFVUkwgc3RyaW5nLiBJZiB1c2luZyBEYXRhVVJMLCB0aGVcbiAgICAgKiAgICAgLy8gc3VwcG9ydGVkIGZvcm1hdHMgYXJlIGBkYXRhOmltYWdlL3BuZ1s7YmFzZTY0XSxgIGFuZCBgZGF0YTppbWFnZS9qcGVnWztiYXNlNjRdLGAuXG4gICAgICogICAgIC8vIFVzaW5nIG90aGVyIGltYWdlLzxmb3JtYXQ+IERhdGFVUkxzIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAgICogICAgIGltYWdlOiAnLi4uJ1xuICAgICAqICAgfVxuICAgICAqIH0pLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ3dyaXRlIGRhdGEgaW50byBjbGlwYm9hcmQnKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHdyaXRlKHdyaXRlT2JqKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUnLCB3cml0ZU9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGF2YWlsYWJsZSBmb3JtYXRzIGZvciB0aGUgY2xpcGJvYXJkIHR5cGVcbiAgICAgKiBAcGFyYW0gdHlwZSBDbGlwYm9hcmQgVHlwZSBkZWZhdWx0cyB0byAnY2xpcGJvYXJkJywgdXNlICdzZWxlY3Rpb24nIGZvciBsaW51eFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5DbGlwYm9hcmQuZ2V0QXZhaWxhYmxlRm9ybWF0cygpLnRoZW4oZm9ybWF0cyA9PiBjb25zb2xlLmxvZyhmb3JtYXRzKSkuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldEF2YWlsYWJsZUZvcm1hdHModHlwZSkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtcmVhZC1mb3JtYXRzJywgeyB0eXBlIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhO1xuICAgIH1cbn1cbmNsaXBib2FyZC5DbGlwYm9hcmQgPSBDbGlwYm9hcmQ7XG5cbnZhciBleHRlcm5hbEFwcGxpY2F0aW9uID0ge307XG5cbnZhciBGYWN0b3J5JDUgPSB7fTtcblxudmFyIEluc3RhbmNlJDQgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbmNlJDQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuSW5zdGFuY2UkNC5FeHRlcm5hbEFwcGxpY2F0aW9uID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuY29uc3QgYmFzZV8xJGMgPSBiYXNlO1xuLyoqXG4gKiBBbiBFeHRlcm5hbEFwcGxpY2F0aW9uIG9iamVjdCByZXByZXNlbnRpbmcgbmF0aXZlIGxhbmd1YWdlIGFkYXB0ZXIgY29ubmVjdGlvbnMgdG8gdGhlIHJ1bnRpbWUuIEFsbG93c1xuICogdGhlIGRldmVsb3BlciB0byBsaXN0ZW4gdG8ge0BsaW5rIE9wZW5GaW4uRXh0ZXJuYWxBcHBsaWNhdGlvbkV2ZW50cyBleHRlcm5hbCBhcHBsaWNhdGlvbiBldmVudHN9LlxuICogRGlzY292ZXJ5IG9mIGNvbm5lY3Rpb25zIGlzIHByb3ZpZGVkIGJ5IHtAbGluayBTeXN0ZW0uU3lzdGVtLmdldEFsbEV4dGVybmFsQXBwbGljYXRpb25zIGdldEFsbEV4dGVybmFsQXBwbGljYXRpb25zfS48L2E+XG4gKlxuICogUHJvY2Vzc2VzIHRoYXQgY2FuIGJlIHdyYXBwZWQgYXMgYEV4dGVybmFsQXBwbGljYXRpb25gcyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFByb2Nlc3NlcyB3aGljaCBoYXZlIGNvbm5lY3RlZCB0byBhbiBPcGVuRmluIHJ1bnRpbWUgdmlhIGFuIGFkYXB0ZXJcbiAqIC0gUHJvY2Vzc2VzIHN0YXJ0ZWQgdmlhIGBTeXN0ZW0ubGF1bmNoRXh0ZXJuYWxBcHBsaWNhdGlvbmBcbiAqIC0gUHJvY2Vzc2VzIG1vbml0b3JlZCB2aWEgYFN5c3RlbS5tb25pdG9yRXh0ZXJuYWxQcm9jZXNzYFxuICovXG5jbGFzcyBFeHRlcm5hbEFwcGxpY2F0aW9uIGV4dGVuZHMgYmFzZV8xJGMuRW1pdHRlckJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIGlkZW50aXR5KSB7XG4gICAgICAgIHN1cGVyKHdpcmUsICdleHRlcm5hbC1hcHBsaWNhdGlvbicsIGlkZW50aXR5LnV1aWQpO1xuICAgICAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXh0ZXJuYWwgYXBwbGljYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0SW5mbygpIHtcbiAgICAgKiAgICAgY29uc3QgZXh0QXBwID0gYXdhaXQgZmluLkV4dGVybmFsQXBwbGljYXRpb24ud3JhcCgnamF2YUFwcC11dWlkJyk7XG4gICAgICogICAgIHJldHVybiBhd2FpdCBleHRBcHAuZ2V0SW5mbygpO1xuICAgICAqIH1cbiAgICAgKiBnZXRJbmZvKCkudGhlbihpbmZvID0+IGNvbnNvbGUubG9nKGluZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtZXh0ZXJuYWwtYXBwbGljYXRpb24taW5mbycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbn1cbkluc3RhbmNlJDQuRXh0ZXJuYWxBcHBsaWNhdGlvbiA9IEV4dGVybmFsQXBwbGljYXRpb247XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWN0b3J5JDUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuRmFjdG9yeSQ1LkV4dGVybmFsQXBwbGljYXRpb25Nb2R1bGUgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEkYiA9IGJhc2U7XG5jb25zdCBJbnN0YW5jZV8xJDQgPSBJbnN0YW5jZSQ0O1xuLyoqXG4gKiBTdGF0aWMgbmFtZXNwYWNlIGZvciBPcGVuRmluIEFQSSBtZXRob2RzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUge0BsaW5rIEV4dGVybmFsQXBwbGljYXRpb259IGNsYXNzLCBhdmFpbGFibGUgdW5kZXIgYGZpbi5FeHRlcm5hbEFwcGxpY2F0aW9uYC5cbiAqL1xuY2xhc3MgRXh0ZXJuYWxBcHBsaWNhdGlvbk1vZHVsZSBleHRlbmRzIGJhc2VfMSRiLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYW4gRXh0ZXJuYWwgQXBwbGljYXRpb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleHRlcm5hbCBhcHBsaWNhdGlvbi5cbiAgICAgKiA8YnI+SXQgaXMgcG9zc2libGUgdG8gd3JhcCBhIHByb2Nlc3MgdGhhdCBkb2VzIG5vdCB5ZXQgZXhpc3QsIChmb3IgZXhhbXBsZSwgdG8gbGlzdGVuIGZvciBzdGFydHVwLXJlbGF0ZWQgZXZlbnRzKVxuICAgICAqIHByb3ZpZGVkIGl0cyB1dWlkIGlzIGFscmVhZHkga25vd24uXG4gICAgICogQHBhcmFtIHV1aWQgVGhlIFVVSUQgb2YgdGhlIGV4dGVybmFsIGFwcGxpY2F0aW9uIHRvIGJlIHdyYXBwZWRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uRXh0ZXJuYWxBcHBsaWNhdGlvbi53cmFwKCdqYXZhQXBwLXV1aWQnKTtcbiAgICAgKiAudGhlbihleHRBcHAgPT4gY29uc29sZS5sb2coJ3dyYXBwZWQgZXh0ZXJuYWwgYXBwbGljYXRpb24nKSlcbiAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHdyYXAodXVpZCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZXh0ZXJuYWwtYXBwbGljYXRpb24td3JhcCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEluc3RhbmNlXzEkNC5FeHRlcm5hbEFwcGxpY2F0aW9uKHRoaXMud2lyZSwgeyB1dWlkIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGFuIEV4dGVybmFsIEFwcGxpY2F0aW9uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgYXBwbGljYXRpb24uXG4gICAgICogPGJyPkl0IGlzIHBvc3NpYmxlIHRvIHdyYXAgYSBwcm9jZXNzIHRoYXQgZG9lcyBub3QgeWV0IGV4aXN0LCAoZm9yIGV4YW1wbGUsIHRvIGxpc3RlbiBmb3Igc3RhcnR1cC1yZWxhdGVkIGV2ZW50cylcbiAgICAgKiBwcm92aWRlZCBpdHMgdXVpZCBpcyBhbHJlYWR5IGtub3duLlxuICAgICAqIEBwYXJhbSB1dWlkIFRoZSBVVUlEIG9mIHRoZSBleHRlcm5hbCBhcHBsaWNhdGlvbiB0byBiZSB3cmFwcGVkXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgZXh0QXBwID0gZmluLkV4dGVybmFsQXBwbGljYXRpb24ud3JhcFN5bmMoJ2phdmFBcHAtdXVpZCcpO1xuICAgICAqIGNvbnN0IGluZm8gPSBhd2FpdCBleHRBcHAuZ2V0SW5mbygpO1xuICAgICAqIGNvbnNvbGUubG9nKGluZm8pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHdyYXBTeW5jKHV1aWQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2V4dGVybmFsLWFwcGxpY2F0aW9uLXdyYXAtc3luYycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMSQ0LkV4dGVybmFsQXBwbGljYXRpb24odGhpcy53aXJlLCB7IHV1aWQgfSk7XG4gICAgfVxufVxuRmFjdG9yeSQ1LkV4dGVybmFsQXBwbGljYXRpb25Nb2R1bGUgPSBFeHRlcm5hbEFwcGxpY2F0aW9uTW9kdWxlO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX2V4cG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0LyoqXG5cdCAqIEVudHJ5IHBvaW50cyBmb3IgdGhlIE9wZW5GaW4gYEV4dGVybmFsQXBwbGljYXRpb25gIEFQSSAoYGZpbi5FeHRlcm5hbEFwcGxpY2F0aW9uYCkuXG5cdCAqXG5cdCAqICoge0BsaW5rIEV4dGVybmFsQXBwbGljYXRpb25Nb2R1bGV9IGNvbnRhaW5zIHN0YXRpYyBtZW1iZXJzIG9mIHRoZSBgRXh0ZXJuYWxBcHBsaWNhdGlvbmAgdHlwZSwgYWNjZXNzaWJsZSB0aHJvdWdoIGBmaW4uRXh0ZXJuYWxBcHBsaWNhdGlvbmAuXG5cdCAqICoge0BsaW5rIEV4dGVybmFsQXBwbGljYXRpb259IGRlc2NyaWJlcyBhbiBpbnN0YW5jZSBvZiBhbiBPcGVuRmluIEV4dGVybmFsQXBwbGljYXRpb24sIGUuZy4gYXMgcmV0dXJuZWQgYnkgYGZpbi5FeHRlcm5hbEFwcGxpY2F0aW9uLmdldEN1cnJlbnRgLlxuXHQgKlxuXHQgKiBUaGVzZSBhcmUgc2VwYXJhdGUgY29kZSBlbnRpdGllcywgYW5kIGFyZSBkb2N1bWVudGVkIHNlcGFyYXRlbHkuICBJbiB0aGUgW3ByZXZpb3VzIHZlcnNpb24gb2YgdGhlIEFQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC8zMi4xMTQuNzYuMTAvaW5kZXguaHRtbCksXG5cdCAqIGJvdGggb2YgdGhlc2Ugd2VyZSBkb2N1bWVudGVkIG9uIHRoZSBzYW1lIHBhZ2UuXG5cdCAqXG5cdCAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuXHQgKi9cblx0X19leHBvcnRTdGFyKEZhY3RvcnkkNSwgZXhwb3J0cyk7XG5cdF9fZXhwb3J0U3RhcihJbnN0YW5jZSQ0LCBleHBvcnRzKTsgXG59IChleHRlcm5hbEFwcGxpY2F0aW9uKSk7XG5cbnZhciBmcmFtZSA9IHt9O1xuXG52YXIgRmFjdG9yeSQ0ID0ge307XG5cbnZhciBJbnN0YW5jZSQzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW5jZSQzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbkluc3RhbmNlJDMuX0ZyYW1lID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuY29uc3QgYmFzZV8xJGEgPSBiYXNlO1xuLyoqXG4gKiBBbiBpZnJhbWUgcmVwcmVzZW50cyBhbiBlbWJlZGRlZCBIVE1MIHBhZ2Ugd2l0aGluIGEgcGFyZW50IEhUTUwgcGFnZS4gQmVjYXVzZSB0aGlzIGVtYmVkZGVkIHBhZ2VcbiAqIGhhcyBpdHMgb3duIERPTSBhbmQgZ2xvYmFsIEpTIGNvbnRleHQgKHdoaWNoIG1heSBvciBtYXkgbm90IGJlIGxpbmtlZCB0byB0aGF0IG9mIHRoZSBwYXJlbnQgZGVwZW5kaW5nXG4gKiBvbiBpZiBpdCBpcyBjb25zaWRlcmVkIG91dCBvZiB0aGUgcm9vdCBkb21haW4gb3Igbm90KSwgaXQgcmVwcmVzZW50cyBhIHVuaXF1ZSBlbmRwb2ludCBhcyBhbiBPcGVuRmluXG4gKiBjb25uZWN0aW9uLiBJZnJhbWVzIG1heSBiZSBnZW5lcmF0ZWQgZHluYW1pY2FsbHksIG9yIGJlIHByZXNlbnQgb24gaW5pdGlhbCBwYWdlIGxvYWQgYW5kIGVhY2ggbm9uLUNPUlNcbiAqIGlmcmFtZSBoYXMgdGhlIE9wZW5GaW4gQVBJIGluamVjdGVkIGJ5IGRlZmF1bHQuIEl0IGlzIHBvc3NpYmxlIHRvIG9wdCBpbnRvIGNyb3NzLW9yaWdpbiBpZnJhbWVzIGhhdmluZ1xuICogdGhlIEFQSSBieSBzZXR0aW5nIGFwaS5pZnJhbWUuY3Jvc3NPcmlnaW5JbmplY3Rpb24gdG8gdHJ1ZSBpbiBhIHdpbmRvdydzIG9wdGlvbnMuIFRvIGJsb2NrIGFsbCBpZnJhbWVzXG4gKiBmcm9tIGdldHRpbmcgdGhlIEFQSSBpbmplY3RlZCB5b3UgY2FuIHNldCBhcGkuZnJhbWUuc2FtZU9yaWdpbkluamVjdGlvblxuICogdG8gZmFsc2UgPGEgaHJlZj1cIldpbmRvdy5odG1sI35vcHRpb25zXCIgdGFyZ2V0PVwiX2JsYW5rXCI+KHtAbGluayBPcGVuRmluLldpbmRvd0NyZWF0aW9uT3B0aW9ucyBzZWUgV2luZG93IE9wdGlvbnN9KTwvYT4uXG4gKlxuICogVG8gYmUgYWJsZSB0byBkaXJlY3RseSBhZGRyZXNzIHRoaXMgY29udGV4dCBmb3IgZXZlbnRpbmcgYW5kIG1lc3NhZ2luZyBwdXJwb3NlcywgaXQgbmVlZHMgYVxuICogdW5pcXVlIHV1aWQgbmFtZSBwYWlyaW5nLiBGb3IgT3BlbkZpbiBhcHBsaWNhdGlvbnMgYW5kIHdpbmRvd3MgdGhpcyBpcyBwcm92aWRlZCB2aWEgYSBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgaW4gdGhlIGZvcm0gb2YgYSBtYW5pZmVzdCBVUkwgb3Igb3B0aW9ucyBvYmplY3QsIGJ1dCB0aGVyZSBpcyBubyBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgaWZyYW1lcy5cbiAqIEp1c3QgYXMgYSBjYWxsIHRvIHdpbmRvdy5vcGVuIG91dHNpZGUgb2Ygb3VyIFdpbmRvdyBBUEkgcmV0dXJucyBhIG5ldyB3aW5kb3cgd2l0aCBhIHJhbmRvbSBHVUlEIGFzc2lnbmVkXG4gKiBmb3IgdGhlIG5hbWUsIGVhY2ggaWZyYW1lIHRoYXQgaGFzIHRoZSBBUEkgaW5qZWN0ZWQgd2lsbCBiZSBhc3NpZ25lZCBhIEdVSUQgYXMgaXRzIG5hbWUsIHRoZSBVVUlEIHdpbGwgYmVcbiAqIHRoZSBzYW1lIGFzIHRoZSBwYXJlbnQgd2luZG93J3MuXG4gKlxuICogVGhlIGZpbi5GcmFtZSBuYW1lc3BhY2UgcmVwcmVzZW50cyBhIHdheSB0byBpbnRlcmFjdCB3aXRoIGBpZnJhbWVzYCBhbmQgZmFjaWxpdGF0ZXMgdGhlIGRpc2NvdmVyeSBvZiBjdXJyZW50IGNvbnRleHRcbiAqIChpZnJhbWUgb3IgbWFpbiB3aW5kb3cpIGFzIHdlbGwgYXMgdGhlIGFiaWxpdHkgdG8gbGlzdGVuIGZvciB7QGxpbmsgT3BlbkZpbi5GcmFtZUV2ZW50cyBmcmFtZS1zcGVjaWZpYyBldmVudHN9LlxuICovXG5jbGFzcyBfRnJhbWUgZXh0ZW5kcyBiYXNlXzEkYS5FbWl0dGVyQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod2lyZSwgaWRlbnRpdHkpIHtcbiAgICAgICAgc3VwZXIod2lyZSwgJ2ZyYW1lJywgaWRlbnRpdHkudXVpZCwgaWRlbnRpdHkubmFtZSk7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZyYW1lIGluZm8gb2JqZWN0IGZvciB0aGUgcmVwcmVzZW50ZWQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogYXN5bmMgZnVuY3Rpb24gZ2V0SW5mbygpIHtcbiAgICAgKiAgICAgY29uc3QgZnJtID0gYXdhaXQgZmluLkZyYW1lLmdldEN1cnJlbnQoKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGZybS5nZXRJbmZvKCk7XG4gICAgICogfVxuICAgICAqIGdldEluZm8oKS50aGVuKGluZm8gPT4gY29uc29sZS5sb2coaW5mbykpLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1mcmFtZS1pbmZvJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmcmFtZSBpbmZvIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHdpbmRvdyB0aGF0IHRoZSByZWZlcmVuY2VkIGlmcmFtZSBpc1xuICAgICAqIGN1cnJlbnRseSBlbWJlZGRlZCBpbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIElmIHRoZSBmcmFtZSBpcyBlbWJlZGRlZCBpbiBhIHZpZXcsIHRoaXMgd2lsbCByZXR1cm4gYW4gaW52YWxpZCBzdHViIHdpdGggZW1wdHkgZmllbGRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGFzeW5jIGZ1bmN0aW9uIGdldFBhcmVudFdpbmRvdygpIHtcbiAgICAgKiAgICAgY29uc3QgZnJtID0gYXdhaXQgZmluLkZyYW1lLmdldEN1cnJlbnQoKTtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IGZybS5nZXRQYXJlbnRXaW5kb3coKTtcbiAgICAgKiB9XG4gICAgICogZ2V0UGFyZW50V2luZG93KCkudGhlbih3aW5JbmZvID0+IGNvbnNvbGUubG9nKHdpbkluZm8pKS5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0UGFyZW50V2luZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1wYXJlbnQtd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxufVxuSW5zdGFuY2UkMy5fRnJhbWUgPSBfRnJhbWU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWN0b3J5JDQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuRmFjdG9yeSQ0Ll9GcmFtZU1vZHVsZSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSQ5ID0gYmFzZTtcbmNvbnN0IHZhbGlkYXRlXzEkMiA9IHZhbGlkYXRlO1xuY29uc3QgSW5zdGFuY2VfMSQzID0gSW5zdGFuY2UkMztcbi8qKlxuICogU3RhdGljIG5hbWVzcGFjZSBmb3IgT3BlbkZpbiBBUEkgbWV0aG9kcyB0aGF0IGludGVyYWN0IHdpdGggdGhlIHtAbGluayBfRnJhbWV9IGNsYXNzLCBhdmFpbGFibGUgdW5kZXIgYGZpbi5GcmFtZWAuXG4gKi9cbmNsYXNzIF9GcmFtZU1vZHVsZSBleHRlbmRzIGJhc2VfMSQ5LkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHNwZWNpZmllZCBmcmFtZS4gVGhlIGZyYW1lIGRvZXMgbm90IGhhdmUgdG8gZXhpc3RcbiAgICAgKiBAcGFyYW0gaWRlbnRpdHkgLSB0aGUgaWRlbnRpdHkgb2YgdGhlIGZyYW1lIHlvdSB3YW50IHRvIHdyYXBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4uRnJhbWUud3JhcCh7IHV1aWQ6ICd0ZXN0RnJhbWUnLCBuYW1lOiAndGVzdEZyYW1lJyB9KVxuICAgICAqIC50aGVuKGZybSA9PiBjb25zb2xlLmxvZygnd3JhcHBlZCBmcmFtZScpKVxuICAgICAqIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgd3JhcChpZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZnJhbWUtd3JhcCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gKDAsIHZhbGlkYXRlXzEkMi52YWxpZGF0ZUlkZW50aXR5KShpZGVudGl0eSk7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEkMy5fRnJhbWUodGhpcy53aXJlLCBpZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgc3BlY2lmaWVkIGZyYW1lLiBUaGUgZnJhbWUgZG9lcyBub3QgaGF2ZSB0byBleGlzdFxuICAgICAqIEBwYXJhbSBpZGVudGl0eSAtIHRoZSBpZGVudGl0eSBvZiB0aGUgZnJhbWUgeW91IHdhbnQgdG8gd3JhcFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGZybSA9IGZpbi5GcmFtZS53cmFwU3luYyh7IHV1aWQ6ICd0ZXN0RnJhbWUnLCBuYW1lOiAndGVzdEZyYW1lJyB9KTtcbiAgICAgKiBjb25zdCBpbmZvID0gYXdhaXQgZnJtLmdldEluZm8oKTtcbiAgICAgKiBjb25zb2xlLmxvZyhpbmZvKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB3cmFwU3luYyhpZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZnJhbWUtd3JhcC1zeW5jJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSAoMCwgdmFsaWRhdGVfMSQyLnZhbGlkYXRlSWRlbnRpdHkpKGlkZW50aXR5KTtcbiAgICAgICAgaWYgKGVycm9yTXNnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMSQzLl9GcmFtZSh0aGlzLndpcmUsIGlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBmcmFtZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGZpbi5GcmFtZS5nZXRDdXJyZW50KClcbiAgICAgKiAudGhlbihmcm0gPT4gY29uc29sZS5sb2coJ2N1cnJlbnQgZnJhbWUnKSlcbiAgICAgKiAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldEN1cnJlbnQoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmcmFtZS1nZXQtY3VycmVudCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEluc3RhbmNlXzEkMy5fRnJhbWUodGhpcy53aXJlLCB0aGlzLndpcmUuZW52aXJvbm1lbnQuZ2V0Q3VycmVudEVudGl0eUlkZW50aXR5KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGZyYW1lXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgZnJtID0gZmluLkZyYW1lLmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogY29uc3QgaW5mbyA9IGF3YWl0IGZybS5nZXRJbmZvKCk7XG4gICAgICogY29uc29sZS5sb2coaW5mbyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFN5bmMoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmcmFtZS1nZXQtY3VycmVudC1zeW5jJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xJDMuX0ZyYW1lKHRoaXMud2lyZSwgdGhpcy53aXJlLmVudmlyb25tZW50LmdldEN1cnJlbnRFbnRpdHlJZGVudGl0eSgpKTtcbiAgICB9XG59XG5GYWN0b3J5JDQuX0ZyYW1lTW9kdWxlID0gX0ZyYW1lTW9kdWxlO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0LyoqXG5cdCAqIEVudHJ5IHBvaW50cyBmb3IgdGhlIE9wZW5GaW4gYEZyYW1lYCBBUEkgKGBmaW4uRnJhbWVgKS5cblx0ICpcblx0ICogKiB7QGxpbmsgX0ZyYW1lTW9kdWxlfSBjb250YWlucyBzdGF0aWMgbWVtYmVycyBvZiB0aGUgYEZyYW1lYCBBUEksIGFjY2Vzc2libGUgdGhyb3VnaCBgZmluLkZyYW1lYC5cblx0ICogKiB7QGxpbmsgX0ZyYW1lfSBkZXNjcmliZXMgYW4gaW5zdGFuY2Ugb2YgYW4gT3BlbkZpbiBGcmFtZSwgZS5nLiBhcyByZXR1cm5lZCBieSBgZmluLkZyYW1lLmdldEN1cnJlbnRgLlxuXHQgKlxuXHQgKiBUaGVzZSBhcmUgc2VwYXJhdGUgY29kZSBlbnRpdGllcywgYW5kIGFyZSBkb2N1bWVudGVkIHNlcGFyYXRlbHkuIEluIHRoZSBbcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0LzMyLjExNC43Ni4xMC9pbmRleC5odG1sKSxcblx0ICogYm90aCBvZiB0aGVzZSB3ZXJlIGRvY3VtZW50ZWQgb24gdGhlIHNhbWUgcGFnZS5cblx0ICpcblx0ICogVW5kZXJzY29yZSBwcmVmaXhpbmcgb2YgT3BlbkZpbiB0eXBlcyB0aGF0IGFsaWFzIERPTSBlbnRpdGllcyB3aWxsIGJlIGZpeGVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG5cdCAqXG5cdCAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuXHQgKi9cblx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX2V4cG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X19leHBvcnRTdGFyKEZhY3RvcnkkNCwgZXhwb3J0cyk7XG5cdF9fZXhwb3J0U3RhcihJbnN0YW5jZSQzLCBleHBvcnRzKTsgXG59IChmcmFtZSkpO1xuXG52YXIgZ2xvYmFsSG90a2V5ID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxIb3RrZXksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZ2xvYmFsSG90a2V5Lkdsb2JhbEhvdGtleSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSQ4ID0gYmFzZTtcbi8qKlxuICogVGhlIEdsb2JhbEhvdGtleSBtb2R1bGUgY2FuIHJlZ2lzdGVyL3VucmVnaXN0ZXIgYSBnbG9iYWwgaG90a2V5cy5cbiAqXG4gKi9cbmNsYXNzIEdsb2JhbEhvdGtleSBleHRlbmRzIGJhc2VfMSQ4LkVtaXR0ZXJCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aXJlKSB7XG4gICAgICAgIHN1cGVyKHdpcmUsICdnbG9iYWwtaG90a2V5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGdsb2JhbCBob3RrZXkgd2l0aCB0aGUgb3BlcmF0aW5nIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gaG90a2V5IGEgaG90a2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBjYWxsZWQgd2hlbiB0aGUgcmVnaXN0ZXJlZCBob3RrZXkgaXMgcHJlc3NlZCBieSB0aGUgdXNlci5cbiAgICAgKiBAdGhyb3dzIElmIHRoZSBgaG90a2V5YCBpcyByZXNlcnZlZCwgc2VlIGxpc3QgYmVsb3cuXG4gICAgICogQHRocm93cyBpZiB0aGUgYGhvdGtleWAgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGJ5IGFub3RoZXIgYXBwbGljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBUaGUgYGhvdGtleWAgcGFyYW1ldGVyIGV4cGVjdHMgYW4gZWxlY3Ryb24gY29tcGF0aWJsZSBbYWNjZWxlcmF0b3JdKGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi9lbGVjdHJvbi9ibG9iL21hc3Rlci9kb2NzL2FwaS9hY2NlbGVyYXRvci5tZCkgYW5kIHRoZSBgbGlzdGVuZXJgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBgaG90a2V5YCBpcyBwcmVzc2VkIGJ5IHRoZSB1c2VyLlxuICAgICAqIElmIHN1Y2Nlc3NmdWxsLCB0aGUgaG90a2V5IHdpbGwgYmUgJ2NsYWltZWQnIGJ5IHRoZSBhcHBsaWNhdGlvbiwgbWVhbmluZyB0aGF0IHRoaXMgcmVnaXN0ZXIgY2FsbCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZyb20gd2l0aGluIHRoZSBzYW1lIGFwcGxpY2F0aW9uIGJ1dCB3aWxsIGZhaWwgaWYgYW5vdGhlciBhcHBsaWNhdGlvbiBoYXMgcmVnaXN0ZXJlZCB0aGUgaG90a2V5LlxuICAgICAqIDxicj5UaGUgcmVnaXN0ZXIgY2FsbCB3aWxsIGZhaWwgaWYgZ2l2ZW4gYW55IG9mIHRoZXNlIHJlc2VydmVkIEhvdGtleXM6XG4gICAgICogKiBgQ29tbWFuZE9yQ29udHJvbCswYFxuICAgICAqICogYENvbW1hbmRPckNvbnRyb2wrPWBcbiAgICAgKiAqIGBDb21tYW5kT3JDb250cm9sK1BsdXNgXG4gICAgICogKiBgQ29tbWFuZE9yQ29udHJvbCstYFxuICAgICAqICogYENvbW1hbmRPckNvbnRyb2wrX2BcbiAgICAgKiAqIGBDb21tYW5kT3JDb250cm9sK1NoaWZ0K0lgXG4gICAgICogKiBgRjVgXG4gICAgICogKiBgQ29tbWFuZE9yQ29udHJvbCtSYFxuICAgICAqICogYFNoaWZ0K0Y1YFxuICAgICAqICogYENvbW1hbmRPckNvbnRyb2wrU2hpZnQrUmBcbiAgICAgKlxuICAgICAqIFJhaXNlcyB0aGUgYHJlZ2lzdGVyZWRgIGV2ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGhvdGtleSA9ICdDb21tYW5kT3JDb250cm9sK1gnO1xuICAgICAqXG4gICAgICogZmluLkdsb2JhbEhvdGtleS5yZWdpc3Rlcihob3RrZXksICgpID0+IHtcbiAgICAgKiBjb25zb2xlLmxvZyhgJHtob3RrZXl9IHByZXNzZWRgKTtcbiAgICAgKiB9KVxuICAgICAqIC50aGVuKCgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3MnKTtcbiAgICAgKiB9KVxuICAgICAqIC5jYXRjaChlcnIgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnRXJyb3IgcmVnaXN0ZXJpbmcgdGhlIGhvdGtleScsIGVycik7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXIoaG90a2V5LCBsaXN0ZW5lcikge1xuICAgICAgICAvLyBUT0RPOiBmaXggdHlwaW5nIChob3RrZXkgZXZlbnRzIGFyZSBub3QgdHlwZWQpXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgYXdhaXQgdGhpcy5vbihob3RrZXksIGxpc3RlbmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dsb2JhbC1ob3RrZXktcmVnaXN0ZXInLCB7IGhvdGtleSB9KTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYSBnbG9iYWwgaG90a2V5IHdpdGggdGhlIG9wZXJhdGluZyBzeXN0ZW0uXG4gICAgICogQHBhcmFtIGhvdGtleSBhIGhvdGtleSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoaXMgbWV0aG9kIHdpbGwgdW5yZWdpc3RlciBhbGwgZXhpc3RpbmcgcmVnaXN0cmF0aW9ucyBvZiB0aGUgaG90a2V5IHdpdGhpbiB0aGUgYXBwbGljYXRpb24uXG4gICAgICogUmFpc2VzIHRoZSBgdW5yZWdpc3RlcmVkYCBldmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBob3RrZXkgPSAnQ29tbWFuZE9yQ29udHJvbCtYJztcbiAgICAgKlxuICAgICAqIGZpbi5HbG9iYWxIb3RrZXkudW5yZWdpc3Rlcihob3RrZXkpXG4gICAgICogLnRoZW4oKCkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnU3VjY2VzcycpO1xuICAgICAqIH0pXG4gICAgICogLmNhdGNoKGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdFcnJvciB1bnJlZ2lzdGVyaW5nIHRoZSBob3RrZXknLCBlcnIpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVucmVnaXN0ZXIoaG90a2V5KSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB0eXBpbmcgKGhvdGtleSBldmVudHMgYXJlIG5vdCB0eXBlZClcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhob3RrZXkpO1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2xvYmFsLWhvdGtleS11bnJlZ2lzdGVyJywgeyBob3RrZXkgfSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIGFsbCBnbG9iYWwgaG90a2V5cyBmb3IgdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBSYWlzZXMgdGhlIGB1bnJlZ2lzdGVyZWRgIGV2ZW50IGZvciBlYWNoIGhvdGtleSB1bnJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLkdsb2JhbEhvdGtleS51bnJlZ2lzdGVyQWxsKClcbiAgICAgKiAudGhlbigoKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzJyk7XG4gICAgICogfSlcbiAgICAgKiAuY2F0Y2goZXJyID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0Vycm9yIHVucmVnaXN0ZXJpbmcgYWxsIGhvdGtleXMgZm9yIHRoaXMgYXBwbGljYXRpb24nLCBlcnIpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVucmVnaXN0ZXJBbGwoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuZXZlbnROYW1lcygpXG4gICAgICAgICAgICAuZmlsdGVyKChuYW1lKSA9PiAhKG5hbWUgPT09ICdyZWdpc3RlcmVkJyB8fCBuYW1lID09PSAndW5yZWdpc3RlcmVkJykpXG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggdHlwaW5nIChob3RrZXkgZXZlbnRzIGFyZSBub3QgdHlwZWQpXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAubWFwKChuYW1lKSA9PiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhuYW1lKSkpO1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2xvYmFsLWhvdGtleS11bnJlZ2lzdGVyLWFsbCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gaG90a2V5IGhhcyBiZWVuIHJlZ2lzdGVyZWQgYnkgYW4gYXBwbGljYXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHJ1bnRpbWUuXG4gICAgICogQHBhcmFtIGhvdGtleSBhIGhvdGtleSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBob3RrZXkgPSAnQ29tbWFuZE9yQ29udHJvbCtYJztcbiAgICAgKlxuICAgICAqIGZpbi5HbG9iYWxIb3RrZXkuaXNSZWdpc3RlcmVkKGhvdGtleSlcbiAgICAgKiAudGhlbigocmVnaXN0ZXJlZCkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgaG90a2V5ICR7aG90a2V5fSBpcyByZWdpc3RlcmVkID8gJHtyZWdpc3RlcmVkfWApO1xuICAgICAqIH0pXG4gICAgICogLmNhdGNoKGVyciA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdFcnJvciB1bnJlZ2lzdGVyaW5nIHRoZSBob3RrZXknLCBlcnIpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGlzUmVnaXN0ZXJlZChob3RrZXkpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGEgfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dsb2JhbC1ob3RrZXktaXMtcmVnaXN0ZXJlZCcsIHsgaG90a2V5IH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5nbG9iYWxIb3RrZXkuR2xvYmFsSG90a2V5ID0gR2xvYmFsSG90a2V5O1xuXG52YXIgcGxhdGZvcm0gPSB7fTtcblxudmFyIEZhY3RvcnkkMyA9IHt9O1xuXG52YXIgSW5zdGFuY2UkMiA9IHt9O1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ2ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX1BsYXRmb3JtX2Nvbm5lY3RUb1Byb3ZpZGVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbmNlJDIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuSW5zdGFuY2UkMi5QbGF0Zm9ybSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQsIG5vLXVuZGVmICovXG5jb25zdCBiYXNlXzEkNyA9IGJhc2U7XG5jb25zdCB2YWxpZGF0ZV8xJDEgPSB2YWxpZGF0ZTtcbi8vIFJldXNlIGNsaWVudHMgdG8gYXZvaWQgb3ZlcndyaXRpbmcgYWxyZWFkeS1yZWdpc3RlcmVkIGNsaWVudCBpbiBwcm92aWRlclxuY29uc3QgY2xpZW50TWFwID0gbmV3IE1hcCgpO1xuLyoqIE1hbmFnZXMgdGhlIGxpZmUgY3ljbGUgb2Ygd2luZG93cyBhbmQgdmlld3MgaW4gdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIEVuYWJsZXMgdGFraW5nIHNuYXBzaG90cyBvZiBpdHNlbGYgYW5kIGFwcGx5aW5nIHRoZW0gdG8gcmVzdG9yZSBhIHByZXZpb3VzIGNvbmZpZ3VyYXRpb25cbiAqIGFzIHdlbGwgYXMgbGlzdGVuIHRvIHtAbGluayBPcGVuRmluLlBsYXRmb3JtRXZlbnRzIHBsYXRmb3JtIGV2ZW50c30uXG4gKi9cbmNsYXNzIFBsYXRmb3JtIGV4dGVuZHMgYmFzZV8xJDcuRW1pdHRlckJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBjb25zdHJ1Y3RvcihpZGVudGl0eSwgY2hhbm5lbCkge1xuICAgICAgICAvLyB3ZSBwaWdneWJhY2sgb2ZmIG9mIGFwcGxpY2F0aW9uIGV2ZW50IGVtaXR0ZXIgYmVjYXVzZSBmcm9tIHRoZSBjb3JlJ3MgcGVyc3BlY3RpdmUgcGxhdGZvcm0gaXMganVzdCBhbiBhcHAuXG4gICAgICAgIHN1cGVyKGNoYW5uZWwud2lyZSwgJ2FwcGxpY2F0aW9uJywgaWRlbnRpdHkudXVpZCk7XG4gICAgICAgIHRoaXMuZ2V0Q2xpZW50ID0gKGlkZW50aXR5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tZ2V0LWNsaWVudCcsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGlkZW50aXR5IHx8IHRoaXMuaWRlbnRpdHk7XG4gICAgICAgICAgICBjb25zdCB7IHV1aWQgfSA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmICghY2xpZW50TWFwLmhhcyh1dWlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFByb21pc2UgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDYodGhpcywgX1BsYXRmb3JtX2Nvbm5lY3RUb1Byb3ZpZGVyLCBcImZcIikuY2FsbCh0aGlzLCB1dWlkKTtcbiAgICAgICAgICAgICAgICBjbGllbnRNYXAuc2V0KHV1aWQsIGNsaWVudFByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IGFib3ZlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudE1hcC5nZXQodXVpZCk7XG4gICAgICAgIH07XG4gICAgICAgIF9QbGF0Zm9ybV9jb25uZWN0VG9Qcm92aWRlci5zZXQodGhpcywgYXN5bmMgKHV1aWQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgY3VzdG9tLWZyYW1lLSR7dXVpZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuX2NoYW5uZWwuY29ubmVjdChjaGFubmVsTmFtZSwgeyB3YWl0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBjbGllbnQub25EaXNjb25uZWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50TWFwLmRlbGV0ZSh1dWlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRNYXAuZGVsZXRlKHV1aWQpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRhcmdldGVkIFBsYXRmb3JtIGlzIG5vdCBjdXJyZW50bHkgcnVubmluZy4gTGlzdGVuIGZvciBhcHBsaWNhdGlvbi1zdGFydGVkIGV2ZW50IGZvciB0aGUgZ2l2ZW4gVXVpZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCAocmVuYW1lZClcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXVuY2hMZWdhY3lNYW5pZmVzdCA9IHRoaXMubGF1bmNoQ29udGVudE1hbmlmZXN0O1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9ICgwLCB2YWxpZGF0ZV8xJDEudmFsaWRhdGVJZGVudGl0eSkoaWRlbnRpdHkpO1xuICAgICAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSB7IHV1aWQ6IGlkZW50aXR5LnV1aWQgfTtcbiAgICAgICAgdGhpcy5MYXlvdXQgPSB0aGlzLmZpbi5QbGF0Zm9ybS5MYXlvdXQ7XG4gICAgICAgIHRoaXMuQXBwbGljYXRpb24gPSB0aGlzLmZpbi5BcHBsaWNhdGlvbi53cmFwU3luYyh0aGlzLmlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2aWV3IGFuZCBhdHRhY2hlcyBpdCB0byBhIHNwZWNpZmllZCB0YXJnZXQgd2luZG93LlxuICAgICAqIEBwYXJhbSB2aWV3T3B0aW9ucyBWaWV3IGNyZWF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB3aW5kb3cgdG8gd2hpY2ggdGhlIG5ldyB2aWV3IGlzIHRvIGJlIGF0dGFjaGVkLiBJZiBubyB0YXJnZXQsIGNyZWF0ZSBhIHZpZXcgaW4gYSBuZXcgd2luZG93LlxuICAgICAqIEBwYXJhbSB0YXJnZXRWaWV3IElmIHByb3ZpZGVkLCB0aGUgbmV3IHZpZXcgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2FtZSB0YWJzdHJpcCBhcyB0YXJnZXRWaWV3LlxuICAgICAqXG4gICAgICogQHJlbWFya3MgSWYgdGhlIHZpZXcgYWxyZWFkeSBleGlzdHMsIHdpbGwgcmVwYXJlbnQgdGhlIHZpZXcgdG8gdGhlIG5ldyB0YXJnZXQuIFlvdSBkbyBub3QgbmVlZCB0byBzZXQgYSBuYW1lIGZvciBhIFZpZXcuXG4gICAgICogVmlld3MgdGhhdCBhcmUgbm90IHBhc3NlZCBhIG5hbWUgZ2V0IGEgcmFuZG9tbHkgZ2VuZXJhdGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBsZXQgd2luZG93SWRlbnRpdHk7XG4gICAgICogaWYgKGZpbi5tZS5pc1dpbmRvdykge1xuICAgICAqICAgICB3aW5kb3dJZGVudGl0eSA9IGZpbi5tZS5pZGVudGl0eTtcbiAgICAgKiB9IGVsc2UgaWYgKGZpbi5tZS5pc1ZpZXcpIHtcbiAgICAgKiAgICAgd2luZG93SWRlbnRpdHkgPSAoYXdhaXQgZmluLm1lLmdldEN1cnJlbnRXaW5kb3coKSkuaWRlbnRpdHk7XG4gICAgICogfSBlbHNlIHtcbiAgICAgKiAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgcnVubmluZyBpbiBhIHBsYXRmb3JtIFZpZXcgb3IgV2luZG93Jyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcGxhdGZvcm0gPSBmaW4uUGxhdGZvcm0uZ2V0Q3VycmVudFN5bmMoKTtcbiAgICAgKlxuICAgICAqIHBsYXRmb3JtLmNyZWF0ZVZpZXcoe1xuICAgICAqICAgICBuYW1lOiAndGVzdF92aWV3JyxcbiAgICAgKiAgICAgdXJsOiAnaHR0cHM6Ly9kZXZlbG9wZXJzLm9wZW5maW4uY28vZG9jcy9wbGF0Zm9ybS1hcGknXG4gICAgICogfSwgd2luZG93SWRlbnRpdHkpLnRoZW4oY29uc29sZS5sb2cpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUmVwYXJlbnRpbmcgYSB2aWV3OlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IHdpbmRvd0lkZW50aXR5O1xuICAgICAqIGlmIChmaW4ubWUuaXNXaW5kb3cpIHtcbiAgICAgKiAgICAgd2luZG93SWRlbnRpdHkgPSBmaW4ubWUuaWRlbnRpdHk7XG4gICAgICogfSBlbHNlIGlmIChmaW4ubWUuaXNWaWV3KSB7XG4gICAgICogICAgIHdpbmRvd0lkZW50aXR5ID0gKGF3YWl0IGZpbi5tZS5nZXRDdXJyZW50V2luZG93KCkpLmlkZW50aXR5O1xuICAgICAqIH0gZWxzZSB7XG4gICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3IG9yIFdpbmRvdycpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGxldCBwbGF0Zm9ybSA9IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50U3luYygpO1xuICAgICAqIGxldCB2aWV3T3B0aW9ucyA9IHtcbiAgICAgKiAgICAgbmFtZTogJ2V4YW1wbGVfdmlldycsXG4gICAgICogICAgIHVybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20nXG4gICAgICogfTtcbiAgICAgKiAvLyBhIG5ldyB2aWV3IHdpbGwgbm93IHNob3cgaW4gdGhlIGN1cnJlbnQgd2luZG93XG4gICAgICogYXdhaXQgcGxhdGZvcm0uY3JlYXRlVmlldyh2aWV3T3B0aW9ucywgd2luZG93SWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogY29uc3QgdmlldyA9IGZpbi5WaWV3LndyYXBTeW5jKHsgdXVpZDogd2luZG93SWRlbnRpdHkudXVpZCwgbmFtZTogJ3lhaG9vX3ZpZXcnIH0pO1xuICAgICAqIC8vIHJlcGFyZW50IGBleGFtcGxlX3ZpZXdgIHdoZW4gYSB2aWV3IGluIHRoZSBuZXcgd2luZG93IGlzIHNob3duXG4gICAgICogdmlldy5vbignc2hvd24nLCBhc3luYyAoKSA9PiB7XG4gICAgICogICAgIGxldCB2aWV3SWRlbnRpdHkgPSB7IHV1aWQ6IHdpbmRvd0lkZW50aXR5LnV1aWQsIG5hbWU6ICdleGFtcGxlX3ZpZXcnfTtcbiAgICAgKiAgICAgbGV0IHRhcmdldCA9IHt1dWlkOiB3aW5kb3dJZGVudGl0eS51dWlkLCBuYW1lOiAndGVzdF93aW4nfTtcbiAgICAgKiAgICAgcGxhdGZvcm0uY3JlYXRlVmlldyh2aWV3T3B0aW9ucywgdGFyZ2V0KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSBhIG5ldyB3aW5kb3dcbiAgICAgKiBhd2FpdCBwbGF0Zm9ybS5jcmVhdGVXaW5kb3coe1xuICAgICAqICAgICBuYW1lOiBcInRlc3Rfd2luXCIsXG4gICAgICogICAgIGxheW91dDoge1xuICAgICAqICAgICAgICAgY29udGVudDogW1xuICAgICAqICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgdHlwZTogJ3N0YWNrJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21wb25lbnQnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6ICd2aWV3JyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZToge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAneWFob29fdmlldycsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8veWFob28uY29tJ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgXVxuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIF1cbiAgICAgKiAgICAgfVxuICAgICAqIH0pLnRoZW4oY29uc29sZS5sb2cpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVZpZXcodmlld09wdGlvbnMsIHRhcmdldCwgdGFyZ2V0Vmlldykge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tY3JlYXRlLXZpZXcnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5kaXNwYXRjaCgnY3JlYXRlLXZpZXcnLCB7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBvcHRzOiB2aWV3T3B0aW9ucyxcbiAgICAgICAgICAgIHRhcmdldFZpZXdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2UgfHwgKDAsIHZhbGlkYXRlXzEkMS52YWxpZGF0ZUlkZW50aXR5KShyZXNwb25zZS5pZGVudGl0eSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2hlbiBvdmVyd3JpdGluZyB0aGUgY3JlYXRlVmlldyBjYWxsLCBwbGVhc2UgcmV0dXJuIGFuIG9iamVjdCB0aGF0IGhhcyBhIHZhbGlkICdpZGVudGl0eScgcHJvcGVydHk6ICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbi5WaWV3LndyYXBTeW5jKHJlc3BvbnNlLmlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBXaW5kb3cuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgV2luZG93IGNyZWF0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoZXJlIGFyZSB0d28gV2luZG93IHR5cGVzIGF0IHlvdXIgZGlzcG9zYWwgd2hpbGUgdXNpbmcgT3BlbkZpbiBQbGF0Zm9ybXMgLSBEZWZhdWx0IFdpbmRvdyBhbmQgQ3VzdG9tIFdpbmRvdy5cbiAgICAgKlxuICAgICAqIFRoZSBEZWZhdWx0IFdpbmRvdyB1c2VzIHRoZSBzdGFuZGFyZCBPcGVuRmluIFdpbmRvdyBVSS4gSXQgY29udGFpbnMgdGhlIHN0YW5kYXJkIGNsb3NlLCBtYXhpbWl6ZSBhbmQgbWluaW1pemUgYnV0dG9ucyxcbiAgICAgKiBhbmQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciB0aGUgV2luZG93J3MgbGF5b3V0IGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBGb3IgZGVlcGVyIGN1c3RvbWl6YXRpb24sIHlvdSBjYW4gYnJpbmcgeW91ciBvd24gV2luZG93IGNvZGUgaW50byBhIFBsYXRmb3JtLiBUaGlzIGlzIGNhbGxlZCBhIEN1c3RvbSBXaW5kb3cuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICpcbiAgICAgKiBUaGUgZXhhbXBsZSBiZWxvdyB3aWxsIGNyZWF0ZSBhIERlZmF1bHQgV2luZG93IHdoaWNoIHVzZXMgT3BlbkZpbiBkZWZhdWx0IFdpbmRvdyBVSS48YnI+XG4gICAgICogVGhlIFdpbmRvdyBjb250YWlucyB0d28gVmlld3MgaW4gYSBzdGFjayBMYXlvdXQ6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogcGxhdGZvcm0uY3JlYXRlV2luZG93KHtcbiAgICAgKiAgICAgbGF5b3V0OiB7XG4gICAgICogICAgICAgICBjb250ZW50OiBbXG4gICAgICogICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICB0eXBlOiAnc3RhY2snLFxuICAgICAqICAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZTogJ3ZpZXcnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YXRlOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXN0X3ZpZXdfMScsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L2NhbmFyeS9QbGF0Zm9ybS5odG1sJ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZTogJ3ZpZXcnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YXRlOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXN0X3ZpZXdfMicsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L2NhbmFyeS9QbGF0Zm9ybS5odG1sJ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgXVxuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIF1cbiAgICAgKiAgICAgfVxuICAgICAqIH0pLnRoZW4oY29uc29sZS5sb2cpO1xuICAgICAqIGBgYFxuICAgICAqIFRoZSBEZWZhdWx0IFdpbmRvdydzIGRlc2lnbiBjYW4gYmUgY3VzdG9taXplZCBieSBzcGVjaWZ5aW5nIHRoZSBgc3R5bGVzaGVldFVybGAgcHJvcGVydHkgaW4gdGhlIG1hbmlmZXN0OlxuICAgICAqXG4gICAgICogYGBganNvblxuICAgICAqIHtcbiAgICAgKiAgICAgcGxhdGZvcm06IHtcbiAgICAgKiAgICAgICAgIGRlZmF1bHRXaW5kb3dPcHRpb25zOiB7XG4gICAgICogICAgICAgICAgICAgc3R5bGVzaGVldFVybDogJ3NvbWUtdXJsLmNzcycsXG4gICAgICogICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogRm9yIGEgbGlzdCBvZiBjb21tb24gTGF5b3V0IENTUyBjbGFzc2VzIHlvdSBjYW4gb3ZlcnJpZGUgaW4geW91ciBjdXN0b20gc3R5bGVzaGVldCwgc2VlIDxhIGhyZWY9XCJ0dXRvcmlhbC1sYXlvdXRTdHlsZXMuaHRtbFwiPlVzZWZ1bCBMYXlvdXQgQ1NTIENsYXNzZXM8L2E+XG4gICAgICoqXG4gICAgICogVG8gc3BlY2lmeSBhIFBsYXRmb3JtIEN1c3RvbSBXaW5kb3csIHByb3ZpZGUgYSBgdXJsYCBwcm9wZXJ0eSB3aGVuIGNyZWF0aW5nIGEgV2luZG93LlxuICAgICAqIElmIHlvdSBpbnRlbmQgdG8gcmVuZGVyIGEgTGF5b3V0IGluIHlvdXIgQ3VzdG9tIFdpbmRvdywgeW91IG11c3QgYWxzbyBzcGVjaWZ5IGFuIGBIVE1MRWxlbWVudGAgdGhhdCB0aGUgTGF5b3V0IHdpbGwgaW5qZWN0IGludG8gYW5kIHNldCBpdHMgYGlkYCBwcm9wZXJ0eSB0byBgXCJsYXlvdXQtY29udGFpbmVyXCJgLlxuICAgICAqXG4gICAgICogVGhlIGV4YW1wbGUgYmVsb3cgd2lsbCBjcmVhdGUgYSBQbGF0Zm9ybSBDdXN0b20gV2luZG93OlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAgICAgLy8gaW4gYW4gT3BlbkZpbiBhcHA6XG4gICAgICogICAgIGNvbnN0IHBsYXRmb3JtID0gZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogICAgIGNvbnN0IHdpbmRvd0NvbmZpZyA9XG4gICAgICogICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vd3d3Lm15LWRvbWFpbi5jb20vbXktY3VzdG9tLXdpbmRvdy5odG1sXCIsIC8vIGhlcmUgd2UgcG9pbnQgdG8gd2hlcmUgdGhlIEN1c3RvbSBGcmFtZSBpcyBob3N0ZWQuXG4gICAgICogICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICogICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YWNrXCIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbXBvbmVudFwiLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZTogXCJ2aWV3XCIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZToge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYXBwICMxXCIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vY2RuLm9wZW5maW4uY28vZG9jcy9qYXZhc2NyaXB0L2NhbmFyeS9QbGF0Zm9ybS5odG1sXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb21wb25lbnRcIixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IFwidmlld1wiLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50U3RhdGU6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImFwcCAjMlwiLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC9jYW5hcnkvUGxhdGZvcm0uaHRtbFwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgICAgIF1cbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICB9O1xuICAgICAqICAgICBwbGF0Zm9ybS5jcmVhdGVXaW5kb3cod2luZG93Q29uZmlnKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEhlcmUncyBhbiBleGFtcGxlIG9mIGEgbWluaW1hbGlzdCBDdXN0b20gUGxhdGZvcm0gV2luZG93IGltcGxlbWVudGF0aW9uOlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aHRtbD5cbiAgICAgKiAgICAgPGhlYWQ+XG4gICAgICogICAgICAgICA8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cbiAgICAgKiAgICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MVwiPlxuICAgICAqICAgICAgICAgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiIGhyZWY9XCIuL3N0eWxlcy5jc3NcIj5cbiAgICAgKiAgICAgPC9oZWFkPlxuICAgICAqICAgICA8Ym9keT5cbiAgICAgKiAgICAgICAgIDxkaXYgaWQ9XCJvZi1mcmFtZS1tYWluXCI+XG4gICAgICogICAgICAgICAgICAgPGRpdiBpZD1cInRpdGxlLWJhclwiPlxuICAgICAqICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGUtYmFyLWRyYWdnYWJsZVwiPlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInRpdGxlXCI+IFRoaXMgaXMgYSBjdXN0b20gZnJhbWUhIDwvZGl2PlxuICAgICAqICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgKiAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImJ1dHRvbnMtd3JhcHBlclwiPlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvblwiIGlkPVwibWluaW1pemUtYnV0dG9uXCI+PC9kaXY+XG4gICAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uXCIgaWQ9XCJleHBhbmQtYnV0dG9uXCI+PC9kaXY+XG4gICAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uXCIgaWQ9XCJjbG9zZS1idXR0b25cIj48L2Rpdj5cbiAgICAgKiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICogICAgICAgICAgICAgPC9kaXY+XG4gICAgICogICAgICAgICAgICAgPGRpdiBpZD1cImxheW91dC1jb250YWluZXJcIj48L2Rpdj4gPCEtLSBPcGVuRmluIGxheW91dCB3b3VsZCBiZSBpbmplY3RlZCBoZXJlIC0tPlxuICAgICAqICAgICAgICAgICAgIDxzY3JpcHQgc3JjPVwiLi9jdXN0b20tZnJhbWUuanNcIj48L3NjcmlwdD5cbiAgICAgKiAgICAgICAgIDwvZGl2PlxuICAgICAqICAgICA8L2JvZHk+XG4gICAgICogPC9odG1sPlxuICAgICAqIGBgYFxuICAgICAqIFlvdXIgQ3VzdG9tIFdpbmRvdyBjYW4gdXNlIGluLWRvbWFpbiByZXNvdXJjZXMgZm9yIGZ1cnRoZXIgY3VzdG9taXphdGlvbiAoc3VjaCBhcyBDU1MsIHNjcmlwdHMsIGV0Yy4pLjxicj5cbiAgICAgKiBGb3IgYSBsaXN0IG9mIGNvbW1vbiBMYXlvdXQgQ1NTIGNsYXNzZXMgeW91IGNhbiBvdmVycmlkZSBpbiB5b3VyIHN0eWxlc2hlZXQsIHNlZSA8YSBocmVmPVwidHV0b3JpYWwtbGF5b3V0U3R5bGVzLmh0bWxcIj5Vc2VmdWwgTGF5b3V0IENTUyBDbGFzc2VzPC9hPlxuICAgICAqXG4gICAgICogVGhlIGV4YW1wbGUgYWJvdmUgd2lsbCByZXF1aXJlIHRoZSBgYm9keWAgZWxlbWVudCB0byBoYXZlIGBoZWlnaHQ6IDEwMCU7YCBzZXQgaW4gb3JkZXIgdG8gcmVuZGVyIHRoZSBsYXlvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVdpbmRvdyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1jcmVhdGUtd2luZG93JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlYXNvbikge1xuICAgICAgICAgICAgb3B0aW9ucy5yZWFzb24gPSAnYXBpLWNhbGwnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdjcmVhdGUtdmlldy1jb250YWluZXInLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAoMCwgdmFsaWRhdGVfMSQxLnZhbGlkYXRlSWRlbnRpdHkpKHJlc3BvbnNlLmlkZW50aXR5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaGVuIG92ZXJ3cml0aW5nIHRoZSBjcmVhdGVXaW5kb3cgY2FsbCwgcGxlYXNlIHJldHVybiBhbiBvYmplY3QgdGhhdCBoYXMgYSB2YWxpZCAnaWRlbnRpdHknIHByb3BlcnR5OiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkZW50aXR5IH0gPSByZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5maW4uV2luZG93LndyYXBTeW5jKGlkZW50aXR5KTtcbiAgICAgICAgLy8gd2UgYWRkIHRoZSBpZGVudGl0eSBhdCB0aGUgdG9wIGxldmVsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgcmVzLm5hbWUgPSBpZGVudGl0eS5uYW1lO1xuICAgICAgICByZXMudXVpZCA9IGlkZW50aXR5LnV1aWQ7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBjdXJyZW50IHBsYXRmb3JtLCBhbGwgaXRzIHdpbmRvd3MsIGFuZCB0aGVpciB2aWV3cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwbGF0Zm9ybSA9IGF3YWl0IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50KCk7XG4gICAgICogcGxhdGZvcm0ucXVpdCgpO1xuICAgICAqIC8vIEFsbCB3aW5kb3dzL3ZpZXdzIGluIGN1cnJlbnQgbGF5b3V0IHBsYXRmb3JtIHdpbGwgY2xvc2UgYW5kIHBsYXRmb3JtIHdpbGwgc2h1dCBkb3duXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcXVpdCgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLXF1aXQnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdxdWl0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhIHNwZWNpZmllZCB2aWV3IGluIGEgdGFyZ2V0IHdpbmRvdy5cbiAgICAgKiBAcGFyYW0gdmlld0lkZW50aXR5IFZpZXcgaWRlbnRpdHlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBsZXQgd2luZG93SWRlbnRpdHk7XG4gICAgICogaWYgKGZpbi5tZS5pc1dpbmRvdykge1xuICAgICAqICAgICB3aW5kb3dJZGVudGl0eSA9IGZpbi5tZS5pZGVudGl0eTtcbiAgICAgKiB9IGVsc2UgaWYgKGZpbi5tZS5pc1ZpZXcpIHtcbiAgICAgKiAgICAgd2luZG93SWRlbnRpdHkgPSAoYXdhaXQgZmluLm1lLmdldEN1cnJlbnRXaW5kb3coKSkuaWRlbnRpdHk7XG4gICAgICogfSBlbHNlIHtcbiAgICAgKiAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgcnVubmluZyBpbiBhIHBsYXRmb3JtIFZpZXcgb3IgV2luZG93Jyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3Qgdmlld09wdGlvbnMgPSB7XG4gICAgICogICAgIG5hbWU6ICd0ZXN0X3ZpZXcnLFxuICAgICAqICAgICB1cmw6ICdodHRwczovL2V4YW1wbGUuY29tJ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzbGVlcChtcykge1xuICAgICAqICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBmaW4uUGxhdGZvcm0uZ2V0Q3VycmVudCgpO1xuICAgICAqXG4gICAgICogYXdhaXQgcGxhdGZvcm0uY3JlYXRlVmlldyh2aWV3T3B0aW9ucywgd2luZG93SWRlbnRpdHkpO1xuICAgICAqIC8vIGEgbmV3IHZpZXcgd2lsbCBub3cgc2hvdyBpbiB0aGUgY3VycmVudCB3aW5kb3dcbiAgICAgKlxuICAgICAqIGF3YWl0IHNsZWVwKDUwMDApO1xuICAgICAqXG4gICAgICogY29uc3Qgdmlld0lkZW50aXR5ID0geyB1dWlkOiB3aW5kb3dJZGVudGl0eS51dWlkLCBuYW1lOiAndGVzdF92aWV3J307XG4gICAgICogcGxhdGZvcm0uY2xvc2VWaWV3KHZpZXdJZGVudGl0eSk7XG4gICAgICogLy8gdGhlIHZpZXcgd2lsbCBub3cgY2xvc2VcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZVZpZXcodmlld0lkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1jbG9zZS12aWV3JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdjbG9zZS12aWV3Jywge1xuICAgICAgICAgICAgdmlldzogdmlld0lkZW50aXR5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAqKipERVBSRUNBVEVEIC0gcGxlYXNlIHVzZSB7QGxpbmsgUGxhdGZvcm0uY3JlYXRlVmlldyBQbGF0Zm9ybS5jcmVhdGVWaWV3fS4qKipcbiAgICAgKiBSZXBhcmVudHMgYSBzcGVjaWZpZWQgdmlldyBpbiBhIG5ldyB0YXJnZXQgd2luZG93LlxuICAgICAqIEBwYXJhbSB2aWV3SWRlbnRpdHkgVmlldyBpZGVudGl0eVxuICAgICAqIEBwYXJhbSB0YXJnZXQgbmV3IG93bmVyIHdpbmRvdyBpZGVudGl0eVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcmVwYXJlbnRWaWV3KHZpZXdJZGVudGl0eSwgdGFyZ2V0KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignUGxhdGZvcm0ucmVwYXJlbnRWaWV3IGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUGxhdGZvcm0uY3JlYXRlVmlldycpO1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tcmVwYXJlbnQtdmlldycsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRWaWV3SWRlbnRpdHkgPSB7XG4gICAgICAgICAgICAuLi52aWV3SWRlbnRpdHksXG4gICAgICAgICAgICB1dWlkOiB2aWV3SWRlbnRpdHkudXVpZCA/PyB0aGlzLmlkZW50aXR5LnV1aWRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmlldyA9IGF3YWl0IHRoaXMuZmluLlZpZXcud3JhcChub3JtYWxpemVkVmlld0lkZW50aXR5KTtcbiAgICAgICAgY29uc3Qgdmlld09wdGlvbnMgPSBhd2FpdCB2aWV3LmdldE9wdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVmlldyh2aWV3T3B0aW9ucywgdGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBwbGF0Zm9ybSBpbiBpdHMgY3VycmVudCBzdGF0ZS4gWW91IGNhbiBwYXNzIHRoZSByZXR1cm5pbmcgb2JqZWN0IHRvXG4gICAgICogW1BsYXRmb3JtLmFwcGx5U25hcHNob3Rde0BsaW5rIFBsYXRmb3JtI2FwcGx5U25hcHNob3R9IHRvIGxhdW5jaCBpdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoZSBzbmFwc2hvdCB3aWxsIGluY2x1ZGUgZGV0YWlscyBzdWNoIGFzIGFuIFtJU08gZm9ybWF0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSlcbiAgICAgKiB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgc25hcHNob3Qgd2FzIHRha2VuLCBPcGVuRmluIHJ1bnRpbWUgdmVyc2lvbiB0aGUgcGxhdGZvcm0gaXMgcnVubmluZyBvbiwgbW9uaXRvciBpbmZvcm1hdGlvblxuICAgICAqIGFuZCB0aGUgbGlzdCBvZiBjdXJyZW50bHkgcnVubmluZyB3aW5kb3dzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLmdldEN1cnJlbnQoKTtcbiAgICAgKiBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IHBsYXRmb3JtLmdldFNuYXBzaG90KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U25hcHNob3QoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1nZXQtc25hcHNob3QnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdnZXQtc25hcHNob3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogKipOT1RFKio6IEludGVybmFsIHVzZSBvbmx5LiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gbWFuYWdlIHRoZSBzdGF0ZSBvZiBpbmRpdmlkdWFsIHZpZXdzLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGEgc2luZ2xlIHZpZXcncyBvcHRpb25zIGluIGl0cyBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gcmVzdG9yZSBhIHZpZXcgdG8gYSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3SWRlbnRpdHkgVmlldyBpZGVudGl0eVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEByZW1hcmtzIFRoaXMgc2xpY2Ugb2Ygc25hcHNob3Qgc3RhdGUgaXMgZXF1aXZhbGVudCB0byB3aGF0IGlzIHN0b3JlZCBhcyBgY29tcG9uZW50U3RhdGVgIGZvciB2aWV3c1xuICAgICAqIHdoZW4gY2FwdHVyaW5nIHBsYXRmb3JtIHN0YXRlIHVzaW5nIFtQbGF0Zm9ybS5nZXRTbmFwc2hvdF17QGxpbmsgUGxhdGZvcm0jZ2V0U25hcHNob3R9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLmdldEN1cnJlbnQoKTtcbiAgICAgKiBjb25zdCB1cmwgPSAnaHR0cHM6Ly9nb29nbGUuY29tJztcbiAgICAgKiBjb25zdCB2aWV3ID0gYXdhaXQgZmluLlZpZXcuY3JlYXRlKHsgbmFtZTogJ215LXZpZXcnLCB0YXJnZXQ6IGZpbi5tZS5pZGVudGl0eSwgdXJsIH0pO1xuICAgICAqXG4gICAgICogYXdhaXQgdmlldy5uYXZpZ2F0ZSh1cmwpO1xuICAgICAqXG4gICAgICogY29uc3Qgdmlld1N0YXRlID0gYXdhaXQgcGxhdGZvcm0uZ2V0Vmlld1NuYXBzaG90KHZpZXcuaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2codmlld1N0YXRlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXRWaWV3U25hcHNob3Qodmlld0lkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2dldC12aWV3LXNuYXBzaG90JywgeyB2aWV3SWRlbnRpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzbmFwc2hvdCB0byBhIHJ1bm5pbmcgUGxhdGZvcm0uXG4gICAgICogUmVxdWVzdGVkIHNuYXBzaG90IG11c3QgYmUgYSB2YWxpZCBTbmFwc2hvdCBvYmplY3QsIG9yIGEgdXJsIG9yIGZpbGVwYXRoIHRvIHN1Y2ggYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQ2FuIG9wdGlvbmFsbHkgY2xvc2UgZXhpc3Rpbmcgd2luZG93cyBhbmQgb3ZlcndyaXRlIGN1cnJlbnQgcGxhdGZvcm0gc3RhdGUgd2l0aCB0aGF0IG9mIGEgc25hcHNob3QuXG4gICAgICpcbiAgICAgKiBUaGUgZnVuY3Rpb24gYWNjZXB0cyBlaXRoZXIgYSBzbmFwc2hvdCB0YWtlbiB1c2luZyB7QGxpbmsgUGxhdGZvcm0jZ2V0U25hcHNob3QgZ2V0U25hcHNob3R9LFxuICAgICAqIG9yIGEgdXJsIG9yIGZpbGVwYXRoIHRvIGEgc25hcHNob3QgSlNPTiBvYmplY3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZFNuYXBzaG90IFNuYXBzaG90IHRvIGFwcGx5LCBvciBhIHVybCBvciBmaWxlcGF0aC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHNwZWNpZnkgd2hldGhlciBleGlzdGluZyB3aW5kb3dzIHNob3VsZCBiZSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBXaWxsIGNyZWF0ZSBhbnkgd2luZG93cyBhbmQgdmlld3MgdGhhdCBhcmUgbm90IHJ1bm5pbmcgYnV0IGFyZSBwYXNzZWQgaW4gdGhlIHNuYXBzaG90IG9iamVjdC4gQW55IFZpZXdcbiAgICAgKiBzcGVjaWZpZWQgaW4gdGhlIHNuYXBzaG90IGlzIGFzc2lnbmVkIGEgcmFuZG9tbHkgZ2VuZXJhdGVkIG5hbWUgdG8gYXZvaWQgY29sbGlzaW9ucy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiAvLyBHZXQgYSB3cmFwcGVkIGxheW91dCBwbGF0Zm9ybSBpbnN0YW5jZVxuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLmdldEN1cnJlbnQoKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAqICAgICB3aW5kb3dzOiBbXG4gICAgICogICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICogICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RhY2snLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lOiAndmlldycsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZToge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb21wb25lbnRfWCcsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93d3cub3BlbmZpbi5jbydcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lOiAndmlldycsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZToge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb21wb25lbnRfWScsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9lbWJlZC13ZWIvY2hhcnQuaHRtbCdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgXVxuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgXVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHBsYXRmb3JtLmFwcGx5U25hcHNob3Qoc25hcHNob3QpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSW4gcGxhY2Ugb2YgYSBzbmFwc2hvdCBvYmplY3QsIGBhcHBseVNuYXBzaG90YCBjYW4gdGFrZSBhIHVybCBvciBmaWxlcGF0aCBhbmQgdG8gcmV0cmlldmUgYSBKU09OIHNuYXBzaG90LlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwbGF0Zm9ybSA9IGF3YWl0IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50KCk7XG4gICAgICogcGxhdGZvcm0uYXBwbHlTbmFwc2hvdCgnaHR0cHM6Ly9hcGkuanNvbmJpbi5pby9iLzVlNmY5MDNlZjQzMzFlNjgxZmMxMjMxZC8xJyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBPcHRpb25hbGx5LCBgYXBwbHlTbmFwc2hvdGAgY2FuIGNsb3NlIGV4aXN0aW5nIHdpbmRvd3MgYW5kIHJlc3RvcmUgYSBQbGF0Zm9ybSB0byBhIHByZXZpb3VzbHkgc2F2ZWQgc3RhdGUuXG4gICAgICogVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgcHJvdmlkaW5nIGB7IGNsb3NlRXhpc3RpbmdXaW5kb3dzOiB0cnVlIH1gIGFzIGFuIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogLy8gR2V0IGEgd3JhcHBlZCBsYXlvdXQgcGxhdGZvcm0gaW5zdGFuY2VcbiAgICAgKiBjb25zdCBwbGF0Zm9ybSA9IGF3YWl0IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50KCk7XG4gICAgICpcbiAgICAgKiBhc3luYyBmdW5jdGlvbiBhZGRWaWV3VG9XaW5kb3cod2luSWQpIHtcbiAgICAgKiAgICAgcmV0dXJuIGF3YWl0IHBsYXRmb3JtLmNyZWF0ZVZpZXcoe1xuICAgICAqICAgICAgICAgbmFtZTogJ3Rlc3Rfdmlld18zJyxcbiAgICAgKiAgICAgICAgIHVybDogJ2h0dHBzOi8vb3BlbmZpbi5jbydcbiAgICAgKiAgICAgfSwgd2luSWQpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvd1dpdGhUd29WaWV3cygpIHtcbiAgICAgKiAgICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBmaW4uUGxhdGZvcm0uZ2V0Q3VycmVudCgpO1xuICAgICAqXG4gICAgICogICAgIHJldHVybiBwbGF0Zm9ybS5jcmVhdGVXaW5kb3coe1xuICAgICAqICAgICAgICAgbGF5b3V0OiB7XG4gICAgICogICAgICAgICAgICAgY29udGVudDogW1xuICAgICAqICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RhY2snLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6ICd2aWV3JyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50U3RhdGU6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXN0X3ZpZXdfMScsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2V4YW1wbGUuY29tJ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21wb25lbnQnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lOiAndmlldycsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YXRlOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGVzdF92aWV3XzInLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly95YWhvby5jb20nXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IHdpbiA9IGF3YWl0IGNyZWF0ZVdpbmRvd1dpdGhUd29WaWV3cygpO1xuICAgICAqIC8vIC4uLiB5b3Ugd2lsbCBub3cgc2VlIGEgbmV3IHdpbmRvdyB3aXRoIHR3byB2aWV3cyBpbiBpdFxuICAgICAqXG4gICAgICogLy8gd2UgdGFrZSBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhcHAsIGJlZm9yZSBjaGFuZ2luZyBpdFxuICAgICAqIGNvbnN0IHNuYXBzaG90T2ZJbml0aWFsQXBwU3RhdGUgPSBhd2FpdCBwbGF0Zm9ybS5nZXRTbmFwc2hvdCgpO1xuICAgICAqXG4gICAgICogLy8gbm93IGxldCdzIGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIGFwcDpcbiAgICAgKiBhd2FpdCBhZGRWaWV3VG9XaW5kb3cod2luLmlkZW50aXR5KTtcbiAgICAgKiAvLyAuLi4gdGhlIHdpbmRvdyBub3cgaGFzIHRocmVlIHZpZXdzIGluIGl0XG4gICAgICpcbiAgICAgKiBhd2FpdCBwbGF0Zm9ybS5hcHBseVNuYXBzaG90KHNuYXBzaG90T2ZJbml0aWFsQXBwU3RhdGUsIHsgY2xvc2VFeGlzdGluZ1dpbmRvd3M6IHRydWUgfSk7XG4gICAgICogLy8gLi4uIHRoZSB3aW5kb3cgd2lsbCByZXZlcnQgdG8gcHJldmlvdXMgc3RhdGUsIHdpdGgganVzdCB0d28gdmlld3NcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGFwcGx5U25hcHNob3QocmVxdWVzdGVkU25hcHNob3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWFwcGx5LXNuYXBzaG90JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ1JlcXVlc3RlZCBzbmFwc2hvdCBtdXN0IGJlIGEgdmFsaWQgU25hcHNob3Qgb2JqZWN0LCBvciBhIHVybCBvciBmaWxlcGF0aCB0byBzdWNoIGFuIG9iamVjdC4nO1xuICAgICAgICBsZXQgc25hcHNob3Q7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdGVkU25hcHNob3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCBhbmQgcGFyc2Ugc25hcHNob3RcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jaGFubmVsLndpcmUuc2VuZEFjdGlvbignZ2V0LWFwcGxpY2F0aW9uLW1hbmlmZXN0Jywge1xuICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdFVybDogcmVxdWVzdGVkU25hcHNob3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdCA9IHJlc3BvbnNlLnBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyTXNnfTogJHtlcnJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzbmFwc2hvdCA9IHJlcXVlc3RlZFNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICAgIGlmICghc25hcHNob3Qud2luZG93cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdhcHBseS1zbmFwc2hvdCcsIHtcbiAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBKU09OIG1hbmlmZXN0IHVzaW5nIHRoZSBicm93c2VyIHByb2Nlc3MgYW5kIHJldHVybnMgYSBKYXZhc2NyaXB0IG9iamVjdC5cbiAgICAgKiBDYW4gYmUgb3ZlcndyaXR0ZW4gdXNpbmcge0BsaW5rIFBsYXRmb3JtLlBsYXRmb3JtTW9kdWxlLmluaXQgUGxhdGZvcm0uaW5pdH0uXG4gICAgICogQHBhcmFtIG1hbmlmZXN0VXJsIFRoZSBVUkwgb2YgdGhlIG1hbmlmZXN0IHRvIGZldGNoLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgQ2FuIGJlIG92ZXJ3cml0dGVuIHVzaW5nIHtAbGluayBQbGF0Zm9ybSNpbml0IFBsYXRmb3JtLmluaXR9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcGxhdGZvcm0gPSBmaW4uUGxhdGZvcm0uZ2V0Q3VycmVudFN5bmMoKTtcbiAgICAgKiBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IHBsYXRmb3JtLmZldGNoTWFuaWZlc3QoJ2h0dHBzOi8vd3d3LnBhdGgtdG8tbWFuaWZlc3QuY29tL2FwcC5qc29uJyk7XG4gICAgICogY29uc29sZS5sb2cobWFuaWZlc3QpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoTWFuaWZlc3QobWFuaWZlc3RVcmwpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgncGxhdGZvcm0tZmV0Y2gtbWFuaWZlc3QnLCB7IG1hbmlmZXN0VXJsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBtYW5pZmVzdCBieSB1cmwgYW5kIGxhdW5jaGVzIGEgbGVnYWN5IGFwcGxpY2F0aW9uIG1hbmlmZXN0IG9yIHNuYXBzaG90IGludG8gdGhlIHBsYXRmb3JtLiAgUmV0dXJucyBhIHByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHRvIHRoZSB3cmFwcGVkIFBsYXRmb3JtLlxuICAgICAqIEBwYXJhbSBtYW5pZmVzdFVybCAtIFRoZSBVUkwgb2YgdGhlIG1hbmlmZXN0IHRoYXQgd2lsbCBiZSBsYXVuY2hlZCBpbnRvIHRoZSBwbGF0Zm9ybS4gIElmIHRoaXMgYXBwIG1hbmlmZXN0XG4gICAgICogY29udGFpbnMgYSBzbmFwc2hvdCwgdGhhdCB3aWxsIGJlIGxhdW5jaGVkIGludG8gdGhlIHBsYXRmb3JtLiAgSWYgbm90LCB0aGUgYXBwbGljYXRpb24gZGVzY3JpYmVkIGluIHN0YXJ0dXBfYXBwIG9wdGlvbnNcbiAgICAgKiB3aWxsIGJlIGxhdW5jaGVkIGludG8gdGhlIHBsYXRmb3JtLiBUaGUgYXBwbGljYWJsZSBzdGFydHVwX2FwcCBvcHRpb25zIHdpbGwgYmVjb21lIHtAbGluayBPcGVuRmluLlZpZXdDcmVhdGlvbk9wdGlvbnMgVmlldyBPcHRpb25zfS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIElmIHRoZSBhcHAgbWFuaWZlc3QgY29udGFpbnMgYSBzbmFwc2hvdCwgdGhhdCB3aWxsIGJlIGxhdW5jaGVkIGludG8gdGhlIHBsYXRmb3JtLiAgSWYgbm90LCB0aGVcbiAgICAgKiBhcHBsaWNhdGlvbiBkZXNjcmliZWQgaW4gc3RhcnR1cF9hcHAgb3B0aW9ucyB3aWxsIGJlIGxhdW5jaGVkIGludG8gdGhlIHBsYXRmb3JtIGFzIGEgd2luZG93IHdpdGggYSBzaW5nbGUgdmlldy5cbiAgICAgKiBUaGUgYXBwbGljYWJsZSBzdGFydHVwX2FwcCBvcHRpb25zIHdpbGwgYmVjb21lIFZpZXcgT3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB0cnkge1xuICAgICAqICAgICBjb25zdCBwbGF0Zm9ybSA9IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50U3luYygpO1xuICAgICAqICAgICBhd2FpdCBwbGF0Zm9ybS5sYXVuY2hDb250ZW50TWFuaWZlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6NTU1NS9hcHAuanNvbicpO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgY29udGVudCBsYXVuY2hlZCBzdWNjZXNzZnVsbHkgaW50byBwbGF0Zm9ybWApO1xuICAgICAqIH0gY2F0Y2goZSkge1xuICAgICAqICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAqIH1cbiAgICAgKiAvLyBGb3IgYSBsb2NhbCBtYW5pZmVzdCBmaWxlOlxuICAgICAqIHRyeSB7XG4gICAgICogICAgIGNvbnN0IHBsYXRmb3JtID0gZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogICAgIHBsYXRmb3JtLmxhdW5jaENvbnRlbnRNYW5pZmVzdCgnZmlsZTovLy9DOi9zb21lZm9sZGVyL2FwcC5qc29uJyk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBjb250ZW50IGxhdW5jaGVkIHN1Y2Nlc3NmdWxseSBpbnRvIHBsYXRmb3JtYCk7XG4gICAgICogfSBjYXRjaChlKSB7XG4gICAgICogICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBsYXVuY2hDb250ZW50TWFuaWZlc3QobWFuaWZlc3RVcmwpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWxhdW5jaC1jb250ZW50LW1hbmlmZXN0JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IHRoaXMuZmV0Y2hNYW5pZmVzdChtYW5pZmVzdFVybCk7XG4gICAgICAgIGNsaWVudC5kaXNwYXRjaCgnbGF1bmNoLWludG8tcGxhdGZvcm0nLCB7IG1hbmlmZXN0LCBtYW5pZmVzdFVybCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGV4dCBvZiBhIGhvc3Qgd2luZG93LiBUaGUgY29udGV4dCB3aWxsIGJlIGF2YWlsYWJsZSB0byB0aGUgd2luZG93IGl0c2VsZiwgYW5kIHRvIGl0cyBjaGlsZCBWaWV3cy4gSXQgd2lsbCBiZSBzYXZlZCBpbiBhbnkgcGxhdGZvcm0gc25hcHNob3RzLlxuICAgICAqIEl0IGNhbiBiZSByZXRyaWV2ZWQgdXNpbmcge0BsaW5rIFBsYXRmb3JtI2dldFdpbmRvd0NvbnRleHQgZ2V0V2luZG93Q29udGV4dH0uXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBBIGZpZWxkIHdoZXJlIHNlcmlhbGl6YWJsZSBjb250ZXh0IGRhdGEgY2FuIGJlIHN0b3JlZCB0byBiZSBzYXZlZCBpbiBwbGF0Zm9ybSBzbmFwc2hvdHMuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIEEgdGFyZ2V0IHdpbmRvdyBvciB2aWV3IG1heSBvcHRpb25hbGx5IGJlIHByb3ZpZGVkLiBJZiBubyB0YXJnZXQgaXMgcHJvdmlkZWQsIHRoZSB1cGRhdGUgd2lsbCBiZSBhcHBsaWVkXG4gICAgICogdG8gdGhlIGN1cnJlbnQgd2luZG93IChpZiBjYWxsZWQgZnJvbSBhIFdpbmRvdykgb3IgdGhlIGN1cnJlbnQgaG9zdCB3aW5kb3cgKGlmIGNhbGxlZCBmcm9tIGEgVmlldykuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBUaGUgY29udGV4dCBkYXRhIG11c3QgYmUgc2VyaWFsaXphYmxlLiAgVGhpcyBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSBhIHdpbmRvdyBvciB2aWV3IHRoYXQgaGFzIGJlZW4gbGF1bmNoZWQgaW50byBhXG4gICAgICogcGxhdGZvcm0uXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSB3aW5kb3cgaXRzZWxmLCBvciBmcm9tIGFueSBjaGlsZCB2aWV3LiBDb250ZXh0IGRhdGEgaXMgc2hhcmVkIGJ5IGFsbFxuICAgICAqIGVudGl0aWVzIHdpdGhpbiBhIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogU2V0dGluZyBvd24gY29udGV4dDpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogY29uc3QgY29udGV4dERhdGEgPSB7XG4gICAgICogICAgIHNlY3VyaXR5OiAnU1RPQ0snLFxuICAgICAqICAgICBjdXJyZW50VmlldzogJ2RldGFpbGVkJ1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGF3YWl0IHBsYXRmb3JtLnNldFdpbmRvd0NvbnRleHQoY29udGV4dERhdGEpO1xuICAgICAqIC8vIENvbnRleHQgb2YgY3VycmVudCB3aW5kb3cgaXMgbm93IHNldCB0byBgY29udGV4dERhdGFgXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoZSBjb250ZXh0IG9mIGFub3RoZXIgd2luZG93IG9yIHZpZXc6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwbGF0Zm9ybSA9IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50U3luYygpO1xuICAgICAqIGNvbnN0IGNvbnRleHREYXRhID0ge1xuICAgICAqICAgICBzZWN1cml0eTogJ1NUT0NLJyxcbiAgICAgKiAgICAgY3VycmVudFZpZXc6ICdkZXRhaWxlZCdcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCB3aW5kb3dPclZpZXdJZGVudGl0eSA9IHsgdXVpZDogZmluLm1lLnV1aWQsIG5hbWU6ICduYW1lT2ZXaW5kb3dPclZpZXcnIH07XG4gICAgICogYXdhaXQgcGxhdGZvcm0uc2V0V2luZG93Q29udGV4dChjb250ZXh0RGF0YSwgd2luZG93T3JWaWV3SWRlbnRpdHkpO1xuICAgICAqIC8vIENvbnRleHQgb2YgdGhlIHRhcmdldCB3aW5kb3cgb3IgdmlldyBpcyBub3cgc2V0IHRvIGBjb250ZXh0RGF0YWBcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEEgdmlldyBjYW4gbGlzdGVuIHRvIGNoYW5nZXMgdG8gaXRzIGhvc3Qgd2luZG93J3MgY29udGV4dCBieSBsaXN0ZW5pbmcgdG8gdGhlIGBob3N0LWNvbnRleHQtY2hhbmdlZGAgZXZlbnQuXG4gICAgICogVGhpcyBldmVudCB3aWxsIGZpcmUgd2hlbiBhIGhvc3Qgd2luZG93J3MgY29udGV4dCBpcyB1cGRhdGVkIG9yIHdoZW4gdGhlIHZpZXcgaXMgcmVwYXJlbnRlZCB0byBhIG5ldyB3aW5kb3c6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIEZyb20gYSB2aWV3XG4gICAgICogY29uc3QgY29udGV4dENoYW5nZUhhbmRsZXIgPSAoeyBjb250ZXh0IH0pID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0hvc3Qgd2luZG93XFwncyBjb250ZXh0IGhhcyBjaGFuZ2VkLiBOZXcgY29udGV4dCBkYXRhOicsIGNvbnRleHQpO1xuICAgICAqICAgICAvLyByZWFjdCB0byBuZXcgY29udGV4dCBkYXRhIGhlcmVcbiAgICAgKiB9XG4gICAgICogYXdhaXQgZmluLm1lLm9uKCdob3N0LWNvbnRleHQtY2hhbmdlZCcsIGNvbnRleHRDaGFuZ2VIYW5kbGVyKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogY29uc3QgY29udGV4dERhdGEgPSB7XG4gICAgICogICAgIHNlY3VyaXR5OiAnU1RPQ0snLFxuICAgICAqICAgICBjdXJyZW50VmlldzogJ2RldGFpbGVkJ1xuICAgICAqIH1cbiAgICAgKiBwbGF0Zm9ybS5zZXRXaW5kb3dDb250ZXh0KGNvbnRleHREYXRhKSAvLyBjb250ZXh0Q2hhbmdlSGFuZGxlciB3aWxsIGxvZyB0aGUgbmV3IGNvbnRleHRcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRvIGxpc3RlbiB0byBhIHdpbmRvdydzIGNvbnRleHQgdXBkYXRlcywgdXNlIHRoZSBgY29udGV4dC1jaGFuZ2VkYCBldmVudDpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIEZyb20gYSB3aW5kb3dcbiAgICAgKiBjb25zdCBjb250ZXh0Q2hhbmdlSGFuZGxlciA9ICh7IGNvbnRleHQgfSkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnVGhpcyB3aW5kb3dcXCdzIGNvbnRleHQgaGFzIGNoYW5nZWQuIE5ldyBjb250ZXh0IGRhdGE6JywgY29udGV4dCk7XG4gICAgICogICAgIC8vIHJlYWN0IHRvIG5ldyBjb250ZXh0IGRhdGEgaGVyZVxuICAgICAqIH1cbiAgICAgKiBhd2FpdCBmaW4ubWUub24oJ2NvbnRleHQtY2hhbmdlZCcsIGNvbnRleHRDaGFuZ2VIYW5kbGVyKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogY29uc3QgY29udGV4dERhdGEgPSB7XG4gICAgICogICAgIHNlY3VyaXR5OiAnU1RPQ0snLFxuICAgICAqICAgICBjdXJyZW50VmlldzogJ2RldGFpbGVkJ1xuICAgICAqIH1cbiAgICAgKiBwbGF0Zm9ybS5zZXRXaW5kb3dDb250ZXh0KGNvbnRleHREYXRhKSAvLyBjb250ZXh0Q2hhbmdlSGFuZGxlciB3aWxsIGxvZyB0aGUgbmV3IGNvbnRleHRcbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0V2luZG93Q29udGV4dChjb250ZXh0ID0ge30sIHRhcmdldCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tc2V0LXdpbmRvdy1jb250ZXh0JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgc2VyaWFsaXphYmxlIG9iamVjdCBvciBzdHJpbmcgdG8gc2V0IHRoZSBjb250ZXh0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IHsgZW50aXR5VHlwZSB9ID0gdGFyZ2V0ID8gYXdhaXQgdGhpcy5maW4uU3lzdGVtLmdldEVudGl0eUluZm8odGFyZ2V0LnV1aWQsIHRhcmdldC5uYW1lKSA6IHRoaXMuZmluLm1lO1xuICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ3NldC13aW5kb3ctY29udGV4dCcsIHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBlbnRpdHlUeXBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQgfHwgeyB1dWlkOiB0aGlzLmZpbi5tZS51dWlkLCBuYW1lOiB0aGlzLmZpbi5tZS5uYW1lIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29udGV4dCBjb250ZXh0IG9mIGEgaG9zdCB3aW5kb3cgdGhhdCB3YXMgcHJldmlvdXNseSBzZXQgdXNpbmcge0BsaW5rIFBsYXRmb3JtI3NldFdpbmRvd0NvbnRleHQgc2V0V2luZG93Q29udGV4dH0uXG4gICAgICogVGhlIGNvbnRleHQgd2lsbCBiZSBzYXZlZCBpbiBhbnkgcGxhdGZvcm0gc25hcHNob3RzLiAgUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gQSB0YXJnZXQgd2luZG93IG9yIHZpZXcgbWF5IG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQuIElmIG5vIHRhcmdldCBpcyBwcm92aWRlZCwgdGFyZ2V0IHdpbGwgYmVcbiAgICAgKiB0aGUgY3VycmVudCB3aW5kb3cgKGlmIGNhbGxlZCBmcm9tIGEgV2luZG93KSBvciB0aGUgY3VycmVudCBob3N0IHdpbmRvdyAoaWYgY2FsbGVkIGZyb20gYSBWaWV3KS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZnJvbSB0aGUgd2luZG93IGl0c2VsZiwgb3IgZnJvbSBhbnkgY2hpbGQgdmlldy4gQ29udGV4dCBkYXRhIGlzIHNoYXJlZFxuICAgICAqIGJ5IGFsbCBlbnRpdGllcyB3aXRoaW4gYSB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogUmV0cmlldmluZyBjb250ZXh0IGZyb20gY3VycmVudCB3aW5kb3c6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwbGF0Zm9ybSA9IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50U3luYygpO1xuICAgICAqIGNvbnN0IGN1c3RvbUNvbnRleHQgPSB7IGFuc3dlcjogNDIgfTtcbiAgICAgKiBhd2FpdCBwbGF0Zm9ybS5zZXRXaW5kb3dDb250ZXh0KGN1c3RvbUNvbnRleHQpO1xuICAgICAqXG4gICAgICogY29uc3QgbXlDb250ZXh0ID0gYXdhaXQgcGxhdGZvcm0uZ2V0V2luZG93Q29udGV4dCgpO1xuICAgICAqIGNvbnNvbGUubG9nKG15Q29udGV4dCk7IC8vIHsgYW5zd2VyOiA0MiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBSZXRyaWV2aW5nIHRoZSBjb250ZXh0IG9mIGFub3RoZXIgd2luZG93IG9yIHZpZXc6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwbGF0Zm9ybSA9IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50U3luYygpO1xuICAgICAqXG4gICAgICogY29uc3Qgd2luZG93T3JWaWV3SWRlbnRpdHkgPSB7IHV1aWQ6IGZpbi5tZS51dWlkLCBuYW1lOiAnbmFtZU9mV2luZG93T3JWaWV3JyB9O1xuICAgICAqXG4gICAgICogY29uc3QgdGFyZ2V0V2luZG93Q29udGV4dCA9IGF3YWl0IHBsYXRmb3JtLmdldFdpbmRvd0NvbnRleHQod2luZG93T3JWaWV3SWRlbnRpdHkpO1xuICAgICAqIGNvbnNvbGUubG9nKHRhcmdldFdpbmRvd0NvbnRleHQpOyAvLyBjb250ZXh0IG9mIHRhcmdldCB3aW5kb3dcbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgZ2V0V2luZG93Q29udGV4dCh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWdldC13aW5kb3ctY29udGV4dCcsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IHsgZW50aXR5VHlwZSB9ID0gdGFyZ2V0ID8gYXdhaXQgdGhpcy5maW4uU3lzdGVtLmdldEVudGl0eUluZm8odGFyZ2V0LnV1aWQsIHRhcmdldC5uYW1lKSA6IHRoaXMuZmluLm1lO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdnZXQtd2luZG93LWNvbnRleHQnLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCB8fCB7IHV1aWQ6IHRoaXMuZmluLm1lLnV1aWQsIG5hbWU6IHRoaXMuZmluLm1lLm5hbWUgfSxcbiAgICAgICAgICAgIGVudGl0eVR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhIHdpbmRvdy4gSWYgZW5hYmxlQmVmb3JlVW5sb2FkIGlzIGVuYWJsZWQgaW4gdGhlIFBsYXRmb3JtIG9wdGlvbnMsIGFueSBiZWZvcmV1bmxvYWQgaGFuZGxlciBzZXQgb24gVmlld3Mgd2lsbCBmaXJlXG4gICAgICogVGhpcyBiZWhhdmlvciBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBza2lwQmVmb3JlVW5sb2FkIHRvIGZhbHNlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0gd2luSWRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJlbWFya3MgVGhpcyBtZXRob2Qgd29ya3MgYnkgc2V0dGluZyBhIGBjbG9zZS1yZXF1ZXN0ZWRgIGhhbmRsZXIgb24gdGhlIFBsYXRmb3JtIFdpbmRvdy4gSWYgeW91IGhhdmUgeW91ciBvd24gYGNsb3NlLXJlcXVlc3RlZGAgaGFuZGxlciBzZXQgb24gdGhlIFBsYXRmb3JtIFdpbmRvdyBhcyB3ZWxsLFxuICAgICAqIGl0IGlzIHJlY29tbWVuZGVkIHRvIG1vdmUgdGhhdCBsb2dpYyBvdmVyIHRvIHRoZSBbUGxhdGZvcm1Qcm92aWRlci5jbG9zZVdpbmRvd117QGxpbmsgUGxhdGZvcm1Qcm92aWRlciNjbG9zZVdpbmRvd30gb3ZlcnJpZGUgdG8gZW5zdXJlIGl0IHJ1bnMgd2hlbiB0aGUgV2luZG93IGNsb3Nlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIENsb3NlIHRoZSBjdXJyZW50IFdpbmRvdyBpbnNpZGUgYSBXaW5kb3cgY29udGV4dFxuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLmdldEN1cnJlbnQoKTtcbiAgICAgKiBwbGF0Zm9ybS5jbG9zZVdpbmRvdyhmaW4ubWUuaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogLy8gQ2xvc2UgdGhlIFdpbmRvdyBmcm9tIGluc2lkZSBhIFZpZXcgY29udGV4dFxuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLmdldEN1cnJlbnQoKTtcbiAgICAgKiBjb25zdCBwYXJlbnRXaW5kb3cgPSBhd2FpdCBmaW4ubWUuZ2V0Q3VycmVudFdpbmRvdygpO1xuICAgICAqIHBsYXRmb3JtLmNsb3NlV2luZG93KHBhcmVudFdpbmRvdy5pZGVudGl0eSk7XG4gICAgICpcbiAgICAgKiAvLyBDbG9zZSB0aGUgV2luZG93IGFuZCBkbyBub3QgZmlyZSB0aGUgYmVmb3JlIHVubG9hZCBoYW5kbGVyIG9uIFZpZXdzXG4gICAgICogY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBmaW4uUGxhdGZvcm0uZ2V0Q3VycmVudCgpO1xuICAgICAqIHBsYXRmb3JtLmNsb3NlV2luZG93KGZpbi5tZS5pZGVudGl0eSwgeyBza2lwQmVmb3JlVW5sb2FkOiB0cnVlIH0pO1xuICAgICAqIGBgYFxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZVdpbmRvdyh3aW5kb3dJZCwgb3B0aW9ucyA9IHsgc2tpcEJlZm9yZVVubG9hZDogZmFsc2UgfSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tY2xvc2Utd2luZG93JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgnY2xvc2Utd2luZG93JywgeyB3aW5kb3dJZCwgb3B0aW9ucyB9KTtcbiAgICB9XG59XG5JbnN0YW5jZSQyLlBsYXRmb3JtID0gUGxhdGZvcm07XG5fUGxhdGZvcm1fY29ubmVjdFRvUHJvdmlkZXIgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgbGF5b3V0ID0ge307XG5cbnZhciBGYWN0b3J5JDIgPSB7fTtcblxudmFyIEluc3RhbmNlJDEgPSB7fTtcblxudmFyIGNvbW1vblV0aWxzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21tb25VdGlscywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb21tb25VdGlscy5vdmVycmlkZUZyb21Db21wb3NhYmxlcyA9IGNvbW1vblV0aWxzLmlzVmFsaWRQcmVzZXRUeXBlID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNWYWxpZFByZXNldFR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb2x1bW5zJzpcbiAgICAgICAgY2FzZSAnZ3JpZCc6XG4gICAgICAgIGNhc2UgJ3Jvd3MnOlxuICAgICAgICBjYXNlICd0YWJzJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbW1vblV0aWxzLmlzVmFsaWRQcmVzZXRUeXBlID0gaXNWYWxpZFByZXNldFR5cGU7XG5mdW5jdGlvbiBvdmVycmlkZUZyb21Db21wb3NhYmxlcyguLi5vdmVycmlkZXMpIHtcbiAgICByZXR1cm4gKGJhc2UpID0+IG92ZXJyaWRlcy5yZWR1Y2VSaWdodCgocCwgYykgPT4gKGIpID0+IGMocChiKSksICh4KSA9PiB4KShiYXNlKTtcbn1cbmNvbW1vblV0aWxzLm92ZXJyaWRlRnJvbUNvbXBvc2FibGVzID0gb3ZlcnJpZGVGcm9tQ29tcG9zYWJsZXM7XG5jb21tb25VdGlscy5kZWZhdWx0ID0geyBpc1ZhbGlkUHJlc2V0VHlwZSB9O1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ1ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0xheW91dF9sYXlvdXRDbGllbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFuY2UkMSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5JbnN0YW5jZSQxLkxheW91dCA9IHZvaWQgMDtcbmNvbnN0IGxhenlfMSA9IGxhenk7XG5jb25zdCB2YWxpZGF0ZV8xID0gdmFsaWRhdGU7XG5jb25zdCBiYXNlXzEkNiA9IGJhc2U7XG5jb25zdCBjb21tb25fdXRpbHNfMSA9IGNvbW1vblV0aWxzO1xuY29uc3QgbGF5b3V0X2VudGl0aWVzXzEgPSBsYXlvdXRFbnRpdGllcztcbmNvbnN0IGxheW91dF9jb25zdGFudHNfMSQxID0gbGF5b3V0X2NvbnN0YW50cztcbi8qKlxuICpcbiAqIExheW91dHMgZ2l2ZSBhcHAgcHJvdmlkZXJzIHRoZSBhYmlsaXR5IHRvIGVtYmVkIG11bHRpcGxlIHZpZXdzIGluIGEgc2luZ2xlIHdpbmRvdy4gVGhlIExheW91dCBuYW1lc3BhY2VcbiAqIGVuYWJsZXMgdGhlIGluaXRpYWxpemF0aW9uIGFuZCBtYW5pcHVsYXRpb24gb2YgYSB3aW5kb3cncyBMYXlvdXQuIEEgTGF5b3V0IHdpbGxcbiAqIGVtaXQgZXZlbnRzIGxvY2FsbHkgb24gdGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgbGF5b3V0LWNvbnRhaW5lci5cbiAqXG4gKlxuICogIyMjIExheW91dC5ET01FdmVudHNcbiAqXG4gKiBXaGVuIGEgTGF5b3V0IGlzIGNyZWF0ZWQsIGl0IGVtaXRzIGV2ZW50cyBvbnRvIHRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIExheW91dCBjb250YWluZXIuXG4gKiBUaGlzIExheW91dCBjb250YWluZXIgaXMgdGhlIERPTSBlbGVtZW50IHJlZmVyZW5jZWQgYnkgY29udGFpbmVySWQgaW4ge0BsaW5rIExheW91dC5MYXlvdXRNb2R1bGUjaW5pdCBMYXlvdXQuaW5pdH0uXG4gKiBZb3UgY2FuIHVzZSB0aGUgYnVpbHQtaW4gZXZlbnQgZW1pdHRlciB0byBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIHVzaW5nIFthZGRFdmVudExpc3RlbmVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lcikuXG4gKiBUaGUgZXZlbnRzIGFyZSBlbWl0dGVkIHN5bmNocm9ub3VzbHkgYW5kIG9ubHkgaW4gdGhlIHByb2Nlc3Mgd2hlcmUgdGhlIExheW91dCBleGlzdHMuXG4gKiBBbnkgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsZWQgbGlzdGVuZXJzIGFyZSBpZ25vcmVkIGFuZCB3aWxsIGJlIGRpc2NhcmRlZC5cbiAqIElmIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgaXMgZGVzdHJveWVkLCBhbnkgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNldCB1cCBvbiB0aGF0IGVsZW1lbnQgd2lsbCBiZSBkZXN0cm95ZWQuXG4gKlxuICogQHJlbWFya3MgVGhlIGJ1aWx0LWluIGV2ZW50IGVtaXR0ZXIgaXMgbm90IGFuIE9wZW5GaW4gZXZlbnQgZW1pdHRlciBzbyBpdCBkb2Vzbid0IHNoYXJlIHByb3BhZ2F0aW9uIHNlbWFudGljcy5cbiAqXG4gKiAjIyMjIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyIFssIG9wdGlvbnNdKTt9XG4gKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBteUxheW91dENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYXlvdXQtY29udGFpbmVyJyk7XG4gKlxuICogbXlMYXlvdXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndGFiLWNyZWF0ZWQnLCBmdW5jdGlvbihldmVudCkge1xuICogICAgICBjb25zdCB7IHRhYlNlbGVjdG9yIH0gPSBldmVudC5kZXRhaWw7XG4gKiAgICAgIGNvbnN0IHRhYkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YWJTZWxlY3Rvcik7XG4gKiAgICAgIGNvbnN0IGV4aXN0aW5nQ29sb3IgPSB0YWJFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAqICAgICAgdGFiRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJlZFwiO1xuICogICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAqICAgICAgICAgIHRhYkVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZXhpc3RpbmdDb2xvcjtcbiAqICAgICAgfSwgMjAwMCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIgWywgb3B0aW9uc10pO31cbiAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IG15TGF5b3V0Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xheW91dC1jb250YWluZXInKTtcbiAqXG4gKiBjb25zdCBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coZXZlbnQuZGV0YWlsKTtcbiAqICAgICBjb25zb2xlLmxvZygnY29udGFpbmVyLWNyZWF0ZWQgZXZlbnQgZmlyZWQgb25jZSwgcmVtb3ZpbmcgbGlzdGVuZXInKTtcbiAqICAgICBteUxheW91dENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250YWluZXItY3JlYXRlZCcsIGxpc3RlbmVyKTtcbiAqIH07XG4gKlxuICogbXlMYXlvdXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGFpbmVyLWNyZWF0ZWQnLCBsaXN0ZW5lcik7XG4gKiBgYGBcbiAqXG4gKiAjIyMgU3VwcG9ydGVkIGV2ZW50IHR5cGVzIGFyZTpcbiAqXG4gKiAqIHRhYi1jcmVhdGVkXG4gKiAqIGNvbnRhaW5lci1jcmVhdGVkXG4gKiAqIGxheW91dC1zdGF0ZS1jaGFuZ2VkXG4gKiAqIHRhYi1jbG9zZWRcbiAqICogdGFiLWRyb3BwZWRcbiAqXG4gKiAjIyMgTGF5b3V0IERPTSBOb2RlIEV2ZW50c1xuICpcbiAqICMjIyMgdGFiLWNyZWF0ZWRcbiAqIEdlbmVyYXRlZCB3aGVuIGEgdGFiIGlzIGNyZWF0ZWQuICBBcyBhIHVzZXIgZHJhZ3MgYW5kIGRyb3BzIHRhYnMgd2l0aGluIHdpbmRvdywgbmV3IHRhYnMgYXJlIGNyZWF0ZWQuICBBIHNpbmdsZSB2aWV3IG1heSBoYXZlIG11bHRpcGxlIHRhYnMgY3JlYXRlZCBhbmQgZGVzdHJveWVkIGR1cmluZyBpdHMgbGlmZXRpbWUgYXR0YWNoZWQgdG8gYSBzaW5nbGUgd2luZG93LlxuICogYGBganNcbiAqIC8vIFRoZSByZXNwb25zZSBoYXMgdGhlIGZvbGxvd2luZyBzaGFwZSBpbiBldmVudC5kZXRhaWw6XG4gKiB7XG4gKiAgICAgY29udGFpbmVyU2VsZWN0b3I6IFwiY29udGFpbmVyLWNvbXBvbmVudF9BXCIsXG4gKiAgICAgbmFtZTogXCJjb21wb25lbnRfQVwiLFxuICogICAgIHRhYlNlbGVjdG9yOiBcInRhYi1jb21wb25lbnRfQVwiLFxuICogICAgIHRvcGljOiBcIm9wZW5maW4tRE9NLWV2ZW50XCIsXG4gKiAgICAgdHlwZTogXCJ0YWItY3JlYXRlZFwiLFxuICogICAgIHV1aWQ6IFwiT3BlbkZpbiBQT0NcIlxuICogfVxuICogYGBgXG4gKlxuICogIyMjIyBjb250YWluZXItY3JlYXRlZFxuICogR2VuZXJhdGVkIHdoZW4gYSBjb250YWluZXIgaXMgY3JlYXRlZC4gIEEgc2luZ2xlIHZpZXcgd2lsbCBoYXZlIG9ubHkgb25lIGNvbnRhaW5lciBkdXJpbmcgaXRzIGxpZmV0aW1lIGF0dGFjaGVkIHRvIGEgc2luZ2xlIHdpbmRvdyBhbmQgdGhlIGNvbnRhaW5lcidzIGxpZmVjeWNsZSBpcyB0aWVkIHRvIHRoZSB2aWV3LiAgVG8gZGlzY292ZXIgd2hlbiB0aGUgY29udGFpbmVyIGlzIGRlc3Ryb3llZCwgcGxlYXNlIGxpc3RlbiB0byB2aWV3LWRldGFjaGVkIGV2ZW50LlxuICogYGBganNcbiAqIC8vIFRoZSByZXNwb25zZSBoYXMgdGhlIGZvbGxvd2luZyBzaGFwZSBpbiBldmVudC5kZXRhaWw6XG4gKiB7XG4gKiAgICAgY29udGFpbmVyU2VsZWN0b3I6IFwiY29udGFpbmVyLWNvbXBvbmVudF9BXCIsXG4gKiAgICAgbmFtZTogXCJjb21wb25lbnRfQVwiLFxuICogICAgIHRhYlNlbGVjdG9yOiBcInRhYi1jb21wb25lbnRfQVwiLFxuICogICAgIHRvcGljOiBcIm9wZW5maW4tRE9NLWV2ZW50XCIsXG4gKiAgICAgdHlwZTogXCJjb250YWluZXItY3JlYXRlZFwiLFxuICogICAgIHV1aWQ6IFwiT3BlbkZpbiBQT0NcIlxuICogfVxuICogYGBgXG4gKlxuICogIyMjIGxheW91dC1zdGF0ZS1jaGFuZ2VkXG4gKiBHZW5lcmF0ZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIGxheW91dCBjaGFuZ2VzIGluIGFueSB3YXksIHN1Y2ggYXMgYSB2aWV3IGFkZGVkL3JlbW92ZWQvcmVwbGFjZWQuIE5vdGUgdGhhdCB0aGlzIGV2ZW50IGNhbiBmaXJlIGZyZXF1ZW50bHkgYXMgdGhlIHVuZGVybHlpbmcgbGF5b3V0IGNhbiBjaGFuZ2UgbXVsdGlwbGUgY29tcG9uZW50cyBmcm9tIGFsbCBraW5kcyBvZiBjaGFuZ2VzIChyZXNpemluZyBmb3IgZXhhbXBsZSkuIEdpdmVuIHRoaXMsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGRlYm91bmNlIHRoaXMgZXZlbnQgYW5kIHRoZW4geW91IGNhbiB1c2UgdGhlIHtAbGluayBMYXlvdXQjZ2V0Q29uZmlnIExheW91dC5nZXRDb25maWd9IEFQSSB0byByZXRyaWV2ZSB0aGUgbW9zdCB1cC10by1kYXRlIHN0YXRlLlxuICogYGBganNcbiAqIC8vIFRoZSByZXNwb25zZSBoYXMgdGhlIGZvbGxvd2luZyBzaGFwZSBpbiBldmVudC5kZXRhaWxcbiAqIHtcbiAqICAgICBjb250YWluZXJTZWxlY3RvcjogXCJjb250YWluZXItY29tcG9uZW50X0FcIixcbiAqICAgICBuYW1lOiBcImNvbXBvbmVudF9BXCIsXG4gKiAgICAgdGFiU2VsZWN0b3I6IFwidGFiLWNvbXBvbmVudF9BXCIsXG4gKiAgICAgdG9waWM6IFwib3BlbmZpbi1ET00tZXZlbnRcIixcbiAqICAgICB0eXBlOiBcImxheW91dC1zdGF0ZS1jaGFuZ2VkXCIsXG4gKiAgICAgdXVpZDogXCJPcGVuRmluIFBPQ1wiXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMjIHRhYi1jbG9zZWRcbiAqIEdlbmVyYXRlZCB3aGVuIGEgdGFiIGlzIGNsb3NlZC5cbiAqIGBgYGpzXG4gKiAvLyBUaGUgcmVzcG9uc2UgaGFzIHRoZSBmb2xsb3dpbmcgc2hhcGUgaW4gZXZlbnQuZGV0YWlsOlxuICoge1xuICogICAgIGNvbnRhaW5lclNlbGVjdG9yOiBcImNvbnRhaW5lci1jb21wb25lbnRfQVwiLFxuICogICAgIG5hbWU6IFwiY29tcG9uZW50X0FcIixcbiAqICAgICB0YWJTZWxlY3RvcjogXCJ0YWItY29tcG9uZW50X0FcIixcbiAqICAgICB0b3BpYzogXCJvcGVuZmluLURPTS1ldmVudFwiLFxuICogICAgIHR5cGU6IFwidGFiLWNsb3NlZFwiLFxuICogICAgIHV1aWQ6IFwiT3BlbkZpbiBQT0NcIixcbiAqICAgICB1cmw6IFwiaHR0cDovL29wZW5maW4uY29cIiAgIC8vIFRoZSB1cmwgb2YgdGhlIHZpZXcgdGhhdCB3YXMgY2xvc2VkLlxuICogfVxuICogYGBgXG4gKlxuICogIyMjIyB0YWItZHJvcHBlZFxuICogR2VuZXJhdGVkIHdoZW4gYSB0YWIgaXMgZHJvcHBlZC5cbiAqIGBgYGpzXG4gKiAvLyBUaGUgcmVzcG9uc2UgaGFzIHRoZSBmb2xsb3dpbmcgc2hhcGUgaW4gZXZlbnQuZGV0YWlsOlxuICoge1xuICogICAgIGNvbnRhaW5lclNlbGVjdG9yOiBcImNvbnRhaW5lci1jb21wb25lbnRfQVwiLFxuICogICAgIG5hbWU6IFwiY29tcG9uZW50X0FcIixcbiAqICAgICB0YWJTZWxlY3RvcjogXCJ0YWItY29tcG9uZW50X0FcIixcbiAqICAgICB0b3BpYzogXCJvcGVuZmluLURPTS1ldmVudFwiLFxuICogICAgIHR5cGU6IFwidGFiLWRyb3BwZWRcIixcbiAqICAgICB1dWlkOiBcIk9wZW5GaW4gUE9DXCIsXG4gKiAgICAgdXJsOiBcImh0dHA6Ly9vcGVuZmluLmNvXCIgICAgLy8gVGhlIHVybCBvZiB0aGUgdmlldyBsaW5rZWQgdG8gdGhlIGRyb3BwZWQgdGFiLlxuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIExheW91dCBleHRlbmRzIGJhc2VfMSQ2LkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBjb25zdHJ1Y3RvcihpZGVudGl0eSwgd2lyZSkge1xuICAgICAgICBzdXBlcih3aXJlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBMYXppbHkgY29uc3RydWN0ZWQge0BsaW5rIExheW91dEVudGl0aWVzQ2xpZW50fSBib3VuZCB0byB0aGlzIHBsYXRmb3JtJ3MgY2xpZW50IGFuZCBpZGVudGl0eVxuICAgICAgICAgKiBUaGUgY2xpZW50IGlzIGZvciB7QGxpbmsgTGF5b3V0RW50aXRpZXNDb250cm9sbGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX0xheW91dF9sYXlvdXRDbGllbnQuc2V0KHRoaXMsIG5ldyBsYXp5XzEuTGF6eShhc3luYyAoKSA9PiBsYXlvdXRfZW50aXRpZXNfMS5MYXlvdXROb2RlLm5ld0xheW91dEVudGl0aWVzQ2xpZW50KGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0Q2xpZW50KCksIGxheW91dF9jb25zdGFudHNfMSQxLkxBWU9VVF9DT05UUk9MTEVSX0lELCB0aGlzLmlkZW50aXR5KSkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZXMgYSBQbGF0Zm9ybSB3aW5kb3cncyBsYXlvdXQgd2l0aCBhIG5ldyBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZW1hcmtzIEFueSB2aWV3cyB0aGF0IHdlcmUgaW4gdGhlIG9sZCBsYXlvdXQgYnV0IG5vdCB0aGUgbmV3IGxheW91dCB3aWxsIGJlIGRlc3Ryb3llZC4gVmlld3Mgd2lsbCBiZSBhc3NpZ25lZCBhIHJhbmRvbWx5IGdlbmVyYXRlZCBuYW1lIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIGxldCB3aW5kb3dJZGVudGl0eTtcbiAgICAgICAgICogaWYgKGZpbi5tZS5pc1dpbmRvdykge1xuICAgICAgICAgKiAgICAgd2luZG93SWRlbnRpdHkgPSBmaW4ubWUuaWRlbnRpdHk7XG4gICAgICAgICAqIH0gZWxzZSBpZiAoZmluLm1lLmlzVmlldykge1xuICAgICAgICAgKiAgICAgd2luZG93SWRlbnRpdHkgPSAoYXdhaXQgZmluLm1lLmdldEN1cnJlbnRXaW5kb3coKSkuaWRlbnRpdHk7XG4gICAgICAgICAqIH0gZWxzZSB7XG4gICAgICAgICAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBydW5uaW5nIGluIGEgcGxhdGZvcm0gVmlldyBvciBXaW5kb3cnKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBsYXlvdXQgPSBmaW4uUGxhdGZvcm0uTGF5b3V0LndyYXBTeW5jKHdpbmRvd0lkZW50aXR5KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgbmV3TGF5b3V0ID0ge1xuICAgICAgICAgKiAgICAgY29udGVudDogW1xuICAgICAgICAgKiAgICAgICAgIHtcbiAgICAgICAgICogICAgICAgICAgICAgdHlwZTogJ3N0YWNrJyxcbiAgICAgICAgICogICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAge1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6ICd2aWV3JyxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZToge1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbmV3X2NvbXBvbmVudF9BMScsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBZmZpbml0eTogJ3BzXzEnLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbSdcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAqICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAge1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6ICd2aWV3JyxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZToge1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbmV3X2NvbXBvbmVudF9BMicsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vY2RuLm9wZW5maW4uY28vZW1iZWQtd2ViL2NoYXJ0Lmh0bWwnXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgKiAgICAgICAgICAgICBdXG4gICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgKiAgICAgXVxuICAgICAgICAgKiB9O1xuICAgICAgICAgKlxuICAgICAgICAgKiBsYXlvdXQucmVwbGFjZShuZXdMYXlvdXQpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVwbGFjZSA9IGFzeW5jIChsYXlvdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdsYXlvdXQtcmVwbGFjZScpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0Q2xpZW50KCk7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ3JlcGxhY2UtbGF5b3V0Jywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICBvcHRzOiB7IGxheW91dCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgdmlldyB3aXRoIGEgdmlldyB3aXRoIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVtYXJrcyBUaGUgb2xkIHZpZXcgaXMgc3RyaXBwZWQgb2YgaXRzIGxpc3RlbmVycyBhbmQgZWl0aGVyIGNsb3NlZCBvciBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZXIgd2luZG93XG4gICAgICAgICAqIGRlcGVuZGluZyBvbiBgZGV0YWNoT25DbG9zZWAgdmlldyBvcHRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWV3VG9SZXBsYWNlIElkZW50aXR5IG9mIHRoZSB2aWV3IHRvIGJlIHJlcGxhY2VkXG4gICAgICAgICAqIEBwYXJhbSBuZXdWaWV3IENyZWF0aW9uIG9wdGlvbnMgb2YgdGhlIG5ldyB2aWV3LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiBsZXQgY3VycmVudFdpbmRvdztcbiAgICAgICAgICogaWYgKGZpbi5tZS5pc1dpbmRvdykge1xuICAgICAgICAgKiAgICAgY3VycmVudFdpbmRvdyA9IGZpbi5tZTtcbiAgICAgICAgICogfSBlbHNlIGlmIChmaW4ubWUuaXNWaWV3KSB7XG4gICAgICAgICAqICAgICBjdXJyZW50V2luZG93ID0gYXdhaXQgZmluLm1lLmdldEN1cnJlbnRXaW5kb3coKTtcbiAgICAgICAgICogfSBlbHNlIHtcbiAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3IG9yIFdpbmRvdycpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IGxheW91dCA9IGZpbi5QbGF0Zm9ybS5MYXlvdXQud3JhcFN5bmMoY3VycmVudFdpbmRvdy5pZGVudGl0eSk7XG4gICAgICAgICAqIGNvbnN0IHZpZXdUb1JlcGxhY2UgPSAoYXdhaXQgY3VycmVudFdpbmRvdy5nZXRDdXJyZW50Vmlld3MoKSlbMF07XG4gICAgICAgICAqIGNvbnN0IG5ld1ZpZXdDb25maWcgPSB7dXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbSd9O1xuICAgICAgICAgKiBhd2FpdCBsYXlvdXQucmVwbGFjZVZpZXcodmlld1RvUmVwbGFjZS5pZGVudGl0eSwgbmV3Vmlld0NvbmZpZyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXBsYWNlVmlldyA9IGFzeW5jICh2aWV3VG9SZXBsYWNlLCBuZXdWaWV3KSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LXJlcGxhY2UtdmlldycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0Q2xpZW50KCk7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ3JlcGxhY2UtdmlldycsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgb3B0czogeyB2aWV3VG9SZXBsYWNlLCBuZXdWaWV3IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZXMgYSBQbGF0Zm9ybSB3aW5kb3cncyBsYXlvdXQgd2l0aCBhIHByZXNldCBsYXlvdXQgYXJyYW5nZW1lbnQgdXNpbmcgdGhlIGV4aXN0aW5nIFZpZXdzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cuXG4gICAgICAgICAqIFRoZSBwcmVzZXQgb3B0aW9ucyBhcmUgYGNvbHVtbnNgLCBgZ3JpZGAsIGByb3dzYCwgYW5kIGB0YWJzYC5cbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgTWFuZGF0b3J5IG9iamVjdCB3aXRoIGBwcmVzZXRUeXBlYCBwcm9wZXJ0eSB0aGF0IHNldHMgd2hpY2ggcHJlc2V0IGxheW91dCBhcnJhbmdlbWVudCB0byB1c2UuXG4gICAgICAgICAqIFRoZSBwcmVzZXQgb3B0aW9ucyBhcmUgYGNvbHVtbnNgLCBgZ3JpZGAsIGByb3dzYCwgYW5kIGB0YWJzYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogbGV0IHdpbmRvd0lkZW50aXR5O1xuICAgICAgICAgKiBpZiAoZmluLm1lLmlzV2luZG93KSB7XG4gICAgICAgICAqICAgICB3aW5kb3dJZGVudGl0eSA9IGZpbi5tZS5pZGVudGl0eTtcbiAgICAgICAgICogfSBlbHNlIGlmIChmaW4ubWUuaXNWaWV3KSB7XG4gICAgICAgICAqICAgICB3aW5kb3dJZGVudGl0eSA9IChhd2FpdCBmaW4ubWUuZ2V0Q3VycmVudFdpbmRvdygpKS5pZGVudGl0eTtcbiAgICAgICAgICogfSBlbHNlIHtcbiAgICAgICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3IG9yIFdpbmRvdycpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IGxheW91dCA9IGZpbi5QbGF0Zm9ybS5MYXlvdXQud3JhcFN5bmMod2luZG93SWRlbnRpdHkpO1xuICAgICAgICAgKiBhd2FpdCBsYXlvdXQuYXBwbHlQcmVzZXQoeyBwcmVzZXRUeXBlOiAnZ3JpZCcgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHdhaXQgNSBzZWNvbmRzIHVudGlsIHlvdSBjaGFuZ2UgdGhlIGxheW91dCBmcm9tIGdyaWQgdG8gdGFic1xuICAgICAgICAgKiBhd2FpdCBuZXcgUHJvbWlzZSAocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MDAwKSk7XG4gICAgICAgICAqIGF3YWl0IGxheW91dC5hcHBseVByZXNldCh7IHByZXNldFR5cGU6ICd0YWJzJyB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGx5UHJlc2V0ID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdsYXlvdXQtYXBwbHktcHJlc2V0JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5wbGF0Zm9ybS5nZXRDbGllbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJlc2V0VHlwZSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGlmICghcHJlc2V0VHlwZSB8fCAhKDAsIGNvbW1vbl91dGlsc18xLmlzVmFsaWRQcmVzZXRUeXBlKShwcmVzZXRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5IHByZXNldCBsYXlvdXQsIHBsZWFzZSBpbmNsdWRlIGFuIGFwcGxpY2FibGUgcHJlc2V0VHlwZSBwcm9wZXJ0eSBpbiB0aGUgUHJlc2V0TGF5b3V0T3B0aW9ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5kaXNwYXRjaCgnYXBwbHktcHJlc2V0LWxheW91dCcsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgb3B0czogeyBwcmVzZXRUeXBlIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9ICgwLCB2YWxpZGF0ZV8xLnZhbGlkYXRlSWRlbnRpdHkpKGlkZW50aXR5KTtcbiAgICAgICAgaWYgKGVycm9yTXNnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHRoaXMuZmluLlBsYXRmb3JtLndyYXBTeW5jKHsgdXVpZDogaWRlbnRpdHkudXVpZCB9KTtcbiAgICAgICAgaWYgKGlkZW50aXR5LnV1aWQgPT09IHRoaXMuZmluLm1lLnV1aWQgJiYgaWRlbnRpdHkubmFtZSA9PT0gdGhpcy5maW4ubWUubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gdGhpcy5maW4uUGxhdGZvcm0uTGF5b3V0LmluaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgd2luZG93J3MgbGF5b3V0LiAgUmV0dXJucyB0aGUgc2FtZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHJldHVybmVkIGZvciBhbGwgd2luZG93cyBpbiBnZXRTbmFwc2hvdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBhIFZpZXcuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsYXlvdXQgPSBmaW4uUGxhdGZvcm0uTGF5b3V0LmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogLy8gVXNlIHdyYXBwZWQgaW5zdGFuY2UgdG8gZ2V0IHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBvZiB0aGUgY3VycmVudCB3aW5kb3cncyBMYXlvdXQ6XG4gICAgICogY29uc3QgbGF5b3V0Q29uZmlnID0gYXdhaXQgbGF5b3V0LmdldENvbmZpZygpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbmZpZygpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC1nZXQtY29uZmlnJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5wbGF0Zm9ybS5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgnZ2V0LWZyYW1lLXNuYXBzaG90Jywge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmlkZW50aXR5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGF0dGFjaGVkIHZpZXdzIGluIGN1cnJlbnQgd2luZG93IGxheW91dC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsYXlvdXQgPSBmaW4uUGxhdGZvcm0uTGF5b3V0LmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogY29uc3Qgdmlld3MgPSBhd2FpdCBsYXlvdXQuZ2V0Q3VycmVudFZpZXdzKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudFZpZXdzKCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LWdldC12aWV3cycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IHZpZXdJZGVudGl0aWVzID0gYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdnZXQtbGF5b3V0LXZpZXdzJywge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmlkZW50aXR5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmlld0lkZW50aXRpZXMubWFwKChpZGVudGl0eSkgPT4gdGhpcy5maW4uVmlldy53cmFwU3luYyhpZGVudGl0eSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHRvcCBsZXZlbCBjb250ZW50IGl0ZW0gb2YgdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBhIHZpZXcuXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGlmICghZmluLm1lLmlzV2luZG93KSB7XG4gICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3LicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIEZyb20gdGhlIGxheW91dCB3aW5kb3dcbiAgICAgKiBjb25zdCBsYXlvdXQgPSBmaW4uUGxhdGZvcm0uTGF5b3V0LmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogLy8gUmV0cmlldmVzIHRoZSBDb2x1bW5PclJvdyBpbnN0YW5jZVxuICAgICAqIGNvbnN0IHJvb3RJdGVtID0gYXdhaXQgbGF5b3V0LmdldFJvb3RJdGVtKCk7XG4gICAgICogY29uc3QgY29udGVudCA9IGF3YWl0IHJvb3RJdGVtLmdldENvbnRlbnQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhgVGhlIHJvb3QgQ29sdW1uT3JSb3cgaW5zdGFuY2UgaGFzICR7Y29udGVudC5sZW5ndGh9IGl0ZW0ocylgKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSb290SXRlbSgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC1nZXQtcm9vdC1pdGVtJykuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDUodGhpcywgX0xheW91dF9sYXlvdXRDbGllbnQsIFwiZlwiKS5nZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByb290ID0gYXdhaXQgY2xpZW50LmdldFJvb3QoJ2xheW91dE5hbWUnIGluIHRoaXMuaWRlbnRpdHkgPyB0aGlzLmlkZW50aXR5IDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIGxheW91dF9lbnRpdGllc18xLkxheW91dE5vZGUuZ2V0RW50aXR5KHJvb3QsIGNsaWVudCk7XG4gICAgfVxufVxuSW5zdGFuY2UkMS5MYXlvdXQgPSBMYXlvdXQ7XG5fTGF5b3V0X2xheW91dENsaWVudCA9IG5ldyBXZWFrTWFwKCk7XG5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9MYXlvdXRNb2R1bGVfaW5zdGFuY2VzLCBfTGF5b3V0TW9kdWxlX2xheW91dEluaXRpYWxpemF0aW9uQXR0ZW1wdGVkLCBfTGF5b3V0TW9kdWxlX2xheW91dE1hbmFnZXIsIF9MYXlvdXRNb2R1bGVfZ2V0TGF5b3V0TWFuYWdlclNweSwgX0xheW91dE1vZHVsZV9nZXRTYWZlTGF5b3V0TWFuYWdlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWN0b3J5JDIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuRmFjdG9yeSQyLkxheW91dE1vZHVsZSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSQ1ID0gYmFzZTtcbmNvbnN0IEluc3RhbmNlXzEkMiA9IEluc3RhbmNlJDE7XG5jb25zdCBsYXlvdXRfY29uc3RhbnRzXzEgPSBsYXlvdXRfY29uc3RhbnRzO1xuLyoqXG4gKiBTdGF0aWMgbmFtZXNwYWNlIGZvciBPcGVuRmluIEFQSSBtZXRob2RzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUge0BsaW5rIExheW91dH0gY2xhc3MsIGF2YWlsYWJsZSB1bmRlciBgZmluLlBsYXRmb3JtLkxheW91dGAuXG4gKi9cbmNsYXNzIExheW91dE1vZHVsZSBleHRlbmRzIGJhc2VfMSQ1LkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBfTGF5b3V0TW9kdWxlX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9MYXlvdXRNb2R1bGVfbGF5b3V0SW5pdGlhbGl6YXRpb25BdHRlbXB0ZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0xheW91dE1vZHVsZV9sYXlvdXRNYW5hZ2VyLnNldCh0aGlzLCBudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIHdpbmRvdydzIExheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlbWFya3MgTXVzdCBiZSBjYWxsZWQgZnJvbSBhIGN1c3RvbSB3aW5kb3cgdGhhdCBoYXMgYSAnbGF5b3V0JyBvcHRpb24gc2V0IHVwb24gY3JlYXRpb24gb2YgdGhhdCB3aW5kb3cuXG4gICAgICAgICAqIElmIGEgY29udGFpbmVySWQgaXMgbm90IHByb3ZpZGVkLCB0aGlzIG1ldGhvZCBhdHRlbXB0cyB0byBmaW5kIGFuIGVsZW1lbnQgd2l0aCB0aGUgaWQgYGxheW91dC1jb250YWluZXJgLlxuICAgICAgICAgKiBBIExheW91dCB3aWxsIGVtaXQgZXZlbnRzIGxvY2FsbHkgb24gdGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgbGF5b3V0LWNvbnRhaW5lci5cbiAgICAgICAgICogSW4gb3JkZXIgdG8gY2FwdHVyZSB0aGUgcmVsZXZhbnQgZXZlbnRzIGR1cmluZyBMYXlvdXQgaW5pdGlhdGlvbiwgc2V0IHVwIHRoZSBsaXN0ZW5lcnMgb24gdGhlIERPTSBlbGVtZW50IHByaW9yIHRvIGNhbGxpbmcgYGluaXRgLlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIExheW91dCBpbml0IG9wdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogLy8gSWYgbm8gb3B0aW9ucyBhcmUgaW5jbHVkZWQsIHRoZSBsYXlvdXQgaW4gdGhlIHdpbmRvdyBvcHRpb25zIGlzIGluaXRpYWxpemVkIGluIGFuIGVsZW1lbnQgd2l0aCB0aGUgaWQgYGxheW91dC1jb250YWluZXJgXG4gICAgICAgICAqIGNvbnN0IGxheW91dCA9IGF3YWl0IGZpbi5QbGF0Zm9ybS5MYXlvdXQuaW5pdCgpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogPGJyPlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiBjb25zdCBjb250YWluZXJJZCA9ICdteS1jdXN0b20tY29udGFpbmVyLWlkJztcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgbXlMYXlvdXRDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG15TGF5b3V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RhYi1jcmVhdGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICogICAgIGNvbnN0IHsgdGFiU2VsZWN0b3IgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICogICAgIGNvbnN0IHRhYkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YWJTZWxlY3Rvcik7XG4gICAgICAgICAqICAgICBjb25zdCBleGlzdGluZ0NvbG9yID0gdGFiRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAqICAgICB0YWJFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmVkXCI7XG4gICAgICAgICAqICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICogICAgICAgICB0YWJFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGV4aXN0aW5nQ29sb3I7XG4gICAgICAgICAqICAgICB9LCAyMDAwKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGluaXRpYWxpemUgdGhlIGxheW91dCBpbnRvIGFuIGV4aXN0aW5nIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBkaXYgYG15LWN1c3RvbS1jb250YWluZXItaWRgXG4gICAgICAgICAqIC8vIHRoZSB3aW5kb3cgbXVzdCBoYXZlIGJlZW4gY3JlYXRlZCB3aXRoIGEgbGF5b3V0IGluIGl0cyB3aW5kb3cgb3B0aW9uc1xuICAgICAgICAgKiBjb25zdCBsYXlvdXQgPSBhd2FpdCBmaW4uUGxhdGZvcm0uTGF5b3V0LmluaXQoeyBjb250YWluZXJJZCB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXQgPSBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LWluaXQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmluLm1lLmlzV2luZG93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYXlvdXQuaW5pdCBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSBhIFdpbmRvdyBjb250ZXh0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ0KHRoaXMsIF9MYXlvdXRNb2R1bGVfbGF5b3V0SW5pdGlhbGl6YXRpb25BdHRlbXB0ZWQsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGF5b3V0LmluaXQgd2FzIGFscmVhZHkgY2FsbGVkLCBwbGVhc2UgdXNlIExheW91dC5jcmVhdGUgdG8gYWRkIGFkZGl0aW9uYWwgbGF5b3V0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkNCh0aGlzLCBfTGF5b3V0TW9kdWxlX2xheW91dEluaXRpYWxpemF0aW9uQXR0ZW1wdGVkLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICAvLyBwcmVsb2FkIHRoZSBjbGllbnRcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCkuZ2V0Q2xpZW50KCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDQodGhpcywgX0xheW91dE1vZHVsZV9sYXlvdXRNYW5hZ2VyLCBhd2FpdCB0aGlzLndpcmUuZW52aXJvbm1lbnQuaW5pdExheW91dE1hbmFnZXIodGhpcy5maW4sIHRoaXMud2lyZSwgb3B0aW9ucyksIFwiZlwiKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2lyZS5lbnZpcm9ubWVudC5hcHBseUxheW91dFNuYXBzaG90KHRoaXMuZmluLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDQodGhpcywgX0xheW91dE1vZHVsZV9sYXlvdXRNYW5hZ2VyLCBcImZcIiksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmxheW91dE1hbmFnZXJPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIC8vIGluIHNpbmdsZS1sYXlvdXQgY2FzZSwgd2UgcmV0dXJuIHRoZSB1bmRvY3VtZW50ZWQgbGF5b3V0TWFuYWdlciB0eXBlIChkZXByZWNhdGUgd2l0aCBDT1JFLTEwODEpXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0SWRlbnRpdHkgPSB7IGxheW91dE5hbWU6IGxheW91dF9jb25zdGFudHNfMS5ERUZBVUxUX0xBWU9VVF9LRVksIC4uLnRoaXMuZmluLm1lLmlkZW50aXR5IH07XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0TWFuYWdlciA9IGF3YWl0IHRoaXMud2lyZS5lbnZpcm9ubWVudC5yZXNvbHZlTGF5b3V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQkNCh0aGlzLCBfTGF5b3V0TW9kdWxlX2xheW91dE1hbmFnZXIsIFwiZlwiKSwgbGF5b3V0SWRlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDQodGhpcywgX0xheW91dE1vZHVsZV9nZXRMYXlvdXRNYW5hZ2VyU3B5LCBcImZcIikuY2FsbCh0aGlzLCBsYXlvdXRJZGVudGl0eSwgbGF5b3V0TWFuYWdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwU3luYyh0aGlzLmZpbi5tZS5pZGVudGl0eSk7XG4gICAgICAgIH07XG4gICAgICAgIF9MYXlvdXRNb2R1bGVfZ2V0TGF5b3V0TWFuYWdlclNweS5zZXQodGhpcywgKGxheW91dElkZW50aXR5LCBsYXlvdXRNYW5hZ2VyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnW0xheW91dF0gWW91IGFyZSB1c2luZyBhIGRlcHJlY2F0ZWQgcHJvcGVydHkgYGxheW91dE1hbmFnZXJgIC0gaXQgd2lsbCB0aHJvdyBpZiB5b3UgYWNjZXNzIGl0IHN0YXJ0aW5nIGluIHYzNy4nO1xuICAgICAgICAgICAgY29uc3QgbWFuYWdlclByb3h5ID0gbmV3IFByb3h5KGxheW91dE1hbmFnZXIsIHtcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbTGF5b3V0LW1nci1wcm94eV0gYWNjZXNzaW5nICR7a2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXQgPSBPYmplY3QuYXNzaWduKHRoaXMud3JhcFN5bmMobGF5b3V0SWRlbnRpdHkpLCB7IGxheW91dE1hbmFnZXI6IG1hbmFnZXJQcm94eSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dFByb3h5ID0gbmV3IFByb3h5KGxheW91dCwge1xuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnbGF5b3V0TWFuYWdlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0xheW91dC1wcm94eV0gYWNjZXNzaW5nICR7a2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0UHJveHk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGF5b3V0IG1hbmFnZXIgZm9yIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TGF5b3V0TWFuYWdlclN5bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQ0KHRoaXMsIF9MYXlvdXRNb2R1bGVfaW5zdGFuY2VzLCBcIm1cIiwgX0xheW91dE1vZHVsZV9nZXRTYWZlTGF5b3V0TWFuYWdlcikuY2FsbCh0aGlzLCBgZmluLlBsYXRmb3JtLkxheW91dC5nZXRDdXJyZW50TGF5b3V0TWFuYWdlclN5bmMoKWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLmVudmlyb25tZW50LmNyZWF0ZUxheW91dChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDQodGhpcywgX0xheW91dE1vZHVsZV9pbnN0YW5jZXMsIFwibVwiLCBfTGF5b3V0TW9kdWxlX2dldFNhZmVMYXlvdXRNYW5hZ2VyKS5jYWxsKHRoaXMsIGBmaW4uUGxhdGZvcm0uTGF5b3V0LmNyZWF0ZSgpYCksIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBhc3luYyAobGF5b3V0SWRlbnRpdHkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpcmUuZW52aXJvbm1lbnQuZGVzdHJveUxheW91dChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDQodGhpcywgX0xheW91dE1vZHVsZV9pbnN0YW5jZXMsIFwibVwiLCBfTGF5b3V0TW9kdWxlX2dldFNhZmVMYXlvdXRNYW5hZ2VyKS5jYWxsKHRoaXMsIGBmaW4uUGxhdGZvcm0uTGF5b3V0LmRlc3Ryb3koKWApLCBsYXlvdXRJZGVudGl0eSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYSBMYXlvdXQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIFdpbmRvdydzIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBsZXQgd2luZG93SWRlbnRpdHk7XG4gICAgICogaWYgKCFmaW4ubWUuaXNXaW5kb3cpIHtcbiAgICAgKiAgICAgd2luZG93SWRlbnRpdHkgPSBmaW4ubWUuaWRlbnRpdHk7XG4gICAgICogfSBlbHNlIGlmIChmaW4ubWUuaXNWaWV3KSB7XG4gICAgICogICAgIHdpbmRvd0lkZW50aXR5ID0gKGF3YWl0IGZpbi5tZS5nZXRDdXJyZW50V2luZG93KCkpLmlkZW50aXR5O1xuICAgICAqIH0gZWxzZSB7XG4gICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3IG9yIFdpbmRvdycpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IGxheW91dCA9IGF3YWl0IGZpbi5QbGF0Zm9ybS5MYXlvdXQud3JhcCh3aW5kb3dJZGVudGl0eSk7XG4gICAgICogLy8gVXNlIHdyYXBwZWQgaW5zdGFuY2UgdG8gY29udHJvbCBsYXlvdXQsIGUuZy46XG4gICAgICogY29uc3QgbGF5b3V0Q29uZmlnID0gYXdhaXQgbGF5b3V0LmdldENvbmZpZygpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHdyYXAoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC13cmFwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xJDIuTGF5b3V0KGlkZW50aXR5LCB0aGlzLndpcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IHJldHVybnMgYSBMYXlvdXQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIFdpbmRvdydzIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBsZXQgd2luZG93SWRlbnRpdHk7XG4gICAgICogaWYgKCFmaW4ubWUuaXNXaW5kb3cpIHtcbiAgICAgKiAgICAgd2luZG93SWRlbnRpdHkgPSBmaW4ubWUuaWRlbnRpdHk7XG4gICAgICogfSBlbHNlIGlmIChmaW4ubWUuaXNWaWV3KSB7XG4gICAgICogICAgIHdpbmRvd0lkZW50aXR5ID0gKGF3YWl0IGZpbi5tZS5nZXRDdXJyZW50V2luZG93KCkpLmlkZW50aXR5O1xuICAgICAqIH0gZWxzZSB7XG4gICAgICogICAgIHRocm93IG5ldyBFcnJvcignTm90IHJ1bm5pbmcgaW4gYSBwbGF0Zm9ybSBWaWV3IG9yIFdpbmRvdycpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IGxheW91dCA9IGZpbi5QbGF0Zm9ybS5MYXlvdXQud3JhcFN5bmMod2luZG93SWRlbnRpdHkpO1xuICAgICAqIC8vIFVzZSB3cmFwcGVkIGluc3RhbmNlIHRvIGNvbnRyb2wgbGF5b3V0LCBlLmcuOlxuICAgICAqIGNvbnN0IGxheW91dENvbmZpZyA9IGF3YWl0IGxheW91dC5nZXRDb25maWcoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB3cmFwU3luYyhpZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LXdyYXAtc3luYycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMSQyLkxheW91dChpZGVudGl0eSwgdGhpcy53aXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIExheW91dCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgV2luZG93J3MgbGF5b3V0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxheW91dCA9IGF3YWl0IGZpbi5QbGF0Zm9ybS5MYXlvdXQuZ2V0Q3VycmVudCgpO1xuICAgICAqIC8vIFVzZSB3cmFwcGVkIGluc3RhbmNlIHRvIGNvbnRyb2wgbGF5b3V0LCBlLmcuOlxuICAgICAqIGNvbnN0IGxheW91dENvbmZpZyA9IGF3YWl0IGxheW91dC5nZXRDb25maWcoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LWdldC1jdXJyZW50JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmZpbi5tZS5pc1dpbmRvdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBpbiBhIFdpbmRvdyBjb250ZXh0LiAgT25seSBXaW5kb3dzIGNhbiBoYXZlIGEgTGF5b3V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdXVpZCwgbmFtZSB9ID0gdGhpcy5maW4ubWU7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoeyB1dWlkLCBuYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IHJldHVybnMgYSBMYXlvdXQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIFdpbmRvdydzIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBhIHZpZXcuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsYXlvdXQgPSBmaW4uUGxhdGZvcm0uTGF5b3V0LmdldEN1cnJlbnRTeW5jKCk7XG4gICAgICogLy8gVXNlIHdyYXBwZWQgaW5zdGFuY2UgdG8gY29udHJvbCBsYXlvdXQsIGUuZy46XG4gICAgICogY29uc3QgbGF5b3V0Q29uZmlnID0gYXdhaXQgbGF5b3V0LmdldENvbmZpZygpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRTeW5jKCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LWdldC1jdXJyZW50LXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZmluLm1lLmlzV2luZG93KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IGluIGEgV2luZG93IGNvbnRleHQuICBPbmx5IFdpbmRvd3MgY2FuIGhhdmUgYSBMYXlvdXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSB0aGlzLmZpbi5tZTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN5bmMoeyB1dWlkLCBuYW1lIH0pO1xuICAgIH1cbn1cbkZhY3RvcnkkMi5MYXlvdXRNb2R1bGUgPSBMYXlvdXRNb2R1bGU7XG5fTGF5b3V0TW9kdWxlX2xheW91dEluaXRpYWxpemF0aW9uQXR0ZW1wdGVkID0gbmV3IFdlYWtNYXAoKSwgX0xheW91dE1vZHVsZV9sYXlvdXRNYW5hZ2VyID0gbmV3IFdlYWtNYXAoKSwgX0xheW91dE1vZHVsZV9nZXRMYXlvdXRNYW5hZ2VyU3B5ID0gbmV3IFdlYWtNYXAoKSwgX0xheW91dE1vZHVsZV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfTGF5b3V0TW9kdWxlX2dldFNhZmVMYXlvdXRNYW5hZ2VyID0gZnVuY3Rpb24gX0xheW91dE1vZHVsZV9nZXRTYWZlTGF5b3V0TWFuYWdlcihtZXRob2QpIHtcbiAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQkNCh0aGlzLCBfTGF5b3V0TW9kdWxlX2xheW91dE1hbmFnZXIsIFwiZlwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IGNhbGwgaW5pdCBiZWZvcmUgdXNpbmcgdGhlIEFQSSAke21ldGhvZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkNCh0aGlzLCBfTGF5b3V0TW9kdWxlX2xheW91dE1hbmFnZXIsIFwiZlwiKTtcbn07XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQvKipcblx0ICogRW50cnkgcG9pbnQgZm9yIHRoZSBPcGVuRmluIGBMYXlvdXRgIHN1YnNldCBvZiB0aGUgYFBsYXRmb3JtYCBBUEkgKGBmaW4uUGxhdGZvcm0uTGF5b3V0YCkuXG5cdCAqXG5cdCAqICoge0BsaW5rIExheW91dE1vZHVsZX0gY29udGFpbnMgc3RhdGljIG1lbWJlcnMgb2YgdGhlIGBMYXlvdXRgIEFQSSwgYWNjZXNzaWJsZSB0aHJvdWdoIGBmaW4uUGxhdGZvcm0uTGF5b3V0YC5cblx0ICogKiB7QGxpbmsgTGF5b3V0fSBkZXNjcmliZXMgYW4gaW5zdGFuY2Ugb2YgYW4gT3BlbkZpbiBMYXlvdXQsIGUuZy4gYXMgcmV0dXJuZWQgYnkgYGZpbi5QbGF0Zm9ybS5MYXlvdXQuZ2V0Q3VycmVudGAuXG5cdCAqXG5cdCAqIFRoZXNlIGFyZSBzZXBhcmF0ZSBjb2RlIGVudGl0aWVzLCBhbmQgYXJlIGRvY3VtZW50ZWQgc2VwYXJhdGVseS4gSW4gdGhlIFtwcmV2aW91cyB2ZXJzaW9uIG9mIHRoZSBBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9jZG4ub3BlbmZpbi5jby9kb2NzL2phdmFzY3JpcHQvMzIuMTE0Ljc2LjEwL2luZGV4Lmh0bWwpLFxuXHQgKiBib3RoIG9mIHRoZXNlIHdlcmUgZG9jdW1lbnRlZCBvbiB0aGUgc2FtZSBwYWdlLlxuXHQgKlxuXHQgKiBAcGFja2FnZURvY3VtZW50YXRpb25cblx0ICpcblx0ICovXG5cdHZhciBfX2NyZWF0ZUJpbmRpbmcgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuXHQgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcblx0ICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblx0ICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG5cdCAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuXHR9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuXHQgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcblx0ICAgIG9bazJdID0gbVtrXTtcblx0fSkpO1xuXHR2YXIgX19leHBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuXHQgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdF9fZXhwb3J0U3RhcihGYWN0b3J5JDIsIGV4cG9ydHMpO1xuXHRfX2V4cG9ydFN0YXIoSW5zdGFuY2UkMSwgZXhwb3J0cyk7IFxufSAobGF5b3V0KSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWN0b3J5JDMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuRmFjdG9yeSQzLlBsYXRmb3JtTW9kdWxlID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xJDQgPSBiYXNlO1xuY29uc3QgSW5zdGFuY2VfMSQxID0gSW5zdGFuY2UkMjtcbmNvbnN0IGluZGV4XzEkMSA9IGxheW91dDtcbi8qKlxuICogU3RhdGljIG5hbWVzcGFjZSBmb3IgT3BlbkZpbiBBUEkgbWV0aG9kcyB0aGF0IGludGVyYWN0IHdpdGggdGhlIHtAbGluayBQbGF0Zm9ybX0gY2xhc3MsIGF2YWlsYWJsZSB1bmRlciBgZmluLlBsYXRmb3JtYC5cbiAqL1xuY2xhc3MgUGxhdGZvcm1Nb2R1bGUgZXh0ZW5kcyBiYXNlXzEkNC5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aXJlLCBjaGFubmVsKSB7XG4gICAgICAgIHN1cGVyKHdpcmUpO1xuICAgICAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXNjIExheW91dHMgZ2l2ZSBhcHAgcHJvdmlkZXJzIHRoZSBhYmlsaXR5IHRvIGVtYmVkIG11bHRpcGxlIHZpZXdzIGluIGEgc2luZ2xlIHdpbmRvdy4gIFRoZSBMYXlvdXQgbmFtZXNwYWNlXG4gICAgICAgICAqIGVuYWJsZXMgdGhlIGluaXRpYWxpemF0aW9uIGFuZCBtYW5pcHVsYXRpb24gb2YgYSB3aW5kb3cncyBMYXlvdXQuICBBIExheW91dCB3aWxsXG4gICAgICAgICAqIDxhIGhyZWY9XCJ0dXRvcmlhbC1MYXlvdXQuRE9NRXZlbnRzLmh0bWxcIj5lbWl0IGV2ZW50cyBsb2NhbGx5PC9hPiBvbiB0aGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBsYXlvdXQtY29udGFpbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5MYXlvdXQgPSBuZXcgaW5kZXhfMSQxLkxheW91dE1vZHVsZSh0aGlzLndpcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIFBsYXRmb3JtLiBNdXN0IGJlIGNhbGxlZCBmcm9tIHRoZSBQcm92aWRlciB3aGVuIHVzaW5nIGEgY3VzdG9tIHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gcGxhdGZvcm0gb3B0aW9ucyBpbmNsdWRpbmcgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGV4dGVuZCBvciByZXBsYWNlXG4gICAgICogZGVmYXVsdCBQcm92aWRlciBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIE11c3QgYmUgY2FsbGVkIGZyb20gdGhlIFByb3ZpZGVyIHdoZW4gdXNpbmcgYSBjdXN0b20gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAvLyBGcm9tIFByb3ZpZGVyIGNvbnRleHRcbiAgICAgKiBhd2FpdCBmaW4uUGxhdGZvcm0uaW5pdCgpO1xuICAgICAqIC8vIFBsYXRmb3JtIEFQSSBpcyBub3cgaG9va2VkIHVwIGFuZCB3aW5kb3dzIGNvbnRhaW5lZCBpbiB0aGUgbWFuaWZlc3Qgc25hcHNob3QgYXJlIG9wZW4uXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgUGxhdGZvcm0uaW5pdGAgYWNjZXB0cyBhbiBvcHRpb25zIG9iamVjdCB0aGF0IGNhbiBjb250YWluIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIG9yXG4gICAgICogcmVwbGFjZSBkZWZhdWx0IFByb3ZpZGVyIGJlaGF2aW9yLiBBcyBhbiBhcmd1bWVudCwgdGhpcyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIGBQcm92aWRlcmAgY2xhc3MsIHdoaWNoIGlzXG4gICAgICogdXNlZCB0byBoYW5kbGUgUGxhdGZvcm0gYWN0aW9ucy4gVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIG1ldGhvZHMgdG8gaGFuZGxlIFBsYXRmb3JtIEFQSSBhY3Rpb25zLlxuICAgICAqIFRoZSByZWNvbW1lbmRlZCBhcHByb2FjaCBpcyB0byBleHRlbmQgdGhlIGBQcm92aWRlcmAgY2xhc3MsIG92ZXJyaWRpbmcgdGhlIG1ldGhvZHMgeW91IHdpc2ggdG8gYWx0ZXIsIGFuZCByZXR1cm4gYW5cbiAgICAgKiBpbnN0YW5jZSBvZiB5b3VyIHN1YmNsYXNzOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBvdmVycmlkZUNhbGxiYWNrID0gYXN5bmMgKFBsYXRmb3JtUHJvdmlkZXIpID0+IHtcbiAgICAgKiAgICAgLy8gQWN0aW9ucyBjYW4gYmUgcGVyZm9ybWVkIGJlZm9yZSBpbml0aWFsaXphdGlvbi5cbiAgICAgKiAgICAgLy8gZS5nLiB3ZSBtaWdodCBhdXRoZW50aWNhdGUgYSB1c2VyLCBzZXQgdXAgYSBDaGFubmVsLCBldGMgYmVmb3JlIGluaXRpYWxpemluZyB0aGUgUGxhdGZvcm0uXG4gICAgICogICAgIGNvbnN0IHsgbWFuaWZlc3RVcmwgfSA9IGF3YWl0IGZpbi5BcHBsaWNhdGlvbi5nZXRDdXJyZW50U3luYygpLmdldEluZm8oKTtcbiAgICAgKlxuICAgICAqICAgICAvLyBFeHRlbmQgb3IgcmVwbGFjZSBkZWZhdWx0IFBsYXRmb3JtUHJvdmlkZXIgYmVoYXZpb3IgYnkgZXh0ZW5kaW5nIHRoZSBQbGF0Zm9ybVByb3ZpZGVyIGNsYXNzLlxuICAgICAqICAgICBjbGFzcyBNeU92ZXJyaWRlIGV4dGVuZHMgUGxhdGZvcm1Qcm92aWRlciB7XG4gICAgICogICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGNhbiBiZSBjaGFuZ2VkIGJ5IGltcGxlbWVudGluZyBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZXMgYXMgdGhvc2UgdXNlZCBieSB0aGUgZGVmYXVsdCBQbGF0Zm9ybVByb3ZpZGVyLlxuICAgICAqICAgICAgICAgYXN5bmMgZ2V0U25hcHNob3QoKSB7XG4gICAgICogICAgICAgICAgICAgLy8gU2luY2Ugd2UgYXJlIGV4dGVuZGluZyB0aGUgY2xhc3MsIHdlIGNhbiBjYWxsIGBzdXBlcmAgbWV0aG9kcyB0byBhY2Nlc3MgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKiAgICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IHN1cGVyLmdldFNuYXBzaG90KCk7XG4gICAgICogICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBtb2RpZnkgcmV0dXJuIHZhbHVlcy5cbiAgICAgKiAgICAgICAgICAgICByZXR1cm4geyAuLi5zbmFwc2hvdCwgYW5zd2VyOiA0MiwgbWFuaWZlc3RVcmwgfTtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIGFzeW5jIHJlcGxhY2VMYXlvdXQoeyBvcHRzLCB0YXJnZXQgfSkge1xuICAgICAqICAgICAgICAgICAgIC8vIFRvIGRpc2FibGUgYW4gQVBJIG1ldGhvZCwgb3ZlcndyaXRlIHdpdGggYSBub29wIGZ1bmN0aW9uLlxuICAgICAqICAgICAgICAgICAgIHJldHVybjtcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqICAgICAvLyBSZXR1cm4gaW5zdGFuY2Ugd2l0aCBtZXRob2RzIHRvIGJlIGNvbnN1bWVkIGJ5IFBsYXRmb3JtLlxuICAgICAqICAgICAvLyBUaGUgcmV0dXJuZWQgb2JqZWN0IG11c3QgaW1wbGVtZW50IGFsbCBtZXRob2RzIG9mIHRoZSBQbGF0Zm9ybVByb3ZpZGVyIGNsYXNzLlxuICAgICAqICAgICAvLyBCeSBleHRlbmRpbmcgdGhlIGNsYXNzLCB3ZSBjYW4gc2ltcGx5IGluaGVyaXQgbWV0aG9kcyB3ZSBkbyBub3Qgd2lzaCB0byBhbHRlci5cbiAgICAgKiAgICAgcmV0dXJuIG5ldyBNeU92ZXJyaWRlKCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZpbi5QbGF0Zm9ybS5pbml0KHtvdmVycmlkZUNhbGxiYWNrfSk7XG4gICAgICogYGBgXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIGluaXQob3B0aW9ucykge1xuICAgICAgICBpZiAoIWZpbi5fX2ludGVybmFsXy5pc1BsYXRmb3JtIHx8IGZpbi5tZS5uYW1lICE9PSBmaW4ubWUudXVpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaW4uUGxhdGZvcm0uaW5pdCBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSBhIGN1c3RvbSBwbGF0Zm9ybSBwcm92aWRlciBydW5uaW5nIGluIHRoZSBtYWluIHdpbmRvdyBvZiB0aGUgYXBwbGljYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5lbnZpcm9ubWVudC5pbml0UGxhdGZvcm0odGhpcy5maW4sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGEgUGxhdGZvcm0gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleGlzdGluZyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB7IGlkZW50aXR5IH0gPSBmaW4ubWU7XG4gICAgICogY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBmaW4uUGxhdGZvcm0ud3JhcChpZGVudGl0eSk7XG4gICAgICogLy8gVXNlIHdyYXBwZWQgaW5zdGFuY2UgdG8gY29udHJvbCBsYXlvdXQsIGUuZy46XG4gICAgICogY29uc3Qgc25hcHNob3QgPSBhd2FpdCBwbGF0Zm9ybS5nZXRTbmFwc2hvdCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHdyYXAoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLXdyYXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEkMS5QbGF0Zm9ybSh7IHV1aWQ6IGlkZW50aXR5LnV1aWQgfSwgdGhpcy5fY2hhbm5lbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFBsYXRmb3JtIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gZXhpc3RpbmcgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgeyBpZGVudGl0eSB9ID0gZmluLm1lO1xuICAgICAqIGNvbnN0IHBsYXRmb3JtID0gZmluLlBsYXRmb3JtLndyYXBTeW5jKGlkZW50aXR5KTtcbiAgICAgKiAvLyBVc2Ugd3JhcHBlZCBpbnN0YW5jZSB0byBjb250cm9sIGxheW91dCwgZS5nLjpcbiAgICAgKiBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IHBsYXRmb3JtLmdldFNuYXBzaG90KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgd3JhcFN5bmMoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLXdyYXAtc3luYycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMSQxLlBsYXRmb3JtKHsgdXVpZDogaWRlbnRpdHkudXVpZCB9LCB0aGlzLl9jaGFubmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFBsYXRmb3JtIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBmaW4uUGxhdGZvcm0uZ2V0Q3VycmVudCgpO1xuICAgICAqIC8vIFVzZSB3cmFwcGVkIGluc3RhbmNlIHRvIGNvbnRyb2wgbGF5b3V0LCBlLmcuOlxuICAgICAqIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgcGxhdGZvcm0uZ2V0U25hcHNob3QoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tZ2V0LWN1cnJlbnQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHsgdXVpZDogdGhpcy53aXJlLm1lLnV1aWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFBsYXRmb3JtIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcGxhdGZvcm0gPSBmaW4uUGxhdGZvcm0uZ2V0Q3VycmVudFN5bmMoKTtcbiAgICAgKiAvLyBVc2Ugd3JhcHBlZCBpbnN0YW5jZSB0byBjb250cm9sIGxheW91dCwgZS5nLjpcbiAgICAgKiBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IHBsYXRmb3JtLmdldFNuYXBzaG90KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFN5bmMoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1nZXQtY3VycmVudC1zeW5jJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN5bmMoeyB1dWlkOiB0aGlzLndpcmUubWUudXVpZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgc3RhcnRzIGEgUGxhdGZvcm0gYW5kIHJldHVybnMgYSB3cmFwcGVkIGFuZCBydW5uaW5nIFBsYXRmb3JtIGluc3RhbmNlLiBUaGUgd3JhcHBlZCBQbGF0Zm9ybSBtZXRob2RzIGNhblxuICAgICAqIGJlIHVzZWQgdG8gbGF1bmNoIGNvbnRlbnQgaW50byB0aGUgcGxhdGZvcm0uICBQcm9taXNlIHdpbGwgcmVqZWN0IGlmIHRoZSBwbGF0Zm9ybSBpcyBhbHJlYWR5IHJ1bm5pbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdHJ5IHtcbiAgICAgKiAgICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBmaW4uUGxhdGZvcm0uc3RhcnQoe1xuICAgICAqICAgICAgICAgdXVpZDogJ3BsYXRmb3JtLTEnLFxuICAgICAqICAgICAgICAgYXV0b1Nob3c6IGZhbHNlLFxuICAgICAqICAgICAgICAgZGVmYXVsdFdpbmRvd09wdGlvbnM6IHtcbiAgICAgKiAgICAgICAgICAgICBzdHlsZXNoZWV0VXJsOiAnY3NzLXNoZWV0LXVybCcsXG4gICAgICogICAgICAgICAgICAgY29ybmVyUm91bmRpbmc6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgKiAgICAgICAgICAgICAgICAgd2lkdGg6IDEwXG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICB9KTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ1BsYXRmb3JtIGlzIHJ1bm5pbmcnLCBwbGF0Zm9ybSk7XG4gICAgICogfSBjYXRjaChlKSB7XG4gICAgICogICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXJ0KHBsYXRmb3JtT3B0aW9ucykge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tc3RhcnQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHV1aWQgfSA9IHBsYXRmb3JtT3B0aW9ucztcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVzaW5nIHByaXZhdGUgdmFyaWFibGUuXG4gICAgICAgICAgICAgICAgY29uc3QgYXBwID0gYXdhaXQgdGhpcy5maW4uQXBwbGljYXRpb24uX2NyZWF0ZSh7IC4uLnBsYXRmb3JtT3B0aW9ucywgaXNQbGF0Zm9ybUNvbnRyb2xsZXI6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZml4IHR5cGluZyAoaW50ZXJuYWwpXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGFwcC5vbmNlKCdwbGF0Zm9ybS1hcGktcmVhZHknLCAoKSA9PiByZXNvbHZlKHRoaXMud3JhcFN5bmMoeyB1dWlkIH0pKSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB1c2luZyBwcml2YXRlIHZhcmlhYmxlLlxuICAgICAgICAgICAgICAgIGFwcC5fcnVuKHsgdXVpZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHBsYXRmb3JtcydzIG1hbmlmZXN0IGFuZCByZXR1cm5zIGEgd3JhcHBlZCBhbmQgcnVubmluZyBQbGF0Zm9ybS4gIElmIHRoZXJlIGlzIGEgc25hcHNob3QgaW4gdGhlIG1hbmlmZXN0LFxuICAgICAqIGl0IHdpbGwgYmUgbGF1bmNoZWQgaW50byB0aGUgcGxhdGZvcm0uXG4gICAgICogQHBhcmFtIG1hbmlmZXN0VXJsIC0gVGhlIFVSTCBvZiBwbGF0Zm9ybSdzIG1hbmlmZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzIC0gUGFyYW1ldGVycyB0aGF0IHRoZSBSVk0gd2lsbCB1c2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdHJ5IHtcbiAgICAgKiAgICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBmaW4uUGxhdGZvcm0uc3RhcnRGcm9tTWFuaWZlc3QoJ2h0dHBzOi8vb3BlbmZpbi5naXRodWIuaW8vZ29sZGVuLXByb3RvdHlwZS9wdWJsaWMuanNvbicpO1xuICAgICAqICAgICBjb25zb2xlLmxvZygnUGxhdGZvcm0gaXMgcnVubmluZywgd3JhcHBlZCBwbGF0Zm9ybTogJywgcGxhdGZvcm0pO1xuICAgICAqIH0gY2F0Y2goZSkge1xuICAgICAqICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAqIH1cbiAgICAgKiAvLyBGb3IgYSBsb2NhbCBtYW5pZmVzdCBmaWxlOlxuICAgICAqIHRyeSB7XG4gICAgICogICAgIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZmluLlBsYXRmb3JtLnN0YXJ0RnJvbU1hbmlmZXN0KCdmaWxlOi8vL0M6L3NvbWVmb2xkZXIvYXBwLmpzb24nKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ1BsYXRmb3JtIGlzIHJ1bm5pbmcsIHdyYXBwZWQgcGxhdGZvcm06ICcsIHBsYXRmb3JtKTtcbiAgICAgKiB9IGNhdGNoKGUpIHtcbiAgICAgKiAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhcnRGcm9tTWFuaWZlc3QobWFuaWZlc3RVcmwsIG9wdHMpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLXN0YXJ0LWZyb20tbWFuaWZlc3QnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVzaW5nIHByaXZhdGUgdmFyaWFibGUuXG4gICAgICAgICAgICAgICAgY29uc3QgYXBwID0gYXdhaXQgdGhpcy5maW4uQXBwbGljYXRpb24uX2NyZWF0ZUZyb21NYW5pZmVzdChtYW5pZmVzdFVybCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZml4IHR5cGluZyAoaW50ZXJuYWwpXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGFwcC5vbmNlKCdwbGF0Zm9ybS1hcGktcmVhZHknLCAoKSA9PiByZXNvbHZlKHRoaXMud3JhcFN5bmMoeyB1dWlkOiBhcHAuaWRlbnRpdHkudXVpZCB9KSkpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdXNpbmcgcHJpdmF0ZSBtZXRob2Qgd2l0aG91dCB3YXJuaW5nLlxuICAgICAgICAgICAgICAgIGFwcC5fcnVuKG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkZhY3RvcnkkMy5QbGF0Zm9ybU1vZHVsZSA9IFBsYXRmb3JtTW9kdWxlO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX2V4cG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0LyoqXG5cdCAqIEVudHJ5IHBvaW50cyBmb3IgdGhlIE9wZW5GaW4gYFBsYXRmb3JtYCBBUEkgKGBmaW4uUGxhdGZvcm1gKVxuXHQgKlxuXHQgKiAqIHtAbGluayBQbGF0Zm9ybU1vZHVsZX0gY29udGFpbnMgc3RhdGljIG1lbWJlcnMgb2YgdGhlIGBQbGF0Zm9ybWAgQVBJLCBhY2Nlc3NpYmxlIHRocm91Z2ggYGZpbi5QbGF0Zm9ybWAuXG5cdCAqICoge0BsaW5rIFBsYXRmb3JtfSBkZXNjcmliZXMgYW4gaW5zdGFuY2Ugb2YgYW4gT3BlbkZpbiBQbGF0Zm9ybSwgZS5nLiBhcyByZXR1cm5lZCBieSBgZmluLlBsYXRmb3JtLmdldEN1cnJlbnRgLlxuXHQgKlxuXHQgKiBUaGVzZSBhcmUgc2VwYXJhdGUgY29kZSBlbnRpdGllcywgYW5kIGFyZSBkb2N1bWVudGVkIHNlcGFyYXRlbHkuICBJbiB0aGUgW3ByZXZpb3VzIHZlcnNpb24gb2YgdGhlIEFQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC8zMi4xMTQuNzYuMTAvaW5kZXguaHRtbCksXG5cdCAqIGJvdGggb2YgdGhlc2Ugd2VyZSBkb2N1bWVudGVkIG9uIHRoZSBzYW1lIHBhZ2UuXG5cdCAqXG5cdCAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuXHQgKi9cblx0X19leHBvcnRTdGFyKEZhY3RvcnkkMywgZXhwb3J0cyk7XG5cdF9fZXhwb3J0U3RhcihJbnN0YW5jZSQyLCBleHBvcnRzKTsgXG59IChwbGF0Zm9ybSkpO1xuXG52YXIgbWUgPSB7fTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5nZXRNZSA9IGV4cG9ydHMuZ2V0QmFzZU1lID0gZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSA9IHZvaWQgMDtcblx0Y29uc3Qgdmlld18xID0gcmVxdWlyZVZpZXcoKTtcblx0Y29uc3QgZnJhbWVfMSA9IGZyYW1lO1xuXHRjb25zdCB3aW5kb3dfMSA9IHJlcXVpcmVXaW5kb3coKTtcblx0Y29uc3QgZXh0ZXJuYWxfYXBwbGljYXRpb25fMSA9IGV4dGVybmFsQXBwbGljYXRpb247XG5cdGV4cG9ydHMuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UgPSAnWW91IGFyZSBub3QgcnVubmluZyBpbiBPcGVuRmluLic7XG5cdGZ1bmN0aW9uIGdldEJhc2VNZShlbnRpdHlUeXBlLCB1dWlkLCBuYW1lKSB7XG5cdCAgICBjb25zdCBlbnRpdHlUeXBlSGVscGVycyA9IHtcblx0ICAgICAgICBpc1ZpZXc6IGVudGl0eVR5cGUgPT09ICd2aWV3Jyxcblx0ICAgICAgICBpc1dpbmRvdzogZW50aXR5VHlwZSA9PT0gJ3dpbmRvdycsXG5cdCAgICAgICAgaXNGcmFtZTogZW50aXR5VHlwZSA9PT0gJ2lmcmFtZScsXG5cdCAgICAgICAgaXNFeHRlcm5hbDogZW50aXR5VHlwZSA9PT0gJ2V4dGVybmFsIGNvbm5lY3Rpb24nXG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHsgLi4uZW50aXR5VHlwZUhlbHBlcnMsIHV1aWQsIG5hbWUsIGVudGl0eVR5cGUgfTtcblx0fVxuXHRleHBvcnRzLmdldEJhc2VNZSA9IGdldEJhc2VNZTtcblx0Ly8gV2UgbmVlZCB0byBkbyBhIGxvdCBvZiBjYXN0aW5nIGFzIHVua25vd24gaGVyZSBiZWNhdXNlIHRoZSBjb21waWxlciBnZXQncyBjb25mdXNlZCBhYm91dCBtYXRjaGluZyB0eXBlcy4gV2hhdCBtYXR0ZXJzIGlzIHRoYXQgaXQgd29ya3Mgb24gdGhlIG91dHNpZGVcblx0ZnVuY3Rpb24gZ2V0TWUod2lyZSkge1xuXHQgICAgY29uc3QgeyB1dWlkLCBuYW1lLCBlbnRpdHlUeXBlIH0gPSB3aXJlLm1lO1xuXHQgICAgY29uc3QgdW5zdXBwb3J0ZWRJbnRlcm9wID0ge1xuXHQgICAgICAgIHNldENvbnRleHQoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGFkZENvbnRleHRIYW5kbGVyKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXRDb250ZXh0R3JvdXBzKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBqb2luQ29udGV4dEdyb3VwKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICByZW1vdmVGcm9tQ29udGV4dEdyb3VwKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXRBbGxDbGllbnRzSW5Db250ZXh0R3JvdXAoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldEluZm9Gb3JDb250ZXh0R3JvdXAoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgY29uc3QgZmFsbGJhY2tFcnJvck1lc3NhZ2UgPSAnSW50ZXJvcCBBUEkgaGFzIG5vdCBiZWVuIGluc3RhbnRpYXRlZC4gRWl0aGVyIGNvbm5lY3Rpb24gaGFzIGZhaWxlZCBvciB5b3UgaGF2ZSBub3QgZGVjbGFyZWQgaW50ZXJvcCBpbiB5b3VyIGNvbmZpZy4nO1xuXHQgICAgY29uc3QgZmFsbGJhY2tJbnRlcm9wID0ge1xuXHQgICAgICAgIHNldENvbnRleHQoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxsYmFja0Vycm9yTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBhZGRDb250ZXh0SGFuZGxlcigpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbGxiYWNrRXJyb3JNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldENvbnRleHRHcm91cHMoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxsYmFja0Vycm9yTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBqb2luQ29udGV4dEdyb3VwKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsbGJhY2tFcnJvck1lc3NhZ2UpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcmVtb3ZlRnJvbUNvbnRleHRHcm91cCgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbGxiYWNrRXJyb3JNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbGxiYWNrRXJyb3JNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldEluZm9Gb3JDb250ZXh0R3JvdXAoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxsYmFja0Vycm9yTWVzc2FnZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGNvbnN0IHVuc3VwcG9ydGVkRXZlbnRCYXNlID0ge1xuXHQgICAgICAgIGV2ZW50TmFtZXM6ICgpID0+IHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cG9ydHMuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW1pdDogKCkgPT4ge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBsaXN0ZW5lcnM6ICgpID0+IHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cG9ydHMuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbGlzdGVuZXJDb3VudDogKCkgPT4ge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBvbjogKCkgPT4ge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBhZGRMaXN0ZW5lcjogKCkgPT4ge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBvbmNlOiAoKSA9PiB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHByZXBlbmRMaXN0ZW5lcjogKCkgPT4ge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwcmVwZW5kT25jZUxpc3RlbmVyOiAoKSA9PiB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJlbW92ZUxpc3RlbmVyOiAoKSA9PiB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogKCkgPT4ge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHN3aXRjaCAoZW50aXR5VHlwZSkge1xuXHQgICAgICAgIGNhc2UgJ3ZpZXcnOlxuXHQgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdmlld18xLlZpZXcod2lyZSwgeyB1dWlkLCBuYW1lIH0pLCBnZXRCYXNlTWUoZW50aXR5VHlwZSwgdXVpZCwgbmFtZSksIHtcblx0ICAgICAgICAgICAgICAgIGludGVyb3A6IGZhbGxiYWNrSW50ZXJvcCxcblx0ICAgICAgICAgICAgICAgIGlzT3BlbkZpbjogdHJ1ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICBjYXNlICd3aW5kb3cnOlxuXHQgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgd2luZG93XzEuX1dpbmRvdyh3aXJlLCB7IHV1aWQsIG5hbWUgfSksIGdldEJhc2VNZShlbnRpdHlUeXBlLCB1dWlkLCBuYW1lKSwge1xuXHQgICAgICAgICAgICAgICAgaW50ZXJvcDogZmFsbGJhY2tJbnRlcm9wLFxuXHQgICAgICAgICAgICAgICAgaXNPcGVuRmluOiB0cnVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIGNhc2UgJ2lmcmFtZSc6XG5cdCAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBmcmFtZV8xLl9GcmFtZSh3aXJlLCB7IHV1aWQsIG5hbWUgfSksIGdldEJhc2VNZShlbnRpdHlUeXBlLCB1dWlkLCBuYW1lKSwge1xuXHQgICAgICAgICAgICAgICAgaW50ZXJvcDogZmFsbGJhY2tJbnRlcm9wLFxuXHQgICAgICAgICAgICAgICAgaXNPcGVuRmluOiB0cnVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIGNhc2UgJ2V4dGVybmFsIGNvbm5lY3Rpb24nOlxuXHQgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgZXh0ZXJuYWxfYXBwbGljYXRpb25fMS5FeHRlcm5hbEFwcGxpY2F0aW9uKHdpcmUsIHsgdXVpZCB9KSwgZ2V0QmFzZU1lKGVudGl0eVR5cGUsIHV1aWQsIG5hbWUpLCB7XG5cdCAgICAgICAgICAgICAgICBpbnRlcm9wOiBmYWxsYmFja0ludGVyb3AsXG5cdCAgICAgICAgICAgICAgICBpc09wZW5GaW46IGZhbHNlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAuLi5nZXRCYXNlTWUoZW50aXR5VHlwZSwgdXVpZCwgbmFtZSksXG5cdCAgICAgICAgICAgICAgICAuLi51bnN1cHBvcnRlZEV2ZW50QmFzZSxcblx0ICAgICAgICAgICAgICAgIGludGVyb3A6IHVuc3VwcG9ydGVkSW50ZXJvcCxcblx0ICAgICAgICAgICAgICAgIGlzT3BlbkZpbjogZmFsc2Vcblx0ICAgICAgICAgICAgfTtcblx0ICAgIH1cblx0fVxuXHRleHBvcnRzLmdldE1lID0gZ2V0TWU7IFxufSAobWUpKTtcblxudmFyIGludGVyb3AgPSB7fTtcblxudmFyIEZhY3RvcnkkMSA9IHt9O1xuXG52YXIgaW5hY2Nlc3NpYmxlT2JqZWN0ID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbmFjY2Vzc2libGVPYmplY3QsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuaW5hY2Nlc3NpYmxlT2JqZWN0LmNyZWF0ZVdhcm5pbmdPYmplY3QgPSBpbmFjY2Vzc2libGVPYmplY3QuY3JlYXRlVW51c2FibGVPYmplY3QgPSB2b2lkIDA7XG5mdW5jdGlvbiBjcmVhdGVVbnVzYWJsZU9iamVjdChtZXNzYWdlKSB7XG4gICAgY29uc3QgaGFuZGxlID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgIGFwcGx5OiBoYW5kbGUsXG4gICAgICAgIGNvbnN0cnVjdDogaGFuZGxlLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogaGFuZGxlLFxuICAgICAgICBkZWxldGVQcm9wZXJ0eTogaGFuZGxlLFxuICAgICAgICBnZXQ6IGhhbmRsZSxcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBoYW5kbGUsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBoYW5kbGUsXG4gICAgICAgIGhhczogaGFuZGxlLFxuICAgICAgICBpc0V4dGVuc2libGU6IGhhbmRsZSxcbiAgICAgICAgb3duS2V5czogaGFuZGxlLFxuICAgICAgICBwcmV2ZW50RXh0ZW5zaW9uczogaGFuZGxlLFxuICAgICAgICBzZXQ6IGhhbmRsZSxcbiAgICAgICAgc2V0UHJvdG90eXBlT2Y6IGhhbmRsZVxuICAgIH0pO1xufVxuaW5hY2Nlc3NpYmxlT2JqZWN0LmNyZWF0ZVVudXNhYmxlT2JqZWN0ID0gY3JlYXRlVW51c2FibGVPYmplY3Q7XG5mdW5jdGlvbiBjcmVhdGVXYXJuaW5nT2JqZWN0KG1lc3NhZ2UsIG9iaikge1xuICAgIHJldHVybiBuZXcgUHJveHkob2JqLCB7XG4gICAgICAgIGdldDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQoLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXM6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuaW5hY2Nlc3NpYmxlT2JqZWN0LmNyZWF0ZVdhcm5pbmdPYmplY3QgPSBjcmVhdGVXYXJuaW5nT2JqZWN0O1xuXG52YXIgSW50ZXJvcEJyb2tlciA9IHt9O1xuXG52YXIgU2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlciA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRTZXNzaW9uQ29udGV4dEdyb3VwQnJva2VyO1xuXG5mdW5jdGlvbiByZXF1aXJlU2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFNlc3Npb25Db250ZXh0R3JvdXBCcm9rZXIpIHJldHVybiBTZXNzaW9uQ29udGV4dEdyb3VwQnJva2VyO1xuXHRoYXNSZXF1aXJlZFNlc3Npb25Db250ZXh0R3JvdXBCcm9rZXIgPSAxO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGNvbnN0IF8xID0gcmVxdWlyZUludGVyb3AoKTtcblx0bGV0IFNlc3Npb25Db250ZXh0R3JvdXBCcm9rZXIkMSA9IGNsYXNzIFNlc3Npb25Db250ZXh0R3JvdXBCcm9rZXIge1xuXHQgICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGlkKSB7XG5cdCAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcblx0ICAgICAgICB0aGlzLmxhc3RDb250ZXh0ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIHRoaXMuY29udGV4dEdyb3VwTWFwID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcblx0ICAgICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cdCAgICB9XG5cdCAgICByZWdpc3Rlckxpc3RlbmVycygpIHtcblx0ICAgICAgICB0aGlzLnByb3ZpZGVyLnJlZ2lzdGVyKGBzZXNzaW9uQ29udGV4dEdyb3VwOmdldENvbnRleHQtJHt0aGlzLmlkfWAsIHRoaXMuZ2V0Q3VycmVudENvbnRleHQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5wcm92aWRlci5yZWdpc3Rlcihgc2Vzc2lvbkNvbnRleHRHcm91cDpzZXRDb250ZXh0LSR7dGhpcy5pZH1gLCB0aGlzLnNldENvbnRleHQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5wcm92aWRlci5yZWdpc3Rlcihgc2Vzc2lvbkNvbnRleHRHcm91cDpoYW5kbGVyQWRkZWQtJHt0aGlzLmlkfWAsIHRoaXMuaGFuZGxlckFkZGVkLmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMucHJvdmlkZXIucmVnaXN0ZXIoYHNlc3Npb25Db250ZXh0R3JvdXA6aGFuZGxlclJlbW92ZWQtJHt0aGlzLmlkfWAsIHRoaXMuaGFuZGxlclJlbW92ZWQuYmluZCh0aGlzKSk7XG5cdCAgICB9XG5cdCAgICBnZXRDdXJyZW50Q29udGV4dChwYXlsb2FkKSB7XG5cdCAgICAgICAgcmV0dXJuIHBheWxvYWQudHlwZSA/IHRoaXMuY29udGV4dEdyb3VwTWFwLmdldChwYXlsb2FkLnR5cGUpIDogdGhpcy5sYXN0Q29udGV4dDtcblx0ICAgIH1cblx0ICAgIHNldENvbnRleHQocGF5bG9hZCwgY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHBheWxvYWQ7XG5cdCAgICAgICAgY29uc3QgY29udGV4dEludGVncml0eUNoZWNrUmVzdWx0ID0gXzEuSW50ZXJvcEJyb2tlci5jaGVja0NvbnRleHRJbnRlZ3JpdHkoY29udGV4dCk7XG5cdCAgICAgICAgaWYgKGNvbnRleHRJbnRlZ3JpdHlDaGVja1Jlc3VsdC5pc1ZhbGlkID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXQgQ29udGV4dCAtIGJhZCBDb250ZXh0LiBSZWFzb246ICR7Y29udGV4dEludGVncml0eUNoZWNrUmVzdWx0LnJlYXNvbn0uIENvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCl9YCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKCFjbGllbnRTdGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBnZXQgaGl0LlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCB3aXRoIElkZW50aXR5OiAke2NsaWVudElkZW50aXR5LnV1aWR9ICR7Y2xpZW50SWRlbnRpdHkubmFtZX0gbm90IGluIFNlc3Npb24gQ2xpZW50IFN0YXRlIE1hcGApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBzZXQgdGhlIGNvbnRleHRcblx0ICAgICAgICB0aGlzLmNvbnRleHRHcm91cE1hcC5zZXQoY29udGV4dC50eXBlLCBjb250ZXh0KTtcblx0ICAgICAgICB0aGlzLmxhc3RDb250ZXh0ID0gY29udGV4dDtcblx0ICAgICAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25TdGF0ZXMgPSBBcnJheS5mcm9tKHRoaXMuY2xpZW50cy52YWx1ZXMoKSk7XG5cdCAgICAgICAgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGVzLmZvckVhY2goKGNsaWVudCkgPT4ge1xuXHQgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdCAgICAgICAgICAgIGNsaWVudC5jb250ZXh0SGFuZGxlcnMuZ2V0KGNvbnRleHQudHlwZSk/LmZvckVhY2goKGhhbmRsZXJJZCkgPT4ge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5kaXNwYXRjaChjbGllbnQuY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY29udGV4dCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZiAoY2xpZW50Lmdsb2JhbEhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuZGlzcGF0Y2goY2xpZW50LmNsaWVudElkZW50aXR5LCBjbGllbnQuZ2xvYmFsSGFuZGxlciwgY29udGV4dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGdldENsaWVudFN0YXRlKGlkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50cy5nZXQoaWQuZW5kcG9pbnRJZCk7XG5cdCAgICB9XG5cdCAgICBhc3luYyBoYW5kbGVyQWRkZWQocGF5bG9hZCwgY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBjb25zdCB7IGhhbmRsZXJJZCwgY29udGV4dFR5cGUgfSA9IHBheWxvYWQ7XG5cdCAgICAgICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICBpZiAoIWNsaWVudFN1YnNjcmlwdGlvblN0YXRlKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IHdpdGggSWRlbnRpdHk6ICR7Y2xpZW50SWRlbnRpdHkudXVpZH0gJHtjbGllbnRJZGVudGl0eS5uYW1lfSBub3QgaW4gQ2xpZW50IFN0YXRlIE1hcGApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29udGV4dFR5cGUpIHtcblx0ICAgICAgICAgICAgY29uc3QgY3VycmVudEhhbmRsZXJMaXN0ID0gY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUuY29udGV4dEhhbmRsZXJzLmdldChjb250ZXh0VHlwZSkgfHwgW107XG5cdCAgICAgICAgICAgIGNsaWVudFN1YnNjcmlwdGlvblN0YXRlLmNvbnRleHRIYW5kbGVycy5zZXQoY29udGV4dFR5cGUsIFsuLi5jdXJyZW50SGFuZGxlckxpc3QsIGhhbmRsZXJJZF0pO1xuXHQgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGV4dCA9IHRoaXMuY29udGV4dEdyb3VwTWFwLmdldChjb250ZXh0VHlwZSk7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5kaXNwYXRjaChjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjdXJyZW50Q29udGV4dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNsaWVudFN1YnNjcmlwdGlvblN0YXRlLmdsb2JhbEhhbmRsZXIgPSBoYW5kbGVySWQ7XG5cdCAgICAgICAgICAgIGNvbnN0IGdsb2JhbERpc3BhdGNoUHJvbWlzZXMgPSBbLi4udGhpcy5jb250ZXh0R3JvdXBNYXAua2V5cygpXS5tYXAoYXN5bmMgKGN1cnJlbnRDb250ZXh0VHlwZSkgPT4ge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSB0aGlzLmNvbnRleHRHcm91cE1hcC5nZXQoY3VycmVudENvbnRleHRUeXBlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZGlzcGF0Y2goY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY3VycmVudENvbnRleHQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZ2xvYmFsRGlzcGF0Y2hQcm9taXNlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaGFuZGxlclJlbW92ZWQocGF5bG9hZCwgY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBjb25zdCB7IGhhbmRsZXJJZCB9ID0gcGF5bG9hZDtcblx0ICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNsaWVudElkZW50aXR5LmVuZHBvaW50SWQpO1xuXHQgICAgICAgIGlmIChjbGllbnQpIHtcblx0ICAgICAgICAgICAgQXJyYXkuZnJvbShjbGllbnQuY29udGV4dEhhbmRsZXJzKS5mb3JFYWNoKChbLCBoYW5kbGVyc10pID0+IHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVySWQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaWYgKGNsaWVudC5nbG9iYWxIYW5kbGVyID09PSBoYW5kbGVySWQpIHtcblx0ICAgICAgICAgICAgICAgIGNsaWVudC5nbG9iYWxIYW5kbGVyID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyeWluZyB0byByZW1vdmUgYSBoYW5kbGVyIGZyb20gYSBjbGllbnQgdGhhdCBpc24ndCBtYXBwZWQuIGhhbmRsZXJJZDogJHtoYW5kbGVySWR9LiBjbGllbnRJZGVudGl0eTogJHtjbGllbnRJZGVudGl0eX1gKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZWdpc3Rlck5ld0NsaWVudChjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIGlmICghdGhpcy5jbGllbnRzLmhhcyhjbGllbnRJZGVudGl0eS5lbmRwb2ludElkKSkge1xuXHQgICAgICAgICAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25TdGF0ZSA9IHtcblx0ICAgICAgICAgICAgICAgIGNvbnRleHRIYW5kbGVyczogbmV3IE1hcCgpLFxuXHQgICAgICAgICAgICAgICAgY2xpZW50SWRlbnRpdHksXG5cdCAgICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVyOiB1bmRlZmluZWRcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdGhpcy5jbGllbnRzLnNldChjbGllbnRJZGVudGl0eS5lbmRwb2ludElkLCBjbGllbnRTdWJzY3JpcHRpb25TdGF0ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgb25EaXNjb25uZWN0aW9uKGNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZShjbGllbnRJZGVudGl0eS5lbmRwb2ludElkKTtcblx0ICAgIH1cblx0fTtcblx0U2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlci5kZWZhdWx0ID0gU2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlciQxO1xuXHRyZXR1cm4gU2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlcjtcbn1cblxudmFyIHV0aWxzJDEgPSB7fTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy53cmFwSW50ZW50SGFuZGxlciA9IGV4cG9ydHMuQlJPS0VSX0VSUk9SUyA9IGV4cG9ydHMuZ2VuZXJhdGVPdmVycmlkZVdhcm5pbmcgPSBleHBvcnRzLmdlbmVyYXRlT3ZlcnJpZGVFcnJvciA9IGV4cG9ydHMud3JhcENvbnRleHRIYW5kbGVyID0gZXhwb3J0cy53cmFwSW5UcnlDYXRjaCA9IGV4cG9ydHMuZ2VuZXJhdGVJZCA9IHZvaWQgMDtcblx0Y29uc3QgZ2VuZXJhdGVJZCA9ICgpID0+IGAke01hdGgucmFuZG9tKCl9JHtEYXRlLm5vdygpfWA7XG5cdGV4cG9ydHMuZ2VuZXJhdGVJZCA9IGdlbmVyYXRlSWQ7XG5cdGNvbnN0IHdyYXBJblRyeUNhdGNoID0gKGYsIHByZWZpeCkgPT4gKC4uLmFyZ3MpID0+IHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIGYoLi4uYXJncyk7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcigocHJlZml4IHx8ICcnKSArIGUpO1xuXHQgICAgfVxuXHR9O1xuXHRleHBvcnRzLndyYXBJblRyeUNhdGNoID0gd3JhcEluVHJ5Q2F0Y2g7XG5cdGNvbnN0IHdyYXBDb250ZXh0SGFuZGxlciA9IChoYW5kbGVyLCBoYW5kbGVySWQpID0+IHtcblx0ICAgIHJldHVybiBhc3luYyAoY29udGV4dCkgPT4ge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIoY29udGV4dCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB0aHJvd24gYnkgaGFuZGxlciAke2hhbmRsZXJJZH0gZm9yIGNvbnRleHQgdHlwZSAke2NvbnRleHQudHlwZX06ICR7ZXJyb3J9YCk7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH07XG5cdGV4cG9ydHMud3JhcENvbnRleHRIYW5kbGVyID0gd3JhcENvbnRleHRIYW5kbGVyO1xuXHRjb25zdCBnZW5lcmF0ZU92ZXJyaWRlRXJyb3IgPSAoY2xpZW50QXBpLCBicm9rZXJBcGkpID0+IHtcblx0ICAgIHJldHVybiBgWW91IGhhdmUgdHJpZWQgdG8gdG8gdXNlICR7Y2xpZW50QXBpfSBidXQgJHticm9rZXJBcGl9IGhhcyBub3QgYmVlbiBvdmVycmlkZGVuIGluIHRoZSBJbnRlcm9wIEJyb2tlci4gUGxlYXNlIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24uIFJlZmVyIHRvIG91ciBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm8uYDtcblx0fTtcblx0ZXhwb3J0cy5nZW5lcmF0ZU92ZXJyaWRlRXJyb3IgPSBnZW5lcmF0ZU92ZXJyaWRlRXJyb3I7XG5cdGNvbnN0IGdlbmVyYXRlT3ZlcnJpZGVXYXJuaW5nID0gKGZkYzNDbGllbnRBcGksIGJyb2tlckFwaSwgaWRlbnRpdHksIGludGVyb3BDbGllbnRBcGkpID0+IHtcblx0ICAgIGNvbnN0IHsgdXVpZCwgbmFtZSB9ID0gaWRlbnRpdHk7XG5cdCAgICBjb25zdCBtZXNzYWdlID0gaW50ZXJvcENsaWVudEFwaVxuXHQgICAgICAgID8gYEVudGl0eSB3aXRoIGlkZW50aXR5OiAke3V1aWR9LyR7bmFtZX0gaGFzIGNhbGxlZCAke2ludGVyb3BDbGllbnRBcGl9IG9yICR7ZmRjM0NsaWVudEFwaX0gYnV0ICR7YnJva2VyQXBpfSBoYXMgbm90IGJlZW4gb3ZlcnJpZGRlbi5gXG5cdCAgICAgICAgOiBgRW50aXR5IHdpdGggaWRlbnRpdHk6ICR7dXVpZH0vJHtuYW1lfSBoYXMgY2FsbGVkICR7ZmRjM0NsaWVudEFwaX0gYnV0ICR7YnJva2VyQXBpfSBoYXMgbm90IGJlZW4gb3ZlcnJpZGRlbi5gO1xuXHQgICAgcmV0dXJuIG1lc3NhZ2U7XG5cdH07XG5cdGV4cG9ydHMuZ2VuZXJhdGVPdmVycmlkZVdhcm5pbmcgPSBnZW5lcmF0ZU92ZXJyaWRlV2FybmluZztcblx0ZXhwb3J0cy5CUk9LRVJfRVJST1JTID0ge1xuXHQgICAgZmlyZUludGVudDogKDAsIGV4cG9ydHMuZ2VuZXJhdGVPdmVycmlkZUVycm9yKSgnZmlyZUludGVudCcsICdoYW5kbGVGaXJlZEludGVudCcpLFxuXHQgICAgZmlyZUludGVudEZvckNvbnRleHQ6ICgwLCBleHBvcnRzLmdlbmVyYXRlT3ZlcnJpZGVFcnJvcikoJ2ZpcmVJbnRlbnRGb3JDb250ZXh0JywgJ2hhbmRsZUZpcmVkSW50ZW50Rm9yQ29udGV4dCcpLFxuXHQgICAgZ2V0SW5mb0ZvckludGVudDogKDAsIGV4cG9ydHMuZ2VuZXJhdGVPdmVycmlkZUVycm9yKSgnZ2V0SW5mb0ZvckludGVudCcsICdoYW5kbGVJbmZvRm9ySW50ZW50JyksXG5cdCAgICBnZXRJbmZvRm9ySW50ZW50c0J5Q29udGV4dDogKDAsIGV4cG9ydHMuZ2VuZXJhdGVPdmVycmlkZUVycm9yKSgnZ2V0SW5mb0ZvckludGVudHNCeUNvbnRleHQnLCAnaGFuZGxlSW5mb0ZvckludGVudHNCeUNvbnRleHQnKSxcblx0ICAgIGpvaW5TZXNzaW9uQ29udGV4dEdyb3VwV2l0aEpvaW5Db250ZXh0R3JvdXA6ICdUaGUgQ29udGV4dCBHcm91cCB5b3UgaGF2ZSB0cmllZCB0byBqb2luIGlzIGEgU2Vzc2lvbiBDb250ZXh0IEdyb3VwLiBDdXN0b20gQ29udGV4dCBHcm91cHMgY2FuIG9ubHkgYmUgZGVmaW5lZCBieSB0aGUgSW50ZXJvcCBCcm9rZXIgdGhyb3VnaCBjb2RlIG9yIG1hbmlmZXN0IGNvbmZpZ3VyYXRpb24uIFBsZWFzZSB1c2Ugam9pblNlc3Npb25Db250ZXh0R3JvdXAuJyxcblx0ICAgIGZkYzNPcGVuOiAoMCwgZXhwb3J0cy5nZW5lcmF0ZU92ZXJyaWRlRXJyb3IpKCdmZGMzLm9wZW4nLCAnZmRjM0hhbmRsZU9wZW4nKSxcblx0ICAgIGZkYzNGaW5kSW5zdGFuY2VzOiAoMCwgZXhwb3J0cy5nZW5lcmF0ZU92ZXJyaWRlRXJyb3IpKCdmZGMzLmZpbmRJbnN0YW5jZXMnLCAnZmRjM0hhbmRsZUZpbmRJbnN0YW5jZXMnKSxcblx0ICAgIGZkYzNHZXRBcHBNZXRhZGF0YTogKDAsIGV4cG9ydHMuZ2VuZXJhdGVPdmVycmlkZUVycm9yKSgnZmRjMy5nZXRBcHBNZXRhZGF0YScsICdmZGMzSGFuZGxlR2V0QXBwTWV0YWRhdGEnKSxcblx0ICAgIGZkYzNHZXRJbmZvOiAoMCwgZXhwb3J0cy5nZW5lcmF0ZU92ZXJyaWRlRXJyb3IpKCdmZGMzLmdldEluZm8nLCAnZmRjM0hhbmRsZUdldEluZm8nKVxuXHR9O1xuXHRjb25zdCB3cmFwSW50ZW50SGFuZGxlciA9IChoYW5kbGVyLCBoYW5kbGVySWQpID0+IHtcblx0ICAgIHJldHVybiBhc3luYyAoaW50ZW50KSA9PiB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoaW50ZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHRocm93biBieSBoYW5kbGVyICR7aGFuZGxlcklkfTogJHtlcnJvcn1gKTtcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fTtcblx0ZXhwb3J0cy53cmFwSW50ZW50SGFuZGxlciA9IHdyYXBJbnRlbnRIYW5kbGVyOyBcbn0gKHV0aWxzJDEpKTtcblxudmFyIFByaXZhdGVDaGFubmVsUHJvdmlkZXIgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkUHJpdmF0ZUNoYW5uZWxQcm92aWRlcjtcblxuZnVuY3Rpb24gcmVxdWlyZVByaXZhdGVDaGFubmVsUHJvdmlkZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRQcml2YXRlQ2hhbm5lbFByb3ZpZGVyKSByZXR1cm4gUHJpdmF0ZUNoYW5uZWxQcm92aWRlcjtcblx0aGFzUmVxdWlyZWRQcml2YXRlQ2hhbm5lbFByb3ZpZGVyID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXZhdGVDaGFubmVsUHJvdmlkZXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRQcml2YXRlQ2hhbm5lbFByb3ZpZGVyLlByaXZhdGVDaGFubmVsUHJvdmlkZXIgPSB2b2lkIDA7XG5cdGNvbnN0IEludGVyb3BCcm9rZXJfMSA9IHJlcXVpcmVJbnRlcm9wQnJva2VyKCk7XG5cdGxldCBQcml2YXRlQ2hhbm5lbFByb3ZpZGVyJDEgPSBjbGFzcyBQcml2YXRlQ2hhbm5lbFByb3ZpZGVyIHtcblx0ICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBpZCkge1xuXHQgICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XG5cdCAgICAgICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHRCeUNvbnRleHRUeXBlID0gbmV3IE1hcCgpO1xuXHQgICAgICAgIHRoaXMubGFzdENvbnRleHQgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5wcm92aWRlci5vbkNvbm5lY3Rpb24oKGNsaWVudElkZW50aXR5KSA9PiB0aGlzLnJlZ2lzdGVyTmV3Q2xpZW50KGNsaWVudElkZW50aXR5KSk7XG5cdCAgICAgICAgdGhpcy5wcm92aWRlci5vbkRpc2Nvbm5lY3Rpb24oYXN5bmMgKGNsaWVudElkZW50aXR5KSA9PiB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgZW5kcG9pbnRJZCB9ID0gY2xpZW50SWRlbnRpdHk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudHMuaGFzKGVuZHBvaW50SWQpKSB7XG5cdCAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZUNsaWVudERpc2Nvbm5lY3RpbmcoY2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICgoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRBbGxDbGllbnRJbmZvKCkpLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5kZXN0cm95KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGdldENsaWVudFN0YXRlKGlkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50cy5nZXQoaWQuZW5kcG9pbnRJZCk7XG5cdCAgICB9XG5cdCAgICByZWdpc3Rlckxpc3RlbmVycygpIHtcblx0ICAgICAgICB0aGlzLnByb3ZpZGVyLnJlZ2lzdGVyKCdicm9hZGNhc3QnLCB0aGlzLmJyb2FkY2FzdC5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLnByb3ZpZGVyLnJlZ2lzdGVyKCdnZXRDdXJyZW50Q29udGV4dCcsIHRoaXMuZ2V0Q3VycmVudENvbnRleHQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5wcm92aWRlci5yZWdpc3RlcignY29udGV4dEhhbmRsZXJBZGRlZCcsIHRoaXMuY29udGV4dEhhbmRsZXJBZGRlZC5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLnByb3ZpZGVyLnJlZ2lzdGVyKCdjb250ZXh0SGFuZGxlclJlbW92ZWQnLCB0aGlzLmNvbnRleHRIYW5kbGVyUmVtb3ZlZC5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLnByb3ZpZGVyLnJlZ2lzdGVyKCdub25TdGFuZGFyZEhhbmRsZXJSZW1vdmVkJywgdGhpcy5ub25TdGFuZGFyZEhhbmRsZXJSZW1vdmVkLmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMucHJvdmlkZXIucmVnaXN0ZXIoJ29uQWRkQ29udGV4dEhhbmRsZXJBZGRlZCcsIHRoaXMub25BZGRDb250ZXh0SGFuZGxlckFkZGVkLmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMucHJvdmlkZXIucmVnaXN0ZXIoJ29uRGlzY29ubmVjdEhhbmRsZXJBZGRlZCcsIHRoaXMub25EaXNjb25uZWN0SGFuZGxlckFkZGVkLmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMucHJvdmlkZXIucmVnaXN0ZXIoJ29uVW5zdWJzY3JpYmVIYW5kbGVyQWRkZWQnLCB0aGlzLm9uVW5zdWJzY3JpYmVIYW5kbGVyQWRkZWQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5wcm92aWRlci5yZWdpc3RlcignY2xpZW50RGlzY29ubmVjdGluZycsIChwYXlsb2FkLCBjbGllbnRJZGVudGl0eSkgPT4ge1xuXHQgICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWVudERpc2Nvbm5lY3RpbmcoY2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgYnJvYWRjYXN0KHBheWxvYWQsIGJyb2FkY2FzdGVyQ2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHBheWxvYWQ7XG5cdCAgICAgICAgY29uc3QgYnJvYWRjYXN0ZXJDbGllbnRTdGF0ZSA9IHRoaXMuZ2V0Q2xpZW50U3RhdGUoYnJvYWRjYXN0ZXJDbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKCFicm9hZGNhc3RlckNsaWVudFN0YXRlKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IHdpdGggSWRlbnRpdHk6ICR7YnJvYWRjYXN0ZXJDbGllbnRJZGVudGl0eS51dWlkfSAke2Jyb2FkY2FzdGVyQ2xpZW50SWRlbnRpdHkubmFtZX0sIHRyaWVkIHRvIGNhbGwgYnJvYWRjYXN0LCBpcyBub3QgY29ubmVjdGVkIHRvIHRoaXMgUHJpdmF0ZSBDaGFubmVsYCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnN0IGNvbnRleHRJbnRlZ3JpdHlDaGVja1Jlc3VsdCA9IEludGVyb3BCcm9rZXJfMS5JbnRlcm9wQnJva2VyLmNoZWNrQ29udGV4dEludGVncml0eShjb250ZXh0KTtcblx0ICAgICAgICBpZiAoY29udGV4dEludGVncml0eUNoZWNrUmVzdWx0LmlzVmFsaWQgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGJyb2FkY2FzdCAtIGJhZCBDb250ZXh0LiBSZWFzb246ICR7Y29udGV4dEludGVncml0eUNoZWNrUmVzdWx0LnJlYXNvbn0uIENvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCl9YCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29udGV4dEJ5Q29udGV4dFR5cGUuc2V0KGNvbnRleHQudHlwZSwgY29udGV4dCk7XG5cdCAgICAgICAgdGhpcy5sYXN0Q29udGV4dCA9IGNvbnRleHQ7XG5cdCAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmNsaWVudHMudmFsdWVzKCkpLmZvckVhY2goKGN1cnJDbGllbnRTdGF0ZSkgPT4ge1xuXHQgICAgICAgICAgICBjb25zdCBoYW5kbGVySWRzRm9yQ29udGV4dFR5cGUgPSBjdXJyQ2xpZW50U3RhdGUuaGFuZGxlcklkc0J5Q29udGV4dFR5cGVzLmdldChjb250ZXh0LnR5cGUpO1xuXHQgICAgICAgICAgICBpZiAoaGFuZGxlcklkc0ZvckNvbnRleHRUeXBlKSB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVySWRzRm9yQ29udGV4dFR5cGUuZm9yRWFjaCgoaGFuZGxlcklkKSA9PiB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5kaXNwYXRjaChjdXJyQ2xpZW50U3RhdGUuY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY3VyckNsaWVudFN0YXRlLmdsb2JhbEhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuZGlzcGF0Y2goY3VyckNsaWVudFN0YXRlLmNsaWVudElkZW50aXR5LCBjdXJyQ2xpZW50U3RhdGUuZ2xvYmFsSGFuZGxlciwgY29udGV4dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGdldEN1cnJlbnRDb250ZXh0KHBheWxvYWQsIHNlbmRlckNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgY29uc3QgeyBjb250ZXh0VHlwZSB9ID0gcGF5bG9hZDtcblx0ICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZ2V0Q2xpZW50U3RhdGUoc2VuZGVyQ2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgIGlmICghY2xpZW50U3RhdGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgd2l0aCBJZGVudGl0eTogJHtzZW5kZXJDbGllbnRJZGVudGl0eS51dWlkfSAke3NlbmRlckNsaWVudElkZW50aXR5Lm5hbWV9LCB0cmllZCB0byBjYWxsIGdldEN1cnJlbnRDb250ZXh0LCBpcyBub3QgY29ubmVjdGVkIHRvIHRoaXMgUHJpdmF0ZSBDaGFubmVsYCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0gdGhpcy5jb250ZXh0QnlDb250ZXh0VHlwZS5nZXQoY29udGV4dFR5cGUpO1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudENvbnRleHQpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29udGV4dCA/IHRoaXMubGFzdENvbnRleHQgOiBudWxsO1xuXHQgICAgfVxuXHQgICAgY29udGV4dEhhbmRsZXJBZGRlZChwYXlsb2FkLCBzZW5kZXJDbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIGNvbnN0IHsgaGFuZGxlcklkLCBjb250ZXh0VHlwZSB9ID0gcGF5bG9hZDtcblx0ICAgICAgICBjb25zdCBzZW5kZXJDbGllbnRTdGF0ZSA9IHRoaXMuZ2V0Q2xpZW50U3RhdGUoc2VuZGVyQ2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgIGlmICghc2VuZGVyQ2xpZW50U3RhdGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgd2l0aCBJZGVudGl0eTogJHtzZW5kZXJDbGllbnRJZGVudGl0eS51dWlkfSAke3NlbmRlckNsaWVudElkZW50aXR5Lm5hbWV9LCB0cmllZCB0byBjYWxsIGFkZENvbnRleHRMaXN0ZW5lciwgaXMgbm90IGNvbm5lY3RlZCB0byB0aGlzIFByaXZhdGUgQ2hhbm5lbGApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29udGV4dFR5cGUpIHtcblx0ICAgICAgICAgICAgY29uc3QgY3VycmVudEhhbmRsZXJzTGlzdCA9IHNlbmRlckNsaWVudFN0YXRlLmhhbmRsZXJJZHNCeUNvbnRleHRUeXBlcy5nZXQoY29udGV4dFR5cGUpIHx8IFtdO1xuXHQgICAgICAgICAgICBzZW5kZXJDbGllbnRTdGF0ZS5oYW5kbGVySWRzQnlDb250ZXh0VHlwZXMuc2V0KGNvbnRleHRUeXBlLCBbLi4uY3VycmVudEhhbmRsZXJzTGlzdCwgaGFuZGxlcklkXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBzZW5kZXJDbGllbnRTdGF0ZS5nbG9iYWxIYW5kbGVyID0gaGFuZGxlcklkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBBcnJheS5mcm9tKHRoaXMuY2xpZW50cy52YWx1ZXMoKSkuZm9yRWFjaCgoY3VyckNsaWVudFN0YXRlKSA9PiB7XG5cdCAgICAgICAgICAgIGlmIChjdXJyQ2xpZW50U3RhdGUuY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCAhPT0gc2VuZGVyQ2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCAmJlxuXHQgICAgICAgICAgICAgICAgY3VyckNsaWVudFN0YXRlLm9uQWRkQ29udGV4dExpc3RlbmVySGFuZGxlcklkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLmRpc3BhdGNoKGN1cnJDbGllbnRTdGF0ZS5jbGllbnRJZGVudGl0eSwgY3VyckNsaWVudFN0YXRlLm9uQWRkQ29udGV4dExpc3RlbmVySGFuZGxlcklkLCBjb250ZXh0VHlwZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGFzeW5jIGNvbnRleHRIYW5kbGVyUmVtb3ZlZChwYXlsb2FkLCByZW1vdmluZ0NsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgLy8gTUM6IE1hZGUgdGhpcyByZW1vdmFsIGFzeW5jIHRvIGVuc3VyZSB0aGF0IG9uVW5zdWJzY3JpYmUgaGFuZGxlcnMgYXJlIGhpdCBiZWZvcmUgYW55dGhpbmcgZWxzZSBoYXBwZW5zLlxuXHQgICAgICAgIGNvbnN0IHsgaGFuZGxlcklkIH0gPSBwYXlsb2FkO1xuXHQgICAgICAgIGNvbnN0IHJlbW92aW5nQ2xpZW50U3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKHJlbW92aW5nQ2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgIGlmIChyZW1vdmluZ0NsaWVudFN0YXRlKSB7XG5cdCAgICAgICAgICAgIGxldCBjb250ZXh0VHlwZTtcblx0ICAgICAgICAgICAgaWYgKHJlbW92aW5nQ2xpZW50U3RhdGUuZ2xvYmFsSGFuZGxlciA9PT0gaGFuZGxlcklkKSB7XG5cdCAgICAgICAgICAgICAgICByZW1vdmluZ0NsaWVudFN0YXRlLmdsb2JhbEhhbmRsZXIgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjdXJyQ29udGV4dFR5cGUsIGhhbmRsZXJzSWRzXSBvZiByZW1vdmluZ0NsaWVudFN0YXRlLmhhbmRsZXJJZHNCeUNvbnRleHRUeXBlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaGFuZGxlcnNJZHMuaW5kZXhPZihoYW5kbGVySWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzSWRzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRUeXBlID0gY3VyckNvbnRleHRUeXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBnZXR0aW5nIG9ubHkgdmFsaWQgY2xpZW50IGNvbm5lY3Rpb25zIGhlcmUsIGl0IGlzIHBvc3NpYmxlIHdlIGhhdmVuJ3QgcmVtb3ZlZCBhIGRpc2Nvbm5lY3RlZCBjbGllbnQgZnJvbSB0aGUgbWFwIHlldFxuXHQgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSB3ZSBkb24ndCBkaXNwYXRjaCB0byBhbnkgZGlzY29ubmVjdGVkIGNsaWVudFxuXHQgICAgICAgICAgICAvLyBUT0RPOiBUYWtlIGEgbG9vayBhdCBvdXIgY2xpZW50IGRpc2Nvbm5lY3Rpb24gbG9naWMgYW5kIHNlZSBpZiB3ZSBjYW4gaGFuZGxlIGNsaWVudCBkaXNjb25uZWN0aW9uIGNsZWFubHlcblx0ICAgICAgICAgICAgY29uc3QgY2xpZW50c1RvRGlzcGF0Y2hUbyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkQ2xpZW50cygpO1xuXHQgICAgICAgICAgICBjb25zdCBkaXNwYXRjaFByb21pc2VzID0gY2xpZW50c1RvRGlzcGF0Y2hUby5tYXAoYXN5bmMgKG90aGVyQ2xpZW50U3RhdGUpID0+IHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50SWRlbnRpdHksIGNsaWVudElkZW50aXR5OiB7IGVuZHBvaW50SWQgfSwgb25VbnN1YnNjcmliZUhhbmRsZXJJZCB9ID0gb3RoZXJDbGllbnRTdGF0ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludElkICE9PSByZW1vdmluZ0NsaWVudElkZW50aXR5LmVuZHBvaW50SWQgJiYgb25VbnN1YnNjcmliZUhhbmRsZXJJZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZGlzcGF0Y2goY2xpZW50SWRlbnRpdHksIG9uVW5zdWJzY3JpYmVIYW5kbGVySWQsIGNvbnRleHRUeXBlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChkaXNwYXRjaFByb21pc2VzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFByb2JsZW0gd2hlbiBhdHRlbXB0aW5nIHRvIGRpc3BhdGNoIHRvIG9uVW5zdWJzY3JpYmVIYW5kbGVycy4gRXJyb3I6ICR7ZXJyb3J9IFJlbW92aW5nIENsaWVudDogJHtoYW5kbGVySWR9LiB1dWlkOiAke3JlbW92aW5nQ2xpZW50SWRlbnRpdHkudXVpZH0uIG5hbWU6ICR7cmVtb3ZpbmdDbGllbnRJZGVudGl0eS5uYW1lfS4gZW5kcG9pbnRJZDogJHtyZW1vdmluZ0NsaWVudElkZW50aXR5LmVuZHBvaW50SWR9YCk7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyeWluZyB0byByZW1vdmUgYSBoYW5kbGVyIGZyb20gYSBjbGllbnQgdGhhdCBpc24ndCBtYXBwZWQuIGhhbmRsZXJJZDogJHtoYW5kbGVySWR9LiB1dWlkOiAke3JlbW92aW5nQ2xpZW50SWRlbnRpdHkudXVpZH0uIG5hbWU6ICR7cmVtb3ZpbmdDbGllbnRJZGVudGl0eS5uYW1lfS4gZW5kcG9pbnRJZDogJHtyZW1vdmluZ0NsaWVudElkZW50aXR5LmVuZHBvaW50SWR9LmApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIG5vblN0YW5kYXJkSGFuZGxlclJlbW92ZWQocGF5bG9hZCwgaWQpIHtcblx0ICAgICAgICBjb25zdCB7IGhhbmRsZXJJZCB9ID0gcGF5bG9hZDtcblx0ICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZ2V0Q2xpZW50U3RhdGUoaWQpO1xuXHQgICAgICAgIGlmIChjbGllbnRTdGF0ZSkge1xuXHQgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUub25EaXNjb25uZWN0SGFuZGxlcklkID09PSBoYW5kbGVySWQpIHtcblx0ICAgICAgICAgICAgICAgIGNsaWVudFN0YXRlLm9uRGlzY29ubmVjdEhhbmRsZXJJZCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjbGllbnRTdGF0ZS5vbkFkZENvbnRleHRMaXN0ZW5lckhhbmRsZXJJZCA9PT0gaGFuZGxlcklkKSB7XG5cdCAgICAgICAgICAgICAgICBjbGllbnRTdGF0ZS5vbkFkZENvbnRleHRMaXN0ZW5lckhhbmRsZXJJZCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjbGllbnRTdGF0ZS5vblVuc3Vic2NyaWJlSGFuZGxlcklkID09PSBoYW5kbGVySWQpIHtcblx0ICAgICAgICAgICAgICAgIGNsaWVudFN0YXRlLm9uVW5zdWJzY3JpYmVIYW5kbGVySWQgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUud2FybihgVHJ5aW5nIHRvIHJlbW92ZSBhIGhhbmRsZXIgZnJvbSBhIGNsaWVudCB0aGF0IGlzbid0IG1hcHBlZC4gaGFuZGxlcklkOiAke2hhbmRsZXJJZH0uIGNsaWVudElkZW50aXR5OiAke2lkfWApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIG9uQWRkQ29udGV4dEhhbmRsZXJBZGRlZChwYXlsb2FkLCBzZW5kZXJDbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShzZW5kZXJDbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgY29uc3QgeyBoYW5kbGVySWQgfSA9IHBheWxvYWQ7XG5cdCAgICAgICAgaWYgKCFjbGllbnRTdGF0ZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCB3aXRoIElkZW50aXR5OiAke3NlbmRlckNsaWVudElkZW50aXR5LnV1aWR9ICR7c2VuZGVyQ2xpZW50SWRlbnRpdHkubmFtZX0sIHRyaWVkIHRvIGNhbGwgb25BZGRDb250ZXh0TGlzdGVuZXIsIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhpcyBQcml2YXRlIENoYW5uZWxgKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2xpZW50U3RhdGUub25BZGRDb250ZXh0TGlzdGVuZXJIYW5kbGVySWQgPSBoYW5kbGVySWQ7XG5cdCAgICAgICAgLy8gRkRDMyBTcGVjIHNheXMgdGhhdCB0aGUgYWRkZWQgbGlzdGVuZXIgc2hvdWxkIGZpcmUgZm9yIGFsbCBwcmV2aW91c2x5LXJlZ2lzdGVyZWQgYWRkQ29udGV4dExpc3RlbmVycyBmcm9tIHRoZSBvdGhlciBjbGllbnRcblx0ICAgICAgICBBcnJheS5mcm9tKHRoaXMuY2xpZW50cy52YWx1ZXMoKSkuZm9yRWFjaCgob3RoZXJDbGllbnRTdGF0ZSkgPT4ge1xuXHQgICAgICAgICAgICBpZiAob3RoZXJDbGllbnRTdGF0ZS5jbGllbnRJZGVudGl0eS5lbmRwb2ludElkICE9PSBzZW5kZXJDbGllbnRJZGVudGl0eS5lbmRwb2ludElkKSB7XG5cdCAgICAgICAgICAgICAgICBBcnJheS5mcm9tKG90aGVyQ2xpZW50U3RhdGUuaGFuZGxlcklkc0J5Q29udGV4dFR5cGVzLmtleXMoKSkuZm9yRWFjaCgoc3Vic2NyaWJlZENvbnRleHRUeXBlKSA9PiB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5kaXNwYXRjaChzZW5kZXJDbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBzdWJzY3JpYmVkQ29udGV4dFR5cGUpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIG9uRGlzY29ubmVjdEhhbmRsZXJBZGRlZChwYXlsb2FkLCBpZCkge1xuXHQgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShpZCk7XG5cdCAgICAgICAgY29uc3QgeyBoYW5kbGVySWQgfSA9IHBheWxvYWQ7XG5cdCAgICAgICAgaWYgKCFjbGllbnRTdGF0ZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCB3aXRoIElkZW50aXR5OiAke2lkLnV1aWR9ICR7aWQubmFtZX0sIHRyaWVkIHRvIGNhbGwgb25EaXNjb25uZWN0LCBpcyBub3QgY29ubmVjdGVkIHRvIHRoaXMgUHJpdmF0ZSBDaGFubmVsYCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNsaWVudFN0YXRlLm9uRGlzY29ubmVjdEhhbmRsZXJJZCA9IGhhbmRsZXJJZDtcblx0ICAgIH1cblx0ICAgIG9uVW5zdWJzY3JpYmVIYW5kbGVyQWRkZWQocGF5bG9hZCwgaWQpIHtcblx0ICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZ2V0Q2xpZW50U3RhdGUoaWQpO1xuXHQgICAgICAgIGNvbnN0IHsgaGFuZGxlcklkIH0gPSBwYXlsb2FkO1xuXHQgICAgICAgIGlmICghY2xpZW50U3RhdGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgd2l0aCBJZGVudGl0eTogJHtpZC51dWlkfSAke2lkLm5hbWV9LCB0cmllZCB0byBjYWxsIG9uVW5zdWJzY3JpYmUsIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhpcyBQcml2YXRlIENoYW5uZWxgKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2xpZW50U3RhdGUub25VbnN1YnNjcmliZUhhbmRsZXJJZCA9IGhhbmRsZXJJZDtcblx0ICAgIH1cblx0ICAgIHJlbW92ZUNsaWVudChkaXNjb25uZWN0aW5nQ2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBjb25zdCBkaXNjb25uZWN0aW5nQ2xpZW50U3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKGRpc2Nvbm5lY3RpbmdDbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKCFkaXNjb25uZWN0aW5nQ2xpZW50U3RhdGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgd2l0aCBJZGVudGl0eTogJHtkaXNjb25uZWN0aW5nQ2xpZW50SWRlbnRpdHkudXVpZH0gJHtkaXNjb25uZWN0aW5nQ2xpZW50SWRlbnRpdHkubmFtZX0sIHRyaWVkIHRvIGNhbGwgZGlzY29ubmVjdCwgaXMgbm90IGNvbm5lY3RlZCB0byB0aGlzIFByaXZhdGUgQ2hhbm5lbGApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkaXNjb25uZWN0aW5nQ2xpZW50U3RhdGUuaGFuZGxlcklkc0J5Q29udGV4dFR5cGVzLmNsZWFyKCk7XG5cdCAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZShkaXNjb25uZWN0aW5nQ2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCk7XG5cdCAgICB9XG5cdCAgICBhc3luYyBmaXJlT25EaXNjb25uZWN0Rm9yT3RoZXJDbGllbnRzKGRpc2Nvbm5lY3RpbmdDbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIC8vIFRPRE86IGNhbGwgb25EaXNjb25uZWN0IEhhbmRsZXIgb2YgdGhlIG90aGVyIGNsaWVudCBvbmx5LlxuXHQgICAgICAgIC8vIENVUlJFTlRMWSwganVzdCBjYWxsaW5nIHRoZSBvbkRpc2Nvbm5lY3QgaGFuZGxlciBmb3IgYWxsIHRoZSBvdGhlciBjbGllbnRzLiBPbmNlIHdlIGxpbWl0IGl0IHRvIGp1c3Qgb25lIG90aGVyIGNsaWVudCwgd2UgY2FuIGVsaW1pbmF0ZSBhbGwgdGhlIGl0ZXJhdGlvbiBjb2RlLlxuXHQgICAgICAgIGNvbnN0IHsgZW5kcG9pbnRJZCB9ID0gZGlzY29ubmVjdGluZ0NsaWVudElkZW50aXR5O1xuXHQgICAgICAgIC8vIGdldHRpbmcgb25seSB2YWxpZCBjbGllbnQgY29ubmVjdGlvbnMgaGVyZSwgaXQgaXMgcG9zc2libGUgd2UgaGF2ZW4ndCByZW1vdmVkIGEgZGlzY29ubmVjdGVkIGNsaWVudCBmcm9tIHRoZSBtYXAgeWV0XG5cdCAgICAgICAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgd2UgZG9uJ3QgZGlzcGF0Y2ggdG8gYW55IGRpc2Nvbm5lY3RlZCBjbGllbnRcblx0ICAgICAgICAvLyBUT0RPOiBUYWtlIGEgbG9vayBhdCBvdXIgY2xpZW50IGRpc2Nvbm5lY3Rpb24gbG9naWMgYW5kIHNlZSBpZiB3ZSBjYW4gaGFuZGxlIGNsaWVudCBkaXNjb25uZWN0aW9uIGNsZWFubHlcblx0ICAgICAgICBjb25zdCBjbGllbnRzVG9EaXNwYXRjaFRvID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWRDbGllbnRzKCk7XG5cdCAgICAgICAgY29uc3QgZGlzcGF0Y2hQcm9taXNlcyA9IGNsaWVudHNUb0Rpc3BhdGNoVG8ubWFwKGFzeW5jIChvdGhlckNsaWVudFN0YXRlKSA9PiB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50SWRlbnRpdHk6IHsgZW5kcG9pbnRJZDogb3RoZXJDbGllbnRFbmRwb2ludElkIH0sIG9uRGlzY29ubmVjdEhhbmRsZXJJZCB9ID0gb3RoZXJDbGllbnRTdGF0ZTtcblx0ICAgICAgICAgICAgaWYgKG90aGVyQ2xpZW50RW5kcG9pbnRJZCAhPT0gZW5kcG9pbnRJZCAmJiBvbkRpc2Nvbm5lY3RIYW5kbGVySWQpIHtcblx0ICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZGlzcGF0Y2gob3RoZXJDbGllbnRTdGF0ZS5jbGllbnRJZGVudGl0eSwgb25EaXNjb25uZWN0SGFuZGxlcklkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGRpc3BhdGNoUHJvbWlzZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJvYmxlbSB3aGVuIGF0dGVtcHRpbmcgdG8gZGlzcGF0Y2ggdG8gb25EaXNjb25uZWN0SGFuZGxlcnMuIEVycm9yOiAke2Vycm9yfSBEaXNjb25uZWN0aW5nIENsaWVudDogdXVpZDogJHtkaXNjb25uZWN0aW5nQ2xpZW50SWRlbnRpdHkudXVpZH0uIG5hbWU6ICR7ZGlzY29ubmVjdGluZ0NsaWVudElkZW50aXR5Lm5hbWV9LiBlbmRwb2ludElkOiAke2Rpc2Nvbm5lY3RpbmdDbGllbnRJZGVudGl0eS5lbmRwb2ludElkfWApO1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGFzeW5jIHVuc3Vic2NyaWJlQWxsKGNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgY29uc3QgeyBlbmRwb2ludElkIH0gPSBjbGllbnRJZGVudGl0eTtcblx0ICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY2xpZW50cy5nZXQoZW5kcG9pbnRJZCk7XG5cdCAgICAgICAgaWYgKHN0YXRlKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IGNvbnRleHRUeXBlSGFuZGxlcklkcyA9IEFycmF5LmZyb20oc3RhdGUuaGFuZGxlcklkc0J5Q29udGV4dFR5cGVzLnZhbHVlcygpKS5mbGF0KCk7XG5cdCAgICAgICAgICAgIGNvbnN0IGdsb2JhbEhhbmRsZXJJZCA9IHN0YXRlLmdsb2JhbEhhbmRsZXI7XG5cdCAgICAgICAgICAgIGlmIChjb250ZXh0VHlwZUhhbmRsZXJJZHMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgdW5zdWJQcm9taXNlcyA9IGNvbnRleHRUeXBlSGFuZGxlcklkcy5tYXAoYXN5bmMgKGhhbmRsZXJJZCkgPT4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRIYW5kbGVyUmVtb3ZlZCh7IGhhbmRsZXJJZCB9LCBjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodW5zdWJQcm9taXNlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChnbG9iYWxIYW5kbGVySWQpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb250ZXh0SGFuZGxlclJlbW92ZWQoeyBoYW5kbGVySWQ6IGdsb2JhbEhhbmRsZXJJZCB9LCBjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgYXN5bmMgaGFuZGxlQ2xpZW50RGlzY29ubmVjdGluZyhkaXNjb25uZWN0aW5nQ2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQWxsKGRpc2Nvbm5lY3RpbmdDbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgdGhpcy5yZW1vdmVDbGllbnQoZGlzY29ubmVjdGluZ0NsaWVudElkZW50aXR5KTtcblx0ICAgICAgICBhd2FpdCB0aGlzLmZpcmVPbkRpc2Nvbm5lY3RGb3JPdGhlckNsaWVudHMoZGlzY29ubmVjdGluZ0NsaWVudElkZW50aXR5KTtcblx0ICAgIH1cblx0ICAgIHJlZ2lzdGVyTmV3Q2xpZW50KGNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuaGFzKGNsaWVudElkZW50aXR5LmVuZHBvaW50SWQpKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvblN0YXRlID0ge1xuXHQgICAgICAgICAgICAgICAgY2xpZW50SWRlbnRpdHksXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVySWRzQnlDb250ZXh0VHlwZXM6IG5ldyBNYXAoKSxcblx0ICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZXI6IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgICAgIG9uQWRkQ29udGV4dExpc3RlbmVySGFuZGxlcklkOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgICAgICBvblVuc3Vic2NyaWJlSGFuZGxlcklkOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3RIYW5kbGVySWQ6IHVuZGVmaW5lZFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB0aGlzLmNsaWVudHMuc2V0KGNsaWVudElkZW50aXR5LmVuZHBvaW50SWQsIGNsaWVudFN1YnNjcmlwdGlvblN0YXRlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBhc3luYyBnZXRDb25uZWN0ZWRDbGllbnRzKCkge1xuXHQgICAgICAgIGNvbnN0IGFsbENsaWVudEluZm8gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEFsbENsaWVudEluZm8oKTtcblx0ICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNsaWVudHMudmFsdWVzKCkpLmZpbHRlcigoY2xpZW50U3RhdGUpID0+IHtcblx0ICAgICAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSBjbGllbnRTdGF0ZS5jbGllbnRJZGVudGl0eTtcblx0ICAgICAgICAgICAgcmV0dXJuIGFsbENsaWVudEluZm8uc29tZSgoY2xpZW50SW5mbykgPT4ge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IGNsaWVudEluZm8ubmFtZSAmJiB1dWlkID09PSBjbGllbnRJbmZvLnV1aWQ7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgc3RhdGljIGluaXQoY2hhbm5lbFByb3ZpZGVyLCBpZCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUNoYW5uZWxQcm92aWRlcihjaGFubmVsUHJvdmlkZXIsIGlkKTtcblx0ICAgIH1cblx0fTtcblx0UHJpdmF0ZUNoYW5uZWxQcm92aWRlci5Qcml2YXRlQ2hhbm5lbFByb3ZpZGVyID0gUHJpdmF0ZUNoYW5uZWxQcm92aWRlciQxO1xuXHRyZXR1cm4gUHJpdmF0ZUNoYW5uZWxQcm92aWRlcjtcbn1cblxudmFyIGhhc1JlcXVpcmVkSW50ZXJvcEJyb2tlcjtcblxuZnVuY3Rpb24gcmVxdWlyZUludGVyb3BCcm9rZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbnRlcm9wQnJva2VyKSByZXR1cm4gSW50ZXJvcEJyb2tlcjtcblx0aGFzUmVxdWlyZWRJbnRlcm9wQnJva2VyID0gMTtcblx0dmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcblx0ICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcblx0ICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcblx0ICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG5cdCAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcblx0fTtcblx0dmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuXHQgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuXHQgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG5cdCAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xuXHR9O1xuXHR2YXIgX0ludGVyb3BCcm9rZXJfZmRjM0luZm8sIF9JbnRlcm9wQnJva2VyX2NvbnRleHRHcm91cHM7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcm9wQnJva2VyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0SW50ZXJvcEJyb2tlci5JbnRlcm9wQnJva2VyID0gdm9pZCAwO1xuXHRjb25zdCBiYXNlXzEgPSBiYXNlO1xuXHRjb25zdCBTZXNzaW9uQ29udGV4dEdyb3VwQnJva2VyXzEgPSByZXF1aXJlU2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlcigpO1xuXHRjb25zdCB1dGlsc18xID0gdXRpbHMkMTtcblx0Y29uc3QgbG9kYXNoXzEgPSByZXF1aXJlJCQzO1xuXHRjb25zdCBQcml2YXRlQ2hhbm5lbFByb3ZpZGVyXzEgPSByZXF1aXJlUHJpdmF0ZUNoYW5uZWxQcm92aWRlcigpO1xuXHRjb25zdCBkZWZhdWx0Q29udGV4dEdyb3VwcyA9IFtcblx0ICAgIHtcblx0ICAgICAgICBpZDogJ2dyZWVuJyxcblx0ICAgICAgICBkaXNwbGF5TWV0YWRhdGE6IHtcblx0ICAgICAgICAgICAgY29sb3I6ICcjMDBDQzg4Jyxcblx0ICAgICAgICAgICAgbmFtZTogJ2dyZWVuJ1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB7XG5cdCAgICAgICAgaWQ6ICdwdXJwbGUnLFxuXHQgICAgICAgIGRpc3BsYXlNZXRhZGF0YToge1xuXHQgICAgICAgICAgICBjb2xvcjogJyM4QzYxRkYnLFxuXHQgICAgICAgICAgICBuYW1lOiAncHVycGxlJ1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB7XG5cdCAgICAgICAgaWQ6ICdvcmFuZ2UnLFxuXHQgICAgICAgIGRpc3BsYXlNZXRhZGF0YToge1xuXHQgICAgICAgICAgICBjb2xvcjogJyNGRjhDNEMnLFxuXHQgICAgICAgICAgICBuYW1lOiAnb3JhbmdlJ1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB7XG5cdCAgICAgICAgaWQ6ICdyZWQnLFxuXHQgICAgICAgIGRpc3BsYXlNZXRhZGF0YToge1xuXHQgICAgICAgICAgICBjb2xvcjogJyNGRjVFNjAnLFxuXHQgICAgICAgICAgICBuYW1lOiAncmVkJ1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB7XG5cdCAgICAgICAgaWQ6ICdwaW5rJyxcblx0ICAgICAgICBkaXNwbGF5TWV0YWRhdGE6IHtcblx0ICAgICAgICAgICAgY29sb3I6ICcjRkY4RkI4Jyxcblx0ICAgICAgICAgICAgbmFtZTogJ3BpbmsnXG5cdCAgICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHtcblx0ICAgICAgICBpZDogJ3llbGxvdycsXG5cdCAgICAgICAgZGlzcGxheU1ldGFkYXRhOiB7XG5cdCAgICAgICAgICAgIGNvbG9yOiAnI0U5RkY4RicsXG5cdCAgICAgICAgICAgIG5hbWU6ICd5ZWxsb3cnXG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRdO1xuXHQvKipcblx0ICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL29mLWRvY3MvZG9jcy9lbmFibGUtY29sb3ItbGlua2luZ31cblx0ICpcblx0ICogVGhlIEludGVyb3AgQnJva2VyIGlzIHJlc3BvbnNpYmxlIGZvciBrZWVwaW5nIHRyYWNrIG9mIHRoZSBJbnRlcm9wIHN0YXRlIG9mIHRoZSBQbGF0Zm9ybSwgYW5kIGZvciBkaXJlY3RpbmcgbWVzc2FnZXMgdG8gdGhlIHByb3BlciBsb2NhdGlvbnMuXG5cdCAqXG5cdCAqIEByZW1hcmtzIFRoaXMgY2xhc3MgY29udGFpbnMgc29tZSB0eXBlcyByZWxhdGVkIHRvIEZEQzMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gT3BlbkZpbi4ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL29mLWRvY3MvZG9jcy9mZGMzLXN1cHBvcnQtaW4tb3BlbmZpbiBPcGVuRmluJ3MgRkRDMyBzdXBwb3J0fSBpcyBmb3J3YXJkLSBhbmQgYmFja3dhcmQtY29tcGF0aWJsZS5cblx0ICogU3RhbmRhcmQgdHlwZXMgZm9yIHtAbGluayBodHRwczovL2ZkYzMuZmlub3Mub3JnLyBGREMzfSBkbyBub3QgYXBwZWFyIGluIE9wZW5GaW7igJlzIEFQSSBkb2N1bWVudGF0aW9uLCB0byBhdm9pZCBkdXBsaWNhdGlvbi5cblx0ICpcblx0ICogLS0tXG5cdCAqXG5cdCAqIFRoZXJlIGFyZSAyIHdheXMgdG8gaW5qZWN0IGN1c3RvbSBmdW5jdGlvbmFsaXR5IGludG8gdGhlIEludGVyb3AgQnJva2VyOlxuXHQgKlxuXHQgKiAqKjEuIENvbmZpZ3VyYXRpb24qKlxuXHQgKlxuXHQgKiBBdCB0aGUgbW9tZW50LCB5b3UgY2FuIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCBjb250ZXh0IGdyb3VwcyBmb3IgdGhlIEludGVyb3AgQnJva2VyIHdpdGhvdXQgaGF2aW5nIHRvIG92ZXJyaWRlIGl0LiBUbyBkbyBzbywgaW5jbHVkZSB0aGUgYGludGVyb3BCcm9rZXJDb25maWd1cmF0aW9uYCBgY29udGV4dEdyb3Vwc2Agb3B0aW9uIGluIHlvdXIgYHBsYXRmb3JtYCBvcHRpb25zIGluIHlvdXIgbWFuaWZlc3QuIFRoaXMgaXMgdGhlIHByZWZlcnJlZCBtZXRob2QuXG5cdCAqIGBgYGpzXG5cdCAqIHtcblx0ICogICAgICBcInJ1bnRpbWVcIjoge1xuXHQgKiAgICAgICAgICBcImFyZ3VtZW50c1wiOiBcIi0tdj0xIC0taW5zcGVjdFwiLFxuXHQgKiAgICAgICAgICBcInZlcnNpb25cIjogXCJhbHBoYS12MTlcIlxuXHQgKiAgICAgIH0sXG5cdCAqICAgICAgXCJwbGF0Zm9ybVwiOiB7XG5cdCAqICAgICAgICAgIFwidXVpZFwiOiBcInBsYXRmb3JtX2N1c3RvbWl6YXRpb25fbG9jYWxcIixcblx0ICogICAgICAgICAgXCJhcHBsaWNhdGlvbkljb25cIjogXCJodHRwczovL29wZW5maW4uZ2l0aHViLmlvL2dvbGRlbi1wcm90b3R5cGUvZmF2aWNvbi5pY29cIixcblx0ICogICAgICAgICAgXCJhdXRvU2hvd1wiOiBmYWxzZSxcblx0ICogICAgICAgICAgXCJwcm92aWRlclVybFwiOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTU1NS9wcm92aWRlci5odG1sXCIsXG5cdCAqICAgICAgICAgIFwiaW50ZXJvcEJyb2tlckNvbmZpZ3VyYXRpb25cIjoge1xuXHQgKiAgICAgICAgICAgICAgXCJjb250ZXh0R3JvdXBzXCI6IFtcblx0ICogICAgICAgICAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJncmVlblwiLFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlNZXRhZGF0YVwiOiB7XG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IFwiIzAwQ0M4OFwiLFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZ3JlZW5cIlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAqICAgICAgICAgICAgICAgICAgfSxcblx0ICogICAgICAgICAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJwdXJwbGVcIixcblx0ICogICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5TWV0YWRhdGFcIjoge1xuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcIiM4QzYxRkZcIixcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInB1cnBsZVwiXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICogICAgICAgICAgICAgICAgICB9LFxuXHQgKiAgICAgICAgICAgICAgXVxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfVxuXHQgKiB9XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBCeSBkZWZhdWx0IHRoZSBJbnRlcm9wIEJyb2tlciBsb2dzIGFsbCBhY3Rpb25zIHRvIHRoZSBjb25zb2xlLiBZb3UgY2FuIGRpc2FibGUgdGhpcyBieSB1c2luZyB0aGUgbG9nZ2luZyBvcHRpb24gaW4gYGludGVyb3BCcm9rZXJDb25maWd1cmF0aW9uYDpcblx0ICogYGBganNcblx0ICoge1xuXHQgKiAgICAgIFwicnVudGltZVwiOiB7XG5cdCAqICAgICAgICAgIFwiYXJndW1lbnRzXCI6IFwiLS12PTEgLS1pbnNwZWN0XCIsXG5cdCAqICAgICAgICAgIFwidmVyc2lvblwiOiBcImFscGhhLXYxOVwiXG5cdCAqICAgICAgfSxcblx0ICogICAgICBcInBsYXRmb3JtXCI6IHtcblx0ICogICAgICAgICAgXCJ1dWlkXCI6IFwicGxhdGZvcm1fY3VzdG9taXphdGlvbl9sb2NhbFwiLFxuXHQgKiAgICAgICAgICBcImFwcGxpY2F0aW9uSWNvblwiOiBcImh0dHBzOi8vb3BlbmZpbi5naXRodWIuaW8vZ29sZGVuLXByb3RvdHlwZS9mYXZpY29uLmljb1wiLFxuXHQgKiAgICAgICAgICBcImF1dG9TaG93XCI6IGZhbHNlLFxuXHQgKiAgICAgICAgICBcInByb3ZpZGVyVXJsXCI6IFwiaHR0cDovL2xvY2FsaG9zdDo1NTU1L3Byb3ZpZGVyLmh0bWxcIixcblx0ICpcdFx0ICAgIFwiaW50ZXJvcEJyb2tlckNvbmZpZ3VyYXRpb25cIjoge1xuXHQgKiAgICAgICBcdFx0XCJsb2dnaW5nXCI6IHtcblx0ICogICBcdFx0XHRcdFwiYmVmb3JlQWN0aW9uXCI6IHtcblx0ICogICBcdFx0XHRcdFx0XCJlbmFibGVkXCI6IGZhbHNlXG5cdCAqICAgXHRcdFx0XHR9LFxuXHQgKiAgIFx0XHRcdFx0XCJhZnRlckFjdGlvblwiOiB7XG5cdCAqICAgXHRcdFx0XHRcdFwiZW5hYmxlZFwiOiBmYWxzZVxuXHQgKiAgIFx0XHRcdFx0fVxuXHQgKiAgIFx0XHRcdH1cblx0ICpcdFx0ICAgIH1cblx0ICogICAgICB9XG5cdCAqIH1cblx0ICogYGBgXG5cdCAqXG5cdCAqIC0tLVxuXHQgKiAqKjIuIE92ZXJyaWRpbmcqKlxuXHQgKlxuXHQgKiBTaW1pbGFybHkgdG8gaG93IHtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL3BsYXRmb3JtLWN1c3RvbWl6YXRpb24jc2VjdGlvbi1jdXN0b21pemluZy1wbGF0Zm9ybS1iZWhhdmlvciBQbGF0Zm9ybSBPdmVycmlkaW5nfSB3b3JrcywgeW91IGNhbiBvdmVycmlkZSBmdW5jdGlvbnMgaW4gdGhlIEludGVyb3AgQnJva2VyIGluIGBmaW4uUGxhdGZvcm0uaW5pdGAuIEFuIGV4YW1wbGUgb2YgdGhhdCBpcyBzaG93biBiZWxvdy4gT3ZlcnJpZGluZyBgaXNDb25uZWN0aW9uQXV0aG9yaXplZGAgYW5kIGBpc0FjdGlvbkF1dGhvcml6ZWRgIHdpbGwgYWxsb3cgeW91IHRvIGNvbnRyb2wgYWxsb3dlZCBjb25uZWN0aW9ucyBhbmQgYWxsb3dlZCBhY3Rpb25zLlxuXHQgKlxuXHQgKiBIb3dldmVyLCBpZiB0aGVyZSBpcyBjdXN0b20gZnVuY3Rpb25hbGl0eSB5b3Ugd2lzaCB0byBpbmNsdWRlIGluIHRoZSBJbnRlcm9wIEJyb2tlciwgcGxlYXNlIGxldCB1cyBrbm93LiBXZSB3b3VsZCBsaWtlIHRvIHByb3ZpZGUgYmV0dGVyIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBzbyB0aGF0IHlvdSBkb24ndCBoYXZlIHRvIGNvbnRpbnVhbGx5IG1haW50YWluIHlvdXIgb3duIG92ZXJyaWRlIGNvZGUuXG5cdCAqXG5cdCAqIGBgYGpzXG5cdCAqIGZpbi5QbGF0Zm9ybS5pbml0KHtcblx0ICogICAgIG92ZXJyaWRlQ2FsbGJhY2s6IGFzeW5jIChQcm92aWRlcikgPT4ge1xuXHQgKiAgICAgICAgIGNsYXNzIE92ZXJyaWRlIGV4dGVuZHMgUHJvdmlkZXIge1xuXHQgKiAgICAgICAgICAgICBhc3luYyBnZXRTbmFwc2hvdCgpIHtcblx0ICogICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdiZWZvcmUgZ2V0U25hcHNob3QnKVxuXHQgKiAgICAgICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBzdXBlci5nZXRTbmFwc2hvdCgpO1xuXHQgKiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FmdGVyIGdldFNuYXBzaG90Jylcblx0ICogICAgICAgICAgICAgICAgIHJldHVybiBzbmFwc2hvdDtcblx0ICogICAgICAgICAgICAgfVxuXHQgKlxuXHQgKiAgICAgICAgICAgICBhc3luYyBhcHBseVNuYXBzaG90KHsgc25hcHNob3QsIG9wdGlvbnMgfSkge1xuXHQgKiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2JlZm9yZSBhcHBseVNuYXBzaG90Jylcblx0ICogICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZSA9IHN1cGVyLmFwcGx5U25hcHNob3QoeyBzbmFwc2hvdCwgb3B0aW9ucyB9KTtcblx0ICogICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZnRlciBhcHBseVNuYXBzaG90Jylcblx0ICpcblx0ICogICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2U7XG5cdCAqICAgICAgICAgICAgIH1cblx0ICogICAgICAgICB9O1xuXHQgKiAgICAgICAgIHJldHVybiBuZXcgT3ZlcnJpZGUoKTtcblx0ICogICAgIH0sXG5cdCAqICAgICBpbnRlcm9wT3ZlcnJpZGU6IGFzeW5jIChJbnRlcm9wQnJva2VyKSA9PiB7XG5cdCAqICAgICAgICAgY2xhc3MgT3ZlcnJpZGUgZXh0ZW5kcyBJbnRlcm9wQnJva2VyIHtcblx0ICogICAgICAgICAgICAgYXN5bmMgam9pbkNvbnRleHRHcm91cChjaGFubmVsTmFtZSA9ICdkZWZhdWx0JywgdGFyZ2V0KSB7XG5cdCAqICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYmVmb3JlIHN1cGVyIGpvaW5Db250ZXh0R3JvdXAnKVxuXHQgKiAgICAgICAgICAgICAgICAgc3VwZXIuam9pbkNvbnRleHRHcm91cChjaGFubmVsTmFtZSwgdGFyZ2V0KTtcblx0ICogICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZnRlciBzdXBlciBqb2luQ29udGV4dEdyb3VwJylcblx0ICogICAgICAgICAgICAgfVxuXHQgKiAgICAgICAgIH1cblx0ICpcblx0ICogICAgICAgcmV0dXJuIG5ldyBPdmVycmlkZSgpO1xuXHQgKiAgIH1cblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiAtLS1cblx0ICpcblx0ICovXG5cdGxldCBJbnRlcm9wQnJva2VyJDEgPSBjbGFzcyBJbnRlcm9wQnJva2VyIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuXHQgICAgLyoqXG5cdCAgICAgKiBAaW50ZXJuYWxcblx0ICAgICAqL1xuXHQgICAgY29uc3RydWN0b3Iod2lyZSwgZ2V0UHJvdmlkZXIsIG9wdGlvbnMpIHtcblx0ICAgICAgICAvLyBUaXAgZnJvbSBQaWVycmUgYW5kIE1pY2hhZWwgZnJvbSB0aGUgb3ZlcnJpZGVDaGVjayB3b3JrOiBEb24ndCB1c2UgYm91bmQgbWV0aG9kcyBmb3Igb3ZlcnJpZGVhYmxlIEludGVyb3BCcm9rZXIgZnVuY3Rpb25zLlxuXHQgICAgICAgIHN1cGVyKHdpcmUpO1xuXHQgICAgICAgIHRoaXMuZ2V0UHJvdmlkZXIgPSBnZXRQcm92aWRlcjtcblx0ICAgICAgICBfSW50ZXJvcEJyb2tlcl9mZGMzSW5mby5zZXQodGhpcywgdm9pZCAwKTtcblx0ICAgICAgICBfSW50ZXJvcEJyb2tlcl9jb250ZXh0R3JvdXBzLnNldCh0aGlzLCB2b2lkIDApO1xuXHQgICAgICAgIHRoaXMuaW50ZXJvcENsaWVudHMgPSBuZXcgTWFwKCk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0R3JvdXBzQnlJZCA9IG5ldyBNYXAoKTtcblx0ICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9JbnRlcm9wQnJva2VyX2NvbnRleHRHcm91cHMsIG9wdGlvbnMuY29udGV4dEdyb3VwcyA/PyBbLi4uZGVmYXVsdENvbnRleHRHcm91cHNdLCBcImZcIik7XG5cdCAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW50ZXJvcEJyb2tlcl9mZGMzSW5mbywgb3B0aW9ucy5mZGMzSW5mbywgXCJmXCIpO1xuXHQgICAgICAgIGlmIChvcHRpb25zPy5sb2dnaW5nKSB7XG5cdCAgICAgICAgICAgIHRoaXMubG9nZ2luZyA9IG9wdGlvbnMubG9nZ2luZztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5pbnRlbnRDbGllbnRNYXAgPSBuZXcgTWFwKCk7XG5cdCAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1hcCA9IG5ldyBNYXAoKTtcblx0ICAgICAgICB0aGlzLnNlc3Npb25Db250ZXh0R3JvdXBNYXAgPSBuZXcgTWFwKCk7XG5cdCAgICAgICAgdGhpcy5zZXRDb250ZXh0R3JvdXBNYXAoKTtcblx0ICAgICAgICB0aGlzLnNldHVwQ2hhbm5lbFByb3ZpZGVyKCk7XG5cdCAgICB9XG5cdCAgICBzdGF0aWMgY3JlYXRlQ2xvc2VkQ29uc3RydWN0b3IoLi4uYXJncykge1xuXHQgICAgICAgIHJldHVybiBjbGFzcyBPdmVycmlkZWFibGVCcm9rZXIgZXh0ZW5kcyBJbnRlcm9wQnJva2VyIHtcblx0ICAgICAgICAgICAgY29uc3RydWN0b3IoLi4udW51c2VkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodW51c2VkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtfaWdub3JlMSwgaWdub3JlMiwgb3B0c10gPSB1bnVzZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmICEoMCwgbG9kYXNoXzEuaXNFcXVhbCkob3B0cywgYXJnc1syXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdZb3UgaGF2ZSBtb2RpZmllZCB0aGUgcGFyYW1ldGVycyBvZiB0aGUgSW50ZXJvcE92ZXJyaWRlIGNvbnN0cnVjdG9yLiBUaGlzIGJlaGF2aW9yIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBZb3UgY2FuIG1vZGlmeSB0aGVzZSBvcHRpb25zIGluIHlvdXIgbWFuaWZlc3QuIFBsZWFzZSBjb25zdWx0IG91ciBJbnRlcm9wIGRvY3MgZm9yIGd1aWRhbmNlIG9uIG1pZ3JhdGluZyB0byB0aGUgbmV3IG92ZXJyaWRlIHNjaGVtZS4nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXIoYXJnc1swXSwgYXJnc1sxXSwgb3B0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byBwYXNzIGFyZ3VtZW50cyB0byB0aGUgSW50ZXJvcE92ZXJyaWRlIGNvbnN0cnVjdG9yLiBUaGlzIGlzIG5vdCBuZWNlc3NhcnksIGFuZCB0aGVzZSBwYXNzZWQgYXJndW1lbnRzIHdpbGwgYmUgaWdub3JlZC4gWW91IGFyZSBsaWtlbHkgdXNpbmcgYW4gb2xkZXIgSW50ZXJvcEJyb2tlciBvdmVycmlkZSBzY2hlbWUuIFBsZWFzZSBjb25zdWx0IG91ciBJbnRlcm9wIGRvY3MgZm9yIGd1aWRhbmNlIG9uIG1pZ3JhdGluZyB0byB0aGUgbmV3IG92ZXJyaWRlIHNjaGVtZS4nKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8qXG5cdCAgICBDbGllbnQgQVBJXG5cdCAgICAqL1xuXHQgICAgLyoqXG5cdCAgICAgKiBTZXRzIGEgY29udGV4dCBmb3IgdGhlIGNvbnRleHQgZ3JvdXAgb2YgdGhlIGluY29taW5nIGN1cnJlbnQgZW50aXR5LlxuXHQgICAgICogQHBhcmFtIHNldENvbnRleHRPcHRpb25zIC0gTmV3IGNvbnRleHQgdG8gc2V0LlxuXHQgICAgICogQHBhcmFtIGNsaWVudElkZW50aXR5IC0gSWRlbnRpdHkgb2YgdGhlIGNsaWVudCBzZW5kZXIuXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBzZXRDb250ZXh0KHsgY29udGV4dCB9LCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1zZXQtY29udGV4dCcpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKGNsaWVudFN0YXRlICYmIGNsaWVudFN0YXRlLmNvbnRleHRHcm91cElkKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgY29udGV4dEdyb3VwSWQgfSA9IGNsaWVudFN0YXRlO1xuXHQgICAgICAgICAgICB0aGlzLnNldENvbnRleHRGb3JHcm91cCh7IGNvbnRleHQgfSwgY29udGV4dEdyb3VwSWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChjbGllbnRTdGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBDbGllbnQgaGFzIG5vdCBqb2luZWQgYW55IGNvbnRleHQgZ3JvdXAgYmVoYXZpb3IuXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgam9pbiBhIGNvbnRleHQgZ3JvdXAgYmVmb3JlIHlvdSBjYW4gc2V0IGNvbnRleHQuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBnZXQgaGl0LlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCB3aXRoIElkZW50aXR5OiAke2NsaWVudElkZW50aXR5LnV1aWR9ICR7Y2xpZW50SWRlbnRpdHkubmFtZX0gbm90IGluIENsaWVudCBTdGF0ZSBNYXBgKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFNldHMgYSBjb250ZXh0IGZvciB0aGUgY29udGV4dCBncm91cC5cblx0ICAgICAqIEBwYXJhbSBzZXRDb250ZXh0T3B0aW9ucyAtIE5ldyBjb250ZXh0IHRvIHNldC5cblx0ICAgICAqIEBwYXJhbSBjb250ZXh0R3JvdXBJZCAtIENvbnRleHQgZ3JvdXAgaWQuXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBzZXRDb250ZXh0Rm9yR3JvdXAoeyBjb250ZXh0IH0sIGNvbnRleHRHcm91cElkKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLXNldC1jb250ZXh0LWZvci1ncm91cCcpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGNvbnN0IGNvbnRleHRHcm91cFN0YXRlID0gdGhpcy5jb250ZXh0R3JvdXBzQnlJZC5nZXQoY29udGV4dEdyb3VwSWQpO1xuXHQgICAgICAgIGlmICghY29udGV4dEdyb3VwU3RhdGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gc2V0IGNvbnRleHQgZm9yIGNvbnRleHQgZ3JvdXAgdGhhdCBpc24ndCBpbiB0aGUgY29udGV4dCBncm91cCBtYXBwaW5nOiAke2NvbnRleHRHcm91cElkfS5gKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc3QgY29udGV4dEludGVncml0eUNoZWNrUmVzdWx0ID0gSW50ZXJvcEJyb2tlci5jaGVja0NvbnRleHRJbnRlZ3JpdHkoY29udGV4dCk7XG5cdCAgICAgICAgaWYgKGNvbnRleHRJbnRlZ3JpdHlDaGVja1Jlc3VsdC5pc1ZhbGlkID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXQgQ29udGV4dCAtIGJhZCBDb250ZXh0LiBSZWFzb246ICR7Y29udGV4dEludGVncml0eUNoZWNrUmVzdWx0LnJlYXNvbn0uIENvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCl9YCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnN0IGJyb2FkY2FzdGVkQ29udGV4dFR5cGUgPSBjb250ZXh0LnR5cGU7XG5cdCAgICAgICAgY29udGV4dEdyb3VwU3RhdGUuc2V0KGJyb2FkY2FzdGVkQ29udGV4dFR5cGUsIGNvbnRleHQpO1xuXHQgICAgICAgIHRoaXMubGFzdENvbnRleHRNYXAuc2V0KGNvbnRleHRHcm91cElkLCBicm9hZGNhc3RlZENvbnRleHRUeXBlKTtcblx0ICAgICAgICBjb25zdCBjbGllbnRzSW5TYW1lQ29udGV4dEdyb3VwID0gQXJyYXkuZnJvbSh0aGlzLmludGVyb3BDbGllbnRzLnZhbHVlcygpKS5maWx0ZXIoKGNvbm5lY3RlZENsaWVudCkgPT4gY29ubmVjdGVkQ2xpZW50LmNvbnRleHRHcm91cElkID09PSBjb250ZXh0R3JvdXBJZCk7XG5cdCAgICAgICAgY2xpZW50c0luU2FtZUNvbnRleHRHcm91cC5mb3JFYWNoKChjbGllbnQpID0+IHtcblx0ICAgICAgICAgICAgZm9yIChjb25zdCBbLCBoYW5kbGVySW5mb10gb2YgY2xpZW50LmNvbnRleHRIYW5kbGVycykge1xuXHQgICAgICAgICAgICAgICAgaWYgKEludGVyb3BCcm9rZXIuaXNDb250ZXh0VHlwZUNvbXBhdGlibGUoYnJvYWRjYXN0ZWRDb250ZXh0VHlwZSwgaGFuZGxlckluZm8uY29udGV4dFR5cGUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VDb250ZXh0SGFuZGxlcihjbGllbnQuY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJbmZvLmhhbmRsZXJJZCwgY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogR2V0IGN1cnJlbnQgY29udGV4dCBmb3IgYSBjbGllbnQgc3Vic2NyaWJlZCB0byBhIENvbnRleHQgR3JvdXAuXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgSXQgdGFrZXMgYW4gb3B0aW9uYWwgQ29udGV4dCBUeXBlIGFyZ3VtZW50IGFuZCByZXR1cm5zIHRoZSBsYXN0IGNvbnRleHQgb2YgdGhhdCB0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBnZXRDb250ZXh0T3B0aW9ucyAtIE9wdGlvbnMgZm9yIGdldHRpbmcgY29udGV4dFxuXHQgICAgICogQHBhcmFtIGNsaWVudElkZW50aXR5IC0gSWRlbnRpdHkgb2YgdGhlIGNsaWVudCBzZW5kZXIuXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBnZXRDdXJyZW50Q29udGV4dChnZXRDdXJyZW50Q29udGV4dE9wdGlvbnMsIGNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLWdldC1jdXJyZW50LWNvbnRleHQnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZ2V0Q2xpZW50U3RhdGUoY2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgIGlmICghY2xpZW50U3RhdGU/LmNvbnRleHRHcm91cElkKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgYSBtZW1iZXIgb2YgYSBjb250ZXh0IGdyb3VwIHRvIGNhbGwgZ2V0Q3VycmVudENvbnRleHQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc3QgeyBjb250ZXh0R3JvdXBJZCB9ID0gY2xpZW50U3RhdGU7XG5cdCAgICAgICAgY29uc3QgY29udGV4dEdyb3VwU3RhdGUgPSB0aGlzLmNvbnRleHRHcm91cHNCeUlkLmdldChjb250ZXh0R3JvdXBJZCk7XG5cdCAgICAgICAgY29uc3QgbGFzdENvbnRleHRUeXBlID0gdGhpcy5sYXN0Q29udGV4dE1hcC5nZXQoY29udGV4dEdyb3VwSWQpO1xuXHQgICAgICAgIGNvbnN0IGNvbnRleHRUeXBlID0gZ2V0Q3VycmVudENvbnRleHRPcHRpb25zPy5jb250ZXh0VHlwZSA/PyBsYXN0Q29udGV4dFR5cGU7XG5cdCAgICAgICAgcmV0dXJuIGNvbnRleHRHcm91cFN0YXRlICYmIGNvbnRleHRUeXBlID8gY29udGV4dEdyb3VwU3RhdGUuZ2V0KGNvbnRleHRUeXBlKSA6IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIC8qXG5cdCAgICBQbGF0Zm9ybSBXaW5kb3cgQVBJc1xuXHQgICAgKi9cblx0ICAgIC8vIGpvaW5Db250ZXh0R3JvdXAgYW5kIGFkZENsaWVudFRvQ29udGV4dEdyb3VwIGFyZSBzZXBhcmF0ZSBmdW5jdGlvbnMgaGVyZSwgZm9yIGVhc2llciBvdmVycmlkZXMgYW5kIHNlcGFyYXRpb24gb2YgY29uY2VybnMuXG5cdCAgICAvLyBqb2luQ29udGV4dEdyb3VwIGNoZWNrcyBhbGwgY29ubmVjdGlvbnMgZm9yIG1hdGNoaW5nIGlkZW50aXRpZXMsIGluIGNhc2Ugd2UgaGF2ZSBtdWx0aXBsZSBjb25uZWN0aW9uIGZyb20gYW4gZW50aXR5LlxuXHQgICAgLyoqXG5cdCAgICAgKiBKb2luIGFsbCBjb25uZWN0aW9ucyBhdCB0aGUgZ2l2ZW4gaWRlbnRpdHkgKG9yIGp1c3Qgb25lIGlmIGVuZHBvaW50SWQgcHJvdmlkZWQpIHRvIGNvbnRleHQgZ3JvdXAgYGNvbnRleHRHcm91cElkYC5cblx0ICAgICAqIElmIG5vIHRhcmdldCBpcyBzcGVjaWZpZWQsIGl0IGFkZHMgdGhlIHNlbmRlciB0byB0aGUgY29udGV4dCBncm91cC5cblx0ICAgICAqIGpvaW5Db250ZXh0R3JvdXAgaXMgcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIGNvbm5lY3Rpb25zIGF0IHRoZSBpbmNvbWluZyBpZGVudGl0eS4gSXQgY2FsbHMge0BsaW5rIEludGVyb3BCcm9rZXIjYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAgSW50ZXJvcEJyb2tlci5hZGRDbGllbnRUb0NvbnRleHRHcm91cH0gdG8gYWN0dWFsbHkgZ3JvdXAgdGhlIGNsaWVudC5cblx0ICAgICAqIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gam9pbkNvbnRleHRHcm91cE9wdGlvbnMgLSBJZCBvZiB0aGUgQ29udGV4dCBHcm91cCBhbmQgaWRlbnRpdHkgb2YgdGhlIGVudGl0eSB0byBqb2luIHRvIHRoZSBncm91cC5cblx0ICAgICAqIEBwYXJhbSBzZW5kZXJJZGVudGl0eSAtIElkZW50aXR5IG9mIHRoZSBjbGllbnQgc2VuZGVyLlxuXHQgICAgICovXG5cdCAgICBhc3luYyBqb2luQ29udGV4dEdyb3VwKHsgY29udGV4dEdyb3VwSWQsIHRhcmdldCB9LCBzZW5kZXJJZGVudGl0eSkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1qb2luLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAodGhpcy5zZXNzaW9uQ29udGV4dEdyb3VwTWFwLmhhcyhjb250ZXh0R3JvdXBJZCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuQlJPS0VSX0VSUk9SUy5qb2luU2Vzc2lvbkNvbnRleHRHcm91cFdpdGhKb2luQ29udGV4dEdyb3VwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRhcmdldCkge1xuXHQgICAgICAgICAgICAvLyBJZiBhbiBlbmRwb2ludElkIGlzIHByb3ZpZGVkLCB1c2UgdGhhdC4gVGhpcyB3aWxsIGxpa2VseSBiZSB1c2VkIGJ5IGV4dGVybmFsIGFkYXB0ZXJzLlxuXHQgICAgICAgICAgICBpZiAoSW50ZXJvcEJyb2tlci5oYXNFbmRwb2ludElkKHRhcmdldCkpIHtcblx0ICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAoeyBjb250ZXh0R3JvdXBJZCB9LCB0YXJnZXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjayBoZXJlIGluIGNhc2UgYSBzaW5nbGUgYXBwIGhhcyBtdWx0aXBsZSBjb25uZWN0aW9uc1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgYWxsQ29ubmVjdGlvbnMgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbnMuZmlsdGVyKCh4KSA9PiB4LnV1aWQgPT09IHRhcmdldC51dWlkICYmIHgubmFtZSA9PT0gdGFyZ2V0Lm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFhbGxDb25uZWN0aW9ucy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdmVuIElkZW50aXR5ICR7dGFyZ2V0LnV1aWR9ICR7dGFyZ2V0Lm5hbWV9IGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIEludGVyb3AgQnJva2VyLmApO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGFsbENvbm5lY3Rpb25zLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgZmlndXJlIG91dCBob3cgd2Ugd2FudCB0byBoYW5kbGUgdGhpcyBzaXR1YXRpb24uIEluIHRoZSBtZWFudGltZSwganVzdCBjaGFuZ2UgY29udGV4dCBncm91cCBmb3IgYWxsIGNvbm5lY3Rpb25zLlxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgTW9yZSB0aGFuIG9uZSBjb25uZWN0aW9uIGZvdW5kIGZvciBpZGVudGl0eSAke3RhcmdldC51dWlkfSAke3RhcmdldC5uYW1lfWApO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29ubmVjdGlvbiBvZiBhbGxDb25uZWN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5hZGRDbGllbnRUb0NvbnRleHRHcm91cCh7IGNvbnRleHRHcm91cElkIH0sIGNvbm5lY3Rpb24pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIE5vIHRhcmdldCBwcm92aWRlZCwgYWRkIHRoZSBzZW5kZXIgdG8gdGhlIGNvbnRleHQgZ3JvdXAuXG5cdCAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAoeyBjb250ZXh0R3JvdXBJZCB9LCBzZW5kZXJJZGVudGl0eSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAgZG9lcyB0aGUgYWN0dWFsIGFkZGl0aW9uIG9mIHRoZSBjbGllbnQgdG8gdGhlIENvbnRleHQgR3JvdXBcblx0ICAgIC8qKlxuXHQgICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciB7QGxpbmsgSW50ZXJvcEJyb2tlciNqb2luQ29udGV4dEdyb3VwIEludGVyb3BCcm9rZXIuam9pbkNvbnRleHRHcm91cH0uIERvZXMgdGhlIHdvcmsgb2YgYWN0dWFsbHkgYWRkaW5nIHRoZSBjbGllbnQgdG8gdGhlIENvbnRleHQgR3JvdXAuXG5cdCAgICAgKiBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGFkZENsaWVudFRvQ29udGV4dEdyb3VwT3B0aW9ucyAtIENvbnRhaW5zIHRoZSBjb250ZXh0R3JvdXBJZFxuXHQgICAgICogQHBhcmFtIGNsaWVudElkZW50aXR5IC0gSWRlbnRpdHkgb2YgdGhlIGNsaWVudCBzZW5kZXIuXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIGFkZENsaWVudFRvQ29udGV4dEdyb3VwKHsgY29udGV4dEdyb3VwSWQgfSwgY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1icm9rZXItYWRkLWNsaWVudC10by1jb250ZXh0LWdyb3VwJykuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICBpZiAoIWNsaWVudFN1YnNjcmlwdGlvblN0YXRlKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IHdpdGggSWRlbnRpdHk6ICR7Y2xpZW50SWRlbnRpdHkudXVpZH0gJHtjbGllbnRJZGVudGl0eS5uYW1lfSBub3QgaW4gQ2xpZW50IFN0YXRlIE1hcGApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXRoaXMuZ2V0Q29udGV4dEdyb3VwcygpLmZpbmQoKGNvbnRleHRHcm91cEluZm8pID0+IGNvbnRleHRHcm91cEluZm8uaWQgPT09IGNvbnRleHRHcm91cElkKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gam9pbiBhIGNvbnRleHQgZ3JvdXAgdGhhdCBkb2VzIG5vdCBleGlzdDogJHtjb250ZXh0R3JvdXBJZH0uIFlvdSBtYXkgb25seSBqb2luIGV4aXN0aW5nIGNvbnRleHQgZ3JvdXBzLmApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb25zdCBvbGRDb250ZXh0R3JvdXBJZCA9IGNsaWVudFN1YnNjcmlwdGlvblN0YXRlLmNvbnRleHRHcm91cElkO1xuXHQgICAgICAgIGlmIChvbGRDb250ZXh0R3JvdXBJZCAhPT0gY29udGV4dEdyb3VwSWQpIHtcblx0ICAgICAgICAgICAgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUuY29udGV4dEdyb3VwSWQgPSBjb250ZXh0R3JvdXBJZDtcblx0ICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50Q29udGV4dEdyb3VwSW5DbGllbnRPcHRpb25zKGNsaWVudElkZW50aXR5LCBjb250ZXh0R3JvdXBJZCk7XG5cdCAgICAgICAgICAgIGNvbnN0IGNvbnRleHRHcm91cE1hcCA9IHRoaXMuY29udGV4dEdyb3Vwc0J5SWQuZ2V0KGNvbnRleHRHcm91cElkKTtcblx0ICAgICAgICAgICAgZm9yIChjb25zdCBbLCBoYW5kbGVySW5mb10gb2YgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUuY29udGV4dEhhbmRsZXJzKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnRleHRUeXBlLCBoYW5kbGVySWQgfSA9IGhhbmRsZXJJbmZvO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIHRoaXMgc2luZ2xlIGhhbmRsZXIgYWxsIG9mIHRoZSBjb250ZXh0LCBiZWNhdXNlIGl0IGFjY2VwdHMgYWxsLlxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHRHcm91cE1hcC5mb3JFYWNoKChjb250ZXh0LCBfKSA9PiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlQ29udGV4dEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0R3JvdXBNYXAuaGFzKGNvbnRleHRUeXBlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRGb3JUeXBlID0gY29udGV4dEdyb3VwTWFwLmdldChjb250ZXh0VHlwZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRGb3JUeXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlQ29udGV4dEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY29udGV4dEZvclR5cGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIFJlbW92ZXMgdGhlIHRhcmdldCBmcm9tIGl0cyBjb250ZXh0IGdyb3VwLiBTaW1pbGFyIHN0cnVjdHVyZSB0byBqb2luQ29udGV4dEdyb3VwLlxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGZyb20gYSBjb250ZXh0IGdyb3VwLlxuXHQgICAgICogSWYgbm8gdGFyZ2V0IGlzIHNwZWNpZmllZCwgaXQgcmVtb3ZlcyB0aGUgc2VuZGVyIGZyb20gdGhlaXIgY29udGV4dCBncm91cC5cblx0ICAgICAqIHJlbW92ZUZyb21Db250ZXh0R3JvdXAgaXMgcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIGNvbm5lY3Rpb25zIGF0IHRoZSBpbmNvbWluZyBpZGVudGl0eS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmVtYXJrcyBJdCBjYWxscyB7QGxpbmsgSW50ZXJvcEJyb2tlciNyZW1vdmVDbGllbnRGcm9tQ29udGV4dEdyb3VwIEludGVyb3BCcm9rZXIucmVtb3ZlQ2xpZW50RnJvbUNvbnRleHRHcm91cH0gdG8gYWN0dWFsbHkgdW5ncm91cFxuXHQgICAgICogdGhlIGNsaWVudC4gVXNlZCBieSBQbGF0Zm9ybSBXaW5kb3dzLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSByZW1vdmVGcm9tQ29udGV4dEdyb3VwT3B0aW9ucyAtIENvbnRhaW5zIHRoZSB0YXJnZXQgaWRlbnRpdHkgdG8gcmVtb3ZlLlxuXHQgICAgICogQHBhcmFtIHNlbmRlcklkZW50aXR5IC0gSWRlbnRpdHkgb2YgdGhlIGNsaWVudCBzZW5kZXIuXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIHJlbW92ZUZyb21Db250ZXh0R3JvdXAoeyB0YXJnZXQgfSwgc2VuZGVySWRlbnRpdHkpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1icm9rZXItcmVtb3ZlLWZyb20tY29udGV4dC1ncm91cCcpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmICh0YXJnZXQpIHtcblx0ICAgICAgICAgICAgLy8gSWYgYW4gZW5kcG9pbnRJZCBpcyBwcm92aWRlZCwgdXNlIHRoYXQuIFRoaXMgd2lsbCBsaWtlbHkgYmUgdXNlZCBieSBleHRlcm5hbCBhZGFwdGVycy5cblx0ICAgICAgICAgICAgaWYgKEludGVyb3BCcm9rZXIuaGFzRW5kcG9pbnRJZCh0YXJnZXQpKSB7XG5cdCAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUNsaWVudEZyb21Db250ZXh0R3JvdXAodGFyZ2V0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrIGhlcmUgaW4gY2FzZSBhIHNpbmdsZSBhcHAgaGFzIG11bHRpcGxlIGNvbm5lY3Rpb25zXG5cdCAgICAgICAgICAgICAgICBjb25zdCBhbGxDb25uZWN0aW9ucyA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9ucy5maWx0ZXIoKHgpID0+IHgudXVpZCA9PT0gdGFyZ2V0LnV1aWQgJiYgeC5uYW1lID09PSB0YXJnZXQubmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWFsbENvbm5lY3Rpb25zLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29ubmVjdGlvbiBmb3VuZCBmb3IgZ2l2ZW4gSWRlbnRpdHkgJHt0YXJnZXQudXVpZH0gJHt0YXJnZXQubmFtZX1gKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChhbGxDb25uZWN0aW9ucy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBNb3JlIHRoYW4gb25lIGNvbm5lY3Rpb24gZm91bmQgZm9yIGlkZW50aXR5ICR7dGFyZ2V0LnV1aWR9ICR7dGFyZ2V0Lm5hbWV9YCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGFsbENvbm5lY3Rpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlbW92ZUNsaWVudEZyb21Db250ZXh0R3JvdXAoY29ubmVjdGlvbikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gTm8gdGFyZ2V0IHByb3ZpZGVkLCByZW1vdmUgdGhlIHNlbmRlciBmcm9tIHRoZSBjb250ZXh0IGdyb3VwLlxuXHQgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUNsaWVudEZyb21Db250ZXh0R3JvdXAoc2VuZGVySWRlbnRpdHkpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIHJlbW92ZUNsaWVudEZyb21Db250ZXh0R3JvdXAgZG9lcyB0aGUgYWN0dWFsIHJlbW92ZSBvZiB0aGUgY2xpZW50IGZyb20gdGhlIENvbnRleHQgR3JvdXBcblx0ICAgIC8qKlxuXHQgICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciB7QGxpbmsgSW50ZXJvcEJyb2tlciNyZW1vdmVGcm9tQ29udGV4dEdyb3VwIEludGVyb3BCcm9rZXIucmVtb3ZlRnJvbUNvbnRleHRHcm91cH0uIERvZXMgdGhlIHdvcmsgb2YgYWN0dWFsbHkgcmVtb3ZpbmcgdGhlIGNsaWVudCBmcm9tIHRoZSBDb250ZXh0IEdyb3VwLlxuXHQgICAgICogVXNlZCBieSBQbGF0Zm9ybSBXaW5kb3dzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7IENsaWVudElkZW50aXR5IH0gY2xpZW50SWRlbnRpdHkgLSBJZGVudGl0eSBvZiB0aGUgY2xpZW50IHNlbmRlci5cblx0ICAgICAqL1xuXHQgICAgYXN5bmMgcmVtb3ZlQ2xpZW50RnJvbUNvbnRleHRHcm91cChjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1yZW1vdmUtY2xpZW50LWZyb20tY29udGV4dC1ncm91cCcpLmNhdGNoKChlKSA9PiB7XG5cdCAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKGNsaWVudFN0YXRlKSB7XG5cdCAgICAgICAgICAgIGNsaWVudFN0YXRlLmNvbnRleHRHcm91cElkID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBhd2FpdCB0aGlzLnNldEN1cnJlbnRDb250ZXh0R3JvdXBJbkNsaWVudE9wdGlvbnMoY2xpZW50SWRlbnRpdHksIG51bGwpO1xuXHQgICAgfVxuXHQgICAgLy8gVXNlZCBieSBwbGF0Zm9ybSB3aW5kb3dzIHRvIGtub3cgd2hhdCBjbGllbnQgZ3JvdXBzIHRoZSBwcm92aWRlciBoYXMgZGVjbGFyZWQuIEFsc28gdXNlZCBpbnRlcm5hbGx5IHRvIGFjY2VzcyBjb250ZXh0IGdyb3Vwcy4gT3ZlcnJpZGVhYmxlIHNvIHRoYXQgdGhlIHBsYXRmb3JtIGRldmVsb3BlciBjYW4gbW9kaWZ5IGl0LlxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRoZSBJbnRlcm9wLUJyb2tlci1kZWZpbmVkIGNvbnRleHQgZ3JvdXBzIGF2YWlsYWJsZSBmb3IgYW4gZW50aXR5IHRvIGpvaW4uIEJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIHRoZSByZXN0IG9mIHRoZSBJbnRlcm9wIEJyb2tlciB0byBmZXRjaCB0aGUgQ29udGV4dCBHcm91cHMsIG92ZXJyaWRpbmcgdGhpcyBhbGxvd3MgeW91IHRvIGN1c3RvbWl6ZSB0aGUgQ29udGV4dCBHcm91cHMgZm9yIHRoZSBJbnRlcm9wIEJyb2tlci4gSG93ZXZlciwgd2UgcmVjb21tZW5kIGN1c3RvbWl6aW5nIHRoZSBjb250ZXh0IGdyb3VwcyB0aHJvdWdoIGNvbmZpZ3VyYXRpb24gaW5zdGVhZC5cblx0ICAgICAqIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cblx0ICAgICAqXG5cdCAgICAgKi9cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cdCAgICBnZXRDb250ZXh0R3JvdXBzKCkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1nZXQtY29udGV4dC1ncm91cHMnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBDcmVhdGUgY29weSBmb3IgaW1tdXRhYmlsaXR5XG5cdCAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0ludGVyb3BCcm9rZXJfY29udGV4dEdyb3VwcywgXCJmXCIpLm1hcCgoY29udGV4dEdyb3VwKSA9PiB7XG5cdCAgICAgICAgICAgIHJldHVybiB7IC4uLmNvbnRleHRHcm91cCB9O1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgLy8gVXNlZCB0byBieSBwbGF0Zm9ybSB3aW5kb3dzIHRvIGdldCBkaXNwbGF5IG1ldGFkYXRhIGZvciBhIGNvbnRleHQgZ3JvdXAuXG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgZGlzcGxheSBpbmZvIGZvciBhIGNvbnRleHQgZ3JvdXBcblx0ICAgICAqXG5cdCAgICAgKiBAcmVtYXJrcyBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGdldEluZm9Gb3JDb250ZXh0R3JvdXBPcHRpb25zIC0gQ29udGFpbnMgY29udGV4dEdyb3VwSWQsIHRoZSBjb250ZXh0IGdyb3VwIHlvdSB3aXNoIHRvIGdldCBkaXNwbGF5IGluZm8gZm9yLlxuXHQgICAgICpcblx0ICAgICAqL1xuXHQgICAgZ2V0SW5mb0ZvckNvbnRleHRHcm91cCh7IGNvbnRleHRHcm91cElkIH0pIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1icm9rZXItZ2V0LWluZm8tZm9yLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZXh0R3JvdXBzKCkuZmluZCgoY29udGV4dEdyb3VwKSA9PiBjb250ZXh0R3JvdXAuaWQgPT09IGNvbnRleHRHcm91cElkKTtcblx0ICAgIH1cblx0ICAgIC8vIFVzZWQgYnkgcGxhdGZvcm0gd2luZG93cyB0byBnZXQgYWxsIGNsaWVudHMgZm9yIGEgY29udGV4dCBncm91cC5cblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyBhbGwgY2xpZW50cyBmb3IgYSBjb250ZXh0IGdyb3VwLlxuXHQgICAgICpcblx0ICAgICAqIEByZW1hcmtzICoqVGhpcyBpcyBwcmltYXJpbHkgdXNlZCBmb3IgcGxhdGZvcm0gd2luZG93cy4gVmlld3Mgd2l0aGluIGEgcGxhdGZvcm0gc2hvdWxkIG5vdCBoYXZlIHRvIHVzZSB0aGlzIEFQSS4qKlxuXHQgICAgICogUmV0dXJucyB0aGUgSW50ZXJvcC1Ccm9rZXItZGVmaW5lZCBjb250ZXh0IGdyb3VwcyBhdmFpbGFibGUgZm9yIGFuIGVudGl0eSB0byBqb2luLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBnZXRBbGxDbGllbnRzSW5Db250ZXh0R3JvdXBPcHRpb25zIC0gQ29udGFpbnMgY29udGV4dEdyb3VwSWQsIHRoZSBjb250ZXh0IGdyb3VwIHlvdSB3aXNoIHRvIGdldCBjbGllbnRzIGZvci5cblx0ICAgICAqXG5cdCAgICAgKi9cblx0ICAgIGdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCh7IGNvbnRleHRHcm91cElkIH0pIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1icm9rZXItZ2V0LWFsbC1jbGllbnRzLWluLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb25zdCBjbGllbnRzSW5Db250ZXh0R3JvdXAgPSBBcnJheS5mcm9tKHRoaXMuaW50ZXJvcENsaWVudHMudmFsdWVzKCkpXG5cdCAgICAgICAgICAgIC5maWx0ZXIoKGNvbm5lY3RlZENsaWVudCkgPT4gY29ubmVjdGVkQ2xpZW50LmNvbnRleHRHcm91cElkID09PSBjb250ZXh0R3JvdXBJZClcblx0ICAgICAgICAgICAgLm1hcCgoc3Vic2NyaXB0aW9uU3RhdGUpID0+IHtcblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvblN0YXRlLmNsaWVudElkZW50aXR5O1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBjbGllbnRzSW5Db250ZXh0R3JvdXA7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJlc3BvbnNpYmxlIGZvciBsYXVuY2hpbmcgb2YgYXBwbGljYXRpb25zIHRoYXQgY2FuIGhhbmRsZSBhIGdpdmVuIGludGVudCwgYW5kIGRlbGVnYXRpb24gb2YgaW50ZW50cyB0byB0aG9zZSBhcHBsaWNhdGlvbnMuXG5cdCAgICAgKiBNdXN0IGJlIG92ZXJyaWRkZW4uXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgVG8gbWFrZSB0aGlzIGNhbGwgRkRDMy1Db21wbGlhbnQgaXQgd291bGQgbmVlZCB0byByZXR1cm4gYW4gSW50ZW50UmVzb2x1dGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogaW50ZXJmYWNlIEludGVudFJlc29sdXRpb24ge1xuXHQgICAgICogICBzb3VyY2U6IFRhcmdldEFwcDtcblx0ICAgICAqICAgLy8gZGVwcmVjYXRlZCwgbm90IGFzc2lnbmFibGUgZnJvbSBpbnRlbnQgbGlzdGVuZXJzXG5cdCAgICAgKiAgIGRhdGE/OiBvYmplY3Q7XG5cdCAgICAgKiAgIHZlcnNpb246IHN0cmluZztcblx0ICAgICAqIH1cblx0ICAgICAqIGBgYFxuXHQgICAgICpcblx0ICAgICAqIE1vcmUgaW5mb3JtYXRpb24gb24gdGhlIEludGVudFJlc29sdXRpb24gdHlwZSBjYW4gYmUgZm91bmQgaW4gdGhlIFtGREMzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZmRjMy5maW5vcy5vcmcvZG9jcy9hcGkvcmVmL0ludGVudFJlc29sdXRpb24pLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBpbnRlbnQgVGhlIGNvbWJpbmF0aW9uIG9mIGFuIGFjdGlvbiBhbmQgYSBjb250ZXh0IHRoYXQgaXMgcGFzc2VkIHRvIGFuIGFwcGxpY2F0aW9uIGZvciByZXNvbHV0aW9uLlxuXHQgICAgICogQHBhcmFtICBjbGllbnRJZGVudGl0eSBJZGVudGl0eSBvZiB0aGUgQ2xpZW50IG1ha2luZyB0aGUgcmVxdWVzdC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIC8vIG92ZXJyaWRlIGNhbGwgc28gd2Ugc2V0IGludGVudCB0YXJnZXQgYW5kIGNyZWF0ZSB2aWV3IHRoYXQgd2lsbCBoYW5kbGUgaXRcblx0ICAgICAqIGZpbi5QbGF0Zm9ybS5pbml0KHtcblx0ICAgICAqICAgICBpbnRlcm9wT3ZlcnJpZGU6IGFzeW5jIChJbnRlcm9wQnJva2VyKSA9PiB7XG5cdCAgICAgKiAgICAgICAgIGNsYXNzIE92ZXJyaWRlIGV4dGVuZHMgSW50ZXJvcEJyb2tlciB7XG5cdCAgICAgKiAgICAgICAgICAgICBhc3luYyBoYW5kbGVGaXJlZEludGVudChpbnRlbnQpIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICBzdXBlci5zZXRJbnRlbnRUYXJnZXQoaW50ZW50LCB7IHV1aWQ6ICdwbGF0Zm9ybS11dWlkJywgbmFtZTogJ2ludGVudC12aWV3JyB9KTtcblx0ICAgICAqICAgICAgICAgICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50U3luYygpO1xuXHQgICAgICogICAgICAgICAgICAgICAgIGNvbnN0IHdpbiA9IGZpbi5XaW5kb3cud3JhcFN5bmMoeyBuYW1lOiAnZm9vJywgdXVpZDogJ3BsYXRmb3JtLXV1aWQnIH0pO1xuXHQgICAgICogICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRWaWV3ID0gYXdhaXQgcGxhdGZvcm0uY3JlYXRlVmlldyh7IHVybDogJ2h0dHA6Ly9vcGVuZmluLmNvJywgbmFtZTogJ2ludGVudC12aWV3JyB9LCB3aW4uaWRlbnRpdHkpO1xuXHQgICAgICogICAgICAgICAgICAgfVxuXHQgICAgICogICAgICAgICB9XG5cdCAgICAgKiAgICAgICAgIHJldHVybiBuZXcgT3ZlcnJpZGUoKTtcblx0ICAgICAqICAgICB9XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuXHQgICAgYXN5bmMgaGFuZGxlRmlyZWRJbnRlbnQoaW50ZW50LCBjbGllbnRJZGVudGl0eSAvLyBUT0RPKENPUkUtODExKTogcmVtb3ZlIGlubGluZSBpbnRlcnNlY3RlZCB0eXBlXG5cdCAgICApIHtcblx0ICAgICAgICBjb25zdCB3YXJuaW5nID0gKDAsIHV0aWxzXzEuZ2VuZXJhdGVPdmVycmlkZVdhcm5pbmcpKCdmZGMzLnJhaXNlSW50ZW50JywgJ0ludGVyb3BCcm9rZXIuaGFuZGxlRmlyZWRJbnRlbnQnLCBjbGllbnRJZGVudGl0eSwgJ2ludGVyb3BDbGllbnQuZmlyZUludGVudCcpO1xuXHQgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5CUk9LRVJfRVJST1JTLmZpcmVJbnRlbnQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGluIHtAbGluayBJbnRlcm9wQnJva2VyI2hhbmRsZUZpcmVkSW50ZW50IEludGVyb3BCcm9rZXIuaGFuZGxlRmlyZWRJbnRlbnR9LlxuXHQgICAgICogV2hpbGUgaGFuZGxlRmlyZWRJbnRlbnQgaXMgcmVzcG9uc2libGUgZm9yIGxhdW5jaGluZyBhcHBsaWNhdGlvbnMsIHNldEludGVudFRhcmdldCBpcyB1c2VkIHRvIHRlbGwgdGhlIEludGVyb3BCcm9rZXIgd2hpY2ggYXBwbGljYXRpb24gc2hvdWxkIHJlY2VpdmUgdGhlIGludGVudCB3aGVuIGl0IGlzIHJlYWR5LlxuXHQgICAgICogQHBhcmFtIGludGVudCBUaGUgY29tYmluYXRpb24gb2YgYW4gYWN0aW9uIGFuZCBhIGNvbnRleHQgdGhhdCBpcyBwYXNzZWQgdG8gYW4gYXBwbGljYXRpb24gZm9yIHJlc29sdXRpb24uXG5cdCAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gSWRlbnRpdHkgb2YgdGhlIHRhcmdldCB0aGF0IHdpbGwgaGFuZGxlIHRoZSBpbnRlbnQuXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBhc3luYyBzZXRJbnRlbnRUYXJnZXQoaW50ZW50LCB0YXJnZXQpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1icm9rZXItc2V0LWludGVudC10YXJnZXQnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIHRoaXMgaXMgb25seSBmb3IgYXBpIGFuYWx5dGljcyBwdXJwb3Nlc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGNvbnN0IHRhcmdldEluZm8gPSB0aGlzLmludGVudENsaWVudE1hcC5nZXQodGFyZ2V0Lm5hbWUpO1xuXHQgICAgICAgIGNvbnN0IGhhbmRsZXJJZCA9IGBpbnRlbnQtaGFuZGxlci0ke2ludGVudC5uYW1lfWA7XG5cdCAgICAgICAgaWYgKCF0YXJnZXRJbmZvKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW50ZW50Q2xpZW50TWFwLnNldCh0YXJnZXQubmFtZSwgbmV3IE1hcCgpKTtcblx0ICAgICAgICAgICAgY29uc3QgbmV3SGFuZGxlckluZm9NYXAgPSB0aGlzLmludGVudENsaWVudE1hcC5nZXQodGFyZ2V0Lm5hbWUpO1xuXHQgICAgICAgICAgICBpZiAobmV3SGFuZGxlckluZm9NYXApIHtcblx0ICAgICAgICAgICAgICAgIG5ld0hhbmRsZXJJbmZvTWFwLnNldChoYW5kbGVySWQsIHsgaXNSZWFkeTogZmFsc2UsIHBlbmRpbmdJbnRlbnRzOiBbaW50ZW50XSB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgY29uc3QgaGFuZGxlckluZm8gPSB0YXJnZXRJbmZvLmdldChoYW5kbGVySWQpO1xuXHQgICAgICAgICAgICBpZiAoIWhhbmRsZXJJbmZvKSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXRJbmZvLnNldChoYW5kbGVySWQsIHsgaXNSZWFkeTogZmFsc2UsIHBlbmRpbmdJbnRlbnRzOiBbaW50ZW50XSB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXJJbmZvLnBlbmRpbmdJbnRlbnRzLnB1c2goaW50ZW50KTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYW5kbGVySW5mby5jbGllbnRJZGVudGl0eSAmJiBoYW5kbGVySW5mby5pc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjbGllbnRJZGVudGl0eSwgcGVuZGluZ0ludGVudHMgfSA9IGhhbmRsZXJJbmZvO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVudFRvU2VuZCA9IHBlbmRpbmdJbnRlbnRzW3BlbmRpbmdJbnRlbnRzLmxlbmd0aCAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmludm9rZUludGVudEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgaW50ZW50VG9TZW5kKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckluZm8ucGVuZGluZ0ludGVudHMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGludm9raW5nIGludGVudCBoYW5kbGVyIGZvciBjbGllbnQgJHtjbGllbnRJZGVudGl0eS51dWlkfS8ke2NsaWVudElkZW50aXR5Lm5hbWV9LyR7Y2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZH1gKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckluZm8uaXNSZWFkeSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmVzcG9uc2libGUgZm9yIHJldHVybmluZyBpbmZvcm1hdGlvbiBvbiBhIHBhcnRpY3VsYXIgSW50ZW50LlxuXHQgICAgICpcblx0ICAgICAqIEByZW1hcmtzIFdoZW5ldmVyIEludGVyb3BDbGllbnQuZ2V0SW5mb0ZvckludGVudCBpcyBjYWxsZWQgdGhpcyBmdW5jdGlvbiB3aWxsIGZpcmUuIFRoZSBvcHRpb25zIGFyZ3VtZW50IGdpdmVzIHlvdVxuXHQgICAgICogYWNjZXNzIHRvIHRoZSBpbnRlbnQgbmFtZSBhbmQgYW55IG9wdGlvbmFsIGNvbnRleHQgdGhhdCB3YXMgcGFzc2VkIGFuZCBjbGllbnRJZGVudGl0eSBpcyB0aGUgaWRlbnRpdHkgb2YgdGhlIGNsaWVudFxuXHQgICAgICogdGhhdCBtYWRlIHRoZSBjYWxsLiBJZGVhbGx5IGhlcmUgeW91IHdvdWxkIGZldGNoIHRoZSBpbmZvIGZvciB0aGUgaW50ZW50IGFuZCByZXR1cm4gaXQgd2l0aCB0aGUgc2hhcGUgdGhhdCB0aGVcblx0ICAgICAqIEludGVyb3BDbGllbnQuZ2V0SW5mb0ZvckludGVudCBjYWxsIGlzIGV4cGVjdGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBUbyBtYWtlIHRoaXMgY2FsbCBGREMzLUNvbXBsaWFudCBpdCB3b3VsZCBuZWVkIHRvIHJldHVybiBhbiBBcHAgSW50ZW50OlxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiAvLyB7XG5cdCAgICAgKiAvLyAgICAgaW50ZW50OiB7IG5hbWU6IFwiU3RhcnRDaGF0XCIsIGRpc3BsYXlOYW1lOiBcIkNoYXRcIiB9LFxuXHQgICAgICogLy8gICAgIGFwcHM6IFt7IG5hbWU6IFwiU2t5cGVcIiB9LCB7IG5hbWU6IFwiU3ltcGhvbnlcIiB9LCB7IG5hbWU6IFwiU2xhY2tcIiB9XVxuXHQgICAgICogLy8gfVxuXHQgICAgICogYGBgXG5cdCAgICAgKlxuXHQgICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgQXBwSW50ZW50IHR5cGUgY2FuIGJlIGZvdW5kIGluIHRoZSBbRkRDMyBkb2N1bWVudGF0aW9uXShodHRwczovL2ZkYzMuZmlub3Mub3JnL2RvY3MvYXBpL3JlZi9BcHBJbnRlbnQpLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBvcHRpb25zXG5cdCAgICAgKiBAcGFyYW0gY2xpZW50SWRlbnRpdHkgSWRlbnRpdHkgb2YgdGhlIENsaWVudCBtYWtpbmcgdGhlIHJlcXVlc3QuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBmaW4uUGxhdGZvcm0uaW5pdCh7XG5cdCAgICAgKiAgICAgaW50ZXJvcE92ZXJyaWRlOiBhc3luYyAoSW50ZXJvcEJyb2tlcikgPT4ge1xuXHQgICAgICogICAgICAgICBjbGFzcyBPdmVycmlkZSBleHRlbmRzIEludGVyb3BCcm9rZXIge1xuXHQgICAgICogICAgICAgICAgICAgYXN5bmMgaGFuZGxlSW5mb0ZvckludGVudChvcHRpb25zLCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICogICAgICAgICAgICAgICAgIC8vIFlvdXIgY29kZSBnb2VzIGhlcmUuXG5cdCAgICAgKiAgICAgICAgICAgICB9XG5cdCAgICAgKiAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgcmV0dXJuIG5ldyBPdmVycmlkZSgpO1xuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cdCAgICBhc3luYyBoYW5kbGVJbmZvRm9ySW50ZW50KG9wdGlvbnMsIGNsaWVudElkZW50aXR5IC8vIFRPRE8oQ09SRS04MTEpOiByZW1vdmUgaW5saW5lIGludGVyc2VjdGVkIHR5cGVcblx0ICAgICkge1xuXHQgICAgICAgIGNvbnN0IHdhcm5pbmcgPSAoMCwgdXRpbHNfMS5nZW5lcmF0ZU92ZXJyaWRlV2FybmluZykoJ2ZkYzMuZmluZEludGVudCcsICdJbnRlcm9wQnJva2VyLmhhbmRsZUluZm9Gb3JJbnRlbnQnLCBjbGllbnRJZGVudGl0eSwgJ2ludGVyb3BDbGllbnQuZ2V0SW5mb0ZvckludGVudCcpO1xuXHQgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5CUk9LRVJfRVJST1JTLmdldEluZm9Gb3JJbnRlbnQpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNwb25zaWJsZSBmb3IgcmV0dXJuaW5nIGluZm9ybWF0aW9uIG9uIHdoaWNoIEludGVudHMgYXJlIG1lYW50IHRvIGhhbmRsZSBhIHNwZWNpZmljIENvbnRleHQuXG5cdCAgICAgKiBNdXN0IGJlIG92ZXJyaWRkZW4uXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgUmVzcG9uc2libGUgZm9yIHJldHVybmluZyBpbmZvcm1hdGlvbiBvbiB3aGljaCBJbnRlbnRzIGFyZSBtZWFudCB0byBoYW5kbGUgYSBzcGVjaWZpYyBDb250ZXh0LiBNdXN0IGJlIG92ZXJyaWRkZW4uXG5cdCAgICAgKlxuXHQgICAgICogV2hlbmV2ZXIgSW50ZXJvcENsaWVudC5nZXRJbmZvRm9ySW50ZW50c0J5Q29udGV4dCBpcyBjYWxsZWQgdGhpcyBmdW5jdGlvbiB3aWxsIGZpcmUuIFRoZSBjb250ZXh0IGFyZ3VtZW50IGdpdmVzIHlvdSBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgdGhhdCB0aGUgY2xpZW50IHdhbnRzIGluZm9ybWF0aW9uIG9uIGFuZCBjbGllbnRJZGVudGl0eSBpcyB0aGUgaWRlbnRpdHkgb2YgdGhlIGNsaWVudCB0aGF0IG1hZGUgdGhlIGNhbGwuIElkZWFsbHkgaGVyZSB5b3Ugd291bGQgZmV0Y2ggdGhlIGluZm8gZm9yIGFueSBpbnRlbnQgdGhhdCBjYW4gaGFuZGxlIGFuZCByZXR1cm4gaXQgd2l0aCB0aGUgc2hhcGUgdGhhdCB0aGUgSW50ZXJvcENsaWVudC5nZXRJbmZvRm9ySW50ZW50c0J5Q29udGV4dCBjYWxsIGlzIGV4cGVjdGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBUbyBtYWtlIHRoaXMgY2FsbCBGREMzLUNvbXBsaWFudCBpdCB3b3VsZCBuZWVkIHRvIHJldHVybiBhbiBhcnJheSBvZiBBcHBJbnRlbnRzOlxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiAvLyBbe1xuXHQgICAgICogLy8gICAgIGludGVudDogeyBuYW1lOiBcIlN0YXJ0Q2FsbFwiLCBkaXNwbGF5TmFtZTogXCJDYWxsXCIgfSxcblx0ICAgICAqIC8vICAgICBhcHBzOiBbeyBuYW1lOiBcIlNreXBlXCIgfV1cblx0ICAgICAqIC8vIH0sXG5cdCAgICAgKiAvLyB7XG5cdCAgICAgKiAvLyAgICAgaW50ZW50OiB7IG5hbWU6IFwiU3RhcnRDaGF0XCIsIGRpc3BsYXlOYW1lOiBcIkNoYXRcIiB9LFxuXHQgICAgICogLy8gICAgIGFwcHM6IFt7IG5hbWU6IFwiU2t5cGVcIiB9LCB7IG5hbWU6IFwiU3ltcGhvbnlcIiB9LCB7IG5hbWU6IFwiU2xhY2tcIiB9XVxuXHQgICAgICogLy8gfV07XG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBNb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBBcHBJbnRlbnQgdHlwZSBjYW4gYmUgZm91bmQgaW4gdGhlIFtGREMzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZmRjMy5maW5vcy5vcmcvZG9jcy9hcGkvcmVmL0FwcEludGVudCkuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGNvbnRleHQgRGF0YSBwYXNzZWQgYmV0d2VlbiBlbnRpdGllcyBhbmQgYXBwbGljYXRpb25zLlxuXHQgICAgICogQHBhcmFtIGNsaWVudElkZW50aXR5IElkZW50aXR5IG9mIHRoZSBDbGllbnQgbWFraW5nIHRoZSByZXF1ZXN0LlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogZmluLlBsYXRmb3JtLmluaXQoe1xuXHQgICAgICogICAgIGludGVyb3BPdmVycmlkZTogYXN5bmMgKEludGVyb3BCcm9rZXIpID0+IHtcblx0ICAgICAqICAgICAgICAgY2xhc3MgT3ZlcnJpZGUgZXh0ZW5kcyBJbnRlcm9wQnJva2VyIHtcblx0ICAgICAqICAgICAgICAgICAgIGFzeW5jIGhhbmRsZUluZm9Gb3JJbnRlbnRzQnlDb250ZXh0KGNvbnRleHQsIGNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgKiAgICAgICAgICAgICAgICAgLy8gWW91ciBjb2RlIGdvZXMgaGVyZS5cblx0ICAgICAqICAgICAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgfVxuXHQgICAgICogICAgICAgICByZXR1cm4gbmV3IE92ZXJyaWRlKCk7XG5cdCAgICAgKiAgICAgfVxuXHQgICAgICogfSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblx0ICAgIGFzeW5jIGhhbmRsZUluZm9Gb3JJbnRlbnRzQnlDb250ZXh0KGNvbnRleHQsIGNsaWVudElkZW50aXR5IC8vIFRPRE8oQ09SRS04MTEpOiByZW1vdmUgaW5saW5lIGludGVyc2VjdGVkIHR5cGVcblx0ICAgICkge1xuXHQgICAgICAgIGNvbnN0IHdhcm5pbmcgPSAoMCwgdXRpbHNfMS5nZW5lcmF0ZU92ZXJyaWRlV2FybmluZykoJ2ZkYzMuZmluZEludGVudHNCeUNvbnRleHQnLCAnSW50ZXJvcEJyb2tlci5oYW5kbGVJbmZvRm9ySW50ZW50c0J5Q29udGV4dCcsIGNsaWVudElkZW50aXR5LCAnaW50ZXJvcENsaWVudC5nZXRJbmZvRm9ySW50ZW50c0J5Q29udGV4dCcpO1xuXHQgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5CUk9LRVJfRVJST1JTLmdldEluZm9Gb3JJbnRlbnRzQnlDb250ZXh0KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmVzcG9uc2libGUgZm9yIHJlc29sdmluZyBhbiBJbnRlbnQgYmFzZWQgb24gYSBzcGVjaWZpYyBDb250ZXh0LlxuXHQgICAgICogTXVzdCBiZSBvdmVycmlkZGVuLlxuXHQgICAgICpcblx0ICAgICAqIEByZW1hcmtzIFdoZW5ldmVyIEludGVyb3BDbGllbnQuZmlyZUludGVudEZvckNvbnRleHQgaXMgY2FsbGVkIHRoaXMgZnVuY3Rpb24gd2lsbCBmaXJlLiBUaGUgY29udGV4dEZvckludGVudCBhcmd1bWVudFxuXHQgICAgICogZ2l2ZXMgeW91IGFjY2VzcyB0byB0aGUgY29udGV4dCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgdG8gYW4gaW50ZW50LiBJdCBhbHNvIGNhbiBvcHRpb25hbGx5IGNvbnRhaW4gYW55IG1ldGFkYXRhIHJlbGV2YW50XG5cdCAgICAgKiB0byByZXNvbHZpbmcgaXQsIGxpa2UgYSBzcGVjaWZpYyBhcHAgdGhlIGNsaWVudCB3YW50cyB0aGUgY29udGV4dCB0byBiZSBoYW5kbGVkIGJ5LiBUaGUgY2xpZW50SWRlbnRpdHkgaXMgdGhlIGlkZW50aXR5XG5cdCAgICAgKiBvZiB0aGUgY2xpZW50IHRoYXQgbWFkZSB0aGUgY2FsbC5cblx0ICAgICAqXG5cdCAgICAgKiBUbyBtYWtlIHRoaXMgY2FsbCBGREMzLUNvbXBsaWFudCBpdCB3b3VsZCBuZWVkIHRvIHJldHVybiBhbiBJbnRlbnRSZXNvbHV0aW9uOlxuXHQgICAgICpcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiAvLyB7XG5cdCAgICAgKiAvLyAgICAgaW50ZW50OiB7IG5hbWU6IFwiU3RhcnRDaGF0XCIsIGRpc3BsYXlOYW1lOiBcIkNoYXRcIiB9LFxuXHQgICAgICogLy8gICAgIGFwcHM6IFt7IG5hbWU6IFwiU2t5cGVcIiB9LCB7IG5hbWU6IFwiU3ltcGhvbnlcIiB9LCB7IG5hbWU6IFwiU2xhY2tcIiB9XVxuXHQgICAgICogLy8gfVxuXHQgICAgICogYGBgXG5cdCAgICAgKlxuXHQgICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgSW50ZW50UmVzb2x1dGlvbiB0eXBlIGNhbiBiZSBmb3VuZCBpbiB0aGUgW0ZEQzMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzL2FwaS9yZWYvTWV0YWRhdGEjaW50ZW50cmVzb2x1dGlvbikuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGNvbnRleHRGb3JJbnRlbnQgRGF0YSBwYXNzZWQgYmV0d2VlbiBlbnRpdGllcyBhbmQgYXBwbGljYXRpb25zLlxuXHQgICAgICogQHBhcmFtIGNsaWVudElkZW50aXR5IElkZW50aXR5IG9mIHRoZSBDbGllbnQgbWFraW5nIHRoZSByZXF1ZXN0LlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogZmluLlBsYXRmb3JtLmluaXQoe1xuXHQgICAgICogICAgIGludGVyb3BPdmVycmlkZTogYXN5bmMgKEludGVyb3BCcm9rZXIpID0+IHtcblx0ICAgICAqICAgICAgICAgY2xhc3MgT3ZlcnJpZGUgZXh0ZW5kcyBJbnRlcm9wQnJva2VyIHtcblx0ICAgICAqICAgICAgICAgICAgIGFzeW5jIGhhbmRsZUZpcmVkSW50ZW50Rm9yQ29udGV4dChjb250ZXh0Rm9ySW50ZW50LCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICogICAgICAgICAgICAgICAgIC8vIFlvdXIgY29kZSBnb2VzIGhlcmUuXG5cdCAgICAgKiAgICAgICAgICAgICB9XG5cdCAgICAgKiAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgcmV0dXJuIG5ldyBPdmVycmlkZSgpO1xuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cdCAgICBhc3luYyBoYW5kbGVGaXJlZEludGVudEZvckNvbnRleHQoY29udGV4dEZvckludGVudCwgY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBjb25zdCB3YXJuaW5nID0gKDAsIHV0aWxzXzEuZ2VuZXJhdGVPdmVycmlkZVdhcm5pbmcpKCdmZGMzLnJhaXNlSW50ZW50Rm9yQ29udGV4dCcsICdJbnRlcm9wQnJva2VyLmhhbmRsZUZpcmVkSW50ZW50Rm9yQ29udGV4dCcsIGNsaWVudElkZW50aXR5LCAnaW50ZXJvcENsaWVudC5maXJlSW50ZW50Rm9yQ29udGV4dCcpO1xuXHQgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5CUk9LRVJfRVJST1JTLmZpcmVJbnRlbnRGb3JDb250ZXh0KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUHJvdmlkZXMgdGhlIGlkZW50aXR5IG9mIGFueSBJbnRlcm9wIENsaWVudCB0aGF0IGRpc2Nvbm5lY3RzIGZyb20gdGhlIEludGVyb3AgQnJva2VyLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4uXG5cdCAgICAgKiBAcGFyYW0gY2xpZW50SWRlbnRpdHlcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogYGBganNcblx0ICAgICAqIGZpbi5QbGF0Zm9ybS5pbml0KHtcblx0ICAgICAqICAgICBpbnRlcm9wT3ZlcnJpZGU6IGFzeW5jIChJbnRlcm9wQnJva2VyKSA9PiB7XG5cdCAgICAgKiAgICAgICAgIGNsYXNzIE92ZXJyaWRlIGV4dGVuZHMgSW50ZXJvcEJyb2tlciB7XG5cdCAgICAgKiAgICAgICAgICAgICBhc3luYyBjbGllbnREaXNjb25uZWN0ZWQoY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IGNsaWVudElkZW50aXR5O1xuXHQgICAgICogICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDbGllbnQgd2l0aCBpZGVudGl0eSAke3V1aWR9LyR7bmFtZX0gaGFzIGJlZW4gZGlzY29ubmVjdGVkYCk7XG5cdCAgICAgKiAgICAgICAgICAgICB9XG5cdCAgICAgKiAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgcmV0dXJuIG5ldyBPdmVycmlkZSgpO1xuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cdCAgICBhc3luYyBjbGllbnREaXNjb25uZWN0ZWQoY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbiBjaGFubmVsLm9uRGlzY29ubmVjdGlvbi5cblx0ICAgICAgICAvLyBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuIHRvIGluZm9ybSB3aGVuIGFuIEludGVyb3AgQ2xpZW50IGhhcyBiZWVuIGRpc2Nvbm5lY3RlZC5cblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmVzcG9uc2libGUgZm9yIHJlc29sdmluZyBhbiBmZGMzLm9wZW4gY2FsbC5cblx0ICAgICAqIE11c3QgYmUgb3ZlcnJpZGRlbi5cblx0ICAgICAqIEBwYXJhbSBmZGMzT3Blbk9wdGlvbnMgZmRjMy5vcGVuIG9wdGlvbnNcblx0ICAgICAqIEBwYXJhbSBjbGllbnRJZGVudGl0eSBJZGVudGl0eSBvZiB0aGUgQ2xpZW50IG1ha2luZyB0aGUgcmVxdWVzdC5cblx0ICAgICAqL1xuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblx0ICAgIGFzeW5jIGZkYzNIYW5kbGVPcGVuKHsgYXBwLCBjb250ZXh0IH0sIGNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgY29uc3Qgd2FybmluZyA9ICgwLCB1dGlsc18xLmdlbmVyYXRlT3ZlcnJpZGVXYXJuaW5nKSgnZmRjMy5vcGVuJywgJ0ludGVyb3BCcm9rZXIuZmRjM0hhbmRsZU9wZW4nLCBjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkJST0tFUl9FUlJPUlMuZmRjM09wZW4pO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNwb25zaWJsZSBmb3IgcmVzb2x2aW5nIHRoZSBmZGMzLmZpbmRJbnN0YW5jZXMgY2FsbC5cblx0ICAgICAqIE11c3QgYmUgb3ZlcnJpZGRlblxuXHQgICAgICogQHBhcmFtIGFwcCBBcHBJZGVudGlmaWVyIHRoYXQgd2FzIHBhc3NlZCB0byBmZGMzLmZpbmRJbnN0YW5jZXNcblx0ICAgICAqIEBwYXJhbSBjbGllbnRJZGVudGl0eSBJZGVudGl0eSBvZiB0aGUgQ2xpZW50IG1ha2luZyB0aGUgcmVxdWVzdC5cblx0ICAgICAqL1xuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblx0ICAgIGFzeW5jIGZkYzNIYW5kbGVGaW5kSW5zdGFuY2VzKGFwcCwgY2xpZW50SWRlbnRpdHkpIHtcblx0ICAgICAgICBjb25zdCB3YXJuaW5nID0gKDAsIHV0aWxzXzEuZ2VuZXJhdGVPdmVycmlkZVdhcm5pbmcpKCdmZGMzLm9wZW4nLCAnSW50ZXJvcEJyb2tlci5mZGMzSGFuZGxlRmluZEluc3RhbmNlcycsIGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuQlJPS0VSX0VSUk9SUy5mZGMzRmluZEluc3RhbmNlcyk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJlc3BvbnNpYmxlIGZvciByZXNvbHZpbmcgdGhlIGZkYzMuZ2V0QXBwTWV0YWRhdGEgY2FsbC5cblx0ICAgICAqIE11c3QgYmUgb3ZlcnJpZGRlblxuXHQgICAgICogQHBhcmFtIGFwcCBBcHBJZGVudGlmaWVyIHRoYXQgd2FzIHBhc3NlZCB0byBmZGMzLmdldEFwcE1ldGFkYXRhXG5cdCAgICAgKiBAcGFyYW0gY2xpZW50SWRlbnRpdHkgSWRlbnRpdHkgb2YgdGhlIENsaWVudCBtYWtpbmcgdGhlIHJlcXVlc3QuXG5cdCAgICAgKi9cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cdCAgICBhc3luYyBmZGMzSGFuZGxlR2V0QXBwTWV0YWRhdGEoYXBwLCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIGNvbnN0IHdhcm5pbmcgPSAoMCwgdXRpbHNfMS5nZW5lcmF0ZU92ZXJyaWRlV2FybmluZykoJ2ZkYzMuZ2V0QXBwTWV0YWRhdGEnLCAnSW50ZXJvcEJyb2tlci5mZGMzSGFuZGxlR2V0QXBwTWV0YWRhdGEnLCBjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkJST0tFUl9FUlJPUlMuZmRjM0dldEFwcE1ldGFkYXRhKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIEludGVyb3AgQnJva2VyIHdoZW5ldmVyIGEgQ29udGV4dCBoYW5kbGVyIHdvdWxkIGZpcmUuXG5cdCAgICAgKiBGb3IgRkRDMyAyLjAgeW91IHdvdWxkIG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBhbmQgYWRkIHRoZSBjb250ZXh0TWV0YWRhdGEgYXNcblx0ICAgICAqIHBhcnQgb2YgdGhlIENvbnRleHQgb2JqZWN0LiBUaGVuIHdvdWxkIHlvdSBuZWVkIHRvIGNhbGxcblx0ICAgICAqIHN1cGVyLmludm9rZUNvbnRleHRIYW5kbGVyIHBhc3NpbmcgaXQgdGhpcyBuZXcgQ29udGV4dCBvYmplY3QgYWxvbmcgd2l0aCB0aGUgY2xpZW50SWRlbnRpdHkgYW5kIGhhbmRsZXJJZFxuXHQgICAgICogQHBhcmFtIGNsaWVudElkZW50aXR5XG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlcklkXG5cdCAgICAgKiBAcGFyYW0gY29udGV4dFxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogZmluLlBsYXRmb3JtLmluaXQoe1xuXHQgICAgICogICAgIGludGVyb3BPdmVycmlkZTogYXN5bmMgKEludGVyb3BCcm9rZXIpID0+IHtcblx0ICAgICAqICAgICAgICAgY2xhc3MgT3ZlcnJpZGUgZXh0ZW5kcyBJbnRlcm9wQnJva2VyIHtcblx0ICAgICAqICAgICAgICAgICAgIGFzeW5jIGludm9rZUNvbnRleHRIYW5kbGVyKGNsaWVudElkZW50aXR5LCBoYW5kbGVySWQsIGNvbnRleHQpIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuaW52b2tlQ29udGV4dEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwge1xuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAuLi5jb250ZXh0LFxuXHQgICAgICogICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWV0YWRhdGE6IHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZToge1xuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcElkOiAnb3BlbmZpbi1hcHAnLFxuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQ6ICczRDU0RDQ1NkQ5SFQwJ1xuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICogICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgKiAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgKiAgICAgICAgICAgICB9XG5cdCAgICAgKiAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgcmV0dXJuIG5ldyBPdmVycmlkZSgpO1xuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIGludm9rZUNvbnRleHRIYW5kbGVyKGNsaWVudElkZW50aXR5LCBoYW5kbGVySWQsIGNvbnRleHQpIHtcblx0ICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBhd2FpdCBwcm92aWRlci5kaXNwYXRjaChjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGludm9raW5nIGNvbnRleHQgaGFuZGxlciAke2hhbmRsZXJJZH0gZm9yIGNvbnRleHQgdHlwZSAke2NvbnRleHQudHlwZX0gaW4gY2xpZW50ICR7Y2xpZW50SWRlbnRpdHkudXVpZH0vJHtjbGllbnRJZGVudGl0eS5uYW1lfS8ke2NsaWVudElkZW50aXR5LmVuZHBvaW50SWR9YCwgZXJyb3IpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIEludGVyb3AgQnJva2VyIHdoZW5ldmVyIGFuIEludGVudCBoYW5kbGVyIHdvdWxkIGZpcmUuXG5cdCAgICAgKiBGb3IgRkRDMyAyLjAgeW91IHdvdWxkIG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBhbmQgYWRkIHRoZSBjb250ZXh0TWV0YWRhdGEgYXNcblx0ICAgICAqIHBhcnQgb2YgdGhlIENvbnRleHQgb2JqZWN0IGluc2lkZSB0aGUgSW50ZW50IG9iamVjdC4gVGhlbiB3b3VsZCB5b3UgbmVlZCB0byBjYWxsXG5cdCAgICAgKiBzdXBlci5pbnZva2VJbnRlbnRIYW5kbGVyIHBhc3NpbmcgaXQgdGhpcyBuZXcgSW50ZW50IG9iamVjdCBhbG9uZyB3aXRoIHRoZSBjbGllbnRJZGVudGl0eSBhbmQgaGFuZGxlcklkXG5cdCAgICAgKiBAcGFyYW0gQ2xpZW50SWRlbnRpdHlcblx0ICAgICAqIEBwYXJhbSBoYW5kbGVySWRcblx0ICAgICAqIEBwYXJhbSBjb250ZXh0XG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBmaW4uUGxhdGZvcm0uaW5pdCh7XG5cdCAgICAgKiAgICAgaW50ZXJvcE92ZXJyaWRlOiBhc3luYyAoSW50ZXJvcEJyb2tlcikgPT4ge1xuXHQgICAgICogICAgICAgICBjbGFzcyBPdmVycmlkZSBleHRlbmRzIEludGVyb3BCcm9rZXIge1xuXHQgICAgICogICAgICAgICAgICAgYXN5bmMgaW52b2tlSW50ZW50SGFuZGxlcihjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0KSB7XG5cdCAgICAgKiAgICAgICAgICAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSBpbnRlbnQ7XG5cdCAgICAgKiAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmludm9rZUludGVudEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwge1xuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAuLi5pbnRlbnQsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbnRleHQsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWV0YWRhdGE6IHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwSWQ6ICdvcGVuZmluLWFwcCcsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQ6ICczRDU0RDQ1NkQ5SFQwJ1xuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICogICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICogICAgICAgICAgICAgfVxuXHQgICAgICogICAgICAgICB9XG5cdCAgICAgKiAgICAgICAgIHJldHVybiBuZXcgT3ZlcnJpZGUoKTtcblx0ICAgICAqICAgICB9XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBpbnZva2VJbnRlbnRIYW5kbGVyKGNsaWVudElkZW50aXR5LCBoYW5kbGVySWQsIGludGVudCkge1xuXHQgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuXHQgICAgICAgIGF3YWl0IHByb3ZpZGVyLmRpc3BhdGNoKGNsaWVudElkZW50aXR5LCBoYW5kbGVySWQsIGludGVudCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJlc3BvbnNpYmxlIGZvciByZXNvbHZpbmcgZmRjMy5nZXRJbmZvIGZvciBGREMzIDIuMFxuXHQgICAgICogV291bGQgbmVlZCB0byByZXR1cm4gdGhlIG9wdGlvbmFsRmVhdHVyZXMgYW5kIGFwcE1ldGFkYXRhIGZvciB0aGUge0BsaW5rIGh0dHBzOi8vZmRjMy5maW5vcy5vcmcvZG9jcy9hcGkvcmVmL01ldGFkYXRhI2ltcGxlbWVudGF0aW9ubWV0YWRhdGEgSW1wbGVtZW50YXRpb25NZXRhZGF0YX0uXG5cdCAgICAgKiBNdXN0IGJlIG92ZXJyaWRkZW4uXG5cdCAgICAgKiBAcGFyYW0gY2xpZW50SWRlbnRpdHlcblx0ICAgICAqXG5cdCAgICAgKi9cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cdCAgICBhc3luYyBmZGMzSGFuZGxlR2V0SW5mbyhwYXlsb2FkLCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIGNvbnN0IHsgZmRjM1ZlcnNpb24gfSA9IHBheWxvYWQ7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgZmRjM1ZlcnNpb24sXG5cdCAgICAgICAgICAgIC4uLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0ludGVyb3BCcm9rZXJfZmRjM0luZm8sIFwiZlwiKSxcblx0ICAgICAgICAgICAgb3B0aW9uYWxGZWF0dXJlczoge1xuXHQgICAgICAgICAgICAgICAgT3JpZ2luYXRpbmdBcHBNZXRhZGF0YTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBVc2VyQ2hhbm5lbE1lbWJlcnNoaXBBUElzOiB0cnVlXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGFwcE1ldGFkYXRhOiB7XG5cdCAgICAgICAgICAgICAgICBhcHBJZDogJycsXG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZUlkOiAnJ1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpbmZvIGZvciBlYWNoIEludGVyb3AgQ2xpZW50IGNvbm5lY3RlZCB0byB0aGUgSW50ZXJvcCBCcm9rZXIuXG5cdCAgICAgKlxuXHQgICAgICogRkRDMyAyLjA6IFVzZSB0aGUgZW5kcG9pbnRJZCBpbiB0aGUgQ2xpZW50SW5mbyBhcyB0aGUgaW5zdGFuY2VJZCB3aGVuIGdlbmVyYXRpbmdcblx0ICAgICAqIGFuIEFwcElkZW50aWZpZXIuXG5cdCAgICAgKlxuXHQgICAgICogQHJlbWFya3MgRkRDMyAyLjAgTm90ZTogV2hlbiBuZWVkaW5nIGFuIGluc3RhbmNlSWQgdG8gZ2VuZXJhdGUgYW4gQXBwSWRlbnRpZmllciB1c2UgdGhpcyBjYWxsIHRvXG5cdCAgICAgKiBnZXQgdGhlIGVuZHBvaW50SWQgYW5kIHVzZSBpdCBhcyB0aGUgaW5zdGFuY2VJZC4gSW4gdGhlIEV4YW1wbGUgYmVsb3cgd2Ugb3ZlcnJpZGUgaGFuZGxlRmlyZWRJbnRlbnRcblx0ICAgICAqIGFuZCB0aGVuIGNhbGwgc3VwZXIuZ2V0QWxsQ2xpZW50SW5mbyB0byBnZW5lcmF0ZSB0aGUgQXBwSWRlbnRpZmllciBmb3IgdGhlIEludGVudFJlc29sdXRpb24uXG5cdCAgICAgKlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBqc1xuXHQgICAgICogLy8gRkRDMyAyLjAgRXhhbXBsZTpcblx0ICAgICAqIGZpbi5QbGF0Zm9ybS5pbml0KHtcblx0ICAgICAqICAgICBpbnRlcm9wT3ZlcnJpZGU6IGFzeW5jIChJbnRlcm9wQnJva2VyLCAuLi5hcmdzKSA9PiB7XG5cdCAgICAgKiAgICAgICAgIGNsYXNzIE92ZXJyaWRlIGV4dGVuZHMgSW50ZXJvcEJyb2tlciB7XG5cdCAgICAgKiAgICAgICAgICAgICBhc3luYyBoYW5kbGVGaXJlZEludGVudChpbnRlbnQpIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICBzdXBlci5zZXRJbnRlbnRUYXJnZXQoaW50ZW50LCB7IHV1aWQ6ICdwbGF0Zm9ybS11dWlkJywgbmFtZTogJ2ludGVudC12aWV3JyB9KTtcblx0ICAgICAqICAgICAgICAgICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IGZpbi5QbGF0Zm9ybS5nZXRDdXJyZW50U3luYygpO1xuXHQgICAgICogICAgICAgICAgICAgICAgIGNvbnN0IHdpbiA9IGZpbi5XaW5kb3cud3JhcFN5bmMoeyBuYW1lOiAnZm9vJywgdXVpZDogJ3BsYXRmb3JtLXV1aWQnIH0pO1xuXHQgICAgICogICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRWaWV3ID0gYXdhaXQgcGxhdGZvcm0uY3JlYXRlVmlldyh7IHVybDogJ2h0dHA6Ly9vcGVuZmluLmNvJywgbmFtZTogJ2ludGVudC12aWV3JyB9LCB3aW4uaWRlbnRpdHkpO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgICAgICAgICAgICBjb25zdCBhbGxDbGllbnRJbmZvID0gYXdhaXQgc3VwZXIuZ2V0QWxsQ2xpZW50SW5mbygpO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgICAgICAgICAgICBjb25zdCBpbmZvRm9yVGFyZ2V0ID0gYWxsQ2xpZW50SW5mby5maW5kKChjbGllbnRJbmZvKSA9PiB7XG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRJbmZvLnV1aWQgPT09ICdwbGF0Zm9ybS11dWlkJyAmJiBjbGllbnRJbmZvLm5hbWUgPT09ICdpbnRlbnQtdmlldyc7XG5cdCAgICAgKiAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgYXBwSWQ6ICdpbnRlbnQtdmlldycsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQ6IGluZm9Gb3JUYXJnZXQuZW5kcG9pbnRJZFxuXHQgICAgICogICAgICAgICAgICAgICAgIH1cblx0ICAgICAqXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuXHQgICAgICogICAgICAgICAgICAgICAgICAgICBpbnRlbnQ6IGludGVudC5uYW1lXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgfVxuXHQgICAgICpcblx0ICAgICAqICAgICAgICAgICAgIH1cblx0ICAgICAqICAgICAgICAgfVxuXHQgICAgICogICAgICAgICByZXR1cm4gbmV3IE92ZXJyaWRlKC4uLmFyZ3MpO1xuXHQgICAgICogICAgIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICogYGBgXG5cdCAgICAgKi9cblx0ICAgIGFzeW5jIGdldEFsbENsaWVudEluZm8oKSB7XG5cdCAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG5cdCAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEFsbENsaWVudEluZm8oKTtcblx0ICAgIH1cblx0ICAgIC8qXG5cdCAgICBTbmFwc2hvdCBBUElzXG5cdCAgICAqL1xuXHQgICAgLy8gVXNlZCB0byBzYXZlIGludGVyb3AgYnJva2VyIHN0YXRlIGluIHNuYXBzaG90c1xuXHQgICAgZGVjb3JhdGVTbmFwc2hvdChzbmFwc2hvdCkge1xuXHQgICAgICAgIHJldHVybiB7IC4uLnNuYXBzaG90LCBpbnRlcm9wU25hcHNob3REZXRhaWxzOiB7IGNvbnRleHRHcm91cFN0YXRlczogdGhpcy5nZXRDb250ZXh0R3JvdXBTdGF0ZXMoKSB9IH07XG5cdCAgICB9XG5cdCAgICAvLyBVc2VkIHRvIHJlc3RvcmUgaW50ZXJvcCBicm9rZXIgc3RhdGUgaW4gc25hcHNob3RzLlxuXHQgICAgYXBwbHlTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuXHQgICAgICAgIGNvbnN0IGNvbnRleHRHcm91cFN0YXRlcyA9IHNuYXBzaG90Py5pbnRlcm9wU25hcHNob3REZXRhaWxzPy5jb250ZXh0R3JvdXBTdGF0ZXM7XG5cdCAgICAgICAgaWYgKGNvbnRleHRHcm91cFN0YXRlcykge1xuXHQgICAgICAgICAgICBpZiAoIW9wdGlvbnM/LmNsb3NlRXhpc3RpbmdXaW5kb3dzKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4aXN0aW5nQ2xpZW50cyhjb250ZXh0R3JvdXBTdGF0ZXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMucmVoeWRyYXRlQ29udGV4dEdyb3VwU3RhdGVzKGNvbnRleHRHcm91cFN0YXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdXBkYXRlRXhpc3RpbmdDbGllbnRzKGNvbnRleHRHcm91cFN0YXRlcykge1xuXHQgICAgICAgIGNvbnN0IGNsaWVudHMgPSB0aGlzLmludGVyb3BDbGllbnRzO1xuXHQgICAgICAgIGNsaWVudHMuZm9yRWFjaCgoc3ViU3RhdGUpID0+IHtcblx0ICAgICAgICAgICAgY29uc3QgeyBjbGllbnRJZGVudGl0eSwgY29udGV4dEdyb3VwSWQsIGNvbnRleHRIYW5kbGVycyB9ID0gc3ViU3RhdGU7XG5cdCAgICAgICAgICAgIGlmIChjb250ZXh0R3JvdXBJZCkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBDb250ZXh0cyA9IGNvbnRleHRHcm91cFN0YXRlc1tjb250ZXh0R3JvdXBJZF07XG5cdCAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFssIGNvbnRleHRdIG9mIE9iamVjdC5lbnRyaWVzKGdyb3VwQ29udGV4dHMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGV4dEhhbmRsZXJzLmZvckVhY2goKGNvbnRleHRIYW5kbGVyKSA9PiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFuZGxlcklkLCBjb250ZXh0VHlwZSB9ID0gY29udGV4dEhhbmRsZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJbnRlcm9wQnJva2VyLmlzQ29udGV4dFR5cGVDb21wYXRpYmxlKGNvbnRleHQudHlwZSwgY29udGV4dFR5cGUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludm9rZUNvbnRleHRIYW5kbGVyKGNsaWVudElkZW50aXR5LCBoYW5kbGVySWQsIGNvbnRleHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8vIFVzZWQgdG8gc3RvcmUgY29udGV4dCBncm91cCBzdGF0ZSBpbiBzbmFwc2hvdHNcblx0ICAgIGdldENvbnRleHRHcm91cFN0YXRlcygpIHtcblx0ICAgICAgICByZXR1cm4gSW50ZXJvcEJyb2tlci50b09iamVjdCh0aGlzLmNvbnRleHRHcm91cHNCeUlkKTtcblx0ICAgIH1cblx0ICAgIC8vIFVzZWQgdG8gcmVoeWRyYXRlIHRoZSBjb250ZXh0IHN0YXRlIGZyb20gYSBzbmFwc2hvdFxuXHQgICAgcmVoeWRyYXRlQ29udGV4dEdyb3VwU3RhdGVzKGluY29taW5nQ29udGV4dEdyb3VwU3RhdGVzKSB7XG5cdCAgICAgICAgY29uc3QgY29udGV4dEdyb3VwU3RhdGVzID0gT2JqZWN0LmVudHJpZXMoaW5jb21pbmdDb250ZXh0R3JvdXBTdGF0ZXMpO1xuXHQgICAgICAgIGZvciAoY29uc3QgW2NvbnRleHRHcm91cElkLCBjb250ZXh0c10gb2YgY29udGV4dEdyb3VwU3RhdGVzKSB7XG5cdCAgICAgICAgICAgIGNvbnN0IGNvbnRleHRPYmplY3RzID0gT2JqZWN0LmVudHJpZXMoY29udGV4dHMpO1xuXHQgICAgICAgICAgICBmb3IgKGNvbnN0IFtjb250ZXh0VHlwZSwgY29udGV4dF0gb2YgY29udGV4dE9iamVjdHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRHcm91cHNCeUlkLmhhcyhjb250ZXh0R3JvdXBJZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGV4dEdyb3VwU3RhdGUgPSB0aGlzLmNvbnRleHRHcm91cHNCeUlkLmdldChjb250ZXh0R3JvdXBJZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRHcm91cFN0YXRlLnNldChjb250ZXh0VHlwZSwgY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxvZ2ljIHdpbGwgY2hhbmdlIHdoZW4gZHluYW1pYyBjb250ZXh0IGdyb3VwIGNyZWF0aW9uIGNvbWVzIGluLlxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQXR0ZW1wdGluZyB0byBzZXQgYSBjb250ZXh0IGdyb3VwIHRoYXQgaXNuJ3QgaW4gdGhlIGNvbnRleHQgZ3JvdXAgbWFwcGluZy4gU2tpcHBpbmcgY29udGV4dCBncm91cCByZWh5ZHJhdGlvbiBmb3I6ICR7Y29udGV4dEdyb3VwSWR9YCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKlxuXHQgICAgSW50ZXJuYWwgQ29udGV4dCBIYW5kbGVyIEFQSXNcblx0ICAgICovXG5cdCAgICAvLyBVc2VkIHRvIGdpdmUgY29udGV4dCB0byBhIGNsaWVudCB0aGF0IGhhcyByZWdpc3RlcmVkIHRoZWlyIGNvbnRleHQgaGFuZGxlclxuXHQgICAgY29udGV4dEhhbmRsZXJSZWdpc3RlcmVkKHsgY29udGV4dFR5cGUsIGhhbmRsZXJJZCB9LCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIGNvbnN0IGhhbmRsZXJJbmZvID0geyBjb250ZXh0VHlwZSwgaGFuZGxlcklkIH07XG5cdCAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICBjbGllbnRTdGF0ZT8uY29udGV4dEhhbmRsZXJzLnNldChoYW5kbGVySWQsIGhhbmRsZXJJbmZvKTtcblx0ICAgICAgICBpZiAoY2xpZW50U3RhdGUgJiYgY2xpZW50U3RhdGUuY29udGV4dEdyb3VwSWQpIHtcblx0ICAgICAgICAgICAgY29uc3QgeyBjb250ZXh0R3JvdXBJZCB9ID0gY2xpZW50U3RhdGU7XG5cdCAgICAgICAgICAgIGNvbnN0IGNvbnRleHRHcm91cE1hcCA9IHRoaXMuY29udGV4dEdyb3Vwc0J5SWQuZ2V0KGNvbnRleHRHcm91cElkKTtcblx0ICAgICAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhpcyBzaW5nbGUgaGFuZGxlciBhbGwgb2YgdGhlIGNvbnRleHQsIGJlY2F1c2UgaXQgYWNjZXB0cyBhbGwuXG5cdCAgICAgICAgICAgICAgICBjb250ZXh0R3JvdXBNYXAuZm9yRWFjaCgoY29udGV4dCwgXykgPT4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlQ29udGV4dEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0R3JvdXBNYXAuaGFzKGNvbnRleHRUeXBlKSkge1xuXHQgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dEZvclR5cGUgPSBjb250ZXh0R3JvdXBNYXAuZ2V0KGNvbnRleHRUeXBlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Rm9yVHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlQ29udGV4dEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY29udGV4dEZvclR5cGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblx0ICAgIGFzeW5jIGludGVudEhhbmRsZXJSZWdpc3RlcmVkKHBheWxvYWQsIGNsaWVudElkZW50aXR5KSB7XG5cdCAgICAgICAgY29uc3QgeyBoYW5kbGVySWQgfSA9IHBheWxvYWQ7XG5cdCAgICAgICAgY29uc3QgY2xpZW50SW50ZW50SW5mbyA9IHRoaXMuaW50ZW50Q2xpZW50TWFwLmdldChjbGllbnRJZGVudGl0eS5uYW1lKTtcblx0ICAgICAgICBjb25zdCBoYW5kbGVySW5mbyA9IGNsaWVudEludGVudEluZm8/LmdldChoYW5kbGVySWQpO1xuXHQgICAgICAgIGlmICghY2xpZW50SW50ZW50SW5mbykge1xuXHQgICAgICAgICAgICB0aGlzLmludGVudENsaWVudE1hcC5zZXQoY2xpZW50SWRlbnRpdHkubmFtZSwgbmV3IE1hcCgpKTtcblx0ICAgICAgICAgICAgY29uc3QgbmV3SGFuZGxlckluZm9NYXAgPSB0aGlzLmludGVudENsaWVudE1hcC5nZXQoY2xpZW50SWRlbnRpdHkubmFtZSk7XG5cdCAgICAgICAgICAgIGlmIChuZXdIYW5kbGVySW5mb01hcCkge1xuXHQgICAgICAgICAgICAgICAgbmV3SGFuZGxlckluZm9NYXAuc2V0KGhhbmRsZXJJZCwgeyBpc1JlYWR5OiB0cnVlLCBwZW5kaW5nSW50ZW50czogW10sIGNsaWVudElkZW50aXR5IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKCFoYW5kbGVySW5mbykge1xuXHQgICAgICAgICAgICBjbGllbnRJbnRlbnRJbmZvLnNldChoYW5kbGVySWQsIHsgaXNSZWFkeTogdHJ1ZSwgcGVuZGluZ0ludGVudHM6IFtdLCBjbGllbnRJZGVudGl0eSB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNvbnN0IHsgcGVuZGluZ0ludGVudHMgfSA9IGhhbmRsZXJJbmZvO1xuXHQgICAgICAgICAgICBoYW5kbGVySW5mby5jbGllbnRJZGVudGl0eSA9IGNsaWVudElkZW50aXR5O1xuXHQgICAgICAgICAgICBoYW5kbGVySW5mby5pc1JlYWR5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nSW50ZW50cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZW50VG9TZW5kID0gcGVuZGluZ0ludGVudHNbcGVuZGluZ0ludGVudHMubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbnZva2VJbnRlbnRIYW5kbGVyKGNsaWVudElkZW50aXR5LCBoYW5kbGVySWQsIGludGVudFRvU2VuZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFuZGxlckluZm8ucGVuZGluZ0ludGVudHMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGludm9raW5nIGludGVudCBoYW5kbGVyOiAke2hhbmRsZXJJZH0gZm9yIGNsaWVudCAke2NsaWVudElkZW50aXR5LnV1aWR9LyR7Y2xpZW50SWRlbnRpdHkubmFtZX0vJHtjbGllbnRJZGVudGl0eS5lbmRwb2ludElkfWApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gVXNlZCB0byByZW1vdmUgYSBjb250ZXh0IGhhbmRsZXIgZm9yIGEgY2xpZW50XG5cdCAgICByZW1vdmVDb250ZXh0SGFuZGxlcih7IGhhbmRsZXJJZCB9LCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgaWYgKGNsaWVudFN0YXRlKSB7XG5cdCAgICAgICAgICAgIGNsaWVudFN0YXRlLmNvbnRleHRIYW5kbGVycy5kZWxldGUoaGFuZGxlcklkKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBoYW5kbGVKb2luU2Vzc2lvbkNvbnRleHRHcm91cCh7IHNlc3Npb25Db250ZXh0R3JvdXBJZCB9LCBjbGllbnRJZGVudGl0eSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGlmICghc2Vzc2lvbkNvbnRleHRHcm91cElkKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBqb2luIHNlc3Npb24gY29udGV4dCBncm91cDogbXVzdCBzcGVjaWZ5IGdyb3VwIGlkLicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Db250ZXh0R3JvdXAgPSB0aGlzLnNlc3Npb25Db250ZXh0R3JvdXBNYXAuZ2V0KHNlc3Npb25Db250ZXh0R3JvdXBJZCk7XG5cdCAgICAgICAgICAgIGlmIChzZXNzaW9uQ29udGV4dEdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICBzZXNzaW9uQ29udGV4dEdyb3VwLnJlZ2lzdGVyTmV3Q2xpZW50KGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Nlc3Npb25Db250ZXh0R3JvdXBCcm9rZXIgPSBuZXcgU2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlcl8xLmRlZmF1bHQodGhpcy5jaGFubmVsLCBzZXNzaW9uQ29udGV4dEdyb3VwSWQpO1xuXHQgICAgICAgICAgICAgICAgbmV3U2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlci5yZWdpc3Rlck5ld0NsaWVudChjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25Db250ZXh0R3JvdXBNYXAuc2V0KHNlc3Npb25Db250ZXh0R3JvdXBJZCwgbmV3U2Vzc2lvbkNvbnRleHRHcm91cEJyb2tlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHsgaGFzQ29uZmxpY3Q6IHRoaXMuY29udGV4dEdyb3Vwc0J5SWQuaGFzKHNlc3Npb25Db250ZXh0R3JvdXBJZCkgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLypcblx0ICAgIEludGVybmFsIFV0aWx0aWVzXG5cdCAgICAqL1xuXHQgICAgLy8gR2V0dGVyIGZvciBpbnRlcm9wIGluZm8gZm9yIGEgY2xpZW50LlxuXHQgICAgZ2V0Q2xpZW50U3RhdGUoaWQpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm9wQ2xpZW50cy5nZXQoaWQuZW5kcG9pbnRJZCk7XG5cdCAgICB9XG5cdCAgICAvLyBVdGlsIGZvciBnZXRDb250ZXh0R3JvdXBTdGF0ZXMuIFNlcmlhbGl6ZXMgdGhlIGNvbnRleHRHcm91cFN0YXRlcyBvYmplY3Qgc28gd2UgY2FuIHN0b3JlIGl0LlxuXHQgICAgc3RhdGljIHRvT2JqZWN0KG1hcCkge1xuXHQgICAgICAgIGNvbnN0IG9iamVjdEZyb21NYXAgPSBPYmplY3QuZnJvbUVudHJpZXMobWFwKTtcblx0ICAgICAgICBjb25zdCBuZXdPYmplY3QgPSB7fTtcblx0ICAgICAgICBPYmplY3QuZW50cmllcyhvYmplY3RGcm9tTWFwKS5mb3JFYWNoKChbY29udGV4dEdyb3VwSWQsIGNvbnRleHRNYXBdKSA9PiB7XG5cdCAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHRPYmplY3QgPSBPYmplY3QuZnJvbUVudHJpZXMoY29udGV4dE1hcCk7XG5cdCAgICAgICAgICAgIG5ld09iamVjdFtjb250ZXh0R3JvdXBJZF0gPSBuZXdDb250ZXh0T2JqZWN0O1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBuZXdPYmplY3Q7XG5cdCAgICB9XG5cdCAgICBzdGF0aWMgY2hlY2tDb250ZXh0SW50ZWdyaXR5KGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoIWNvbnRleHQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIHJlYXNvbjogJ05vIGNvbnRleHQgc3VwcGxpZWQnIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIHJlYXNvbjogJ0NvbnRleHQgbXVzdCBiZSBhbiBPYmplY3QnIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY29udGV4dC50eXBlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCByZWFzb246ICdDb250ZXh0IG11c3QgaGF2ZSBhIHR5cGUgcHJvcGVydHknIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb250ZXh0LmlkICYmIHR5cGVvZiBjb250ZXh0LmlkICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICByZWFzb246ICdDb250ZXh0IGlkIG11c3QgYmUgYW4gT2JqZWN0IHBvcHVsYXRlZCB3aXRoIGtleS12YWx1ZSBpZGVudGlmaWVycyAoaWYgc2V0KSdcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbnRleHQuaWQpIHtcblx0ICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gY29udGV4dDtcblx0ICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlkKTtcblx0ICAgICAgICAgICAgbGV0IGZvdW5kQmFkSWRlbnRpZmllciA9IGZhbHNlO1xuXHQgICAgICAgICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgcmVhc29uOiAnQ29udGV4dCBpZCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGtleS12YWx1ZSBpZGVudGlmaWVyJyB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGlkW2tleV0gIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm91bmRCYWRJZGVudGlmaWVyID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlmIChmb3VuZEJhZElkZW50aWZpZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCByZWFzb246ICdDb250ZXh0IGlkIGtleS12YWx1ZSBpZGVudGlmaWVycyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nJyB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb250ZXh0Lm5hbWUgJiYgdHlwZW9mIGNvbnRleHQubmFtZSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIHJlYXNvbjogJ0NvbnRleHQgbmFtZSBtdXN0IGJlIG9mIHN0cmluZyB0eXBlIChpZiBzZXQpJyB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG5cdCAgICB9XG5cdCAgICAvLyBVdGlsIHRvIGNoZWNrIGEgY2xpZW50IGlkZW50aXR5LlxuXHQgICAgc3RhdGljIGhhc0VuZHBvaW50SWQodGFyZ2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIHRhcmdldC5lbmRwb2ludElkICE9PSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICAvLyBVdGlsIHRvIGNoZWNrIGlmIHdlIHNob3VsZCBzZW5kIGEgY29udGV4dCB0byBhIGhhbmRsZXIuXG5cdCAgICBzdGF0aWMgaXNDb250ZXh0VHlwZUNvbXBhdGlibGUoY29udGV4dFR5cGUsIHJlZ2lzdGVyZWRDb250ZXh0VHlwZSkge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgcmVnaXN0ZXJlZENvbnRleHRUeXBlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0VHlwZSA9PT0gcmVnaXN0ZXJlZENvbnRleHRUeXBlO1xuXHQgICAgfVxuXHQgICAgLy8gU2V0dXAgZnVuY3Rpb24gZm9yIHN0YXRlIG1hcHBpbmdcblx0ICAgIHNldENvbnRleHRHcm91cE1hcCgpIHtcblx0ICAgICAgICAvLyBUaGlzIHdheSwgaWYgYSB1c2VyIG92ZXJyaWRlcyB0aGlzLmdldENvbnRleHRHcm91cHMsIGl0J3MgcmVmbGVjdGVkIGluIHRoZSBjb250ZXh0R3JvdXBNYXBwaW5nLlxuXHQgICAgICAgIGZvciAoY29uc3QgY29udGV4dEdyb3VwSW5mbyBvZiB0aGlzLmdldENvbnRleHRHcm91cHMoKSkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHRHcm91cHNCeUlkLnNldChjb250ZXh0R3JvdXBJbmZvLmlkLCBuZXcgTWFwKCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGFzeW5jIHNldEN1cnJlbnRDb250ZXh0R3JvdXBJbkNsaWVudE9wdGlvbnMoY2xpZW50SWRlbnRpdHksIGNvbnRleHRHcm91cElkKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY29uc3QgZW50aXR5SW5mbyA9IGF3YWl0IHRoaXMuZmluLlN5c3RlbS5nZXRFbnRpdHlJbmZvKGNsaWVudElkZW50aXR5LnV1aWQsIGNsaWVudElkZW50aXR5Lm5hbWUpO1xuXHQgICAgICAgICAgICBsZXQgZW50aXR5O1xuXHQgICAgICAgICAgICBpZiAoZW50aXR5SW5mby5lbnRpdHlUeXBlID09PSAndmlldycpIHtcblx0ICAgICAgICAgICAgICAgIGVudGl0eSA9IGF3YWl0IHRoaXMuZmluLlZpZXcud3JhcChjbGllbnRJZGVudGl0eSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoZW50aXR5SW5mby5lbnRpdHlUeXBlID09PSAnd2luZG93Jykge1xuXHQgICAgICAgICAgICAgICAgZW50aXR5ID0gYXdhaXQgdGhpcy5maW4uV2luZG93LndyYXAoY2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChlbnRpdHkpIHtcblx0ICAgICAgICAgICAgICAgIGF3YWl0IGVudGl0eS51cGRhdGVPcHRpb25zKHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnRlcm9wOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0R3JvdXA6IGNvbnRleHRHcm91cElkXG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIC8vICBNYXkgZmlsZSBpbiBpbnRlcm9wXG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgYXN5bmMgc2V0dXBDaGFubmVsUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcblx0ICAgICAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcblx0ICAgICAgICAgICAgdGhpcy53aXJlQ2hhbm5lbChjaGFubmVsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igc2V0dGluZyB1cCBJbnRlcm9wIEJyb2tlciBDaGFubmVsIFByb3ZpZGVyOiAke2Vycm9yfWApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIFNldHVwIENoYW5uZWwgQ29ubmVjdGlvbiBMb2dpY1xuXHQgICAgd2lyZUNoYW5uZWwoY2hhbm5lbCkge1xuXHQgICAgICAgIGNoYW5uZWwub25Db25uZWN0aW9uKGFzeW5jIChjbGllbnRJZGVudGl0eSwgLy8gVE9ETyhDT1JFLTgxMSk6IHJlbW92ZSBpbmxpbmUgaW50ZXJzZWN0ZWQgdHlwZVxuXHQgICAgICAgIHBheWxvYWQpID0+IHtcblx0ICAgICAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5pc0Nvbm5lY3Rpb25BdXRob3JpemVkKGNsaWVudElkZW50aXR5LCBwYXlsb2FkKSkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgYXV0aG9yaXplZCBmb3IgJHtjbGllbnRJZGVudGl0eS51dWlkfSwgJHtjbGllbnRJZGVudGl0eS5uYW1lfWApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIHRvbyBvbGQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIEludGVyb3AuIFBsZWFzZSB1cGdyYWRlIHlvdXIgcnVudGltZSB0byBhIG1vcmUgcmVjZW50IHZlcnNpb24uJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUgPSB7XG5cdCAgICAgICAgICAgICAgICBjb250ZXh0R3JvdXBJZDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgICAgICAgY29udGV4dEhhbmRsZXJzOiBuZXcgTWFwKCksXG5cdCAgICAgICAgICAgICAgICBjbGllbnRJZGVudGl0eVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAvLyBPbmx5IGFsbG93IHRoZSBjbGllbnQgdG8gam9pbiBhIGNvbnRleHRHcm91cCB0aGF0IGFjdHVhbGx5IGV4aXN0cy5cblx0ICAgICAgICAgICAgaWYgKHBheWxvYWQ/LmN1cnJlbnRDb250ZXh0R3JvdXAgJiYgdGhpcy5jb250ZXh0R3JvdXBzQnlJZC5oYXMocGF5bG9hZC5jdXJyZW50Q29udGV4dEdyb3VwKSkge1xuXHQgICAgICAgICAgICAgICAgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUuY29udGV4dEdyb3VwSWQgPSBwYXlsb2FkPy5jdXJyZW50Q29udGV4dEdyb3VwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuaW50ZXJvcENsaWVudHMuc2V0KGNsaWVudElkZW50aXR5LmVuZHBvaW50SWQsIGNsaWVudFN1YnNjcmlwdGlvblN0YXRlKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjaGFubmVsLm9uRGlzY29ubmVjdGlvbigoY2xpZW50SWRlbnRpdHkpID0+IHtcblx0ICAgICAgICAgICAgdGhpcy5pbnRlcm9wQ2xpZW50cy5kZWxldGUoY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHRhcmdldEluZm8gPSB0aGlzLmludGVudENsaWVudE1hcC5nZXQoY2xpZW50SWRlbnRpdHkubmFtZSk7XG5cdCAgICAgICAgICAgIGlmICh0YXJnZXRJbmZvICYmIGNsaWVudElkZW50aXR5LnV1aWQgPT09IHRoaXMuZmluLm1lLnV1aWQpIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldEluZm8uZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuaXNSZWFkeSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uQ29udGV4dEdyb3VwTWFwLmZvckVhY2goKHNlc3Npb25Db250ZXh0R3JvdXApID0+IHtcblx0ICAgICAgICAgICAgICAgIHNlc3Npb25Db250ZXh0R3JvdXAub25EaXNjb25uZWN0aW9uKGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuY2xpZW50RGlzY29ubmVjdGVkKGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjaGFubmVsLmJlZm9yZUFjdGlvbihhc3luYyAoYWN0aW9uLCBwYXlsb2FkLCBjbGllbnRJZGVudGl0eSkgPT4ge1xuXHQgICAgICAgICAgICBpZiAoIShhd2FpdCB0aGlzLmlzQWN0aW9uQXV0aG9yaXplZChhY3Rpb24sIHBheWxvYWQsIGNsaWVudElkZW50aXR5KSkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uICgke2FjdGlvbn0pIG5vdCBhdXRob3JpemVkIGZvciAke2NsaWVudElkZW50aXR5LnV1aWR9LCAke2NsaWVudElkZW50aXR5Lm5hbWV9YCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2luZz8uYmVmb3JlQWN0aW9uPy5lbmFibGVkKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhY3Rpb24sIHBheWxvYWQsIGNsaWVudElkZW50aXR5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGNoYW5uZWwuYWZ0ZXJBY3Rpb24oKGFjdGlvbiwgcGF5bG9hZCwgY2xpZW50SWRlbnRpdHkpID0+IHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2luZz8uYWZ0ZXJBY3Rpb24/LmVuYWJsZWQpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFjdGlvbiwgcGF5bG9hZCwgY2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gQ2xpZW50IGZ1bmN0aW9uc1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ3NldENvbnRleHQnLCB0aGlzLnNldENvbnRleHQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgY2hhbm5lbC5yZWdpc3RlcignZmlyZUludGVudCcsIHRoaXMuaGFuZGxlRmlyZWRJbnRlbnQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgY2hhbm5lbC5yZWdpc3RlcignZ2V0Q3VycmVudENvbnRleHQnLCB0aGlzLmdldEN1cnJlbnRDb250ZXh0LmJpbmQodGhpcykpO1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2dldEluZm9Gb3JJbnRlbnQnLCB0aGlzLmhhbmRsZUluZm9Gb3JJbnRlbnQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgY2hhbm5lbC5yZWdpc3RlcignZ2V0SW5mb0ZvckludGVudHNCeUNvbnRleHQnLCB0aGlzLmhhbmRsZUluZm9Gb3JJbnRlbnRzQnlDb250ZXh0LmJpbmQodGhpcykpO1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2ZpcmVJbnRlbnRGb3JDb250ZXh0JywgdGhpcy5oYW5kbGVGaXJlZEludGVudEZvckNvbnRleHQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgLy8gUGxhdGZvcm0gd2luZG93IGZ1bmN0aW9uc1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2dldENvbnRleHRHcm91cHMnLCB0aGlzLmdldENvbnRleHRHcm91cHMuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgY2hhbm5lbC5yZWdpc3Rlcignam9pbkNvbnRleHRHcm91cCcsIHRoaXMuam9pbkNvbnRleHRHcm91cC5iaW5kKHRoaXMpKTtcblx0ICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdyZW1vdmVGcm9tQ29udGV4dEdyb3VwJywgdGhpcy5yZW1vdmVGcm9tQ29udGV4dEdyb3VwLmJpbmQodGhpcykpO1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2dldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCcsIHRoaXMuZ2V0QWxsQ2xpZW50c0luQ29udGV4dEdyb3VwLmJpbmQodGhpcykpO1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2dldEluZm9Gb3JDb250ZXh0R3JvdXAnLCB0aGlzLmdldEluZm9Gb3JDb250ZXh0R3JvdXAuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kc1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2NvbnRleHRIYW5kbGVyUmVnaXN0ZXJlZCcsIHRoaXMuY29udGV4dEhhbmRsZXJSZWdpc3RlcmVkLmJpbmQodGhpcykpO1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2ludGVudEhhbmRsZXJSZWdpc3RlcmVkJywgdGhpcy5pbnRlbnRIYW5kbGVyUmVnaXN0ZXJlZC5iaW5kKHRoaXMpKTtcblx0ICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdyZW1vdmVDb250ZXh0SGFuZGxlcicsIHRoaXMucmVtb3ZlQ29udGV4dEhhbmRsZXIuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgY2hhbm5lbC5yZWdpc3Rlcignc2Vzc2lvbkNvbnRleHRHcm91cDpjcmVhdGVJZk5lZWRlZCcsIHRoaXMuaGFuZGxlSm9pblNlc3Npb25Db250ZXh0R3JvdXAuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgLy8gZmRjMyBvbmx5IG1ldGhvZHNcblx0ICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdmZGMzT3BlbicsIHRoaXMuZmRjM0hhbmRsZU9wZW4uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgY2hhbm5lbC5yZWdpc3RlcignZmRjM3YyRmluZEludGVudHNCeUNvbnRleHQnLCB0aGlzLmhhbmRsZUluZm9Gb3JJbnRlbnRzQnlDb250ZXh0LmJpbmQodGhpcykpO1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2ZkYzNGaW5kSW5zdGFuY2VzJywgdGhpcy5mZGMzSGFuZGxlRmluZEluc3RhbmNlcy5iaW5kKHRoaXMpKTtcblx0ICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdmZGMzR2V0QXBwTWV0YWRhdGEnLCB0aGlzLmZkYzNIYW5kbGVHZXRBcHBNZXRhZGF0YS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdmZGMzdjJHZXRJbmZvJywgYXN5bmMgKHBheWxvYWQsIGNsaWVudElkZW50aXR5KSA9PiB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZkYzNIYW5kbGVHZXRJbmZvLmJpbmQodGhpcykocGF5bG9hZCwgY2xpZW50SWRlbnRpdHkpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2NyZWF0ZVByaXZhdGVDaGFubmVsUHJvdmlkZXInLCBhc3luYyAocGF5bG9hZCkgPT4ge1xuXHQgICAgICAgICAgICBjb25zdCB7IGNoYW5uZWxJZCB9ID0gcGF5bG9hZDtcblx0ICAgICAgICAgICAgY29uc3QgY2hhbm5lbFByb3ZpZGVyID0gYXdhaXQgdGhpcy5maW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNyZWF0ZShjaGFubmVsSWQpO1xuXHQgICAgICAgICAgICBQcml2YXRlQ2hhbm5lbFByb3ZpZGVyXzEuUHJpdmF0ZUNoYW5uZWxQcm92aWRlci5pbml0KGNoYW5uZWxQcm92aWRlciwgY2hhbm5lbElkKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQ2FuIGJlIHVzZWQgdG8gY29tcGxldGVseSBwcmV2ZW50IGEgY29ubmVjdGlvbi4gUmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgY29ubmVjdGlvbnMuIEFsbG93cyBhbGwgY29ubmVjdGlvbnMgYnkgZGVmYXVsdC5cblx0ICAgICAqIEBwYXJhbSBfaWQgdGhlIGlkZW50aXR5IHRyeWluYyB0byBjb25uZWN0XG5cdCAgICAgKiBAcGFyYW0gX2Nvbm5lY3Rpb25QYXlsb2FkIG9wdGlvbmFsIHBheWxvYWQgdG8gdXNlIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMsIHdpbGwgYmUgdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0ICAgICAqL1xuXHQgICAgaXNDb25uZWN0aW9uQXV0aG9yaXplZChfaWQsIF9jb25uZWN0aW9uUGF5bG9hZCkge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1pcy1jb25uZWN0aW9uLWF1dGhvcml6ZWQnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBDYWxsZWQgYmVmb3JlIGV2ZXJ5IGFjdGlvbiB0byBjaGVjayBpZiB0aGlzIGVudGl0eSBzaG91bGQgYmUgYWxsb3dlZCB0byB0YWtlIHRoZSBhY3Rpb24uXG5cdCAgICAgKiBSZXR1cm4gZmFsc2UgdG8gcHJldmVudCB0aGUgYWN0aW9uXG5cdCAgICAgKiBAcGFyYW0gX2FjdGlvbiB0aGUgc3RyaW5nIGFjdGlvbiB0byBhdXRob3JpemUgaW4gY2FtZWwgY2FzZVxuXHQgICAgICogQHBhcmFtIF9wYXlsb2FkIHRoZSBkYXRhIGJlaW5nIHNlbnQgZm9yIHRoaXMgYWN0aW9uXG5cdCAgICAgKiBAcGFyYW0gX2lkZW50aXR5IHRoZSBjb25uZWN0aW9uIGF0dGVtcHRpbmcgdG8gZGlzcGF0Y2ggdGhpcyBhY3Rpb25cblx0ICAgICAqL1xuXHQgICAgaXNBY3Rpb25BdXRob3JpemVkKF9hY3Rpb24sIF9wYXlsb2FkLCBfaWRlbnRpdHkpIHtcblx0ICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1icm9rZXItaXMtYWN0aW9uLWF1dGhvcml6ZWQnKS5jYXRjaCgoZSkgPT4ge1xuXHQgICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHQgICAgfVxuXHR9O1xuXHRJbnRlcm9wQnJva2VyLkludGVyb3BCcm9rZXIgPSBJbnRlcm9wQnJva2VyJDE7XG5cdF9JbnRlcm9wQnJva2VyX2ZkYzNJbmZvID0gbmV3IFdlYWtNYXAoKSwgX0ludGVyb3BCcm9rZXJfY29udGV4dEdyb3VwcyA9IG5ldyBXZWFrTWFwKCk7XG5cdHJldHVybiBJbnRlcm9wQnJva2VyO1xufVxuXG52YXIgSW50ZXJvcENsaWVudCQxID0ge307XG5cbnZhciBTZXNzaW9uQ29udGV4dEdyb3VwQ2xpZW50JDEgPSB7fTtcblxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX1Nlc3Npb25Db250ZXh0R3JvdXBDbGllbnRfY2xpZW50UHJvbWlzZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uQ29udGV4dEdyb3VwQ2xpZW50JDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmFzZV8xJDMgPSBiYXNlO1xuY29uc3QgdXRpbHNfMSQzID0gdXRpbHMkMTtcbmNsYXNzIFNlc3Npb25Db250ZXh0R3JvdXBDbGllbnQgZXh0ZW5kcyBiYXNlXzEkMy5CYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlLCBjbGllbnQsIGlkKSB7XG4gICAgICAgIHN1cGVyKHdpcmUpO1xuICAgICAgICBfU2Vzc2lvbkNvbnRleHRHcm91cENsaWVudF9jbGllbnRQcm9taXNlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMyh0aGlzLCBfU2Vzc2lvbkNvbnRleHRHcm91cENsaWVudF9jbGllbnRQcm9taXNlLCBjbGllbnQsIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGNvbnRleHQgZm9yIHRoZSBzZXNzaW9uIGNvbnRleHQgZ3JvdXAuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBOZXcgY29udGV4dCB0byBzZXQuXG4gICAgICpcbiAgICAgKiBAdHV0b3JpYWwgaW50ZXJvcC5zZXRDb250ZXh0XG4gICAgICovXG4gICAgYXN5bmMgc2V0Q29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLXNlc3Npb24tY29udGV4dC1ncm91cC1zZXQtY29udGV4dCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMyh0aGlzLCBfU2Vzc2lvbkNvbnRleHRHcm91cENsaWVudF9jbGllbnRQcm9taXNlLCBcImZcIik7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goYHNlc3Npb25Db250ZXh0R3JvdXA6c2V0Q29udGV4dC0ke3RoaXMuaWR9YCwge1xuICAgICAgICAgICAgc2Vzc2lvbkNvbnRleHRHcm91cElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3VycmVudENvbnRleHQodHlwZSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1zZXNzaW9uLWNvbnRleHQtZ3JvdXAtZ2V0LWNvbnRleHQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDModGhpcywgX1Nlc3Npb25Db250ZXh0R3JvdXBDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKGBzZXNzaW9uQ29udGV4dEdyb3VwOmdldENvbnRleHQtJHt0aGlzLmlkfWAsIHtcbiAgICAgICAgICAgIHNlc3Npb25Db250ZXh0R3JvdXBJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZENvbnRleHRIYW5kbGVyKGNvbnRleHRIYW5kbGVyLCBjb250ZXh0VHlwZSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1zZXNzaW9uLWNvbnRleHQtZ3JvdXAtYWRkLWhhbmRsZXInKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24tZnVuY3Rpb24gYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBmaXJzdCBwYXJhbWV0ZXIgJ2hhbmRsZXInLiBCZSBhd2FyZSB0aGF0IHRoZSBhcmd1bWVudCBvcmRlciBkb2VzIG5vdCBtYXRjaCB0aGUgRkRDMyBzdGFuZGFyZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQzKHRoaXMsIF9TZXNzaW9uQ29udGV4dEdyb3VwQ2xpZW50X2NsaWVudFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgbGV0IGhhbmRsZXJJZDtcbiAgICAgICAgaWYgKGNvbnRleHRUeXBlKSB7XG4gICAgICAgICAgICBoYW5kbGVySWQgPSBgc2Vzc2lvbkNvbnRleHRIYW5kbGVyOmludm9rZS0ke3RoaXMuaWR9LSR7Y29udGV4dFR5cGV9LSR7KDAsIHV0aWxzXzEkMy5nZW5lcmF0ZUlkKSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVySWQgPSBgc2Vzc2lvbkNvbnRleHRIYW5kbGVyOmludm9rZS0ke3RoaXMuaWR9YDtcbiAgICAgICAgfVxuICAgICAgICBjbGllbnQucmVnaXN0ZXIoaGFuZGxlcklkLCAoMCwgdXRpbHNfMSQzLndyYXBDb250ZXh0SGFuZGxlcikoY29udGV4dEhhbmRsZXIsIGhhbmRsZXJJZCkpO1xuICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goYHNlc3Npb25Db250ZXh0R3JvdXA6aGFuZGxlckFkZGVkLSR7dGhpcy5pZH1gLCB7IGhhbmRsZXJJZCwgY29udGV4dFR5cGUgfSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiBhd2FpdCB0aGlzLmNyZWF0ZVVuc3Vic2NyaWJlQ2IoaGFuZGxlcklkKSB9O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVVbnN1YnNjcmliZUNiKGhhbmRsZXJJZCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDModGhpcywgX1Nlc3Npb25Db250ZXh0R3JvdXBDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY2xpZW50LnJlbW92ZShoYW5kbGVySWQpO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmRpc3BhdGNoKGBzZXNzaW9uQ29udGV4dEdyb3VwOmhhbmRsZXJSZW1vdmVkLSR7dGhpcy5pZH1gLCB7IGhhbmRsZXJJZCB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0VXNlckluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBzZXRDb250ZXh0OiAoMCwgdXRpbHNfMSQzLndyYXBJblRyeUNhdGNoKSh0aGlzLnNldENvbnRleHQuYmluZCh0aGlzKSwgJ0ZhaWxlZCB0byBzZXQgY29udGV4dDogJyksXG4gICAgICAgICAgICBnZXRDdXJyZW50Q29udGV4dDogKDAsIHV0aWxzXzEkMy53cmFwSW5UcnlDYXRjaCkodGhpcy5nZXRDdXJyZW50Q29udGV4dC5iaW5kKHRoaXMpLCAnRmFpbGVkIHRvIGdldCBjb250ZXh0OiAnKSxcbiAgICAgICAgICAgIGFkZENvbnRleHRIYW5kbGVyOiAoMCwgdXRpbHNfMSQzLndyYXBJblRyeUNhdGNoKSh0aGlzLmFkZENvbnRleHRIYW5kbGVyLmJpbmQodGhpcyksICdGYWlsZWQgdG8gYWRkIGNvbnRleHQgaGFuZGxlcjogJylcbiAgICAgICAgfTtcbiAgICB9XG59XG5TZXNzaW9uQ29udGV4dEdyb3VwQ2xpZW50JDEuZGVmYXVsdCA9IFNlc3Npb25Db250ZXh0R3JvdXBDbGllbnQ7XG5fU2Vzc2lvbkNvbnRleHRHcm91cENsaWVudF9jbGllbnRQcm9taXNlID0gbmV3IFdlYWtNYXAoKTtcblxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMiA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSwgX0ludGVyb3BDbGllbnRfc2Vzc2lvbkNvbnRleHRHcm91cHM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJvcENsaWVudCQxLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbkludGVyb3BDbGllbnQkMS5JbnRlcm9wQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xJDIgPSBiYXNlO1xuY29uc3QgU2Vzc2lvbkNvbnRleHRHcm91cENsaWVudF8xID0gU2Vzc2lvbkNvbnRleHRHcm91cENsaWVudCQxO1xuY29uc3QgdXRpbHNfMSQyID0gdXRpbHMkMTtcbi8qKlxuICogVGhlIEludGVyb3AgQ2xpZW50IEFQSSBpcyBicm9rZW4gdXAgaW50byB0d28gZ3JvdXBzOlxuICpcbiAqICoqQ29udGVudCBGYWNpbmcgQVBJcyoqIC0gRm9yIEFwcGxpY2F0aW9uIERldmVsb3BlcnMgcHV0dGluZyBWaWV3cyBpbnRvIGEgUGxhdGZvcm0gV2luZG93LCB3aG8gY2FyZSBhYm91dCBDb250ZXh0LiBUaGVzZSBhcmUgQVBJcyB0aGF0IHNlbmQgb3V0IGFuZCByZWNlaXZlIHRoZSBDb250ZXh0IGRhdGEgdGhhdCBmbG93cyBiZXR3ZWVuIGFwcGxpY2F0aW9ucy4gVGhpbmsgb2YgdGhpcyBhcyB0aGUgV2F0ZXIgaW4gdGhlIEludGVyb3AgUGlwZXMuXG4gKlxuICogKipDb250ZXh0IEdyb3VwaW5nIEFQSXMqKiAtIEZvciBQbGF0Zm9ybSBEZXZlbG9wZXJzLCB0byBhZGQgYW5kIHJlbW92ZSBWaWV3cyB0byBhbmQgZnJvbSBDb250ZXh0IEdyb3Vwcy4gVGhlc2UgQVBJcyBhcmUgdXRpbGl6ZWQgdW5kZXItdGhlLWhvb2QgaW4gUGxhdGZvcm1zLCBzbyB0aGV5IGRvbid0IG5lZWQgdG8gYmUgdXNlZCB0byBwYXJ0aWNpcGF0ZSBpbiBJbnRlcm9wLiBUaGVzZSBhcmUgdGhlIEFQSXMgdGhhdCBkZWNpZGUgd2hpY2ggZW50aXRpZXMgdGhlIGNvbnRleHQgZGF0YSBmbG93cyBiZXR3ZWVuLiBUaGluayBvZiB0aGVzZSBhcyB0aGUgdmFsdmVzIG9yIHBpcGVzIHRoYXQgY29udHJvbCB0aGUgZmxvdyBvZiBDb250ZXh0IERhdGEgZm9yIEludGVyb3AuXG4gKlxuICogLS0tXG4gKlxuICogQWxsIEFQSXMgYXJlIGF2YWlsYWJsZSBhdCB0aGUgYGZpbi5tZS5pbnRlcm9wYCBuYW1lc3BhY2UuXG4gKlxuICogLS0tXG4gKlxuICogKipZb3Ugb25seSBuZWVkIDIgdGhpbmdzIHRvIHBhcnRpY2lwYXRlIGluIEludGVyb3AgQ29udGV4dCBHcm91cGluZzoqKlxuICogKiBBIENvbnRleHQgSGFuZGxlciBmb3IgaW5jb21pbmcgY29udGV4dDoge0BsaW5rIEludGVyb3BDbGllbnQjYWRkQ29udGV4dEhhbmRsZXIgYWRkQ29udGV4dEhhbmRsZXIoaGFuZGxlciwgY29udGV4dFR5cGU/KX1cbiAqICogQ2FsbCBzZXRDb250ZXh0IG9uIHlvdXIgY29udGV4dCBncm91cCB3aGVuIHlvdSB3YW50IHRvIHNoYXJlIGNvbnRleHQgd2l0aCBvdGhlciBncm91cCBtZW1iZXJzOiB7QGxpbmsgSW50ZXJvcENsaWVudCNzZXRDb250ZXh0IHNldENvbnRleHQoY29udGV4dCl9XG4gKlxuICogLS0tXG4gKlxuICogIyMjIyMgQ29uc3RydWN0b3JcbiAqIFJldHVybmVkIGJ5IHtAbGluayBJbnRlcm9wLmNvbm5lY3RTeW5jIEludGVyb3AuY29ubmVjdFN5bmN9LlxuICpcbiAqIC0tLVxuICpcbiAqICMjIyMjIEludGVyb3AgbWV0aG9kcyBpbnRlbmRlZCBmb3IgVmlld3NcbiAqXG4gKlxuICogKipDb250ZXh0IEdyb3VwcyBBUEkqKlxuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjYWRkQ29udGV4dEhhbmRsZXIgYWRkQ29udGV4dEhhbmRsZXIoaGFuZGxlciwgY29udGV4dFR5cGU/KX1cbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I3NldENvbnRleHQgc2V0Q29udGV4dChjb250ZXh0KX1cbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I2dldEN1cnJlbnRDb250ZXh0IGdldEN1cnJlbnRDb250ZXh0KGNvbnRleHRUeXBlPyl9XG4gKiAgKiB7QGxpbmsgSW50ZXJvcENsaWVudCNqb2luU2Vzc2lvbkNvbnRleHRHcm91cCBqb2luU2Vzc2lvbkNvbnRleHRHcm91cChzZXNzaW9uQ29udGV4dEdyb3VwSWQpfVxuICpcbiAqXG4gKiAqKkludGVudHMgQVBJKipcbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I2ZpcmVJbnRlbnQgZmlyZUludGVudChpbnRlbnQpfVxuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjcmVnaXN0ZXJJbnRlbnRIYW5kbGVyIHJlZ2lzdGVySW50ZW50SGFuZGxlcihpbnRlbnRIYW5kbGVyLCBpbnRlbnROYW1lKX1cbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I2dldEluZm9Gb3JJbnRlbnQgZ2V0SW5mb0ZvckludGVudChpbmZvRm9ySW50ZW50T3B0aW9ucyl9XG4gKiAgKiB7QGxpbmsgSW50ZXJvcENsaWVudCNnZXRJbmZvRm9ySW50ZW50c0J5Q29udGV4dCBnZXRJbmZvRm9ySW50ZW50c0J5Q29udGV4dChjb250ZXh0KX1cbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I2ZpcmVJbnRlbnRGb3JDb250ZXh0IGZpcmVJbnRlbnRGb3JDb250ZXh0KGNvbnRleHRGb3JJbnRlbnQpfVxuICpcbiAqICMjIyMjIEludGVyb3AgbWV0aG9kcyBpbnRlbmRlZCBmb3IgV2luZG93c1xuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjZ2V0Q29udGV4dEdyb3VwcyBnZXRDb250ZXh0R3JvdXBzKCl9XG4gKiAgKiB7QGxpbmsgSW50ZXJvcENsaWVudCNqb2luQ29udGV4dEdyb3VwIGpvaW5Db250ZXh0R3JvdXAoY29udGV4dEdyb3VwSWQsIHRhcmdldD8pfVxuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjcmVtb3ZlRnJvbUNvbnRleHRHcm91cCByZW1vdmVGcm9tQ29udGV4dEdyb3VwKHRhcmdldD8pfVxuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjZ2V0SW5mb0ZvckNvbnRleHRHcm91cCBnZXRJbmZvRm9yQ29udGV4dEdyb3VwKGNvbnRleHRHcm91cElkKX1cbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I2dldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCBnZXRBbGxDbGllbnRzSW5Db250ZXh0R3JvdXAoY29udGV4dEdyb3VwSWQpfVxuICpcbiAqL1xuY2xhc3MgSW50ZXJvcENsaWVudCBleHRlbmRzIGJhc2VfMSQyLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIG5hbWUsIGludGVyb3BDb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih3aXJlKTtcbiAgICAgICAgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0ludGVyb3BDbGllbnRfc2Vzc2lvbkNvbnRleHRHcm91cHMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMih0aGlzLCBfSW50ZXJvcENsaWVudF9zZXNzaW9uQ29udGV4dEdyb3VwcywgbmV3IE1hcCgpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMih0aGlzLCBfSW50ZXJvcENsaWVudF9jbGllbnRQcm9taXNlLCB0aGlzLndpcmUuZW52aXJvbm1lbnQud2hlblJlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNvbm5lY3QoYGludGVyb3AtYnJva2VyLSR7bmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogaW50ZXJvcENvbmZpZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgfVxuICAgIC8qXG4gICAgQ2xpZW50IEFQSXNcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBjb250ZXh0IGZvciB0aGUgY29udGV4dCBncm91cCBvZiB0aGUgY3VycmVudCBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBUaGUgZW50aXR5IG11c3QgYmUgcGFydCBvZiBhIGNvbnRleHQgZ3JvdXAgaW4gb3JkZXIgc2V0IGEgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gTmV3IGNvbnRleHQgdG8gc2V0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHNldEluc3RydW1lbnRDb250ZXh0ID0gYXN5bmMgKHRpY2tlcikgPT4ge1xuICAgICAqICAgICBmaW4ubWUuaW50ZXJvcC5zZXRDb250ZXh0KHt0eXBlOiAnaW5zdHJ1bWVudCcsIGlkOiB7dGlja2VyfX0pXG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gVGhlIHVzZXIgY2xpY2tzIGFuIGluc3RydW1lbnQgb2YgaW50ZXJlc3QuIFdlIHdhbnQgdG8gc2V0IHRoYXQgSW5zdHJ1bWVudCBjb250ZXh0IHNvIHRoYXQgdGhlIHJlc3Qgb2Ygb3VyIHdvcmtmbG93IHVwZGF0ZXMgd2l0aCBpbmZvcm1hdGlvbiBmb3IgdGhhdCBpbnN0cnVtZW50XG4gICAgICogaW5zdHJ1bWVudEVsZW1lbnQub24oJ2NsaWNrJywgKGV2dCkgPT4ge1xuICAgICAqICAgICBzZXRJbnN0cnVtZW50Q29udGV4dChldnQudGlja2VyKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2V0Q29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1zZXQtY29udGV4dCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMih0aGlzLCBfSW50ZXJvcENsaWVudF9jbGllbnRQcm9taXNlLCBcImZcIik7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ3NldENvbnRleHQnLCB7IGNvbnRleHQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnRleHQgaGFuZGxlciBmb3IgaW5jb21pbmcgY29udGV4dC4gSWYgYW4gZW50aXR5IGlzIHBhcnQgb2YgYSBjb250ZXh0IGdyb3VwLCBhbmQgdGhlbiBzZXRzIGl0cyBjb250ZXh0IGhhbmRsZXIsXG4gICAgICogaXQgd2lsbCByZWNlaXZlIGFsbCBvZiBpdHMgZGVjbGFyZWQgY29udGV4dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIEhhbmRsZXIgZm9yIGluY29taW5nIGNvbnRleHQuXG4gICAgICogQHBhcmFtIGNvbnRleHRUeXBlIC0gVGhlIHR5cGUgb2YgY29udGV4dCB5b3Ugd2lzaCB0byBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZnVuY3Rpb24gaGFuZGxlSW5jb21pbmdDb250ZXh0KGNvbnRleHRJbmZvKSB7XG4gICAgICogICAgIGNvbnN0IHsgdHlwZSwgaWQgfSA9IGNvbnRleHRJbmZvO1xuICAgICAqICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgKiAgICAgICAgIGNhc2UgJ2luc3RydW1lbnQnOlxuICAgICAqICAgICAgICAgICAgIGhhbmRsZUluc3RydW1lbnRDb250ZXh0KGNvbnRleHRJbmZvKTtcbiAgICAgKiAgICAgICAgICAgICBicmVhaztcbiAgICAgKiAgICAgICAgIGNhc2UgJ2NvdW50cnknOlxuICAgICAqICAgICAgICAgICAgIGhhbmRsZUNvdW50cnlDb250ZXh0KGNvbnRleHRJbmZvKTtcbiAgICAgKiAgICAgICAgICAgICBicmVhaztcbiAgICAgKlxuICAgICAqICAgICAgICAgZGVmYXVsdDpcbiAgICAgKiAgICAgICAgICAgICBicmVhaztcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaGFuZGxlSW5zdHJ1bWVudENvbnRleHQoY29udGV4dEluZm8pIHtcbiAgICAgKiAgICAgY29uc3QgeyB0eXBlLCBpZCB9ID0gY29udGV4dEluZm87XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjb250ZXh0SW5mbyBmb3IgaW5zdHJ1bWVudCcsIGNvbnRleHRJbmZvKVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGhhbmRsZUNvdW50cnlDb250ZXh0KGNvbnRleHRJbmZvKSB7XG4gICAgICogICAgIGNvbnN0IHsgdHlwZSwgaWQgfSA9IGNvbnRleHRJbmZvO1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY29udGV4dEluZm8gZm9yIGNvdW50cnknLCBjb250ZXh0SW5mbylcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmaW4ubWUuaW50ZXJvcC5hZGRDb250ZXh0SGFuZGxlcihoYW5kbGVJbmNvbWluZ0NvbnRleHQpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBXZSBhcmUgYWxzbyB0ZXN0aW5nIHRoZSBhYmlsaXR5IHRvIGFkZCBhIGNvbnRleHQgaGFuZGxlciBmb3Igc3BlY2lmaWMgY29udGV4dHMuIElmIHlvdSB3b3VsZCBsaWtlIHRvIHVzZVxuICAgICAqIHRoaXMsIHBsZWFzZSBtYWtlIHN1cmUgeW91IGFkZCB5b3VyIGNvbnRleHQgaGFuZGxlcnMgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIGFwcGxpY2F0aW9uLCBvbiBhIHBhZ2UgdGhhdFxuICAgICAqIGRvZXMgbm90IG5hdmlnYXRlL3JlbG9hZC9yZS1yZW5kZXIsIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy4gIFRoaXMgZmVhdHVyZSBpcyBleHBlcmltZW50YWw6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGZ1bmN0aW9uIGhhbmRsZUluc3RydW1lbnRDb250ZXh0KGNvbnRleHRJbmZvKSB7XG4gICAgICogICAgIGNvbnN0IHsgdHlwZSwgaWQgfSA9IGNvbnRleHRJbmZvO1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY29udGV4dEluZm8gZm9yIGluc3RydW1lbnQnLCBjb250ZXh0SW5mbylcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBoYW5kbGVDb3VudHJ5Q29udGV4dChjb250ZXh0SW5mbykge1xuICAgICAqICAgICBjb25zdCB7IHR5cGUsIGlkIH0gPSBjb250ZXh0SW5mbztcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NvbnRleHRJbmZvIGZvciBjb3VudHJ5JywgY29udGV4dEluZm8pXG4gICAgICogfVxuICAgICAqXG4gICAgICpcbiAgICAgKiBmaW4ubWUuaW50ZXJvcC5hZGRDb250ZXh0SGFuZGxlcihoYW5kbGVJbnN0cnVtZW50Q29udGV4dCwgJ2luc3RydW1lbnQnKVxuICAgICAqIGZpbi5tZS5pbnRlcm9wLmFkZENvbnRleHRIYW5kbGVyKGhhbmRsZUNvdW50cnlDb250ZXh0LCAnY291bnRyeScpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgYWRkQ29udGV4dEhhbmRsZXIoaGFuZGxlciwgY29udGV4dFR5cGUpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY2xpZW50LWFkZC1jb250ZXh0LWhhbmRsZXInKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1mdW5jdGlvbiBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGZpcnN0IHBhcmFtZXRlciAnaGFuZGxlcicuIEJlIGF3YXJlIHRoYXQgdGhlIGFyZ3VtZW50IG9yZGVyIGRvZXMgbm90IG1hdGNoIHRoZSBGREMzIHN0YW5kYXJkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDIodGhpcywgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICBsZXQgaGFuZGxlcklkO1xuICAgICAgICBpZiAoY29udGV4dFR5cGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJJZCA9IGBpbnZva2VDb250ZXh0SGFuZGxlci0ke2NvbnRleHRUeXBlfS0keygwLCB1dGlsc18xJDIuZ2VuZXJhdGVJZCkoKX1gO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBCeSBwcm92aWRpbmcgYSBjb250ZXh0VHlwZSAoJHtjb250ZXh0VHlwZX0pLCB5b3UgYXJlIHVzaW5nIHRoZSBleHBlcmltZW50YWwgYWRkQ29udGV4dEhhbmRsZXIuIFRvIGF2b2lkIGlzc3VlcywgbWFrZSBzdXJlIHlvdSBhcmUgYWRkaW5nIHlvdXIgY29udGV4dCBoYW5kbGVycyBhdCB0aGUgdG9wIGxldmVsIGluIHlvdXIgYXBwbGljYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVySWQgPSAnaW52b2tlQ29udGV4dEhhbmRsZXInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVyID0gKDAsIHV0aWxzXzEkMi53cmFwQ29udGV4dEhhbmRsZXIpKGhhbmRsZXIsIGhhbmRsZXJJZCk7XG4gICAgICAgIGNsaWVudC5yZWdpc3RlcihoYW5kbGVySWQsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdjb250ZXh0SGFuZGxlclJlZ2lzdGVyZWQnLCB7IGhhbmRsZXJJZCwgY29udGV4dFR5cGUgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsaWVudC5yZW1vdmUoaGFuZGxlcklkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ3JlbW92ZUNvbnRleHRIYW5kbGVyJywgeyBoYW5kbGVySWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgUGxhdGZvcm0gV2luZG93IEFQSXNcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEludGVyb3AtQnJva2VyLWRlZmluZWQgY29udGV4dCBncm91cHMgYXZhaWxhYmxlIGZvciBhbiBlbnRpdHkgdG8gam9pbi5cbiAgICAgKiBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLm1lLmludGVyb3AuZ2V0Q29udGV4dEdyb3VwcygpXG4gICAgICogICAgICAgICAudGhlbihjb250ZXh0R3JvdXBzID0+IHtcbiAgICAgKiAgICAgICAgICAgICBjb250ZXh0R3JvdXBzLmZvckVhY2goY29udGV4dEdyb3VwID0+IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29udGV4dEdyb3VwLmRpc3BsYXlNZXRhZGF0YS5uYW1lKVxuICAgICAqICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb250ZXh0R3JvdXAuZGlzcGxheU1ldGFkYXRhLmNvbG9yKVxuICAgICAqICAgICAgICAgICAgIH0pXG4gICAgICogICAgICAgICB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRleHRHcm91cHMoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1nZXQtY29udGV4dC1ncm91cHMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDIodGhpcywgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdnZXRDb250ZXh0R3JvdXBzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gYWxsIEludGVyb3AgQ2xpZW50cyBhdCB0aGUgZ2l2ZW4gaWRlbnRpdHkgdG8gY29udGV4dCBncm91cCBgY29udGV4dEdyb3VwSWRgLlxuICAgICAqIElmIG5vIHRhcmdldCBpcyBzcGVjaWZpZWQsIGl0IGFkZHMgdGhlIHNlbmRlciB0byB0aGUgY29udGV4dCBncm91cC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIEJlY2F1c2UgbXVsdGlwbGUgQ2hhbm5lbCBjb25uZWN0aW9ucy9JbnRlcm9wIENsaWVudHMgY2FuIHBvdGVudGlhbGx5IGV4aXN0IGF0IGEgYHV1aWRgL2BuYW1lYCBjb21ibywgd2UgY3VycmVudGx5IGpvaW4gYWxsIENoYW5uZWwgY29ubmVjdGlvbnMvSW50ZXJvcCBDbGllbnRzIGF0IHRoZSBnaXZlbiBpZGVudGl0eSB0byB0aGUgY29udGV4dCBncm91cC5cbiAgICAgKiBJZiBhbiBgZW5kcG9pbnRJZGAgaXMgcHJvdmlkZWQgKHdoaWNoIGlzIHVubGlrZWx5LCB1bmxlc3MgdGhlIGNhbGwgaXMgY29taW5nIGZyb20gYW4gZXh0ZXJuYWwgYWRhcHRlciksIHRoZW4gd2Ugb25seSBqb2luIHRoYXQgc2luZ2xlIGNvbm5lY3Rpb24gdG8gdGhlIGNvbnRleHQgZ3JvdXAuXG4gICAgICogRm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcywgdGhlcmUgd2lsbCBvbmx5IGJlIDEgY29ubmVjdGlvbiBwcmVzZW50IGluIFBsYXRmb3JtIGFuZCBCcm93c2VyIGltcGxtZW50YXRpb25zLCBzbyB0aGlzIHBvaW50IGlzIG1vcmUtb3ItbGVzcyBtb290LlxuICAgICAqIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0R3JvdXBJZCAtIElkIG9mIHRoZSBjb250ZXh0IGdyb3VwLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBJZGVudGl0eSBvZiB0aGUgZW50aXR5IHlvdSB3aXNoIHRvIGpvaW4gdG8gYSBjb250ZXh0IGdyb3VwLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGpvaW5WaWV3VG9Db250ZXh0R3JvdXAgPSBhc3luYyAoY29udGV4dEdyb3VwSWQsIHZpZXcpID0+IHtcbiAgICAgKiAgICAgYXdhaXQgZmluLm1lLmludGVyb3Auam9pbkNvbnRleHRHcm91cChjb250ZXh0R3JvdXBJZCwgdmlldyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZ2V0TGFzdEZvY3VzZWRWaWV3KClcbiAgICAgKiAgICAgLnRoZW4obGFzdEZvY3VzZWRWaWV3SWRlbnRpdHkgPT4ge1xuICAgICAqICAgICAgICAgam9pblZpZXdUb0NvbnRleHRHcm91cCgncmVkJywgbGFzdEZvY3VzZWRWaWV3SWRlbnRpdHkpXG4gICAgICogICAgIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgam9pbkNvbnRleHRHcm91cChjb250ZXh0R3JvdXBJZCwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1qb2luLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDIodGhpcywgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICBpZiAoIWNvbnRleHRHcm91cElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRleHRHcm91cElkIHNwZWNpZmllZCBmb3Igam9pbkNvbnRleHRHcm91cC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdqb2luQ29udGV4dEdyb3VwJywgeyBjb250ZXh0R3JvdXBJZCwgdGFyZ2V0IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGZyb20gYSBjb250ZXh0IGdyb3VwLlxuICAgICAqIElmIG5vIHRhcmdldCBpcyBzcGVjaWZpZWQsIGl0IHJlbW92ZXMgdGhlIHNlbmRlciBmcm9tIHRoZWlyIGNvbnRleHQgZ3JvdXAuXG4gICAgICogVXNlZCBieSBQbGF0Zm9ybSBXaW5kb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldCAtIElkZW50aXR5IG9mIHRoZSBlbnRpdHkgeW91IHdpc2ggdG8gam9pbiB0byBhIGNvbnRleHQgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogcmVtb3ZlVmlld0Zyb21Db250ZXh0R3JvdXAgPSBhc3luYyAodmlldykgPT4ge1xuICAgICAqICAgICBhd2FpdCBmaW4ubWUuaW50ZXJvcC5yZW1vdmVGcm9tQ29udGV4dEdyb3VwKHZpZXcpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGdldExhc3RGb2N1c2VkVmlldygpXG4gICAgICogICAgIC50aGVuKGxhc3RGb2N1c2VkVmlld0lkZW50aXR5ID0+IHtcbiAgICAgKiAgICAgICAgIHJlbW92ZVZpZXdGcm9tQ29udGV4dEdyb3VwKGxhc3RGb2N1c2VkVmlld0lkZW50aXR5KVxuICAgICAqICAgICB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUZyb21Db250ZXh0R3JvdXAodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1yZW1vdmUtZnJvbS1jb250ZXh0LWdyb3VwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyKHRoaXMsIF9JbnRlcm9wQ2xpZW50X2NsaWVudFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgncmVtb3ZlRnJvbUNvbnRleHRHcm91cCcsIHsgdGFyZ2V0IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBjbGllbnRzIGZvciBhIGNvbnRleHQgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyAqKlRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgZm9yIHBsYXRmb3JtIHdpbmRvd3MuIFZpZXdzIHdpdGhpbiBhIHBsYXRmb3JtIHNob3VsZCBub3QgaGF2ZSB0byB1c2UgdGhpcyBBUEkuKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIEludGVyb3AtQnJva2VyLWRlZmluZWQgY29udGV4dCBncm91cHMgYXZhaWxhYmxlIGZvciBhbiBlbnRpdHkgdG8gam9pbi5cbiAgICAgKiBAcGFyYW0gY29udGV4dEdyb3VwSWQgLSBUaGUgaWQgb2YgY29udGV4dCBncm91cCB5b3Ugd2lzaCB0byBnZXQgY2xpZW50cyBmb3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZmluLm1lLmludGVyb3AuZ2V0QWxsQ2xpZW50c0luQ29udGV4dEdyb3VwKCdyZWQnKVxuICAgICAqICAgICAudGhlbihjbGllbnRzSW5Db250ZXh0R3JvdXAgPT4ge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coY2xpZW50c0luQ29udGV4dEdyb3VwKVxuICAgICAqICAgICB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cChjb250ZXh0R3JvdXBJZCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1jbGllbnQtZ2V0LWFsbC1jbGllbnRzLWluLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDIodGhpcywgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICBpZiAoIWNvbnRleHRHcm91cElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRleHRHcm91cElkIHNwZWNpZmllZCBmb3IgZ2V0QWxsQ2xpZW50c0luQ29udGV4dEdyb3VwLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2dldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCcsIHsgY29udGV4dEdyb3VwSWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgZGlzcGxheSBpbmZvIGZvciBhIGNvbnRleHQgZ3JvdXBcbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cbiAgICAgKiBAcGFyYW0gY29udGV4dEdyb3VwSWQgLSBUaGUgaWQgb2YgY29udGV4dCBncm91cCB5b3Ugd2lzaCB0byBnZXQgZGlzcGxheSBpbmZvIGZvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmaW4ubWUuaW50ZXJvcC5nZXRJbmZvRm9yQ29udGV4dEdyb3VwKCdyZWQnKVxuICAgICAqICAgICAudGhlbihjb250ZXh0R3JvdXBJbmZvID0+IHtcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGNvbnRleHRHcm91cEluZm8uZGlzcGxheU1ldGFkYXRhLm5hbWUpXG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhjb250ZXh0R3JvdXBJbmZvLmRpc3BsYXlNZXRhZGF0YS5jb2xvcilcbiAgICAgKiAgICAgfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbmZvRm9yQ29udGV4dEdyb3VwKGNvbnRleHRHcm91cElkKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1nZXQtaW5mby1mb3ItY29udGV4dC1ncm91cCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMih0aGlzLCBfSW50ZXJvcENsaWVudF9jbGllbnRQcm9taXNlLCBcImZcIik7XG4gICAgICAgIGlmICghY29udGV4dEdyb3VwSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGV4dEdyb3VwSWQgc3BlY2lmaWVkIGZvciBnZXRJbmZvRm9yQ29udGV4dEdyb3VwLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2dldEluZm9Gb3JDb250ZXh0R3JvdXAnLCB7IGNvbnRleHRHcm91cElkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBpbnRlbnQgdG8gdGhlIEludGVyb3AgQnJva2VyIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIGludGVudCAtIFRoZSBjb21iaW5hdGlvbiBvZiBhbiBhY3Rpb24gYW5kIGEgY29udGV4dCB0aGF0IGlzIHBhc3NlZCB0byBhbiBhcHBsaWNhdGlvbiBmb3IgcmVzb2x1dGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiAvLyBWaWV3IHdhbnRzIHRvIGZpcmUgYW4gSW50ZW50IGFmdGVyIGEgdXNlciBjbGlja3Mgb24gYSB0aWNrZXJcbiAgICAgKiB0aWNrZXJFbGVtZW50Lm9uKCdjbGljaycsIChlbGVtZW50KSA9PiB7XG4gICAgICogICAgIGNvbnN0IHRpY2tlciA9IGVsZW1lbnQuaW5uZXJUZXh0O1xuICAgICAqICAgICBjb25zdCBpbnRlbnQgPSB7XG4gICAgICogICAgICAgICBuYW1lOiAnVmlld0NoYXJ0JyxcbiAgICAgKiAgICAgICAgIGNvbnRleHQ6IHt0eXBlOiAnZmRjMy5pbnN0cnVtZW50JywgaWQ6IHsgdGlja2VyIH19XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICBmaW4ubWUuaW50ZXJvcC5maXJlSW50ZW50KGludGVudCk7XG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBmaXJlSW50ZW50KGludGVudCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1jbGllbnQtZmlyZS1pbnRlbnQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCB0aGlzIGlzIG9ubHkgZm9yIGFwaSBhbmFseXRpY3MgcHVycG9zZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMih0aGlzLCBfSW50ZXJvcENsaWVudF9jbGllbnRQcm9taXNlLCBcImZcIik7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2ZpcmVJbnRlbnQnLCBpbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGludGVudCBoYW5kbGVyIGZvciBpbmNvbWluZyBpbnRlbnRzLiBUaGUgbGFzdCBpbnRlbnQgc2VudCBvZiB0aGUgbmFtZSBzdWJzY3JpYmVkIHRvIHdpbGwgYmUgcmVjZWl2ZWQuXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBSZWdpc3RlcmVkIGZ1bmN0aW9uIG1lYW50IHRvIGhhbmRsZSBhIHNwZWNpZmljIGludGVudCB0eXBlLlxuICAgICAqIEBwYXJhbSBpbnRlbnROYW1lIC0gVGhlIG5hbWUgb2YgYW4gaW50ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGludGVudEhhbmRsZXIgPSAoaW50ZW50KSA9PiB7XG4gICAgICogICAgIGNvbnN0IHsgY29udGV4dCB9ID0gaW50ZW50O1xuICAgICAqICAgICBteVZpZXdDaGFydEhhbmRsZXIoY29udGV4dCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGZpbi5tZS5pbnRlcm9wLnJlZ2lzdGVySW50ZW50SGFuZGxlcihpbnRlbnRIYW5kbGVyLCAnVmlld0NoYXJ0Jyk7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBteUFwcENsb3NlU2VxdWVuY2UoKSB7XG4gICAgICogICAgIC8vIHRvIHVuc3Vic2NyaWJlIHRoZSBoYW5kbGVyLCBzaW1wbHkgY2FsbDpcbiAgICAgKiAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVySW50ZW50SGFuZGxlcihoYW5kbGVyLCBpbnRlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1yZWdpc3Rlci1pbnRlbnQtaGFuZGxlcicpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIHRoaXMgaXMgb25seSBmb3IgYXBpIGFuYWx5dGljcyBwdXJwb3Nlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyKHRoaXMsIF9JbnRlcm9wQ2xpZW50X2NsaWVudFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgY29uc3QgaGFuZGxlcklkID0gYGludGVudC1oYW5kbGVyLSR7aW50ZW50TmFtZX1gO1xuICAgICAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9ICgwLCB1dGlsc18xJDIud3JhcEludGVudEhhbmRsZXIpKGhhbmRsZXIsIGhhbmRsZXJJZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucmVnaXN0ZXIoaGFuZGxlcklkLCB3cmFwcGVkSGFuZGxlcik7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ2ludGVudEhhbmRsZXJSZWdpc3RlcmVkJywgeyBoYW5kbGVySWQsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWdpc3RlciBpbnRlbnQgaGFuZGxlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsaWVudC5yZW1vdmUoaGFuZGxlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBjb250ZXh0IG9mIHRoZSBDb250ZXh0IEdyb3VwIGN1cnJlbnRseSBzdWJzY3JpYmVkIHRvLiBJdCB0YWtlcyBhbiBvcHRpb25hbCBDb250ZXh0IFR5cGUgYW5kIHJldHVybnMgdGhlXG4gICAgICogbGFzdCBjb250ZXh0IG9mIHRoYXQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY29udGV4dFR5cGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBhd2FpdCBmaW4ubWUuaW50ZXJvcC5qb2luQ29udGV4dEdyb3VwKCd5ZWxsb3cnKTtcbiAgICAgKiBhd2FpdCBmaW4ubWUuaW50ZXJvcC5zZXRDb250ZXh0KHsgdHlwZTogJ2luc3RydW1lbnQnLCBpZDogeyB0aWNrZXI6ICdGT08nIH19KTtcbiAgICAgKiBjb25zdCBjdXJyZW50Q29udGV4dCA9IGF3YWl0IGZpbi5tZS5pbnRlcm9wLmdldEN1cnJlbnRDb250ZXh0KCk7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgc3BlY2lmaWMgY29udGV4dFxuICAgICAqIGF3YWl0IGZpbi5tZS5pbnRlcm9wLmpvaW5Db250ZXh0R3JvdXAoJ3llbGxvdycpO1xuICAgICAqIGF3YWl0IGZpbi5tZS5pbnRlcm9wLnNldENvbnRleHQoeyB0eXBlOiAnY291bnRyeScsIGlkOiB7IElTT0FMUEhBMzogJ1VTJyB9fSk7XG4gICAgICogYXdhaXQgZmluLm1lLmludGVyb3Auc2V0Q29udGV4dCh7IHR5cGU6ICdpbnN0cnVtZW50JywgaWQ6IHsgdGlja2VyOiAnRk9PJyB9fSk7XG4gICAgICogY29uc3QgY3VycmVudENvbnRleHQgPSBhd2FpdCBmaW4ubWUuaW50ZXJvcC5nZXRDdXJyZW50Q29udGV4dCgnY291bnRyeScpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRDb250ZXh0KGNvbnRleHRUeXBlKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1nZXQtY3VycmVudC1jb250ZXh0JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyKHRoaXMsIF9JbnRlcm9wQ2xpZW50X2NsaWVudFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgnZ2V0Q3VycmVudENvbnRleHQnLCB7IGNvbnRleHRUeXBlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaW5mb3JtYXRpb24gZm9yIGEgcGFydGljdWxhciBJbnRlbnQgZnJvbSB0aGUgSW50ZXJvcCBCcm9rZXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBUbyByZXNvbHZlIHRoaXMgaW5mbywgdGhlIGZ1bmN0aW9uIGhhbmRsZUluZm9Gb3JJbnRlbnQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgSW50ZXJvcCBCcm9rZXIuXG4gICAgICogVGhlIGZvcm1hdCBmb3IgdGhlIHJlc3BvbnNlIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgQXBwIFByb3ZpZGVyIG92ZXJyaWRpbmcgdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBpbnRlbnRJbmZvID0gYXdhaXQgZmluLm1lLmludGVyb3AuZ2V0SW5mb0ZvckludGVudCgnVmlld0NoYXJ0Jyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW5mb0ZvckludGVudChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1nZXQtaW5mby1mb3ItaW50ZW50JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyKHRoaXMsIF9JbnRlcm9wQ2xpZW50X2NsaWVudFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgnZ2V0SW5mb0ZvckludGVudCcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaW5mb3JtYXRpb24gZnJvbSB0aGUgSW50ZXJvcCBCcm9rZXIgb24gYWxsIEludGVudHMgdGhhdCBhcmUgbWVhbnQgdG8gaGFuZGxlIGEgcGFydGljdWxhciBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHJlbWFya3MgVG8gcmVzb2x2ZSB0aGlzIGluZm8sIHRoZSBmdW5jdGlvbiBoYW5kbGVJbmZvRm9ySW50ZW50c0J5Q29udGV4dCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuIGluIHRoZSBJbnRlcm9wIEJyb2tlci5cbiAgICAgKiBUaGUgZm9ybWF0IGZvciB0aGUgcmVzcG9uc2Ugd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBBcHAgUHJvdmlkZXIgb3ZlcnJpZGluZyB0aGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHRpY2tlckVsZW1lbnQub24oJ2NsaWNrJywgKGVsZW1lbnQpID0+IHtcbiAgICAgKiAgICAgY29uc3QgdGlja2VyID0gZWxlbWVudC5pbm5lclRleHQ7XG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgKiAgICAgICAgIHR5cGU6ICdmZGMzLmluc3RydW1lbnQnLFxuICAgICAqICAgICAgICAgaWQ6IHtcbiAgICAgKiAgICAgICAgICAgICB0aWNrZXJcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgIGNvbnN0IGludGVudHNJbmZvID0gYXdhaXQgZmluLm1lLmludGVyb3AuZ2V0SW5mb0ZvckludGVudEJ5Q29udGV4dChjb250ZXh0KTtcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldEluZm9Gb3JJbnRlbnRzQnlDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY2xpZW50LWdldC1pbmZvLWZvci1pbnRlbnRzLWJ5LWNvbnRleHQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDIodGhpcywgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdnZXRJbmZvRm9ySW50ZW50c0J5Q29udGV4dCcsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIENvbnRleHQgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHRvIGFuIEludGVudCBieSB0aGUgSW50ZXJvcCBCcm9rZXIuXG4gICAgICogVGhpcyBjb250ZXh0IGFjY2VwdHMgYSBtZXRhZGF0YSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFRvIHJlc29sdmUgdGhpcyBpbmZvLCB0aGUgZnVuY3Rpb24gaGFuZGxlRmlyZWRJbnRlbnRCeUNvbnRleHQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgSW50ZXJvcCBCcm9rZXIuXG4gICAgICogVGhlIGZvcm1hdCBmb3IgdGhlIHJlc3BvbnNlIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgQXBwIFByb3ZpZGVyIG92ZXJyaWRpbmcgdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB0aWNrZXJFbGVtZW50Lm9uKCdjbGljaycsIChlbGVtZW50KSA9PiB7XG4gICAgICogICAgIGNvbnN0IHRpY2tlciA9IGVsZW1lbnQuaW5uZXJUZXh0O1xuICAgICAqXG4gICAgICogICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICogICAgICAgICB0eXBlOiAnZmRjMy5pbnN0cnVtZW50JyxcbiAgICAgKiAgICAgICAgIGlkOiB7XG4gICAgICogICAgICAgICAgICAgdGlja2VyXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICBjb25zdCBpbnRlbnRSZXNvbHV0aW9uID0gYXdhaXQgZmluLm1lLmludGVyb3AuZmlyZUludGVudEZvckNvbnRleHQoY29udGV4dCk7XG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBmaXJlSW50ZW50Rm9yQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1maXJlLWludGVudC1mb3ItY29udGV4dCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMih0aGlzLCBfSW50ZXJvcENsaWVudF9jbGllbnRQcm9taXNlLCBcImZcIik7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2ZpcmVJbnRlbnRGb3JDb250ZXh0JywgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gdGhlIGN1cnJlbnQgZW50aXR5IHRvIHNlc3Npb24gY29udGV4dCBncm91cCBgc2Vzc2lvbkNvbnRleHRHcm91cElkYCBhbmQgcmV0dXJuIGEgc2Vzc2lvbkNvbnRleHRHcm91cCBpbnN0YW5jZS5cbiAgICAgKiBJZiB0aGUgc2Vzc2lvbkNvbnRleHRHcm91cCBkb2Vzbid0IGV4aXN0LCBvbmUgd2lsbCBnZXQgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIFNlc3Npb24gQ29udGV4dCBHcm91cHMgZG8gbm90IHBlcnNpc3QgYmV0d2VlbiBydW5zIGFuZCBhcmVuJ3QgcHJlc2VudCBvbiBzbmFwc2hvdHMuXG4gICAgICogQHBhcmFtIHNlc3Npb25Db250ZXh0R3JvdXBJZCAtIElkIG9mIHRoZSBjb250ZXh0IGdyb3VwLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBTYXkgd2Ugd2FudCB0byBoYXZlIGEgU2Vzc2lvbiBDb250ZXh0IEdyb3VwIHRoYXQgaG9sZHMgVUkgdGhlbWUgaW5mb3JtYXRpb24gZm9yIGFsbCBhcHBzIHRvIGNvbnN1bWU6XG4gICAgICpcbiAgICAgKiBNeSBjb2xvci1waWNrZXIgVmlldzpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBjb25zdCB0aGVtZVNlc3Npb25Db250ZXh0R3JvdXAgPSBhd2FpdCBmaW4ubWUuaW50ZXJvcC5qb2luU2Vzc2lvbkNvbnRleHRHcm91cCgndGhlbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBjb25zdCBteUNvbG9yUGlja2VyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb2xvci1wYWxldHRlLXBpY2tlcicpO1xuICAgICAqICAgICBteUNvbG9yUGlja2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBldmVudCA9PiB7XG4gICAgICogICAgICAgICB0aGVtZVNlc3Npb25Db250ZXh0R3JvdXAuc2V0Q29udGV4dCh7IHR5cGU6ICdjb2xvci1wYWxldHRlJywgc2VsZWN0aW9uOiBldmVudC52YWx1ZSB9KTtcbiAgICAgKiAgICAgfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB2aWV3czpcbiAgICAgKiBgYGBqc1xuICAgICAqICAgICBjb25zdCB0aGVtZVNlc3Npb25Db250ZXh0R3JvdXAgPSBhd2FpdCBmaW4ubWUuaW50ZXJvcC5qb2luU2Vzc2lvbkNvbnRleHRHcm91cCgndGhlbWUnKTtcbiAgICAgKlxuICAgICAqICAgICBjb25zdCBjaGFuZ2VDb2xvclBhbGV0dGUgPSAoeyBzZWxlY3Rpb24gfSkgPT4ge1xuICAgICAqICAgICAgICAgLy8gY2hhbmdlIHRoZSBjb2xvciBwYWxldHRlIHRvIHRoZSBzZWxlY3Rpb25cbiAgICAgKiAgICAgfTtcbiAgICAgKlxuICAgICAqICAgICAvLyBJZiB0aGUgY29udGV4dCBpcyBhbHJlYWR5IHNldCBieSB0aGUgdGltZSB0aGUgaGFuZGxlciB3YXMgc2V0LCB0aGUgaGFuZGxlciB3aWxsIGdldCBpbnZva2VkIGltbWVkaWF0ZWx5IHdpdGggdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKiAgICAgdGhlbWVTZXNzaW9uQ29udGV4dEdyb3VwLmFkZENvbnRleHRIYW5kbGVyKGNoYW5nZUNvbG9yUGFsZXR0ZSwgJ2NvbG9yLXBhbGV0dGUnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBqb2luU2Vzc2lvbkNvbnRleHRHcm91cChzZXNzaW9uQ29udGV4dEdyb3VwSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uQ29udGV4dEdyb3VwID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyKHRoaXMsIF9JbnRlcm9wQ2xpZW50X3Nlc3Npb25Db250ZXh0R3JvdXBzLCBcImZcIikuZ2V0KHNlc3Npb25Db250ZXh0R3JvdXBJZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb25Db250ZXh0R3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlc3Npb25Db250ZXh0R3JvdXAuZ2V0VXNlckluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDIodGhpcywgX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNDb25mbGljdCB9ID0gYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdzZXNzaW9uQ29udGV4dEdyb3VwOmNyZWF0ZUlmTmVlZGVkJywge1xuICAgICAgICAgICAgICAgIHNlc3Npb25Db250ZXh0R3JvdXBJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzQ29uZmxpY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEEgKG5vbi1zZXNzaW9uKSBjb250ZXh0IGdyb3VwIHdpdGggdGhlIG5hbWUgXCIke3Nlc3Npb25Db250ZXh0R3JvdXBJZH1cIiBhbHJlYWR5IGV4aXN0cy4gSWYgeW91IGFyZSB0cnlpbmcgdG8gam9pbiBhIENvbnRleHQgR3JvdXAsIGNhbGwgam9pbkNvbnRleHRHcm91cCBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3U2Vzc2lvbkNvbnRleHRHcm91cCA9IG5ldyBTZXNzaW9uQ29udGV4dEdyb3VwQ2xpZW50XzEuZGVmYXVsdCh0aGlzLndpcmUsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMih0aGlzLCBfSW50ZXJvcENsaWVudF9jbGllbnRQcm9taXNlLCBcImZcIiksIHNlc3Npb25Db250ZXh0R3JvdXBJZCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDIodGhpcywgX0ludGVyb3BDbGllbnRfc2Vzc2lvbkNvbnRleHRHcm91cHMsIFwiZlwiKS5zZXQoc2Vzc2lvbkNvbnRleHRHcm91cElkLCBuZXdTZXNzaW9uQ29udGV4dEdyb3VwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTZXNzaW9uQ29udGV4dEdyb3VwLmdldFVzZXJJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdGhyb3duIHRyeWluZyB0byBjcmVhdGUgU2Vzc2lvbiBDb250ZXh0IEdyb3VwIHdpdGggaWQgXCIke3Nlc3Npb25Db250ZXh0R3JvdXBJZH1cIjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgSW50ZXJvcCBDbGllbnQgaGFzIGJlZW4gZGlzY29ubmVjdGVkIGZyb20gdGhlIEludGVyb3AgQnJva2VyLlxuICAgICAqIE9ubHkgb25lIGxpc3RlbmVyIHBlciBJbnRlcm9wIENsaWVudCBjYW4gYmUgc2V0LlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICogICAgIGNvbnN0IHsgdHlwZSwgdG9waWMsIGJyb2tlck5hbWV9ID0gZXZlbnQ7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBEaXNjb25uZWN0ZWQgZnJvbSBJbnRlcm9wIEJyb2tlciAke2Jyb2tlck5hbWV9IGApO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGF3YWl0IGZpbi5tZS5pbnRlcm9wLm9uRGlzY29ubmVjdGlvbihsaXN0ZW5lcik7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgb25EaXNjb25uZWN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1hZGQtb25kaXNjb25uZWN0aW9uLWxpc3RlbmVyJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyKHRoaXMsIF9JbnRlcm9wQ2xpZW50X2NsaWVudFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5vbkRpc2Nvbm5lY3Rpb24oKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHV1aWQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgbGlzdGVuZXIoeyB0eXBlOiAnaW50ZXJvcC1icm9rZXInLCB0b3BpYzogJ2Rpc2Nvbm5lY3RlZCcsIGJyb2tlck5hbWU6IHV1aWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKlxuICAgICAqIFVzZWQgdG8gZmVycnkgZmRjMy1vbmx5IGNhbGxzIGZyb20gdGhlIGZkYzMgc2hpbSB0byB0aGUgSW50ZXJvcCBCcm9rZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZmVycnlGZGMzQ2FsbChpbnRlcm9wQ2xpZW50LCBhY3Rpb24sIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQyKGludGVyb3BDbGllbnQsIF9JbnRlcm9wQ2xpZW50X2NsaWVudFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaChhY3Rpb24sIHBheWxvYWQgfHwgbnVsbCk7XG4gICAgfVxufVxuSW50ZXJvcENsaWVudCQxLkludGVyb3BDbGllbnQgPSBJbnRlcm9wQ2xpZW50O1xuX0ludGVyb3BDbGllbnRfY2xpZW50UHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9JbnRlcm9wQ2xpZW50X3Nlc3Npb25Db250ZXh0R3JvdXBzID0gbmV3IFdlYWtNYXAoKTtcblxudmFyIG92ZXJyaWRlQ2hlY2sgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkT3ZlcnJpZGVDaGVjaztcblxuZnVuY3Rpb24gcmVxdWlyZU92ZXJyaWRlQ2hlY2sgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRPdmVycmlkZUNoZWNrKSByZXR1cm4gb3ZlcnJpZGVDaGVjaztcblx0aGFzUmVxdWlyZWRPdmVycmlkZUNoZWNrID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG92ZXJyaWRlQ2hlY2ssIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRvdmVycmlkZUNoZWNrLm92ZXJyaWRlQ2hlY2sgPSBvdmVycmlkZUNoZWNrLmNoZWNrRkRDMzJPdmVycmlkZXMgPSBvdmVycmlkZUNoZWNrLmdldERlZmF1bHRWaWV3RmRjM1ZlcnNpb25Gcm9tQXBwSW5mbyA9IHZvaWQgMDtcblx0Y29uc3QgSW50ZXJvcEJyb2tlcl8xID0gcmVxdWlyZUludGVyb3BCcm9rZXIoKTtcblx0ZnVuY3Rpb24gZ2V0RGVmYXVsdFZpZXdGZGMzVmVyc2lvbkZyb21BcHBJbmZvKHsgbWFuaWZlc3QsIGluaXRpYWxPcHRpb25zIH0pIHtcblx0ICAgIGNvbnN0IHNldFZlcnNpb24gPSBtYW5pZmVzdD8ucGxhdGZvcm0/LmRlZmF1bHRWaWV3T3B0aW9ucz8uZmRjM0ludGVyb3BBcGkgPz8gaW5pdGlhbE9wdGlvbnMuZGVmYXVsdFZpZXdPcHRpb25zPy5mZGMzSW50ZXJvcEFwaTtcblx0ICAgIHJldHVybiBbJzEuMicsICcyLjAnXS5pbmNsdWRlcyhzZXRWZXJzaW9uID8/ICcnKSA/IHNldFZlcnNpb24gOiB1bmRlZmluZWQ7XG5cdH1cblx0b3ZlcnJpZGVDaGVjay5nZXREZWZhdWx0Vmlld0ZkYzNWZXJzaW9uRnJvbUFwcEluZm8gPSBnZXREZWZhdWx0Vmlld0ZkYzNWZXJzaW9uRnJvbUFwcEluZm87XG5cdGZ1bmN0aW9uIGNoZWNrRkRDMzJPdmVycmlkZXMob3ZlcnJpZGRlbkJyb2tlcikge1xuXHQgICAgLy8gVGhlc2UgYXJlIHRoZSBBUElzIHRoYXQgbXVzdCBiZSBvdmVycmlkZGVuIGZvciBGREMzIDIuMCBjb21wbGlhbmNlXG5cdCAgICBjb25zdCBtdXN0T3ZlcnJpZGVBUElzID0gW1xuXHQgICAgICAgICdmZGMzSGFuZGxlRmluZEluc3RhbmNlcycsXG5cdCAgICAgICAgJ2hhbmRsZUluZm9Gb3JJbnRlbnQnLFxuXHQgICAgICAgICdoYW5kbGVJbmZvRm9ySW50ZW50c0J5Q29udGV4dCcsXG5cdCAgICAgICAgJ2ZkYzNIYW5kbGVHZXRBcHBNZXRhZGF0YScsXG5cdCAgICAgICAgJ2ZkYzNIYW5kbGVHZXRJbmZvJyxcblx0ICAgICAgICAnZmRjM0hhbmRsZU9wZW4nLFxuXHQgICAgICAgICdoYW5kbGVGaXJlZEludGVudCcsXG5cdCAgICAgICAgJ2hhbmRsZUZpcmVkSW50ZW50Rm9yQ29udGV4dCdcblx0ICAgIF07XG5cdCAgICByZXR1cm4gbXVzdE92ZXJyaWRlQVBJcy5maWx0ZXIoKGFwaSkgPT4ge1xuXHQgICAgICAgIHJldHVybiBvdmVycmlkZGVuQnJva2VyW2FwaV0gPT09IEludGVyb3BCcm9rZXJfMS5JbnRlcm9wQnJva2VyLnByb3RvdHlwZVthcGldO1xuXHQgICAgfSk7XG5cdH1cblx0b3ZlcnJpZGVDaGVjay5jaGVja0ZEQzMyT3ZlcnJpZGVzID0gY2hlY2tGREMzMk92ZXJyaWRlcztcblx0ZnVuY3Rpb24gb3ZlcnJpZGVDaGVjayQxKG92ZXJyaWRkZW5Ccm9rZXIsIGZkYzNJbnRlcm9wQXBpKSB7XG5cdCAgICBpZiAoZmRjM0ludGVyb3BBcGkgJiYgZmRjM0ludGVyb3BBcGkgPT09ICcyLjAnKSB7XG5cdCAgICAgICAgY29uc3Qgbm90T3ZlcnJpZGRlbiA9IGNoZWNrRkRDMzJPdmVycmlkZXMob3ZlcnJpZGRlbkJyb2tlcik7XG5cdCAgICAgICAgaWYgKG5vdE92ZXJyaWRkZW4ubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IEZEQzMgMi4wIGhhcyBiZWVuIHNldCBhcyBhIGRlZmF1bHQgb3B0aW9uIGZvciBWaWV3cyBpbiB0aGlzIFBsYXRmb3JtLCBidXQgdGhlIHJlcXVpcmVkIEludGVyb3BCcm9rZXIgQVBJcyBmb3IgRkRDMyAyLjAgY29tcGxpYW5jZSBoYXZlIG5vdCBhbGwgYmVlbiBvdmVycmlkZGVuLlxcblRoZSBmb2xsb3dpbmcgQVBJcyBuZWVkIHRvIGJlIG92ZXJyaWRkZW46XFxuJHtub3RPdmVycmlkZGVuLmpvaW4oJ1xcbicpfWApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXHRvdmVycmlkZUNoZWNrLm92ZXJyaWRlQ2hlY2sgPSBvdmVycmlkZUNoZWNrJDE7XG5cdHJldHVybiBvdmVycmlkZUNoZWNrO1xufVxuXG52YXIgaGFzUmVxdWlyZWRGYWN0b3J5O1xuXG5mdW5jdGlvbiByZXF1aXJlRmFjdG9yeSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEZhY3RvcnkpIHJldHVybiBGYWN0b3J5JDE7XG5cdGhhc1JlcXVpcmVkRmFjdG9yeSA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWN0b3J5JDEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRGYWN0b3J5JDEuSW50ZXJvcE1vZHVsZSA9IHZvaWQgMDtcblx0Y29uc3QgbG9kYXNoXzEgPSByZXF1aXJlJCQzO1xuXHRjb25zdCBpbmFjY2Vzc2libGVPYmplY3RfMSA9IGluYWNjZXNzaWJsZU9iamVjdDtcblx0Y29uc3QgYmFzZV8xID0gYmFzZTtcblx0Y29uc3QgSW50ZXJvcEJyb2tlcl8xID0gcmVxdWlyZUludGVyb3BCcm9rZXIoKTtcblx0Y29uc3QgSW50ZXJvcENsaWVudF8xID0gSW50ZXJvcENsaWVudCQxO1xuXHRjb25zdCBvdmVycmlkZUNoZWNrXzEgPSByZXF1aXJlT3ZlcnJpZGVDaGVjaygpO1xuXHRjb25zdCBjb21tb25fdXRpbHNfMSA9IGNvbW1vblV0aWxzO1xuXHRjb25zdCBkZWZhdWx0T3ZlcnJpZGUgPSAoQ2xhc3MpID0+IG5ldyBDbGFzcygpO1xuXHRjb25zdCBCcm9rZXJQYXJhbUFjY2Vzc0Vycm9yID0gJ1lvdSBoYXZlIGF0dGVtcHRlZCB0byB1c2Ugb3IgbW9kaWZ5IEludGVyb3BCcm9rZXIgcGFyYW1ldGVycywgd2hpY2ggaXMgbm90IGFsbG93ZWQuIFlvdSBhcmUgbGlrZWx5IHVzaW5nIGFuIG9sZGVyIEludGVyb3BCcm9rZXIgb3ZlcnJpZGUgc2NoZW1lLiBQbGVhc2UgY29uc3VsdCBvdXIgSW50ZXJvcCBkb2NzIGZvciBndWlkYW5jZSBvbiBtaWdyYXRpbmcgdG8gdGhlIG5ldyBvdmVycmlkZSBzY2hlbWUuJztcblx0LyoqXG5cdCAqIE1hbmFnZXMgY3JlYXRpb24gb2YgSW50ZXJvcCBCcm9rZXJzIGFuZCBJbnRlcm9wIENsaWVudHMuIFRoZXNlIEFQSXMgYXJlIGNhbGxlZCB1bmRlci10aGUtaG9vZCBpbiBQbGF0Zm9ybXMuXG5cdCAqXG5cdCAqL1xuXHRjbGFzcyBJbnRlcm9wTW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuXHQgICAgLyoqXG5cdCAgICAgKiBJbml0aWFsaXplcyBhbiBJbnRlcm9wIEJyb2tlci4gVGhpcyBpcyBjYWxsZWQgdW5kZXItdGhlLWhvb2QgZm9yIFBsYXRmb3Jtcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcmVtYXJrcyBGb3IgUGxhdGZvcm1zLCB0aGlzIGlzIHNldCB1cCBhdXRvbWF0aWNhbGx5LiBXZSBhZHZpc2UgdG8gb25seSBjcmVhdGUgeW91ciBvd24gSW50ZXJvcCBCcm9rZXJcblx0ICAgICAqIHdoZW4gbm90IHVzaW5nIGEgUGxhdGZvcm0gYXBwLiBZb3UgY2FuIG92ZXJyaWRlIGZ1bmN0aW9ucyBpbiB0aGUgSW50ZXJvcCBCcm9rZXIuIE1vcmUgaW5mbyB7QGxpbmsgSW50ZXJvcEJyb2tlciBoZXJlfS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIEludGVyb3AgQnJva2VyLlxuXHQgICAgICogQHBhcmFtIG92ZXJyaWRlIC0gQSBjYWxsYmFjayBmdW5jdGlvbiBvciBhcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBleHRlbmQgb3IgcmVwbGFjZSBkZWZhdWx0IEludGVyb3AgQnJva2VyIGJlaGF2aW9yLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGAganNcblx0ICAgICAqIGNvbnN0IGludGVyb3BCcm9rZXIgPSBhd2FpdCBmaW4uSW50ZXJvcC5pbml0KCdvcGVuZmluJyk7XG5cdCAgICAgKiBjb25zdCBjb250ZXh0R3JvdXBzID0gYXdhaXQgaW50ZXJvcEJyb2tlci5nZXRDb250ZXh0R3JvdXBzKCk7XG5cdCAgICAgKiBjb25zb2xlLmxvZyhjb250ZXh0R3JvdXBzKTtcblx0ICAgICAqIGBgYFxuXHQgICAgICovXG5cdCAgICBhc3luYyBpbml0KG5hbWUsIG92ZXJyaWRlID0gZGVmYXVsdE92ZXJyaWRlKSB7XG5cdCAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtaW5pdCcpLmNhdGNoKCgpID0+IHtcblx0ICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gQWxsb3dzIGZvciBtYW5pZmVzdC1sZXZlbCBjb25maWd1cmF0aW9uLCB3aXRob3V0IGhhdmluZyB0byBvdmVycmlkZS4gKGUuZy4gc3BlY2lmeWluZyBjdXN0b20gY29udGV4dCBncm91cHMpXG5cdCAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXRJbnRlcm9wSW5mbyh0aGlzLndpcmUuZ2V0RmluKCkpO1xuXHQgICAgICAgIGNvbnN0IG9iamVjdFRoYXRUaHJvd3MgPSAoMCwgaW5hY2Nlc3NpYmxlT2JqZWN0XzEuY3JlYXRlVW51c2FibGVPYmplY3QpKEJyb2tlclBhcmFtQWNjZXNzRXJyb3IpO1xuXHQgICAgICAgIGNvbnN0IHdhcm5pbmdPcHRzQ2xvbmUgPSAoMCwgaW5hY2Nlc3NpYmxlT2JqZWN0XzEuY3JlYXRlV2FybmluZ09iamVjdCkoQnJva2VyUGFyYW1BY2Nlc3NFcnJvciwgKDAsIGxvZGFzaF8xLmNsb25lRGVlcCkob3B0aW9ucykpO1xuXHQgICAgICAgIGxldCBwcm92aWRlcjtcblx0ICAgICAgICBjb25zdCBnZXRQcm92aWRlciA9ICgpID0+IHtcblx0ICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB0aGlzLmZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKGBpbnRlcm9wLWJyb2tlci0ke25hbWV9YCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgY29uc3QgdGhyb3dpbmdHZXRQcm92aWRlciA9IGFzeW5jICgpID0+IHtcblx0ICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEJyb2tlclBhcmFtQWNjZXNzRXJyb3IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgY29uc3QgT3ZlcnJpZGVhYmxlQnJva2VyID0gSW50ZXJvcEJyb2tlcl8xLkludGVyb3BCcm9rZXIuY3JlYXRlQ2xvc2VkQ29uc3RydWN0b3IodGhpcy53aXJlLCBnZXRQcm92aWRlciwgb3B0aW9ucyk7XG5cdCAgICAgICAgbGV0IGJyb2tlcjtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdmVycmlkZSkpIHtcblx0ICAgICAgICAgICAgY29uc3QgQnJva2VyQ29uc3RydWN0b3IgPSAoMCwgY29tbW9uX3V0aWxzXzEub3ZlcnJpZGVGcm9tQ29tcG9zYWJsZXMpKC4uLm92ZXJyaWRlKShPdmVycmlkZWFibGVCcm9rZXIpO1xuXHQgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSB0aGVzZSBvYmplY3RzIGJlY2F1c2UgcmVtb3ZpbmcgdGhlbSBlbnRpcmVseSB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZSBhbmQgd2Ugd2FudCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxuXHQgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG5cdCAgICAgICAgICAgIGJyb2tlciA9IG5ldyBCcm9rZXJDb25zdHJ1Y3RvcihvYmplY3RUaGF0VGhyb3dzLCB0aHJvd2luZ0dldFByb3ZpZGVyLCB3YXJuaW5nT3B0c0Nsb25lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoZXNlIG9iamVjdHMgYmVjYXVzZSByZW1vdmluZyB0aGVtIGVudGlyZWx5IHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlIGFuZCB3ZSB3YW50IGFuIGluZm9ybWF0aXZlIGVycm9yXG5cdCAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ICAgICAgICAgICAgYnJva2VyID0gYXdhaXQgb3ZlcnJpZGUoT3ZlcnJpZGVhYmxlQnJva2VyLCBvYmplY3RUaGF0VGhyb3dzLCB0aHJvd2luZ0dldFByb3ZpZGVyLCB3YXJuaW5nT3B0c0Nsb25lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKDAsIG92ZXJyaWRlQ2hlY2tfMS5vdmVycmlkZUNoZWNrKShicm9rZXIsIG9wdGlvbnMuZmRjM1ZlcnNpb24pO1xuXHQgICAgICAgIHJldHVybiBicm9rZXI7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIENvbm5lY3RzIGEgY2xpZW50IHRvIGFuIEludGVyb3AgYnJva2VyLiBUaGlzIGlzIGNhbGxlZCB1bmRlci10aGUtaG9vZCBmb3IgVmlld3MgaW4gYSBQbGF0Zm9ybS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmVtYXJrc1xuXHQgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgSW50ZXJvcCBCcm9rZXIgdG8gY29ubmVjdCB0by4gRm9yIFBsYXRmb3JtcywgdGhpcyB3aWxsIGRlZmF1bHQgdG8gdGhlIHV1aWQgb2YgdGhlIFBsYXRmb3JtLlxuXHQgICAgICogQHBhcmFtIGludGVyb3BDb25maWcgLSBJbmZvcm1hdGlvbiByZWxldmFudCB0byB0aGUgSW50ZXJvcCBCcm9rZXIuIFR5cGljYWxseSBhIGRlY2xhcmF0aW9uIG9mXG5cdCAgICAgKiB3aGF0IGNvbnRleHQocykgdGhlIGVudGl0eSB3YW50cyB0byBzdWJzY3JpYmUgdG8sIGFuZCB0aGUgY3VycmVudCBDb250ZXh0IEdyb3VwIG9mIHRoZSBlbnRpdHkuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIGBgYGpzXG5cdCAgICAgKiBjb25zdCBpbnRlcm9wQ29uZmlnID0ge1xuXHQgICAgICogICAgIGN1cnJlbnRDb250ZXh0R3JvdXA6ICdncmVlbidcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBjb25zdCBpbnRlcm9wQnJva2VyID0gYXdhaXQgZmluLkludGVyb3AuaW5pdCgnb3BlbmZpbicpO1xuXHQgICAgICogY29uc3QgY2xpZW50ID0gYXdhaXQgZmluLkludGVyb3AuY29ubmVjdFN5bmMoJ29wZW5maW4nLCBpbnRlcm9wQ29uZmlnKTtcblx0ICAgICAqIGNvbnN0IGNvbnRleHRHcm91cEluZm8gPSBhd2FpdCBjbGllbnQuZ2V0SW5mb0ZvckNvbnRleHRHcm91cCgpO1xuXHQgICAgICogY29uc29sZS5sb2coY29udGV4dEdyb3VwSW5mbyk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgY29ubmVjdFN5bmMobmFtZSwgaW50ZXJvcENvbmZpZykge1xuXHQgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNvbm5lY3Qtc3luYycpLmNhdGNoKCgpID0+IHtcblx0ICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm9wQ2xpZW50XzEuSW50ZXJvcENsaWVudCh0aGlzLndpcmUsIG5hbWUsIGludGVyb3BDb25maWcpO1xuXHQgICAgfVxuXHR9XG5cdEZhY3RvcnkkMS5JbnRlcm9wTW9kdWxlID0gSW50ZXJvcE1vZHVsZTtcblx0cmV0dXJuIEZhY3RvcnkkMTtcbn1cblxudmFyIGhhc1JlcXVpcmVkSW50ZXJvcDtcblxuZnVuY3Rpb24gcmVxdWlyZUludGVyb3AgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbnRlcm9wKSByZXR1cm4gaW50ZXJvcDtcblx0aGFzUmVxdWlyZWRJbnRlcm9wID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0LyoqXG5cdFx0ICogRW50cnkgcG9pbnQgZm9yIHRoZSBPcGVuRmluIGBJbnRlcm9wYCBBUEkgKGBmaW4uSW50ZXJvcGApLlxuXHRcdCAqXG5cdFx0ICogKiB7QGxpbmsgSW50ZXJvcE1vZHVsZX0gY29udGFpbnMgc3RhdGljIG1lbWJlcnMgb2YgdGhlIGBJbnRlcm9wYCBBUEkgKGF2YWlsYWJsZSB1bmRlciBgZmluLkludGVyb3BgKVxuXHRcdCAqICoge0BsaW5rIEludGVyb3BDbGllbnR9IGFuZCB7QGxpbmsgSW50ZXJvcEJyb2tlcn0gZG9jdW1lbnQgaW5zdGFuY2VzIG9mIHRoZWlyIHJlc3BlY3RpdmUgY2xhc3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuXHRcdCAqL1xuXHRcdHZhciBfX2NyZWF0ZUJpbmRpbmcgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuXHRcdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHRcdCAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cdFx0ICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG5cdFx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuXHRcdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdFx0ICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG5cdFx0ICAgIG9bazJdID0gbVtrXTtcblx0XHR9KSk7XG5cdFx0dmFyIF9fZXhwb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcblx0XHQgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xuXHRcdH07XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdF9fZXhwb3J0U3RhcihyZXF1aXJlRmFjdG9yeSgpLCBleHBvcnRzKTtcblx0XHRfX2V4cG9ydFN0YXIoSW50ZXJvcENsaWVudCQxLCBleHBvcnRzKTtcblx0XHRfX2V4cG9ydFN0YXIocmVxdWlyZUludGVyb3BCcm9rZXIoKSwgZXhwb3J0cyk7IFxuXHR9IChpbnRlcm9wKSk7XG5cdHJldHVybiBpbnRlcm9wO1xufVxuXG52YXIgc25hcHNob3RTb3VyY2UgPSB7fTtcblxudmFyIEZhY3RvcnkgPSB7fTtcblxudmFyIEluc3RhbmNlID0ge307XG5cbnZhciB1dGlscyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodXRpbHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudXRpbHMuZ2V0U25hcHNob3RTb3VyY2VDaGFubmVsTmFtZSA9IHZvaWQgMDtcbmNvbnN0IGNoYW5uZWxQcmVmaXggPSAnc25hcHNob3Qtc291cmNlLXByb3ZpZGVyLSc7XG5jb25zdCBnZXRTbmFwc2hvdFNvdXJjZUNoYW5uZWxOYW1lID0gKGlkKSA9PiBgJHtjaGFubmVsUHJlZml4fSR7aWQudXVpZH1gO1xudXRpbHMuZ2V0U25hcHNob3RTb3VyY2VDaGFubmVsTmFtZSA9IGdldFNuYXBzaG90U291cmNlQ2hhbm5lbE5hbWU7XG5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9TbmFwc2hvdFNvdXJjZV9pZGVudGl0eSwgX1NuYXBzaG90U291cmNlX2dldENvbm5lY3Rpb24sIF9TbmFwc2hvdFNvdXJjZV9nZXRDbGllbnQsIF9TbmFwc2hvdFNvdXJjZV9zdGFydENvbm5lY3Rpb24sIF9TbmFwc2hvdFNvdXJjZV9zZXRVcENvbm5lY3Rpb25MaXN0ZW5lcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW5jZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5JbnN0YW5jZS5TbmFwc2hvdFNvdXJjZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cbmNvbnN0IGJhc2VfMSQxID0gYmFzZTtcbmNvbnN0IHV0aWxzXzEkMSA9IHV0aWxzO1xuY29uc3QgY29ubmVjdGlvbk1hcCA9IG5ldyBNYXAoKTtcbi8qKlxuICogRW5hYmxlcyBjb25maWd1cmluZyBhIFNuYXBzaG90U291cmNlIHdpdGggY3VzdG9tIGdldFNuYXBzaG90IGFuZCBhcHBseVNuYXBzaG90IG1ldGhvZHMuXG4gKlxuICogQHR5cGVQYXJhbSBTbmFwc2hvdCBJbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHNoYXBlIG9mIGFuIGFwcGxpY2F0aW9uIHNuYXBzaG90LiAgQWxsb3dzXG4gKiBjdXN0b20gc25hcHNob3QgaW1wbGVtZW50YXRpb25zIGZvciBsZWdhY3kgYXBwbGljYXRpb25zIHRvIGRlZmluZSB0aGVpciBvd24gc25hcHNob3QgZm9ybWF0LlxuICovXG5jbGFzcyBTbmFwc2hvdFNvdXJjZSBleHRlbmRzIGJhc2VfMSQxLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIGlkKSB7XG4gICAgICAgIHN1cGVyKHdpcmUpO1xuICAgICAgICBfU25hcHNob3RTb3VyY2VfaWRlbnRpdHkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TbmFwc2hvdFNvdXJjZV9nZXRDb25uZWN0aW9uLnNldCh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb25NYXAuaGFzKHRoaXMuaWRlbnRpdHkudXVpZCkpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFwLnNldCh0aGlzLmlkZW50aXR5LnV1aWQsIHsgZXZlbnRGaXJlZDogbnVsbCwgY2xpZW50UHJvbWlzZTogbnVsbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uTWFwLmdldCh0aGlzLmlkZW50aXR5LnV1aWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgX1NuYXBzaG90U291cmNlX2dldENsaWVudC5zZXQodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1NuYXBzaG90U291cmNlX2dldENvbm5lY3Rpb24sIFwiZlwiKS5jYWxsKHRoaXMpLmNsaWVudFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1NuYXBzaG90U291cmNlX2dldENvbm5lY3Rpb24sIFwiZlwiKS5jYWxsKHRoaXMpLmNsaWVudFByb21pc2UgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1NuYXBzaG90U291cmNlX3N0YXJ0Q29ubmVjdGlvbiwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9TbmFwc2hvdFNvdXJjZV9nZXRDb25uZWN0aW9uLCBcImZcIikuY2FsbCh0aGlzKS5jbGllbnRQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICAgICAgX1NuYXBzaG90U291cmNlX3N0YXJ0Q29ubmVjdGlvbi5zZXQodGhpcywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSAoMCwgdXRpbHNfMSQxLmdldFNuYXBzaG90U291cmNlQ2hhbm5lbE5hbWUpKHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfU25hcHNob3RTb3VyY2VfZ2V0Q29ubmVjdGlvbiwgXCJmXCIpLmNhbGwodGhpcykuZXZlbnRGaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1NuYXBzaG90U291cmNlX3NldFVwQ29ubmVjdGlvbkxpc3RlbmVyLCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5maW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLmNvbm5lY3QoY2hhbm5lbE5hbWUsIHsgd2FpdDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgY2xpZW50Lm9uRGlzY29ubmVjdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfU25hcHNob3RTb3VyY2VfZ2V0Q29ubmVjdGlvbiwgXCJmXCIpLmNhbGwodGhpcykuY2xpZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfU25hcHNob3RTb3VyY2VfZ2V0Q29ubmVjdGlvbiwgXCJmXCIpLmNhbGwodGhpcykuZXZlbnRGaXJlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9TbmFwc2hvdFNvdXJjZV9nZXRDb25uZWN0aW9uLCBcImZcIikuY2FsbCh0aGlzKS5jbGllbnRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGFyZ2V0ZWQgU25hcHNob3RTb3VyY2UgaXMgbm90IGN1cnJlbnRseSBpbml0aWFsaXplZC4gQXdhaXQgdGhpcyBvYmplY3QncyByZWFkeSgpIG1ldGhvZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfU25hcHNob3RTb3VyY2Vfc2V0VXBDb25uZWN0aW9uTGlzdGVuZXIuc2V0KHRoaXMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gKDAsIHV0aWxzXzEkMS5nZXRTbmFwc2hvdFNvdXJjZUNoYW5uZWxOYW1lKSh0aGlzLmlkZW50aXR5KTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RmlyZWQgPSBuZXcgUHJvbWlzZSgoeSwgbikgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSB5O1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IG47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfU25hcHNob3RTb3VyY2VfZ2V0Q29ubmVjdGlvbiwgXCJmXCIpLmNhbGwodGhpcykuZXZlbnRGaXJlZCA9IGV2ZW50RmlyZWQ7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY2hhbm5lbE5hbWUgPT09IGNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3RlZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwub24oJ2Nvbm5lY3RlZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfU25hcHNob3RTb3VyY2VfaWRlbnRpdHksIGlkLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBpZGVudGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfU25hcHNob3RTb3VyY2VfaWRlbnRpdHksIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGRldGVybWluZSBpZiB0aGUgU25hcHNob3RTb3VyY2UgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBVc2Ugd2hlbiB0aGUgcGFyZW50IGFwcGxpY2F0aW9uIGlzIHN0YXJ0aW5nIHVwIHRvIGVuc3VyZSB0aGUgU25hcHNob3RTb3VyY2UgaXMgYWJsZSB0byBhY2NlcHQgYW5kXG4gICAgICogYXBwbHkgYSBzbmFwc2hvdCB1c2luZyB0aGUge0BsaW5rIFNuYXBzaG90U291cmNlI2FwcGx5U25hcHNob3QgYXBwbHlTbmFwc2hvdH0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBzbmFwc2hvdFNvdXJjZSA9IGZpbi5TbmFwc2hvdFNvdXJjZS53cmFwU3luYyhmaW4ubWUpO1xuICAgICAqXG4gICAgICogY29uc3Qgc25hcHNob3RQcm92aWRlciA9IHtcbiAgICAgKiAgICAgYXN5bmMgZ2V0U25hcHNob3QoKSB7IHJldHVybiAnZm9vJyB9LFxuICAgICAqICAgICBhc3luYyBhcHBseVNuYXBzaG90KHNuYXBzaG90KSB7XG4gICAgICogICAgICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICAgICAqICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogYXdhaXQgZmluLlNuYXBzaG90U291cmNlLmluaXQoc25hcHNob3RQcm92aWRlcik7XG4gICAgICpcbiAgICAgKiB0cnkge1xuICAgICAqICAgYXdhaXQgc25hcHNob3RTb3VyY2UucmVhZHkoKTtcbiAgICAgKiAgIGF3YWl0IHNuYXBzaG90U291cmNlLmFwcGx5U25hcHNob3QoJ2ZvbycpO1xuICAgICAqIH0gY2F0Y2ggKGVycikge1xuICAgICAqICAgY29uc29sZS5sb2coZXJyKVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWFkeSgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3NuYXBzaG90LXNvdXJjZS1yZWFkeScpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBnZXRDbGllbnQgd2FzIGFscmVhZHkgY2FsbGVkIGJlZm9yZSB0aGlzLCBkbyB3ZSBoYXZlIGEgdGltaW5nIGlzc3VlIHdoZXJlIHRoZSBjaGFubmVsIG1pZ2h0IGhhdmUgYmVlbiBjcmVhdGVkIGJ1dCB3ZSBtaXNzZWQgdGhlIGV2ZW50IGJ1dCB0aGlzIHN0aWxsIGZhaWxzP1xuICAgICAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9TbmFwc2hvdFNvdXJjZV9nZXRDbGllbnQsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpdCB3YXMgbm90IHJ1bm5pbmcuXG4gICAgICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1NuYXBzaG90U291cmNlX2dldENvbm5lY3Rpb24sIFwiZlwiKS5jYWxsKHRoaXMpLmV2ZW50RmlyZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgU25hcHNob3RTb3VyY2UncyBnZXRTbmFwc2hvdCBtZXRob2QgZGVmaW5lZCBieSB7QGxpbmsgU25hcHNob3RTb3VyY2UuU25hcHNob3RTb3VyY2VNb2R1bGUjaW5pdCBpbml0fS5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNuYXBzaG90KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc25hcHNob3Qtc291cmNlLWdldC1zbmFwc2hvdCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfU25hcHNob3RTb3VyY2VfZ2V0Q2xpZW50LCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdnZXQtc25hcHNob3QnKSk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcmVzcG9uc2UpLnNuYXBzaG90O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBTbmFwc2hvdFNvdXJjZSdzIGFwcGx5U25hcHNob3QgbWV0aG9kIGRlZmluZWQgYnkge0BsaW5rIFNuYXBzaG90U291cmNlLlNuYXBzaG90U291cmNlTW9kdWxlI2luaXQgaW5pdH0uXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBhcHBseVNuYXBzaG90KHNuYXBzaG90KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzbmFwc2hvdC1zb3VyY2UtYXBwbHktc25hcHNob3QnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1NuYXBzaG90U291cmNlX2dldENsaWVudCwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2FwcGx5LXNuYXBzaG90JywgeyBzbmFwc2hvdCB9KTtcbiAgICB9XG59XG5JbnN0YW5jZS5TbmFwc2hvdFNvdXJjZSA9IFNuYXBzaG90U291cmNlO1xuX1NuYXBzaG90U291cmNlX2lkZW50aXR5ID0gbmV3IFdlYWtNYXAoKSwgX1NuYXBzaG90U291cmNlX2dldENvbm5lY3Rpb24gPSBuZXcgV2Vha01hcCgpLCBfU25hcHNob3RTb3VyY2VfZ2V0Q2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgX1NuYXBzaG90U291cmNlX3N0YXJ0Q29ubmVjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9TbmFwc2hvdFNvdXJjZV9zZXRVcENvbm5lY3Rpb25MaXN0ZW5lciA9IG5ldyBXZWFrTWFwKCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWN0b3J5LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbkZhY3RvcnkuU25hcHNob3RTb3VyY2VNb2R1bGUgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSBiYXNlO1xuY29uc3QgSW5zdGFuY2VfMSA9IEluc3RhbmNlO1xuY29uc3QgdXRpbHNfMSA9IHV0aWxzO1xuLyoqXG4gKiBTdGF0aWMgbmFtZXNwYWNlIGZvciBPcGVuRmluIEFQSSBtZXRob2RzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUge0BsaW5rIFNuYXBzaG90U291cmNlfSBjbGFzcywgYXZhaWxhYmxlIHVuZGVyIGBmaW4uU25hcHNob3RTb3VyY2VgLlxuICovXG5jbGFzcyBTbmFwc2hvdFNvdXJjZU1vZHVsZSBleHRlbmRzIGJhc2VfMS5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIFNuYXBzaG90U291cmNlIHdpdGggdGhlIGdldFNuYXBzaG90IGFuZCBhcHBseVNuYXBzaG90IG1ldGhvZHMgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEB0eXBlUGFyYW0gU25hcHNob3QgSW1wbGVtZW50YXRpb24tZGVmaW5lZCBzaGFwZSBvZiBhbiBhcHBsaWNhdGlvbiBzbmFwc2hvdC4gIEFsbG93c1xuICAgICAqIGN1c3RvbSBzbmFwc2hvdCBpbXBsZW1lbnRhdGlvbnMgZm9yIGxlZ2FjeSBhcHBsaWNhdGlvbnMgdG8gZGVmaW5lIHRoZWlyIG93biBzbmFwc2hvdCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgc25hcHNob3RQcm92aWRlciA9IHtcbiAgICAgKiAgICAgYXN5bmMgZ2V0U25hcHNob3QoKSB7XG4gICAgICogICAgICAgY29uc3QgYm91bmRzID0gYXdhaXQgZmluLm1lLmdldEJvdW5kcygpO1xuICAgICAqICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICogICAgICB9LFxuICAgICAqICAgICBhc3luYyBhcHBseVNuYXBzaG90KHNuYXBzaG90KSB7XG4gICAgICogICAgICAgYXdhaXQgZmluLm1lLnNldEJvdW5kcyhzbmFwc2hvdCk7XG4gICAgICogICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGF3YWl0IGZpbi5TbmFwc2hvdFNvdXJjZS5pbml0KHNuYXBzaG90UHJvdmlkZXIpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgaW5pdChwcm92aWRlcikge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc25hcHNob3Qtc291cmNlLWluaXQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIHByb3ZpZGVyLmdldFNuYXBzaG90ICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdmlkZXIuYXBwbHlTbmFwc2hvdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5b3UgbXVzdCBwYXNzIGluIGEgdmFsaWQgU25hcHNob3RQcm92aWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCB0aGlzLmZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKCgwLCB1dGlsc18xLmdldFNuYXBzaG90U291cmNlQ2hhbm5lbE5hbWUpKHRoaXMuZmluLm1lKSk7XG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2dldC1zbmFwc2hvdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgcHJvdmlkZXIuZ2V0U25hcHNob3QoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNuYXBzaG90IH07XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdhcHBseS1zbmFwc2hvdCcsICh7IHNuYXBzaG90IH0pID0+IHByb3ZpZGVyLmFwcGx5U25hcHNob3Qoc25hcHNob3QpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgU25hcHNob3RTb3VyY2Ugb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBTbmFwc2hvdFNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBzbmFwc2hvdFNvdXJjZSA9IGZpbi5TbmFwc2hvdFNvdXJjZS53cmFwU3luYyhmaW4ubWUpO1xuICAgICAqIC8vIFVzZSB3cmFwcGVkIGluc3RhbmNlJ3MgZ2V0U25hcHNob3QgbWV0aG9kLCBlLmcuOlxuICAgICAqIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgc25hcHNob3RTb3VyY2UuZ2V0U25hcHNob3QoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB3cmFwU3luYyhpZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc25hcHNob3Qtc291cmNlLXdyYXAtc3luYycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMS5TbmFwc2hvdFNvdXJjZSh0aGlzLndpcmUsIGlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFNuYXBzaG90U291cmNlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgU25hcHNob3RTb3VyY2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgc25hcHNob3RTb3VyY2UgPSBhd2FpdCBmaW4uU25hcHNob3RTb3VyY2Uud3JhcChmaW4ubWUpO1xuICAgICAqIC8vIFVzZSB3cmFwcGVkIGluc3RhbmNlJ3MgZ2V0U25hcHNob3QgbWV0aG9kLCBlLmcuOlxuICAgICAqIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgc25hcHNob3RTb3VyY2UuZ2V0U25hcHNob3QoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB3cmFwKGlkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzbmFwc2hvdC1zb3VyY2Utd3JhcCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBTeW5jKGlkZW50aXR5KTtcbiAgICB9XG59XG5GYWN0b3J5LlNuYXBzaG90U291cmNlTW9kdWxlID0gU25hcHNob3RTb3VyY2VNb2R1bGU7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQvKipcblx0ICogRW50cnkgcG9pbnRzIGZvciB0aGUgT3BlbkZpbiBgU25hcHNob3RTb3VyY2VgIEFQSSAoYGZpbi5TbmFwc2hvdFNvdXJjZWApLlxuXHQgKlxuXHQgKiAqIHtAbGluayBTbmFwc2hvdFNvdXJjZU1vZHVsZX0gY29udGFpbnMgc3RhdGljIG1lbWJlcnMgb2YgdGhlIGBTbmFwc2hvdFNvdXJjZWAgQVBJLCBhY2Nlc3NpYmxlIHRocm91Z2ggYGZpbi5TbmFwc2hvdFNvdXJjZWAuXG5cdCAqICoge0BsaW5rIFNuYXBzaG90U291cmNlfSBkZXNjcmliZXMgYW4gaW5zdGFuY2Ugb2YgYW4gT3BlbkZpbiBTbmFwc2hvdFNvdXJjZSwgZS5nLiBhcyByZXR1cm5lZCBieSBgZmluLlNuYXBzaG90U291cmNlLndyYXBgLlxuXHQgKlxuXHQgKiBUaGVzZSBhcmUgc2VwYXJhdGUgY29kZSBlbnRpdGllcywgYW5kIGFyZSBkb2N1bWVudGVkIHNlcGFyYXRlbHkuICBJbiB0aGUgW3ByZXZpb3VzIHZlcnNpb24gb2YgdGhlIEFQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2Nkbi5vcGVuZmluLmNvL2RvY3MvamF2YXNjcmlwdC8zMi4xMTQuNzYuMTAvaW5kZXguaHRtbCksXG5cdCAqIGJvdGggb2YgdGhlc2Ugd2VyZSBkb2N1bWVudGVkIG9uIHRoZSBzYW1lIHBhZ2UuXG5cdCAqXG5cdCAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuXHQgKi9cblx0dmFyIF9fY3JlYXRlQmluZGluZyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXHQgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcblx0ICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG5cdH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG5cdCAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuXHQgICAgb1trMl0gPSBtW2tdO1xuXHR9KSk7XG5cdHZhciBfX2V4cG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0X19leHBvcnRTdGFyKEZhY3RvcnksIGV4cG9ydHMpO1xuXHRfX2V4cG9ydFN0YXIoSW5zdGFuY2UsIGV4cG9ydHMpOyBcbn0gKHNuYXBzaG90U291cmNlKSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaW4kMSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5maW4kMS5GaW4gPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSQzID0gcmVxdWlyZSQkMDtcbi8vIEltcG9ydCBmcm9tIHRoZSBmaWxlIHJhdGhlciB0aGFuIHRoZSBkaXJlY3RvcnkgaW4gY2FzZSBzb21lb25lIGNvbnN1bWluZyB0eXBlcyBpcyB1c2luZyBtb2R1bGUgcmVzb2x1dGlvbiBvdGhlciB0aGFuIFwibm9kZVwiXG5jb25zdCBpbmRleF8xID0gc3lzdGVtO1xuY29uc3QgaW5kZXhfMiA9IHJlcXVpcmVXaW5kb3coKTtcbmNvbnN0IGluZGV4XzMgPSByZXF1aXJlQXBwbGljYXRpb24oKTtcbmNvbnN0IGluZGV4XzQgPSBpbnRlcmFwcGJ1cztcbmNvbnN0IGluZGV4XzUgPSBjbGlwYm9hcmQ7XG5jb25zdCBpbmRleF82ID0gZXh0ZXJuYWxBcHBsaWNhdGlvbjtcbmNvbnN0IGluZGV4XzcgPSBmcmFtZTtcbmNvbnN0IGluZGV4XzggPSBnbG9iYWxIb3RrZXk7XG5jb25zdCBpbmRleF85ID0gcmVxdWlyZVZpZXcoKTtcbmNvbnN0IGluZGV4XzEwID0gcGxhdGZvcm07XG5jb25zdCBtZV8xJDIgPSBtZTtcbmNvbnN0IGludGVyb3BfMSA9IHJlcXVpcmVJbnRlcm9wKCk7XG5jb25zdCBzbmFwc2hvdF9zb3VyY2VfMSA9IHNuYXBzaG90U291cmNlO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRmluIGV4dGVuZHMgZXZlbnRzXzEkMy5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpcmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aXJlID0gd2lyZTtcbiAgICAgICAgdGhpcy5TeXN0ZW0gPSBuZXcgaW5kZXhfMS5TeXN0ZW0od2lyZSk7XG4gICAgICAgIHRoaXMuV2luZG93ID0gbmV3IGluZGV4XzIuX1dpbmRvd01vZHVsZSh3aXJlKTtcbiAgICAgICAgdGhpcy5BcHBsaWNhdGlvbiA9IG5ldyBpbmRleF8zLkFwcGxpY2F0aW9uTW9kdWxlKHdpcmUpO1xuICAgICAgICB0aGlzLkludGVyQXBwbGljYXRpb25CdXMgPSBuZXcgaW5kZXhfNC5JbnRlckFwcGxpY2F0aW9uQnVzKHdpcmUpO1xuICAgICAgICB0aGlzLkNsaXBib2FyZCA9IG5ldyBpbmRleF81LkNsaXBib2FyZCh3aXJlKTtcbiAgICAgICAgdGhpcy5FeHRlcm5hbEFwcGxpY2F0aW9uID0gbmV3IGluZGV4XzYuRXh0ZXJuYWxBcHBsaWNhdGlvbk1vZHVsZSh3aXJlKTtcbiAgICAgICAgdGhpcy5GcmFtZSA9IG5ldyBpbmRleF83Ll9GcmFtZU1vZHVsZSh3aXJlKTtcbiAgICAgICAgdGhpcy5HbG9iYWxIb3RrZXkgPSBuZXcgaW5kZXhfOC5HbG9iYWxIb3RrZXkod2lyZSk7XG4gICAgICAgIHRoaXMuUGxhdGZvcm0gPSBuZXcgaW5kZXhfMTAuUGxhdGZvcm1Nb2R1bGUod2lyZSwgdGhpcy5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwpO1xuICAgICAgICB0aGlzLlZpZXcgPSBuZXcgaW5kZXhfOS5WaWV3TW9kdWxlKHdpcmUpO1xuICAgICAgICB0aGlzLkludGVyb3AgPSBuZXcgaW50ZXJvcF8xLkludGVyb3BNb2R1bGUod2lyZSk7XG4gICAgICAgIHRoaXMuU25hcHNob3RTb3VyY2UgPSBuZXcgc25hcHNob3Rfc291cmNlXzEuU25hcHNob3RTb3VyY2VNb2R1bGUod2lyZSk7XG4gICAgICAgIHdpcmUucmVnaXN0ZXJGaW4odGhpcyk7XG4gICAgICAgIHRoaXMubWUgPSAoMCwgbWVfMSQyLmdldE1lKSh3aXJlKTtcbiAgICAgICAgLy8gSGFuZGxlIGRpc2Nvbm5lY3QgZXZlbnRzXG4gICAgICAgIHdpcmUub24oJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZpbiQxLkZpbiA9IEZpbjtcblxudmFyIHRyYW5zcG9ydCA9IHt9O1xuXG52YXIgd2lyZSA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2lyZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG53aXJlLmlzSW50ZXJuYWxDb25uZWN0Q29uZmlnID0gd2lyZS5pc1BvcnREaXNjb3ZlcnlDb25maWcgPSB3aXJlLmlzTmV3Q29ubmVjdENvbmZpZyA9IHdpcmUuaXNDb25maWdXaXRoUmVjZWl2ZXIgPSB3aXJlLmlzUmVtb3RlQ29uZmlnID0gd2lyZS5pc0V4aXN0aW5nQ29ubmVjdENvbmZpZyA9IHdpcmUuaXNFeHRlcm5hbENvbmZpZyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzRXh0ZXJuYWxDb25maWcoY29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcubWFuaWZlc3RVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG53aXJlLmlzRXh0ZXJuYWxDb25maWcgPSBpc0V4dGVybmFsQ29uZmlnO1xuZnVuY3Rpb24gaXNFeGlzdGluZ0Nvbm5lY3RDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIGhhc1V1aWQoY29uZmlnKSAmJiB0eXBlb2YgY29uZmlnLmFkZHJlc3MgPT09ICdzdHJpbmcnO1xufVxud2lyZS5pc0V4aXN0aW5nQ29ubmVjdENvbmZpZyA9IGlzRXhpc3RpbmdDb25uZWN0Q29uZmlnO1xuZnVuY3Rpb24gaXNSZW1vdGVDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIGlzRXhpc3RpbmdDb25uZWN0Q29uZmlnKGNvbmZpZykgJiYgdHlwZW9mIGNvbmZpZy50b2tlbiA9PT0gJ3N0cmluZyc7XG59XG53aXJlLmlzUmVtb3RlQ29uZmlnID0gaXNSZW1vdGVDb25maWc7XG5mdW5jdGlvbiBpc0NvbmZpZ1dpdGhSZWNlaXZlcihjb25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbmZpZy5yZWNlaXZlciA9PT0gJ29iamVjdCcgJiYgaXNSZW1vdGVDb25maWcoeyAuLi5jb25maWcsIGFkZHJlc3M6ICcnIH0pO1xufVxud2lyZS5pc0NvbmZpZ1dpdGhSZWNlaXZlciA9IGlzQ29uZmlnV2l0aFJlY2VpdmVyO1xuZnVuY3Rpb24gaGFzVXVpZChjb25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbmZpZy51dWlkID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGhhc1J1bnRpbWVWZXJzaW9uKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcucnVudGltZSAmJiB0eXBlb2YgY29uZmlnLnJ1bnRpbWUudmVyc2lvbiA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc05ld0Nvbm5lY3RDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIGhhc1V1aWQoY29uZmlnKSAmJiBoYXNSdW50aW1lVmVyc2lvbihjb25maWcpO1xufVxud2lyZS5pc05ld0Nvbm5lY3RDb25maWcgPSBpc05ld0Nvbm5lY3RDb25maWc7XG5mdW5jdGlvbiBpc1BvcnREaXNjb3ZlcnlDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIChpc0V4dGVybmFsQ29uZmlnKGNvbmZpZykgJiYgaGFzUnVudGltZVZlcnNpb24oY29uZmlnKSkgfHwgaXNOZXdDb25uZWN0Q29uZmlnKGNvbmZpZyk7XG59XG53aXJlLmlzUG9ydERpc2NvdmVyeUNvbmZpZyA9IGlzUG9ydERpc2NvdmVyeUNvbmZpZztcbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb25uZWN0Q29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiBpc0V4aXN0aW5nQ29ubmVjdENvbmZpZyhjb25maWcpIHx8IGlzTmV3Q29ubmVjdENvbmZpZyhjb25maWcpO1xufVxud2lyZS5pc0ludGVybmFsQ29ubmVjdENvbmZpZyA9IGlzSW50ZXJuYWxDb25uZWN0Q29uZmlnO1xuXG52YXIgZXZlbnRBZ2dyZWdhdG9yID0ge307XG5cbnZhciBlbWl0dGVyTWFwID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbWl0dGVyTWFwLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmVtaXR0ZXJNYXAuRW1pdHRlck1hcCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xJDIgPSByZXF1aXJlJCQwO1xuY2xhc3MgRW1pdHRlck1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBoYXNoS2V5cyhrZXlzKSB7XG4gICAgICAgIGNvbnN0IGhhc2hlZCA9IGtleXMubWFwKG5vcm1hbGl6ZVN0cmluZyk7XG4gICAgICAgIHJldHVybiBoYXNoZWQuam9pbignLycpO1xuICAgIH1cbiAgICBnZXRPckNyZWF0ZShrZXlzKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmhhc2hLZXlzKGtleXMpO1xuICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZS5oYXMoaGFzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoaGFzaCwgbmV3IGV2ZW50c18xJDIuRXZlbnRFbWl0dGVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHNldCBpdCBhYm92ZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldChoYXNoKTtcbiAgICB9XG4gICAgaGFzKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5oYXModGhpcy5oYXNoS2V5cyhrZXlzKSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXlzKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmhhc2hLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmRlbGV0ZShoYXNoKTtcbiAgICB9XG59XG5lbWl0dGVyTWFwLkVtaXR0ZXJNYXAgPSBFbWl0dGVyTWFwO1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHMpIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmZyb20ocyk7XG4gICAgcmV0dXJuIGIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnRBZ2dyZWdhdG9yLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGVtaXR0ZXJNYXBfMSA9IGVtaXR0ZXJNYXA7XG5mdW5jdGlvbiBpc0V2ZW50TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UuYWN0aW9uID09PSAncHJvY2Vzcy1kZXNrdG9wLWV2ZW50Jztcbn1cbmZ1bmN0aW9uIG1hcEtleUZyb21FdmVudChldmVudCkge1xuICAgIGNvbnN0IHsgdG9waWMgfSA9IGV2ZW50O1xuICAgIGlmICh0b3BpYyA9PT0gJ2ZyYW1lJyB8fCB0b3BpYyA9PT0gJ3dpbmRvdycgfHwgdG9waWMgPT09ICd2aWV3Jykge1xuICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gW3RvcGljLCB1dWlkLCBuYW1lXTtcbiAgICB9XG4gICAgaWYgKHRvcGljID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIGNvbnN0IHsgdXVpZCB9ID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBbdG9waWMsIHV1aWRdO1xuICAgIH1cbiAgICByZXR1cm4gW3RvcGljXTtcbn1cbmNsYXNzIEV2ZW50QWdncmVnYXRvciBleHRlbmRzIGVtaXR0ZXJNYXBfMS5FbWl0dGVyTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0V2ZW50TWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NvciA9IG1hcEtleUZyb21FdmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMoYWNjZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JDcmVhdGUoYWNjZXNzb3IpLmVtaXQocGF5bG9hZC50eXBlLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV2ZW50QWdncmVnYXRvci5kZWZhdWx0ID0gRXZlbnRBZ2dyZWdhdG9yO1xuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9UcmFuc3BvcnRfd2lyZSwgX1RyYW5zcG9ydF9maW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkodHJhbnNwb3J0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnRyYW5zcG9ydC5UcmFuc3BvcnQgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSQxID0gcmVxdWlyZSQkMDtcbmNvbnN0IHdpcmVfMSA9IHdpcmU7XG5jb25zdCB0cmFuc3BvcnRfZXJyb3JzXzEgPSB0cmFuc3BvcnRFcnJvcnM7XG5jb25zdCBldmVudEFnZ3JlZ2F0b3JfMSA9IGV2ZW50QWdncmVnYXRvcjtcbmNvbnN0IG1lXzEkMSA9IG1lO1xuY29uc3QgZXJyb3JzXzEgPSBlcnJvcnM7XG5jbGFzcyBUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNfMSQxLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoV2lyZVR5cGUsIGVudmlyb25tZW50LCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aXJlTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRvcGljUmVmTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmV2ZW50QWdncmVnYXRvciA9IG5ldyBldmVudEFnZ3JlZ2F0b3JfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzID0gW3RoaXMuZXZlbnRBZ2dyZWdhdG9yLmRpc3BhdGNoRXZlbnRdO1xuICAgICAgICBfVHJhbnNwb3J0X3dpcmUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8vIFR5cGluZyBhcyB1bmtub3duIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgICAgX1RyYW5zcG9ydF9maW4uc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY29ubmVjdFN5bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3aXJlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVHJhbnNwb3J0X3dpcmUsIFwiZlwiKTtcbiAgICAgICAgICAgIHdpcmUuY29ubmVjdFN5bmMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgaW4gb3VyIHRlc3RzLlxuICAgICAgICB0aGlzLmdldFBvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3aXJlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVHJhbnNwb3J0X3dpcmUsIFwiZlwiKTtcbiAgICAgICAgICAgIHJldHVybiB3aXJlLmdldFBvcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfVHJhbnNwb3J0X3dpcmUsIG5ldyBXaXJlVHlwZSh0aGlzLm9ubWVzc2FnZS5iaW5kKHRoaXMpKSwgXCJmXCIpO1xuICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG4gICAgICAgIHRoaXMuc2VuZFJhdyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1RyYW5zcG9ydF93aXJlLCBcImZcIikuc2VuZC5iaW5kKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1RyYW5zcG9ydF93aXJlLCBcImZcIikpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIodGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9UcmFuc3BvcnRfd2lyZSwgXCJmXCIpLm9uKCdkaXNjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHsgaGFuZGxlTmFjayB9XSBvZiB0aGlzLndpcmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOYWNrKHsgcmVhc29uOiAnUmVtb3RlIGNvbm5lY3Rpb24gaGFzIGNsb3NlZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpcmVMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgZW50aXR5VHlwZSA9IHRoaXMuZW52aXJvbm1lbnQuZ2V0Q3VycmVudEVudGl0eVR5cGUoKTtcbiAgICAgICAgdGhpcy5tZSA9ICgwLCBtZV8xJDEuZ2V0QmFzZU1lKShlbnRpdHlUeXBlLCB1dWlkLCBuYW1lKTtcbiAgICB9XG4gICAgZ2V0RmluKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1RyYW5zcG9ydF9maW4sIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBGaW4gb2JqZWN0IHJlZ2lzdGVyZWQgZm9yIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1RyYW5zcG9ydF9maW4sIFwiZlwiKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJGaW4oX2Zpbikge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVHJhbnNwb3J0X2ZpbiwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbiBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGZvciB0aGlzIHRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1RyYW5zcG9ydF9maW4sIF9maW4sIFwiZlwiKTtcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIGNvbnN0IHdpcmUgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9UcmFuc3BvcnRfd2lyZSwgXCJmXCIpO1xuICAgICAgICByZXR1cm4gd2lyZS5zaHV0ZG93bigpO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoKDAsIHdpcmVfMS5pc0NvbmZpZ1dpdGhSZWNlaXZlcikoY29uZmlnKSkge1xuICAgICAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVHJhbnNwb3J0X3dpcmUsIFwiZlwiKS5jb25uZWN0KGNvbmZpZy5yZWNlaXZlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpemUoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHdpcmVfMS5pc1JlbW90ZUNvbmZpZykoY29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFJlbW90ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgd2lyZV8xLmlzRXhpc3RpbmdDb25uZWN0Q29uZmlnKShjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0QnlQb3J0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB3aXJlXzEuaXNOZXdDb25uZWN0Q29uZmlnKShjb25maWcpKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gYXdhaXQgdGhpcy5lbnZpcm9ubWVudC5yZXRyaWV2ZVBvcnQoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RCeVBvcnQoeyAuLi5jb25maWcsIGFkZHJlc3M6IGB3czovL2xvY2FsaG9zdDoke3BvcnR9YCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0UmVtb3RlKGNvbmZpZykge1xuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9UcmFuc3BvcnRfd2lyZSwgXCJmXCIpLmNvbm5lY3QobmV3ICh0aGlzLmVudmlyb25tZW50LmdldFdzQ29uc3RydWN0b3IoKSkoY29uZmlnLmFkZHJlc3MpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aG9yaXplKGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3RCeVBvcnQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcywgdXVpZCB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCByZXFBdXRoUGF5bG9hZCA9IHsgLi4uY29uZmlnLCB0eXBlOiAnZmlsZS10b2tlbicgfTtcbiAgICAgICAgY29uc3Qgd2lyZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1RyYW5zcG9ydF93aXJlLCBcImZcIik7XG4gICAgICAgIGF3YWl0IHdpcmUuY29ubmVjdChuZXcgKHRoaXMuZW52aXJvbm1lbnQuZ2V0V3NDb25zdHJ1Y3RvcigpKShjb25maWcuYWRkcmVzcykpO1xuICAgICAgICBjb25zdCByZXF1ZXN0RXh0QXV0aFJldCA9IGF3YWl0IHRoaXMuc2VuZEFjdGlvbigncmVxdWVzdC1leHRlcm5hbC1hdXRob3JpemF0aW9uJywge1xuICAgICAgICAgICAgdXVpZCxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlLXRva2VuJ1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlcXVlc3RFeHRBdXRoUmV0LmFjdGlvbiAhPT0gJ2V4dGVybmFsLWF1dGhvcml6YXRpb24tcmVzcG9uc2UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHJhbnNwb3J0X2Vycm9yc18xLlVuZXhwZWN0ZWRBY3Rpb25FcnJvcihyZXF1ZXN0RXh0QXV0aFJldC5hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZW52aXJvbm1lbnQud3JpdGVUb2tlbihyZXF1ZXN0RXh0QXV0aFJldC5wYXlsb2FkLmZpbGUsIHJlcXVlc3RFeHRBdXRoUmV0LnBheWxvYWQudG9rZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpemUocmVxQXV0aFBheWxvYWQpO1xuICAgIH1cbiAgICBhc3luYyBhdXRob3JpemUocmVxQXV0aFBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEF1dGhSZXQgPSBhd2FpdCB0aGlzLnNlbmRBY3Rpb24oJ3JlcXVlc3QtYXV0aG9yaXphdGlvbicsIHJlcUF1dGhQYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgaWYgKHJlcXVlc3RBdXRoUmV0LmFjdGlvbiAhPT0gJ2F1dGhvcml6YXRpb24tcmVzcG9uc2UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHJhbnNwb3J0X2Vycm9yc18xLlVuZXhwZWN0ZWRBY3Rpb25FcnJvcihyZXF1ZXN0QXV0aFJldC5hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3RBdXRoUmV0LnBheWxvYWQuc3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHRyYW5zcG9ydF9lcnJvcnNfMS5SdW50aW1lRXJyb3IocmVxdWVzdEF1dGhSZXQucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZEFjdGlvbihhY3Rpb24sIHBheWxvYWQgPSB7fSwgdW5jb3JyZWxhdGVkID0gZmFsc2VcbiAgICAvLyBzcGVjaWFsUmVzcG9uc2UgdHlwZSBpcyBvbmx5IHVzZWQgZm9yICdyZXF1ZXN0QXV0aG9yaXphdGlvbidcbiAgICApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICBsZXQgY2FuY2VsID0gKCkgPT4geyB9O1xuICAgICAgICAvLyBXZSB3YW50IHRoZSBjYWxsc2l0ZSBmcm9tIHRoZSBjYWxsZXIgb2YgdGhpcyBmdW5jdGlvbiwgbm90IGZyb20gaGVyZS5cbiAgICAgICAgY29uc3QgY2FsbFNpdGVzID0gdHJhbnNwb3J0X2Vycm9yc18xLlJ1bnRpbWVFcnJvci5nZXRDYWxsU2l0ZSgxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5lbnZpcm9ubWVudC5nZXROZXh0TWVzc2FnZUlkKCk7XG4gICAgICAgIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjYW5jZWwgPSByZWplY3Q7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgd2lyZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1RyYW5zcG9ydF93aXJlLCBcImZcIik7XG4gICAgICAgICAgICB0aGlzLmFkZFdpcmVMaXN0ZW5lcihtZXNzYWdlSWQsIHJlc29sdmUsIChwYXlsb2FkKSA9PiB0aGlzLm5hY2tIYW5kbGVyKHBheWxvYWQsIHJlamVjdCwgY2FsbFNpdGVzKSwgdW5jb3JyZWxhdGVkKTtcbiAgICAgICAgICAgIHJldHVybiB3aXJlLnNlbmQobXNnKS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbSwgeyBjYW5jZWwsIG1lc3NhZ2VJZCB9KTtcbiAgICB9XG4gICAgbmFja0hhbmRsZXIocGF5bG9hZE9yTWVzc2FnZSwgcmVqZWN0LCBjYWxsU2l0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkT3JNZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdG8gc3VwcG9ydCBwbGFpbiBzdHJpbmcgcmVqZWN0aW9uc1xuICAgICAgICAgICAgcmVqZWN0KHBheWxvYWRPck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEuUnVudGltZUVycm9yKHBheWxvYWRPck1lc3NhZ2UsIGNhbGxTaXRlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZlcnJ5QWN0aW9uKG9yaWdEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMuZW52aXJvbm1lbnQuZ2V0TmV4dE1lc3NhZ2VJZCgpO1xuICAgICAgICAgICAgb3JpZ0RhdGEubWVzc2FnZUlkID0gaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhLnBheWxvYWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHdpcmUgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9UcmFuc3BvcnRfd2lyZSwgXCJmXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHdpcmVcbiAgICAgICAgICAgICAgICAuc2VuZChvcmlnRGF0YSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmFkZFdpcmVMaXN0ZW5lcihpZCwgcmVzb2x2ZXIsIChwYXlsb2FkKSA9PiB0aGlzLm5hY2tIYW5kbGVyKHBheWxvYWQsIHJlamVjdCksIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgIH1cbiAgICBhZGRXaXJlTGlzdGVuZXIoaWQsIHJlc29sdmUsIGhhbmRsZU5hY2ssIHVuY29ycmVsYXRlZCkge1xuICAgICAgICBpZiAodW5jb3JyZWxhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuY29ycmVsYXRlZExpc3RlbmVyID0gcmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndpcmVMaXN0ZW5lcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgaGFuZGxlTmFjayh7XG4gICAgICAgICAgICAgICAgcmVhc29uOiAnRHVwbGljYXRlIGhhbmRsZXIgaWQnLFxuICAgICAgICAgICAgICAgIGVycm9yOiAoMCwgZXJyb3JzXzEuZXJyb3JUb1BPSk8pKG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEuRHVwbGljYXRlQ29ycmVsYXRpb25FcnJvcihTdHJpbmcoaWQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aXJlTGlzdGVuZXJzLnNldChpZCwgeyByZXNvbHZlLCBoYW5kbGVOYWNrIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRpbWVvdXQgYW5kIHJlamVjdCgpP1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBleGVjdXRlcyBtZXNzYWdlIGhhbmRsZXJzIHVudGlsIHRoZSBfb25lXyB0aGF0IGhhbmRsZXMgdGhlIG1lc3NhZ2UgKHJldHVybnMgdHJ1dGh5KSBoYXMgcnVuXG4gICAgb25tZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBoIG9mIHRoaXMubWVzc2FnZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICBoLmNhbGwobnVsbCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZGF0YS5jb3JyZWxhdGlvbklkIHx8IE5hTjtcbiAgICAgICAgaWYgKCEoJ2NvcnJlbGF0aW9uSWQnIGluIGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51bmNvcnJlbGF0ZWRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMudW5jb3JyZWxhdGVkTGlzdGVuZXIuY2FsbChudWxsLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5jb3JyZWxhdGVkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgYmxvY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMud2lyZUxpc3RlbmVycy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBqdXN0IGNoZWNrZWQgZm9yIGV4aXN0ZW5jZSBhYm92ZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgaGFuZGxlTmFjayB9ID0gdGhpcy53aXJlTGlzdGVuZXJzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoZGF0YS5hY3Rpb24gIT09ICdhY2snKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTmFjayh7IHJlYXNvbjogJ0RpZCBub3QgcmVjZWl2ZSBhY2sgYWN0aW9uJywgZXJyb3I6ICgwLCBlcnJvcnNfMS5lcnJvclRvUE9KTykobmV3IHRyYW5zcG9ydF9lcnJvcnNfMS5Ob0Fja0Vycm9yKGRhdGEuYWN0aW9uKSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKCdwYXlsb2FkJyBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vIEknbSBub3Qgc3VyZSB3aGVuIHRoaXMgY29kZSB3b3VsZCBhY3R1YWxseSBydW4sIGJ1dCBwYXNzaW5nIGluIHNvbWV0aGluZyB0aGF0IGRvZWVzbid0IGhhdmUgYSByZWFzb24gdG8gdGhlIHJ1bnRpbWVlcnJvciBjb25zdHJ1Y3RvciB3aWxsIG5vdCBlbmQgd2VsbC5cbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLnJlYXNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVjZWl2ZWQgaW52YWxpZCByZXNwb25zZSBmcm9tIGNvcmUnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTmFjayh7IHJlYXNvbjogJ2ludmFsaWQgcmVzcG9uc2Ugc2hhcGUnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhLnBheWxvYWQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5hY2soZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUuY2FsbChudWxsLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud2lyZUxpc3RlbmVycy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbnRyYW5zcG9ydC5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG5fVHJhbnNwb3J0X3dpcmUgPSBuZXcgV2Vha01hcCgpLCBfVHJhbnNwb3J0X2ZpbiA9IG5ldyBXZWFrTWFwKCk7XG5cbnZhciBtb2NrRW52aXJvbm1lbnQgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vY2tFbnZpcm9ubWVudCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5tb2NrRW52aXJvbm1lbnQuTW9ja0Vudmlyb25tZW50ID0gdm9pZCAwO1xuY29uc3QgbWVfMSA9IG1lO1xuY2xhc3MgTW9ja0Vudmlyb25tZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ290aGVyJztcbiAgICAgICAgdGhpcy5jaGlsZFZpZXdzID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW50ZXJvcEluZm8oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdENoYW5uZWxPcHRpb25zKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVfMS5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG4gICAgfVxuICAgIGdldFJ0Y1BlZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgaW5pdExheW91dE1hbmFnZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgYXBwbHlMYXlvdXRTbmFwc2hvdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lXzEuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVMYXlvdXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgYXN5bmMgZGVzdHJveUxheW91dCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lXzEuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTGF5b3V0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVfMS5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG4gICAgfVxuICAgIGluaXRQbGF0Zm9ybSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lXzEuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBvYnNlcnZlQm91bmRzKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVfMS5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG4gICAgfVxuICAgIHdyaXRlVG9rZW4ocGF0aCwgdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lXzEuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXRyaWV2ZVBvcnQoY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgZ2V0TmV4dE1lc3NhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIGBtb2NrLW1lc3NhZ2UtaWQtJHtNYXRoLnJhbmRvbSgpfWA7XG4gICAgfVxuICAgIGdldFJhbmRvbUlkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVfMS5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkQ29udGVudChvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgZ2V0V2ViV2luZG93KGlkZW50aXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudEVudGl0eUlkZW50aXR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVfMS5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRFbnRpdHlUeXBlKCkge1xuICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgIH1cbiAgICByYWlzZUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZV8xLmVudmlyb25tZW50VW5zdXBwb3J0ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgZ2V0VXJsKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVfMS5lbnZpcm9ubWVudFVuc3VwcG9ydGVkTWVzc2FnZSk7XG4gICAgfVxuICAgIHdoZW5SZWFkeSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lXzEuZW52aXJvbm1lbnRVbnN1cHBvcnRlZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBnZXRXc0NvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxufVxubW9ja0Vudmlyb25tZW50Lk1vY2tFbnZpcm9ubWVudCA9IE1vY2tFbnZpcm9ubWVudDtcblxudmFyIG1vY2tXaXJlID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2NrV2lyZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5tb2NrV2lyZS5Nb2NrV2lyZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlJCQwO1xuY2xhc3MgTW9ja1dpcmUgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgcnVubmluZyBpbiBPcGVuRmluLicpO1xuICAgIH1cbiAgICBjb25uZWN0U3luYygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBydW5uaW5nIGluIE9wZW5GaW4uJyk7XG4gICAgfVxuICAgIHNlbmQoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IHJ1bm5pbmcgaW4gT3BlbkZpbi4nKTtcbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgcnVubmluZyBpbiBPcGVuRmluLicpO1xuICAgIH1cbiAgICBnZXRQb3J0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdHJhbnNwb3J0IGhhcyBubyBwb3J0Jyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxubW9ja1dpcmUuTW9ja1dpcmUgPSBNb2NrV2lyZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vY2ssIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maW4gPSBtb2NrLmZpbiA9IHZvaWQgMDtcbmNvbnN0IE9wZW5GaW4gPSBPcGVuRmluJDE7XG5jb25zdCBmaW5fMSA9IGZpbiQxO1xuY29uc3QgdHJhbnNwb3J0XzEgPSB0cmFuc3BvcnQ7XG5jb25zdCBtb2NrRW52aXJvbm1lbnRfMSA9IG1vY2tFbnZpcm9ubWVudDtcbmNvbnN0IG1vY2tXaXJlXzEgPSBtb2NrV2lyZTtcbmV4cG9ydHMuZmluID0gbW9jay5maW4gPSAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdz8uZmluKSB8fFxuICAgICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVudmlyb25tZW50ID0gbmV3IG1vY2tFbnZpcm9ubWVudF8xLk1vY2tFbnZpcm9ubWVudCgpO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0XzEuVHJhbnNwb3J0KG1vY2tXaXJlXzEuTW9ja1dpcmUsIGVudmlyb25tZW50LCB7XG4gICAgICAgICAgICB1dWlkOiAnJyxcbiAgICAgICAgICAgIG5hbWU6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IGZpbl8xLkZpbih0cmFuc3BvcnQpO1xuICAgIH0pKCkpO1xudmFyIF9kZWZhdWx0ID0gbW9jay5kZWZhdWx0ID0gT3BlbkZpbjtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy4yMSc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIENPUkVfRVJST1JfVEVYVCA9ICdVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC4nLFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nLFxuICAgICAgSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCA9ICdJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYCc7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xuICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKipcbiAgICogVXNlZCB0byB2YWxpZGF0ZSB0aGUgYHZhbGlkYXRlYCBvcHRpb24gaW4gYF8udGVtcGxhdGVgIHZhcmlhYmxlLlxuICAgKlxuICAgKiBGb3JiaWRzIGNoYXJhY3RlcnMgd2hpY2ggY291bGQgcG90ZW50aWFsbHkgY2hhbmdlIHRoZSBtZWFuaW5nIG9mIHRoZSBmdW5jdGlvbiBhcmd1bWVudCBkZWZpbml0aW9uOlxuICAgKiAtIFwiKCksXCIgKG1vZGlmaWNhdGlvbiBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICAgKiAtIFwiPVwiIChkZWZhdWx0IHZhbHVlKVxuICAgKiAtIFwiW117fVwiIChkZXN0cnVjdHVyaW5nIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMpXG4gICAqIC0gXCIvXCIgKGJlZ2lubmluZyBvZiBhIGNvbW1lbnQpXG4gICAqIC0gd2hpdGVzcGFjZVxuICAgKi9cbiAgdmFyIHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzID0gL1soKT0se31cXFtcXF1cXC9cXHNdLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmdcbiAgICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgICA6IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGNvdW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICArK3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIHZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgKytyZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qcy5cbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIHZhciBydW5JbkNvbnRleHQgPSAoZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KCkpO1xuXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY3R4Tm93ID0gRGF0ZSAmJiBEYXRlLm5vdyAhPT0gcm9vdC5EYXRlLm5vdyAmJiBEYXRlLm5vdyxcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSm9pbiA9IGFycmF5UHJvdG8uam9pbixcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxuICAgICAgICBQcm9taXNlID0gZ2V0TmF0aXZlKGNvbnRleHQsICdQcm9taXNlJyksXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbiAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcy4gTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLFxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICAgKiBhbmQgcmV0dXJuIHRoZSB1bndyYXBwZWQgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbiBzZXF1ZW5jZXMsIHdoaWNoIG11c3QgYmUgdW53cmFwcGVkIHdpdGggYF8jdmFsdWVgLCBtYXkgYmVcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAgICAgKlxuICAgICAqIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGl0J3MgZGVmZXJyZWQgdW50aWxcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLlxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAgICogaXRlcmF0ZWUgZXhlY3V0aW9ucy4gU2VjdGlvbnMgb2YgYSBjaGFpbiBzZXF1ZW5jZSBxdWFsaWZ5IGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICAgKiBgZmluZExhc3RgLCBgaGVhZGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHJlamVjdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICAgKiBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbmZvcm1zYCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLCBgY3JlYXRlYCxcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgICAqIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZXh0ZW5kYCwgYGV4dGVuZFdpdGhgLCBgZmlsbGAsIGBmaWx0ZXJgLFxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGZ1bmN0aW9uc0luYCwgYGdyb3VwQnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW50ZXJzZWN0aW9uQnlgLFxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgICAqIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1lcmdlV2l0aGAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLCBgbmVnYXRlYCxcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICAgKiBgcGlja0J5YCwgYHBsYW50YCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQWxsYCwgYHB1bGxBbGxCeWAsXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAgICogYHVuaW9uYCwgYHVuaW9uQnlgLCBgdW5pb25XaXRoYCwgYHVuaXFgLCBgdW5pcUJ5YCwgYHVuaXFXaXRoYCwgYHVuc2V0YCxcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAgICogYHppcE9iamVjdGAsIGB6aXBPYmplY3REZWVwYCwgYW5kIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbGFtcGAsIGBjbG9uZWAsXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICAgKiBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCwgYGZpbmRLZXlgLCBgZmluZExhc3RgLFxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgICAqIGBoYXNJbmAsIGBoZWFkYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpbnZva2VgLFxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgICAqIGBpc0VxdWFsV2l0aGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNJbnRlZ2VyYCwgYGlzTGVuZ3RoYCxcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAgICogYGlzU2FmZUludGVnZXJgLCBgaXNTZXRgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCxcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAgICogYG1pbmAsIGBtaW5CeWAsIGBtdWx0aXBseWAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLCBgbm93YCwgYG50aGAsIGBwYWRgLFxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZEluZGV4QnlgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0aW1lc2AsIGB0b0Zpbml0ZWAsIGB0b0ludGVnZXJgLCBgdG9KU09OYCwgYHRvTGVuZ3RoYCxcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAgICogYHVwcGVyRmlyc3RgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICAgIEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICAtLXRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICAgICApKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAgICogdmFsdWUgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShpdGVyYXRlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmFzZUdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaWRlbnRpdHldO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICB2YXIgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgICAgIG90aEluZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBiYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXG4gICAgICogcmVwbGFjZW1lbnQgcGx1Z2lucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BjbGVhclRpbWVvdXRgXShodHRwczovL21kbi5pby9jbGVhclRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IGlkIFRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdCBvZiB0aGUgdGltZXIgdG8gY2xlYXIuXG4gICAgICovXG4gICAgdmFyIGNsZWFyVGltZW91dCA9IGN0eENsZWFyVGltZW91dCB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICAgICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICAgKlxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gICAgICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICAgICAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgICAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcml0eSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlcik7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgIGZ1bmNzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gaW5kZXggOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmXG4gICAgICAgICAgICAgICAgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgICAgID8gd3JhcHBlcltmdW5jTmFtZV0oKVxuICAgICAgICAgICAgICA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAgICAgKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uaW52ZXJ0QnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdG9JdGVyYXRlZSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52ZXJ0ZXIoc2V0dGVyLCB0b0l0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCB0b0l0ZXJhdGVlKGl0ZXJhdGVlKSwge30pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb1N0cmluZyhvdGhlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5vdmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG92ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT3ZlcihhcnJheUZ1bmMpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AgYmFzZWQgb24gYGxlbmd0aGAuIFRoZSBgY2hhcnNgIHN0cmluZ1xuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgY2hhcnMgPSBjaGFycyA9PT0gdW5kZWZpbmVkID8gJyAnIDogYmFzZVRvU3RyaW5nKGNoYXJzKTtcblxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgaWYgKGNoYXJzTGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChsZW5ndGggLyBzdHJpbmdTaXplKGNoYXJzKSkpO1xuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIG90aGVyID0gdG9OdW1iZXIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gY29udGludWUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAgICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgICAgICBuZXdIb2xkZXJzID0gaXNDdXJyeSA/IGhvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXG4gICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBwYXJ0aWFscztcblxuICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICAgICAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xuICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywgcmVzdWx0KSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgJ3BsYWNlaG9sZGVyJykgPyBsb2Rhc2ggOiBmdW5jO1xuICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGJhc2VJdGVyYXRlZWAuXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIHRoZSBjcmVhdGVkIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLml0ZXJhdGVlIHx8IGl0ZXJhdGVlO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpdGVyYXRlZSA/IGJhc2VJdGVyYXRlZSA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgICAvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG4gICAgaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgICAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAgICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgICAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3cmFwcGVyIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2gocmVXcmFwRGV0YWlscyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChyZVNwbGl0RGV0YWlscykgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZUJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIG9yZGVyIGFuZFxuICAgICAqIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxXaXRoYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZVdpdGgob2JqZWN0cywgW3sgJ3gnOiAxLCAneSc6IDIgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZVdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4LCAxMF0sICcqJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXG4gICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBmaXJzdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmhlYWQoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMCwgLTEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoaXRlcmF0ZWUgPT09IGxhc3QobWFwcGVkKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGFycmF5LCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gJycgOiBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgID8gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleClcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgaWYgKGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFCeWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXFCeShbMS4xLCAxLjIsIDIuMywgMi40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMSwgMi4zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAxLCBsZW5ndGgpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbVxuICAgICAqIHRoZSBmaXJzdCBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgICAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcikgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmVcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvckJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy54b3JXaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHhvcldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gbGVuZ3RoID8gcGF0aHNbMF0gOiAwLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xuXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXG4gICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAmJiAhYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKVxuICAgICAqICAgLmNoYWluKClcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcblxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbiBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwbGFudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcbiAgICAgKiB2YXIgb3RoZXIgPSB3cmFwcGVkLnBsYW50KFszLCA0XSk7XG4gICAgICpcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XG4gICAgICAgIGNsb25lLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICArK3Jlc3VsdFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICAgICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5yZWplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBDb21iaW5pbmcgc2V2ZXJhbCBwcmVkaWNhdGVzIHVzaW5nIGBfLm92ZXJFdmVyeWAgb3IgYF8ub3ZlclNvbWVgLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFt7ICdhZ2UnOiAzNiB9LCBbJ2FnZScsIDQwXV0pKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDMwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICAgICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xuICAgICAqIGFyZSBhc3NpZ25lZCB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID09IG51bGwgPyByZXN1bHQgOiBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvclJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2InIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgdGhlbiAnYicuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gYW5kIGluaGVyaXRlZFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICAgICAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG90aGVyLCAnYScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGVcbiAgICAgKiBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxuICAgICAqIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGludmVydGVkIHZhbHVlIG9mIGVhY2ggaW52ZXJ0ZWQga2V5IGlzIGFuIGFycmF5IG9mIGtleXNcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdncm91cDEnOiBbJ2EnLCAnYyddLCAnZ3JvdXAyJzogWydiJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRCeSA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgIH1cbiAgICB9LCBnZXRJdGVyYXRlZSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKG9iamVjdCwgJ2FbMF0uYi5jLnNsaWNlJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IGJhc2VSZXN0KGJhc2VJbnZva2UpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwVmFsdWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gICAgICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAgICAgKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9KTtcbiAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgbG9vcCBpcyBlbnRlcmVkIHdoZW4gcGF0aCBpcyBlbXB0eS5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8uc2V0V2l0aChvYmplY3QsICdbMF1bMV0nLCAnYScsIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICAgICAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xuICAgICAqIGZvciBgb2JqZWN0YCB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXBcbiAgICAgKiBvciBzZXQsIGl0cyBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzSW5cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IGNyZWF0ZVRvUGFpcnMoa2V5c0luKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiA3IH0gfV0gfTtcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGFjY2VwdHMgYHVwZGF0ZXJgIHRvIHByb2R1Y2UgdGhlXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAnYVswXS5iLmMnLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy51cGRhdGVXaXRoKG9iamVjdCwgJ1swXVsxXScsIF8uY29uc3RhbnQoJ2EnKSwgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXaXRoKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdmUkVEJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xuICAgICAgICBzdHJpbmcgK1xuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkIHx8IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhhcmdzWzBdKTtcblxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwKHNlcGFyYXRvcikpXG4gICAgICAgICAgKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gICAgICAvLyB0byBub3JtYWxpemUgYWxsIGtpbmRzIG9mIHdoaXRlc3BhY2UsIHNvIGUuZy4gbmV3bGluZXMgKGFuZCB1bmljb2RlIHZlcnNpb25zIG9mIGl0KSBjYW4ndCBzbmVhayBpblxuICAgICAgLy8gYW5kIGVzY2FwZSB0aGUgY29tbWVudCwgdGh1cyBpbmplY3RpbmcgY29kZSB0aGF0IGdldHMgZXZhbGVkLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICAgICAgICA/IChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9cXHMvZywgJyAnKVxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgYSBmb3JiaWRkZW4gY2hhcmFjdGVyIHdhcyBmb3VuZCBpbiBgdmFyaWFibGVgLCB0byBwcmV2ZW50XG4gICAgICAvLyBwb3RlbnRpYWwgY29tbWFuZCBpbmplY3Rpb24gYXR0YWNrcy5cbiAgICAgIGVsc2UgaWYgKHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzLnRlc3QodmFyaWFibGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9Mb3dlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvTG93ZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICctLWZvby1iYXItLSdcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb2JhcidcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnX19mb29fYmFyX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byB1cHBlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9VcHBlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvVXBwZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1VwcGVyKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICctLUZPTy1CQVItLSdcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPT0JBUidcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnX19GT09fQkFSX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VcHBlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBiYXNlVHJpbShzdHJpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCBfLm1hdGNoZXMoeyAnYSc6IDQgfSldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlc1Byb3BlcnR5KCdhJywgMSksIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgxKSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJ10pKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhcmd1bWVudCBhdCBpbmRleCBgbmAuIElmIGBuYCBpcyBuZWdhdGl2ZSxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKC0yKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2MnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBtYXRjaGVzRnVuYyA9IF8ub3ZlclNvbWUoW3sgJ2EnOiAxIH0sIHsgJ2EnOiAyIH1dKVxuICAgICAqIHZhciBtYXRjaGVzUHJvcGVydHlGdW5jID0gXy5vdmVyU29tZShbWydhJywgMV0sIFsnYScsIDJdXSlcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICByZWFsTmFtZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiaW1wb3J0IHR5cGUgT3BlbkZpbiBmcm9tIFwiQG9wZW5maW4vY29yZVwiO1xuaW1wb3J0IHsgZmluIH0gZnJvbSBcIkBvcGVuZmluL2NvcmVcIjtcblxubGV0IGZpbGVOYW1lOiBzdHJpbmc7XG5sZXQgZGVidWdMb2dTdHI6IHN0cmluZztcbmxldCBkZWJ1Z0xvZ0ZpbGU6IEZpbGU7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGFzeW5jICgpID0+IHtcblx0dHJ5IHtcblx0XHRhd2FpdCBpbml0RG9tKCk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFBvcHVsYXRlcyBET00gd2l0aCB0aGUgVUkgZWxlbWVudHMgYW5kIGFkZHMgbGlzdGVuZXJzIG9idGFpbmluZyBzZWxlY3RlZC9zdWJtaXR0ZWQgb3B0aW9ucy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdERvbSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0Y29uc3QgbG9nTGlzdEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxTZWxlY3RFbGVtZW50PihcIiNsb2ctbGlzdFwiKTtcblx0aWYgKGxvZ0xpc3RFbGVtZW50KSB7XG5cdFx0YXdhaXQgY3JlYXRlTG9nRHJvcERvd24obG9nTGlzdEVsZW1lbnQpO1xuXHRcdGxvZ0xpc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgYXN5bmMgKHNlbGVjdGlvbkNoYW5nZUV2ZW50KSA9PiB7XG5cdFx0XHRmaWxlTmFtZSA9IChzZWxlY3Rpb25DaGFuZ2VFdmVudC50YXJnZXQgYXMgSFRNTE9wdGlvbkVsZW1lbnQpLnZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblx0Y29uc3QgdXBsb2FkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcjxIVE1MRm9ybUVsZW1lbnQ+KFwiI3VwbG9hZC1mb3JtXCIpO1xuXHRpZiAodXBsb2FkKSB7XG5cdFx0dXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgdXBsb2FkSGFuZGxlcik7XG5cdH1cblx0Y29uc3Qgc2VuZEFwcExvZ0J0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8SFRNTEJ1dHRvbkVsZW1lbnQ+KFwiI3NlbmQtYXBwLWxvZ1wiKTtcblx0aWYgKHNlbmRBcHBMb2dCdG4pIHtcblx0XHRzZW5kQXBwTG9nQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzZW5kQXBwbGljYXRpb25Mb2dzKTtcblx0fVxufVxuXG4vKipcbiAqIEhhbmRsZSB1cGxvYWRzLlxuICogMS4gQ3JlYXRlcyBhIEZvcm1EYXRhIG9iamVjdC5cbiAqIDIuIENyZWF0ZXMgYSBGaWxlIG9iamVjdCBmcm9tIHRoZSBzdHJpbmcgb2YgdGhlIFJ1bnRpbWUgZGVidWcgbG9nIGZpbGUgY29udGVudHMuXG4gKiAzLiBQb3B1bGF0ZXMgdGhlIEZvcm1EYXRhIG9iamVjdCB3aXRoIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzIHRvIGJlIHJlYWQgYnkgdGhlIHNlcnZlci5cbiAqIDQuIFVwbG9hZHMgdGhlIGNyZWF0ZWQgcnVudGltZSBkZWJ1ZyBsb2cgZmlsZSB0byBhIHNlcnZlciBlbmRwb2ludC5cbiAqIEBwYXJhbSBzdWJtaXRFdmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlLlxuICovXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRIYW5kbGVyKHN1Ym1pdEV2ZW50OiBFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuXHRzdWJtaXRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRpZiAoIWZpbGVOYW1lKSB7XG5cdFx0ZmlsZU5hbWUgPSBcImRlYnVnLmxvZ1wiO1xuXHR9XG5cdGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cdGRlYnVnTG9nU3RyID0gYXdhaXQgZ2V0TG9nRnJvbU5hbWUoZmlsZU5hbWUpO1xuXHRkZWJ1Z0xvZ0ZpbGUgPSBuZXcgRmlsZShbZGVidWdMb2dTdHJdLCBmaWxlTmFtZSwgeyB0eXBlOiBcInRleHQvcGxhaW5cIiB9KTtcblx0Zm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBkZWJ1Z0xvZ0ZpbGUpO1xuXHRmb3JtRGF0YS5hcHBlbmQoXCJmaWxlbmFtZVwiLCBmaWxlTmFtZSk7XG5cdGZvcm1EYXRhLmFwcGVuZChcInV1aWRcIiwgZmluLm1lLnV1aWQpO1xuXHRjb25zdCB1cGxvYWRTdGF0ZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDo1MDUwL3VwbG9hZHNcIiwge1xuXHRcdG1ldGhvZDogXCJQT1NUXCIsXG5cdFx0Ym9keTogZm9ybURhdGFcblx0fSk7XG5cblx0Y29uc3QgdXBsb2FkU3RhdGVKc29uID0gYXdhaXQgdXBsb2FkU3RhdGUuanNvbigpO1xuXHRjb25zdCB1cGxvYWRTdGF0ZUpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeSh1cGxvYWRTdGF0ZUpzb24sIG51bGwsIDUpO1xuXHRjb25zdCBsb2dzID0gYCR7bmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKX06ICR7dXBsb2FkU3RhdGVKc29uU3RyaW5nfVxcbmA7XG5cdGNvbnN0IGxvZ1ByZXZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3ByZXZpZXdcIik7XG5cdGlmIChsb2dQcmV2aWV3KSB7XG5cdFx0bG9nUHJldmlldy50ZXh0Q29udGVudCArPSBsb2dzO1xuXHR9XG59XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBPcGVuRmluIFJWTSB0byBzZW5kIHRoZSBhcHBsaWNhdGlvbiBsb2dzLlxuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kQXBwbGljYXRpb25Mb2dzKCk6IFByb21pc2U8dm9pZD4ge1xuXHR0cnkge1xuXHRcdGNvbnN0IGFwcExvZ1Jlc3BvbnNlID0gYXdhaXQgZmluLkFwcGxpY2F0aW9uLmdldEN1cnJlbnRTeW5jKCkuc2VuZEFwcGxpY2F0aW9uTG9nKCk7XG5cdFx0Y29uc29sZS5sb2coYExvZyBJRDogJHthcHBMb2dSZXNwb25zZS5sb2dJZH1gKTtcblx0fSBjYXRjaCB7XG5cdFx0Ly8gc3dhbGxvdyB1bm5lY2Vzc2FyeSBlcnJvcnMuXG5cdH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHJ1bnRpbWUgZGVidWcgbG9nIGZyb20gYSBmaWxlbmFtZS5cbiAqIEBwYXJhbSBuYW1lIGZpbGUgbmFtZSBvZiB0aGUgcnVudGltZSBkZWJ1ZyBsb2cgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJucyB0aGUgbG9nIGNvbnRlbnQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvZ0Zyb21OYW1lKG5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdGNvbnN0IGxvZyA9IGF3YWl0IGZpbi5TeXN0ZW0uZ2V0TG9nKHsgbmFtZSB9KTtcblx0cmV0dXJuIGxvZztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUxPcHRpb25FbGVtZW50IGZvciBlYWNoIG9mIHRoZSBSdW50aW1lIGRlYnVnIGxvZ3MuXG4gKiBAcGFyYW0gcGFyZW50RWxlbWVudCBIVE1MIEVsZW1lbnQgdG8gYXBwZW5kIHRoZSBsb2cgZmlsZW5hbWUgSFRNTE9wdGlvbkVsZW1lbnQgdG8uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxvZ0Ryb3BEb3duKHBhcmVudEVsZW1lbnQ6IEhUTUxTZWxlY3RFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG5cdGNvbnN0IGxvZ0xpc3Q6IE9wZW5GaW4uTG9nSW5mb1tdID0gYXdhaXQgZmluLlN5c3RlbS5nZXRMb2dMaXN0KCk7XG5cblx0Zm9yIChjb25zdCBsb2cgb2YgbG9nTGlzdCkge1xuXHRcdGNvbnN0IGxvZ0VsZW1lbnQ6IEhUTUxPcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcblx0XHRsb2dFbGVtZW50LmlkID0gbG9nLmRhdGU7XG5cdFx0bG9nRWxlbWVudC50ZXh0Q29udGVudCA9IGxvZy5uYW1lO1xuXHRcdGxvZ0VsZW1lbnQudmFsdWUgPSBsb2cubmFtZTtcblx0XHRwYXJlbnRFbGVtZW50LmFwcGVuZChsb2dFbGVtZW50KTtcblx0fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9